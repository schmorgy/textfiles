//	REBatchThread.txt

ExecC() ;

char	*NULL ;
int		 FALSE = 0 ;
int		 TRUE  = ! FALSE ;


int		 gNewWay = TRUE ;


//Trace(4) ;

main()
{
	Debug(0) ;
	SessionLogDirect( _T("REBatchThread.main: Version 1.0.3")) ;

//	UCInterpreter	*thisCI = THIS() ;
//	thisCI->SetProfiling( TRUE ) ;
}

CIThread	*gThisThread ;
int			 WM_QUIT  = 0x0012 ;
int			 WM_TIMER = 0x0113 ;

//	UNITS SERIES FOR SENDING DATA
//	TENS SERIES FOR STARTUP AND SHUTDOWN
//	TWENTY SERIES FOR SUSPEND AND RESUME
//	THIRTY TO SIXTY SERIES FOR WORK COMMANDS
//	SEVENTY SERIES FOR COMPLETE MESSAGES
//	EIGHTY SERIES FOR CANCEL MESSAGES
//	NINETY SERIES FOR ERROR MESSAGES

//	THE RENDER ENGINE DIALOG THREAD
int			 REM_DIALOG					= 0x9000 ;
int			 REM_DATAGC					= 0x9001 ;
int			 REM_RE_START				= 0x9010 ;
int			 REM_RE_SHUTDOWN			= 0x9011 ;
int			 REM_RE_HAS_SHUTDOWN		= 0x9012 ;
int			 REM_RE_SUSPEND				= 0x9020 ;
int			 REM_RE_RESUME				= 0x9021 ;
int			 REM_RE_SHOWSTATUS			= 0x9030 ;
int			 REM_RE_SIREN				= 0x9090 ;
int			 REM_RE_WAIT_FOR_STATUS		= 0x9091 ;
int			 REM_UPDATE_PRINTER_SETUP	= 0x9092 ;

//	THE RENDER ENGINE MAIN THREAD
int			 REM_PRINTERSETUP			= 0x9102 ;
int			 REM_STATUS_GC				= 0x9103 ;
int			 REM_SHUTDOWN				= 0x9111 ;
int			 REM_SUSPEND				= 0x9120 ;
int			 REM_RESUME					= 0x9121 ;
int			 REM_TIMER					= 0x9225 ;
int			 REM_STATUS_REQUEST			= 0x9130 ;
int			 REM_RESERVE_NEXT_BATCH		= 0x9131 ;
int			 REM_GET_PAGE_LIST			= 0x9132 ;
int			 REM_START_BATCH			= 0x9133 ;
int			 REM_RESPONSESCRIPT			= 0x9134 ;
int			 REM_DB_SQL					= 0x9135 ;
int			 REM_GET_PRINTER_STATUS		= 0x9136 ;
int			 REM_DELETE_JOB_RECORD		= 0x9137 ;
int			 REM_ORDER_COMPLETE			= 0x9170 ;
int			 REM_BATCH_COMPLETE			= 0x9171 ;
int			 REM_CANCEL_BATCH			= 0x9180 ;


//	THE RENDER ENGINE BATCH THREAD
int			 REM_BATCH_PRINTERSETUP		= 0x9202 ;
int			 REM_BATCH_STATUS_GC		= 0x9203 ;
int			 REM_BATCH_BATCH_GC			= 0x9204 ;
int			 REM_BATCH_START_RENDER		= 0x9205 ;
int			 REM_BATCH_SHUTDOWN			= 0x9211 ;
int			 REM_BATCH_SUSPEND			= 0x9220 ;
int			 REM_BATCH_RESUME			= 0x9221 ;

int			 REM_BATCH_TIMER			= 0x9225 ;

int			 REM_BATCH_STATUS_REQ		= 0x9230 ;
int			 REM_BATCH_PARSE_JOB		= 0x9234 ;
int			 REM_BATCH_PRGRM_JOB		= 0x9235 ;
int			 REM_BATCH_RENDER_JOB		= 0x9236 ;

int			 REM_BATCH_ORDERCOMP		= 0x9250 ;
int			 REM_BATCH_BATCHCOMP		= 0x9251 ;
int			 REM_SCRIPT_COMPLETE		= 0x9252 ;

int			 REM_BATCH_CANCEL_BATCH		= 0x9260 ;
int			 REM_BATCH_CANCEL_ORDER		= 0x9261 ;
int			 REM_BATCH_CANCEL_PAGE		= 0x9262 ;

int			 REM_BATCH_PARSE_ERROR		= 0x9265 ;

int			 REM_BATCH_RNDR_SUCCESS		= 0x9270 ;
int			 REM_BATCH_RNDR_ERROR		= 0x9271 ;
int			 REM_BATCH_RNDR_CANCEL		= 0x9272 ;

int			 REM_BATCH_PRINT_SUCCESS	= 0x9280 ;
int			 REM_BATCH_PRINT_ERROR		= 0x9281 ;
int			 REM_BATCH_PRINT_CANCEL		= 0x9282 ;

int			 REM_BATCH_MESSAGE_RESPONSE	= 0x9290 ;
int			 REM_BATCH_PARSE_RESPONSE	= 0x9291 ;
int			 REM_BATCH_RENDER_RESPONSE	= 0x9292 ;
int			 REM_BATCH_PRINTER_RESPONSE = 0x9293 ;
int			 REM_BATCH_EXCEPTION_RESPONSE = 0x9094 ;

//	THE RENDER ENGINE PIE THREAD
int			 REM_PIE_SET_PAGE			= 0x9300 ;
int			 REM_PIE_START_RENDER		= 0x9301 ;
int			 REM_PIE_ADVERTIZE			= 0x9302 ;
int			 REM_PIE_STATUS				= 0x9330 ;

//	THE RENDER ENGINE RESPONSE THREAD

//	THE RENDER ENGINE SCRIPT THREAD



//	PRINT QUEUE JOB STATES
int			 HOLD				=  0 ;
int			 READY				=  1 ;
int			 RESERVED			=  2 ;
int			 PRINTING			=  3 ;
int			 COMPLETED			=  4 ;
int			 SAVED				=  5 ;
int			 ERROR				=  6 ;
int			 CANCELLED			=  7 ;
int			 PENDING			=  8 ;
int			 LOADED				=  9 ;
int			 PARSED				= 10 ;

//	BATCH STATES
int			 BATCH_RESERVED		= 1 ;
int			 BATCH_READY		= 2 ;
int			 BATCH_PRINTING		= 3 ;
int			 BATCH_CANCELLING	= 4 ;
int			 BATCH_COMPLETED	= 5 ;
int			 BATCH_ERROR		= 6 ;

//	PAGE STATES
int			 PAGE_READY			= 1 ;
int			 PAGE_PARSED		= 2 ;
int			 PAGE_PROGRAMMED	= 3 ;
int			 PAGE_RENDERED		= 4 ;
int			 PAGE_CANCELLED		= 5 ;
int			 PAGE_COMPLETE		= 6 ;
int			 PAGE_ERROR			= 7 ;
int			 PAGE_PF_HOLD		= 8 ;

//	RENDER ENGINE STATUS
int			 RE_RUNNING			= 1 ;
int			 RE_SUSPENDED		= 2 ;
int			 RE_SHUTTING_DOWN	= 3 ;
int			 RE_QUITTING		= 4 ;

int			 RE_USER_SUSPEND	= 0x01 ;	//	THE USER SUSPENDED US
int			 RE_PROG_SUSPEND	= 0x02 ;	//	THE PROGRAM SUSPENDED US
int			 RE_ERR_SUSPEND		= 0x04 ;	//	WE ARE SUSPENDED DUE TO AN ERROR
int			 RE_THRT_SUSPEND	= 0x08 ;	//	ARE WE SUSPENDED BECAUSE OF THROTTLING ?
int			 RE_DISK_SUSPEND	= 0x10 ;	//	ARE WE SUSPENDED FOR DISK SPACE ?

CIThread	*gREThread			= NULL ;
int			 gREStatus			= RE_SUSPENDED ;
int			 gSuspendType		= RE_PROG_SUSPEND ;		//	WHO SUSPENDED US

UGenCon		*gCurrentBatch		= NULL ;	//	BATCH CURRENTLY RENDERING
UGenCon		*gPageRendering		= NULL ;	//	THE CURRENTLY RENDERING PAGE
UQueue		*gPagesRendering	= NULL ;	//	THE QUEUE OF PAGES RENDERING
long		 gShuttingDown		= FALSE ;	//	ARE WE SHUTTING DOWN ?
long		 gPagesToGo			= 0 ;		//	THE PAGES LEFT TO RENDER
long		 gLastWorkCheck		= 0 ;		//	TICKS SINCE WE LAST CHECKED FOR WORK

//	THE PRINTER SETUP GENCON HAS CHILDREN...
//	THE FIRST CHILD IS THE STATUS TO BE RETURNED TO THE DIALOG.
//	THE SECOND CHILD IS A GENCON TO KEEP TRACK OF THE ORDER PROCESSING THREAD.
UGenCon		*gPrinterSetupGC ;		//	THE PRINTER SETUP GENCON
UGenCon		*gStatusGC ;			//	THE STATUS GENCON

UList		*gPageList ;			//	THE WORKING PAGE LIST
long		 gPageListPos ;			//	THE POSITION IN THE PAGE LIST OF THE NEXT PAGE
UQueue		*gParsedQueue ;			//	THE LIST OF PARSED JOBS
UQueue		*gProgrammedQueue ;		//	THE LIST OF PROGRAMMED JOBS
UQueue		*gRenderedQueue	;		//	THE LIST OF RENDERED JOBS
UQueue		*gCompletedQueue ;		//	THE LIST OF COMPLETED JOBS
UQueue		*gErrorJobQueue ;		//	THE LIST OF ERROR'D JOBS
UQueue		*gPaperFillHoldQueue ;	//	THE PAPER FILL PAGE LIST
UList		*gPaperFillPageList ;	//	THE LIST OF EXTRA PAGES FOR PAPER FILL QUANTITIES
UList		*gPaperFillPackages ;	//	THE PAPERFILL PACKAGES

long		 gNumSimultaneousRenders ;	//	THE NUMBER OF SIMULTANEOUS RENDERS
long		 gNextCompletePage ;	//	USED FOR ORDERING THE OUTPUT OF PRINTS.
UList		*gCompleteList ;		//	USED FOR ORDERING THE OUTPUT OF PRINTS.

UGenCon		*gRELookAhead ;			//	THE QUEUE TUNING PARAMETERS
long		 gLogAmount = 0L ;		//	THE AMOUNT OF LOGGING TO DO
int			 gCheckTextLibFirst ;	//	DO WE CHECK THE TEXT LIBRARY FIRST ?

UREBatch	*gREBatch			= NULL ;

//UREUtils	*gREUtils ;				//	COMPILED UTILITIES FOR PERFORMANCE

/*
Dictionary: DDREStatus
	Fields:	Name	Time			Type	Text
	Fields:	Name	Status			Type	Text
	Fields:	Name	Batch			Type	Text
	Fields:	Name	Order			Type	Text
	Fields:	Name	Item			Type	Long
	Fields:	Name	QtyRendered		Type	Long
	Fields:	Name	DlgThread		Type	Long
	Fields:	Name	REThread		Type	Long
	Fields:	Name	BatchThread		Type	Long
	Fields:	Name	ScriptThread	Type	Long
	Fields:	Name	LogAmount		Type	Long
	;

Dictionary:	DDREBatchInfo
	Fields:	Name	BatchID				Type	Text
	Fields:	Name	OrderID				Type	Text
	Fields:	Name	OrderItemID			Type	Long
	Fields:	Name	JobID				Type	Long
	Fields:	Name	State				Type	Long
	Fields:	Name	REThread			Type	Long
	Fields:	Name	BatchThread			Type	Long
	Fields:	Name	PrinterSetup		Type	Reference

			//	FROM DDFSOrder
	Fields:	Name	CustomerID			Type	Text
	Fields:	Name	VendorOrderNumber	Type	Text
	Fields:	Name	OrderStatus			Type	Long
	Fields:	Name	TotalPrints			Type	Long
	Fields:	Name	NumPkgPrints		Type	Long
	Fields:	Name	ErrorCode			Type	Long
	Fields:	Name	ErrorText			Type	Text
	Fields:	Name	ErrorType			Type	Long
	Fields:	Name	LastPrintTime		Type	Long
	;

Dictionary:	DDREPageInfo
	Fields:	Name	PageID				Type	Text
	Fields:	Name	JobID				Type	Long
	Fields:	Name	State				Type	Long
	Fields:	Name	PrintNumber			Type	Long
	Fields:	Name	PageNumber			Type	Long
	Fields:	Name	BatchID				Type	Text
	Fields:	Name	OrderID				Type	Text
	Fields:	Name	OrderSeq			Type	Long
	Fields:	Name	OrderItemID			Type	Long
	Fields:	Name	OrderItemSeq		Type	Long
	Fields:	Name	OrderItemQty		Type	Long
	Fields:	Name	JobPath				Type	Text
	Fields: Name	IsPackage			Type	Long
	Fields:	Name	PkgCode				Type	Long
	Fields:	Name	BarCode				Type	Text
	Fields:	Name	BarCodeType			Type	Long	//	FALSE, TRUE (Full), TRUE_INTERMEDIATE
	Fields:	Name	EndOfOrder			Type	Long
	Fields:	Name	URenderList			Type	Long
	Fields:	Name	UIC					Type	Reference
	Fields:	Name	Pie					Type	Long
	Fields:	Name	BatchThread			Type	Long
	Fields:	Name	PieThread			Type	Long
	Fields:	Name	ErrorCode			Type	Long	//	OK, Error Number
	Fields:	Name	ErrorType			Type	Long	//	INFO, WARN, FATAL
	Fields:	Name	ErrorText			Type	Text
	Fields: Name	RenderErrorList		Type	Reference	//	THE LIST OF RENDER ERRORS
	Fields:	Name	PrintThisPage		Type	Long	//	FOR PAPER FILL
	Fields:	Name	DeleteAfter			Type	Long	//	FOR PAPER FILL
	Fields:	Name	NodeID				Type	Long	//	FOR LUCHT PAPER FILL

			//	FROM DDFSPrint
	Fields:	Name	ProductDesc			Type	Text
	Fields:	Name	ShortDimension		Type	Double
	Fields:	Name	LongDimension		Type	Double
	Fields:	Name	Units				Type	Text
	Fields:	Name	Quantity			Type	Long
	Fields:	Name	ImagePath			Type	Text
	Fields:	Name	FileFormat			Type	Text
	Fields:	Name	ColorSpace			Type	Text
	Fields:	Name	DeleteOnComplete	Type	Long
	Fields:	Name	BackPrintMessage1	Type	Text
	Fields:	Name	BackPrintMessage2	Type	Text
	Fields:	Name	PrintStatus			Type	Long
	Fields:	Name	PrinterChannel		Type	Long
	Fields:	Name	PaperSurface		Type	Long
	Fields:	Name	OEMPrinterChannel	Type	Long	//	FOR BACKWARD COMPATABILITY
	Fields:	Name	OEMPrinterSurface	Type	Long	//	FOR BACKWARD COMPATABILITY
	Fields:	Name	ReproMode			Type	Long
	Fields:	Name	PrinterResize		Type	Long
	Fields:	Name	ResponseText		Type	Text
	Fields:	Name	ResponseCode		Type	Long
	Fields:	Name	OutputNode			Type	Long
	Fields:	Name	Resolution			Type	Double
	Fields:	Name	PaperWidth			Type	Double
	Fields:	Name	CommandSent			Type	Long
	Fields:	Name	ExpandedCDSaveName	Type	Text
	Fields:	Name	IDPunch				Type	Long
	;

Dictionary:	DDREThreadResponse
	Fields:	Name	PrinterSetupGC			Type	Long
	Fields:	Name	StatusGC				Type	Long
	Fields:	Name	PageGC					Type	Long
	Fields:	Name	BatchGC					Type	Long
	Fields:	Name	PrinterResponseGC		Type	Reference
	Fields:	Name	ErrorCode				Type	Long	// OK, Error Number
	Fields:	Name	ErrorText				Type	Text
	Fields:	Name	CancelPage				Type	Long
	Fields:	Name	CancelOrder				Type	Long
	Fields:	Name	CancelBatch				Type	Long
	;

*/


//	START THE THREAD HERE !
//	NOTE THAT THE THREAD STARTS OUT SUSPENDED
//	UNTIL WE ARE TOLD TO START.
int InitInstance(CIThread *ThisThread)
{
	TCHAR	buffer[256] ;
	int Result = GetEnvironmentVariable(_T("NUMBER_OF_PROCESSORS"), buffer, 256 ) ;
	long NumProcessors = atoi( buffer ) ;

	long	NumSimultaneousRenders = (NumProcessors + 1) / 2 ;

	SessionLogDirect( _T("REBatch.InitInstance: Number of Processors: %ld,\tNumber of Simultaneous Renders: %ld"),
									NumProcessors, NumSimultaneousRenders ) ;

	if( gNewWay )
	{
		gREBatch = new UREBatch ;
		Result = gREBatch->InitInstance( ThisThread ) ;
		gREBatch->SetNumSimultaneousRenders( NumSimultaneousRenders ) ;
		return( Result ) ;
	}

	gNumSimultaneousRenders = NumSimultaneousRenders ;

	gThisThread		= ThisThread ;
	gCurrentBatch	= NULL ;
	gREStatus		= RE_SUSPENDED ;
	gSuspendType	= RE_PROG_SUSPEND ;
	gRELookAhead	= GetTreeObject(_T("RELookAhead"),_T("[GenCons]")) ;


	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.InitInstance: ThisThread: %08lX"), ThisThread ) ;
	}

	gParsedQueue		= new UQueue ;		//	THE LIST OF PARSED JOBS
	gPaperFillHoldQueue	= new UQueue ;		//	THE PAPER FILL HOLD QUEUE
	gProgrammedQueue	= new UQueue ;		//	THE LIST OF PROGRAMMED JOBS
	gRenderedQueue		= new UQueue ;		//	THE LIST OF RENDERED JOBS
	gCompletedQueue		= new UQueue ;		//	THE LIST OF COMPLETED JOBS
	gErrorJobQueue		= new UQueue ;		//	THE LIST OF ERROR'D JOBS
	gPagesRendering		= new UQueue ;		//	THE LIST OF JOBS BEING RENDERED

	gParsedQueue->SetName(_T("ParsedQueue")) ;
	gPaperFillHoldQueue->SetName(_T("PaperFillHoldQueue")) ;
	gProgrammedQueue->SetName(_T("ProgrammedQueue")); 
	gRenderedQueue->SetName(_T("RenderedQueue")); 
	gCompletedQueue->SetName(_T("CompletedQueue")); 
	gErrorJobQueue->SetName(_T("ErrorList")); 
	gPagesRendering->SetName( _T("PagesRendering")) ;

	gPaperFillPageList	= new UList ;
	gPaperFillPackages	= new UQueue ;

	gNextCompletePage	= 1L ;
	gCompleteList		= new UList ;

	gCheckTextLibFirst = TRUE ;
	UGenCon	*CICheckTextLibFirst = GetTreeObject( _T("CICheckTextLibFirst"), _T("GENCONS")) ;
	if( CICheckTextLibFirst )
	{
		gCheckTextLibFirst = CICheckTextLibFirst->GetLongValue(_T("Long")) ;
	}

//	gREUtils = new REUtils ;

	HangDebugTargetGC() ;	//	DEBUGGER2 CODE

	return( TRUE ) ;
}

int OnIdle( long Count )
{
	return( Count ) ;
}

//	THE PRINTER SETUP GENCON HAS A LIST OF CHILDREN WHICH ARE
//	THE RENDER ENGINE THREADS.
//	WHEN EXITING, FIND AND REMOVE OURSELVES FROM THE LIST.
int ExitInstance()
{
	if( gNewWay )
	{
		int Result = gREBatch->ExitInstance() ;
		delete gREBatch ;
		return( Result ) ;
	}



	gShuttingDown = TRUE ;

	if( gLogAmount >= 2 )
		{ SessionLogDirect( _T("****\tREBatchThread.ExitInstance: ThisThread: %08lX"), gThisThread ) ; }

	CleanUpPages( gProgrammedQueue ) ;	//	REMOVES ANY DEFINED PIE's FROM THE JOBS

	if( gParsedQueue )			{ gParsedQueue->RemoveAll()			; delete gParsedQueue ;		}
	if( gProgrammedQueue )		{ gProgrammedQueue->RemoveAll()		; delete gProgrammedQueue ; }
	if( gRenderedQueue )		{ gRenderedQueue->RemoveAll()		; delete gRenderedQueue ;	}
	if( gCompletedQueue )		{ gCompletedQueue->RemoveAll()		; delete gCompletedQueue ;	}
	if( gErrorJobQueue )		{ gErrorJobQueue->RemoveAll()		; delete gErrorJobQueue ;	}
	if( gPaperFillHoldQueue )	{ gPaperFillHoldQueue->RemoveAll()	; delete gPaperFillHoldQueue ; }
	if( gPaperFillPageList )	{ gPaperFillPageList->RemoveAll()	; delete gPaperFillPageList ; }
	if( gPagesRendering )		{ gPagesRendering->RemoveAll()		; delete gPagesRendering ; }
	if( gCompleteList )			{ gCompleteList->RemoveAll()		; delete gCompleteList ; }

	//	THE SOURCE PAGES FOR EACH PACKAGE ARE DELETED IN REThread
	if( gPaperFillPackages )
	{
		UList	*PFSourcePages ;
		UListIterator	*anIter = new UListIterator( gPaperFillPackages ) ;
		UGenCon			*aPkg	= (UGenCon *) anIter->GetFirst() ;
		while( aPkg )
		{
			PFSourcePages = aPkg->GetChildren() ;
			if( PFSourcePages )
			{
				PFSourcePages->RemoveAll() ;
				delete PFSourcePages ;
				aPkg->SetChildren(NULL) ;
				aPkg->SetLongValue(_T("UIC"), NULL ) ;
			}

			if( gLogAmount >= 6 )
				{ SessionLogDirect( _T("****\tREBatch.ExitInstance: Deleting Package: 0x%08lX, \"%s\""),
												aPkg, aPkg->GetName()) ; }
			gPaperFillPackages->RemoveItem( aPkg ) ;
			delete aPkg ;

			aPkg = (UGenCon *) anIter->GetFirst() ;
		}
		delete anIter ;

		delete gPaperFillPackages ; 
	}

	CleanUpLuchtPaperFill() ;	//	CLEAN UP THE LUCHT PAPER FILL IMAGE LIST

	if( gLogAmount >= 5 )
		{ SessionLogDirect( _T("****\tREBatchThread.ExitInstance: Notify Thread: %08lX"), gREThread ) ; }

	if( gREThread )
	{
		//	SAY THE BATCH IS COMPLETE
		PostAThreadMessage( gREThread, REM_BATCH_COMPLETE, 0L, (long) gCurrentBatch ) ;
		PostAThreadMessage( gREThread, WM_TIMER, 0L, 0L ) ;
	}

//	if( gREUtils )	{ delete gREUtils ; }


	RemoveDebugTargetGC() ;		//	DEBUGGER2 CODE

	return( 1 ) ;
}

int CleanUpPages( UList *theList )
{
	if( gLogAmount > 3 )
	{
		SessionLogDirect( _T("**\tREBatchThread.CleanUpPages: NumberPages: %ld"), theList->GetNumEntries()) ;
	}

	PIE	*thePie = NULL ;

	if( theList == NULL )	{ return( TRUE ) ; }
	UListIterator	*anIter = new UListIterator( theList ) ;
	if( anIter )
	{
		UGenCon *aPage = (UGenCon *) anIter->GetFirst() ;
		while( aPage )
		{
			if( gLogAmount > 3 )
			{
				SessionLogDirect( _T("**\t\tREBatchThread.CleanUpPages: PageID: \"%s\""), aPage->GetStringValue(_T("PageID"))) ;
			}

			thePie = aPage->GetLongValue(_T("Pie")) ;
			if( thePie )
			{
				delete thePie ;
				aPage->SetLongValue(_T("Pie"), NULL ) ;
			}

			aPage  = (UGenCon *) anIter->GetNext() ;
		}
		delete anIter ;
	}
}



int PreTranslateMessage( UGenCon *pMsg)
{
	if( gNewWay )
	{
		int Result = gREBatch->PreTranslateMessage(pMsg) ;
		return( Result ) ;
	}

	
	
	
	long		MessageHandled = FALSE ;
	long		Value ;

	long		Message = pMsg->GetLongValue(_T("Message")) ;
	long		wParam  = pMsg->GetLongValue(_T("wParam"))  ;
	long		lParam  = pMsg->GetLongValue(_T("lParam"))  ;

	if( Message != WM_TIMER && gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.PreTranslateMessage: Status: %ld, Msg: 0x%08lX, wParam: 0x%08lX, lParam: 0x%08lX"),
									gREStatus, Message, wParam, lParam ) ;
	}

	switch( Message )
	{
		case		WM_TIMER	:					//	HANDLE TIMER CODE
			PostAThreadMessage( gThisThread, REM_BATCH_TIMER, 0L, 0L ) ;
			break ;

		case		REM_BATCH_TIMER	:				//	REALLY HANDLE THE TIMER
			HandleTimer() ;
			break ;
			//	BATCH SETUP MESSAGES

		case		REM_BATCH_PRINTERSETUP		:	//	SET PrinterSetup GC
			gPrinterSetupGC = lParam ;
			SetupPaperFill( gPrinterSetupGC ) ;
//			gREUtils->SetPrinterSetup( gPrinterSetupGC ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_STATUS_GC			:	//	Set the Status GC
			gStatusGC  = lParam ;
			gREThread  = gStatusGC->GetLongValue(_T("REThread")) ;
			gLogAmount = gStatusGC->GetLongValue(_T("LogAmount")) ;
//			gREUtils->SetLogAmount( gLogAmount ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_BATCH_GC			:	//	Set the Batch GC
			gCurrentBatch = lParam ;
			gPageList = gCurrentBatch->GetChildren() ;
			gPagesToGo = gPageList->GetNumEntries() ;
			gPrinterSetupGC = gCurrentBatch->GetLongValue(_T("PrinterSetup")) ;
			gPageListPos = 0L ;
//			gREUtils->SetBatchInfo( gCurrentBatch ) ;
			SessionLogDirect( _T("****\tREBatch.PreTranslateMessage: Starting Batch: \"%s\", With %ld Pages."), 
					gCurrentBatch->GetStringValue(_T("BatchID")), gPagesToGo ) ;
			if( gLogAmount >= 8 )
			{
				DumpList(gPageList) ;
			}
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_START_RENDER		:	//	Start Rendering
			StartRendering() ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_SHUTDOWN			:	//	Shutdown
			gREStatus = RE_SHUTTING_DOWN ;
			HandleShutDown() ;

			//	CANCEL THE UNFINISHED PAGES IN THE JOB QUEUE AND QUIT
			RestoreJobQueueToStatus(CANCELLED) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_SUSPEND			:	//	Handle Suspend
			gREStatus = RE_SUSPENDED ;
			gSuspendType |= lParam ;				//	WHO SUSPENDED US
			SessionLogDirect( _T("****\tREBatchThread.PreTranslateMessage: Suspended... (SuspendType: %ld)"), gSuspendType ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_RESUME			:	//	Handle Resume
			if( gSuspendType & lParam )	{ gSuspendType -= lParam ; }

			if( gSuspendType <= 0 )
			{
				gREStatus = RE_RUNNING ;
				gSuspendType = 0 ;
				SessionLogDirect( _T("****\tREBatchThread.PreTranslateMessage: Resumed... (SuspendType: %ld)"), gSuspendType ) ;
			}
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_ORDERCOMP			:	//	Handle Order Complete	TBD
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_BATCHCOMP			:	//	Handle Batch Complete
			HandleBatchComplete() ;					//	lParam is the BatchInfo GenCon
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_CANCEL_PAGE		:	//	Handle Cancel Page		TBD
			CancelThisPage( lParam ) ;				//	lParam = The Page we are working on.
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_CANCEL_ORDER		:	//	Handle Cancel Order	TBD
			CancelThisOrder( lParam ) ;				//	NOT CURRENTLY USED
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_CANCEL_BATCH		:	//	Handle Cancel Batch	TBD
			CancelThisBatch( lParam ) ;				//	lParam = The Batch we are working on.
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_STATUS_REQ		:	//	Status Request
			HandleStatusRequest() ;
			MessageHandled = TRUE ;
			break ;

			//	PARSING / PROGRAMMING / RENDERING MESSAGES

		case		REM_BATCH_PARSE_JOB			:	//	PARSE A JOB
			ParseAJob() ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_PRGRM_JOB			:	//	PROGRAM A JOB
			ProgramAJob() ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_RENDER_JOB		:	//	RENDER A JOB
			RenderAJob() ;
			MessageHandled = TRUE ;
			break ;

			//	RENDERING RETURN MESSAGES

		case		REM_BATCH_RNDR_SUCCESS		:	//	JOB SUCCESSFUL
			//	lParam = the successful page
			HandleSuccessfulRender( lParam ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_PARSE_ERROR		:	//	PARSE ERROR
			HandleParseError( lParam ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_RNDR_ERROR		:	//	JOB NOT SUCCESSFUL
			//	lParam = the error page
			HandleRenderError( lParam ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_RNDR_CANCEL		:	//	JOB CANCELLED
			//	lParam = the cancelled page
			HandleRenderCancel( lParam ) ;
			MessageHandled = TRUE ;
			break ;

			//	PRINTING RETURN MESSAGES

		case		REM_BATCH_PRINT_SUCCESS		:	//	SUCCESSFUL PRINT
			HandleSuccessfulPrint( lParam ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_PRINT_CANCEL		:	//	CANCEL PRINT
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_PRINT_ERROR		:	//	ERROR PRINT
			gREStatus = RE_SUSPENDED ;
			gSuspendType |= RE_ERR_SUSPEND ;

			HandlePrintError( lParam ) ;

			if( gSuspendType & RE_ERR_SUSPEND )	{ gSuspendType -= RE_ERR_SUSPEND ; }

			if( gSuspendType <= 0 )
			{
				gREStatus = RE_RUNNING ;
				gSuspendType = 0 ;
				SessionLogDirect( _T("****\tREBatchThread.PreTranslateMessage: Resumed...")) ;
			}
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_MESSAGE_RESPONSE	:	//	MESSAGE DIALOG RESPONDS HERE
			MessageDialogReply(lParam) ;			//	A COPY OF THE MESSAGE DIALOG GENCON
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_PARSE_RESPONSE	:	//	PARSE DIALOG RESPONDS HERE
			HandleParseResponse(lParam) ;
//			gREStatus = RE_RUNNING ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_RENDER_RESPONSE	:	//	RENDER DIALOG RESPONDS HERE
			HandleRenderResponse(wParam, lParam) ;
//			gREStatus = RE_RUNNING ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_PRINTER_RESPONSE	:	//	PRINTER DIALOG RESPONDS HERE
			HandlePrinterResponse(wParam, lParam) ;
//			gREStatus = RE_RUNNING ;
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_EXCEPTION_RESPONSE :	//	EXCEPTION DIALOG RESPONDS HERE
			HandleExceptionResponse(lParam) ;
//			gREStatus = RE_RUNNING ;
			MessageHandled = TRUE ;
			break ;

	}

	return( MessageHandled ) ;
}

//=============================================================================
//=============================================================================
//============================= HANDLE TIMER ==================================
//=============================================================================
//=============================================================================

//	HandleTimer() IS CALLED EVERY 1/2 SECOND
/*
int			 RE_RUNNING			= 1 ;
int			 RE_SUSPENDED		= 2 ;
int			 RE_SHUTTING_DOWN	= 3 ;
int			 RE_QUITTING		= 4 ;
*/

long	gLastLogUpdate = 0L ;
long	gLastKick = 0L ;

int HandleTimer()
{

	gLogAmount = gStatusGC->GetLongValue(_T("LogAmount")) ;
//	long	SuspendNow = gRELookAhead->GetLongValue(_T("SuspendNow")) ;

	if( gLogAmount >= 3 )
	{
		TCHAR			*TextStatus[5] ;
		TextStatus[0] = _T("Status?") ;
		TextStatus[1] = _T("Running") ;
		TextStatus[2] = _T("Suspended") ;
		TextStatus[3] = _T("ShuttingDown") ;
		TextStatus[4] = _T("Quitting") ;

		SessionLogDirect( _T("****\tREBatch.HandleTimer: REStatus: %s, PagesToGo: %ld"),
			TextStatus[gREStatus], gPagesToGo ) ;
	}

	if( gREStatus != RE_SUSPENDED && gPagesToGo <= 0 )	/*&& SuspendNow == FALSE */ 
	{
		PostAThreadMessage( gThisThread, REM_BATCH_BATCHCOMP, 0L, 0L ) ;
	}

	if( gCurrentBatch == NULL )
	{
		return( TRUE ) ;
	}

	if( gREStatus == RE_RUNNING ) // && SuspendNow == FALSE )
	{
		PostAThreadMessage( gThisThread, REM_BATCH_RENDER_JOB, 0L, 0L ) ;	//	Render a Job
		PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program a Job
		PostAThreadMessage( gThisThread, REM_BATCH_PARSE_JOB,  0L, 0L ) ;	//	Parse a Job
	}


	if( gREStatus == RE_QUITTING )
	{
//		if( gPageRendering == NULL )
		if( gPagesRendering->GetNumEntries() == 0 )
		{
			//	TBD		TAKE CARE OF ANY UNFINISHED PAGES (UPDATE JOB QUEUE.)
			PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;	//	Shutdown this thread.
		}
	}

	if( gREStatus == RE_SHUTTING_DOWN )
	{
		SessionLogDirect(_T("****\tREBatchThread.HandleTimer: Status = %ld, PagesToGo: %ld"), gREStatus, gPagesToGo ) ;
		if( gPagesToGo == 0L )
		{
			PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;	//	Shutdown this thread.
		}
	}

	long	TimeNow = Clock() ;
	if( TimeNow > gLastLogUpdate + 10000 )
	{
		TCHAR	*BatchID = _T(" ") ;
		if( gCurrentBatch )
		{
			BatchID = gCurrentBatch->GetStringValue(_T("BatchID")) ;
		}

		long	 Parsed	 = gParsedQueue->GetNumEntries() ;
		long	 Program = gProgrammedQueue->GetNumEntries() ;
		long	 Renderd = gRenderedQueue->GetNumEntries() ;
		long	 Complet = gCompletedQueue->GetNumEntries() ;
		long	 Errord  = gErrorJobQueue->GetNumEntries() ;
		long	 PFilled = gPaperFillHoldQueue->GetNumEntries() ;

		if( gLogAmount >= 1 )
		{
			SessionLogDirect( _T("****\tREBatchThread.HandleTimer:    Batch     PagesToGo Parsed  PFill Prog Rendered Complete Errs")) ; 
			SessionLogDirect( _T("****\tREBatchThread.HandleTimer: \"%-10.10s\" %9ld %6ld %6ld %4ld %8ld %8ld %5ld"),
							BatchID, gPagesToGo, Parsed, PFilled, Program, Renderd, Complet, Errord ) ;
		}

		gLastLogUpdate = TimeNow ;

	}

	if( TimeNow > gLastKick + 10000 && gREThread )
	{
		PostAThreadMessage( gREThread, WM_TIMER, 0L, 0L ) ;
		gLastKick = TimeNow ;
	}

	return( TRUE ) ;
}

/*
	gParsedQueue		= new UQueue ;		//	THE LIST OF PARSED JOBS
	gProgrammedQueue	= new UQueue ;		//	THE LIST OF PROGRAMMED JOBS
	gRenderedQueue		= new UQueue ;		//	THE LIST OF RENDERED JOBS
	gCompletedQueue		= new UQueue ;		//	THE LIST OF COMPLETED JOBS
	gErrorJobQueue		= new UList ;		//	THE LIST OF ERROR'D JOBS
	gPaperFillHoldQueue = new UQueue ;		//	THE PAPER FILL PAGE LIST
*/
//=============================================================================
//=============================================================================
//========================== START RENDERING ==================================
//=============================================================================
//=============================================================================

int StartRendering()
{
	gREStatus = RE_RUNNING ;
	gSuspendType = 0 ;

	//	BELOW IS DEBUG STUFF
	if( gLogAmount >= 3 )
	{
		if( gPageList )
		{
			UListIterator	*anIter = new UListIterator( gPageList ) ;
			UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
			while( aPage )
			{
				SessionLogDirect(_T("****\tREBatchThread.StartRendering: Order: \"%s\", Item: \"%ld\", PageID: P%09ld, EndOfOrder: %ld"),
					aPage->GetStringValue(_T("OrderID")),
					aPage->GetLongValue(_T("OrderItemID")),
					aPage->GetLongValue(_T("JobID")),
					aPage->GetLongValue(_T("EndOfOrder")) ) ;
				aPage  = (UGenCon *) anIter->GetNext() ;
			}
			delete anIter ;
		}
	}
	//	ABOVE IS DEBUG STUFF

	PostAThreadMessage( gThisThread, REM_BATCH_PARSE_JOB, 0L, 0L ) ;

	return( TRUE ) ;
}


int ParseAJob()
{
	long		 PageState ;

	if( gLogAmount >= 7 )
		{ SessionLogDirect( _T("****\tREBatchThread.ParseAJob")) ; }

	if( WeCanParse() == FALSE )		{ return( FALSE ) ; }

	if( gPageList )
	{
		TCHAR		 PageIDString[1024] ;
		TCHAR		 Msg[1024] ;

		if( gLogAmount >= 8 )	{ DumpList(gPageList) ; }

		UGenCon		*aPage = gPageList->GetAt(gPageListPos++) ;
		if( aPage )
		{
			PageState = aPage->GetLongValue(_T("State")) ;

			if( PageState != PAGE_READY )	{ return( FALSE ) ; }

			GetPageIDString( aPage, PageIDString ) ;

			if( gLogAmount >= 3 )
			{
				SessionLogDirect(_T("****\tREBatchThread.ParseAJob: Got Page at: %ld, Page: \"%s\""), gPageListPos-1, PageIDString ) ;
			}

			if( gLogAmount >= 3 )
				{ SessionLogDirect( _T("****\tREBatchThread.ParseAJob: %s"), PageIDString ) ; }

			UIC		*theUIC = GetTheUIC(aPage) ;
			if( theUIC == NULL )			{ return( FALSE ) ; }

//=============================================================================
			URenderList	*theRL = ParseTheJob( aPage, theUIC ) ;
//=============================================================================

			if( theRL == NULL )
			{
				
				//	if this is the last job, and we are paper filling, then we
				//	have some clean-up to do.	QWERTY TBD QWERTY


				sprintf( Msg, _T("****\tREBatchThread.ParseAJob: ERROR: Page: P%09ld, No Render List From ParseTheJob."), 
													aPage->GetLongValue(_T("JobID")) ) ;
				AddError( aPage, Msg ) ;
				PostAThreadMessage( gThisThread, REM_BATCH_PARSE_ERROR, 0L, aPage ) ;	//	say we have an error.

				CreateEndOfOrderPackage(aPage) ;

				return( FALSE ) ;
			}

			DoQueueOverRides( aPage, theRL ) ;

			//	VERIFY THAT THIS IMAGE WILL FIT ON THE PAPER...
			if( ImageFitsOnPaper( theRL ) == FALSE )
			{
				sprintf( Msg, _T("****\tREBatchThread.ParseAJob: ERROR: Page: P%09ld, Page will not fit on paper."), 
													aPage->GetLongValue(_T("JobID")) ) ;
				SessionLogDirect( Msg ) ;

				sprintf( Msg, _T("Parsing Job: ERROR: Page: P%09ld will not fit on the paper."), 
													aPage->GetLongValue(_T("JobID")) ) ;
				
				AddError( aPage, Msg ) ;
				PostAThreadMessage( gThisThread, REM_BATCH_PARSE_ERROR, 0L, aPage ) ;	//	say we have an error.

				CreateEndOfOrderPackage(aPage) ;

//				PostAThreadMessage( gThisThread, REM_BATCH_PARSE_JOB,  0L, 0L ) ;	//	Parse another Job

				return( FALSE ) ;
			}

			if( gLogAmount >= 5 )
			{
				SessionLogDirect( _T("****\tREBatchThread.ParseAJob: SUCCESS.") ) ;
			}

			if( gPrinterSetupGC->GetLongValue(_T("PaperFill")) == FALSE )
			{
				aPage->SetLongValue( _T("State"), PAGE_PARSED ) ;
				aPage->SetLongValue( _T("PrintStatus"), PAGE_PARSED ) ;
				gParsedQueue->EnQueue( aPage ) ;
			}
			else	//	ELSE WE ARE PAPER FILLING
			{
				if( aPage->GetLongValue(_T("IsPackage")) == FALSE )
				{
					//	THIS PAGE IS NOT A PACKAGE, SO PLACE IT IN HOLD QUEUE.
					aPage->SetLongValue( _T("State"), PAGE_PF_HOLD ) ;
					aPage->SetLongValue(_T("PrintStatus"), PAGE_PF_HOLD ) ;
					gPaperFillHoldQueue->EnQueue( aPage ) ;
					if( gLogAmount >= 6 )
					{
						SessionLogDirect( _T("****\tREBatch.ParseAJob: Adding to PaperFillHoldQueue: P%09ld"), aPage->GetLongValue(_T("JobID"))) ;
					}
				}

				HandlePaperFill( theRL, aPage ) ;

			}	//	END: WE ARE PAPER FILLING

			//	THERE MAY HAVE BEEN AN ERROR HANDLING PAPER FILL.
			PageState = aPage->GetLongValue(_T("State")) ;
			if( PageState < PAGE_CANCELLED )
			{
				gParsedQueue->EnQueue( aPage ) ;
			}

			if( PageState != PAGE_COMPLETE && PageState != PAGE_ERROR )
			{
//				UpdateJobRecord( aPage, PARSED ) ;
				UpdateJobRecord( aPage, PRINTING ) ;
			}

//			PostAThreadMessage( gThisThread, REM_BATCH_PARSE_JOB,  0L, 0L ) ;	//	Parse another Job

		}
	}

	return( TRUE ) ;
}


int CreateEndOfOrderPackage(UGenCon *aPage)
{
	long IsLastPage = aPage->GetLongValue(_T("EndOfOrder")) ;
	if( IsLastPage )
	{
		long	PkgCode = 0L ;
		long	IsEndOfOrder = TRUE ;
		if( gPrinterSetupGC->GetLongValue(_T("PaperFill")))
		{
			CreatePackagePage( PkgCode, IsEndOfOrder ) ;
		}
		return( TRUE ) ;
	}
	return( FALSE ) ;
}

//	Fields: Name	SpillOverType	Type	long		//	0: None, 1: Percent, 2: Fixed
//	Fields:	Name	SpillOverAmt	Type	double

int ImageFitsOnPaper(URenderList *theRL)
{
	int		 FitsOnPaper = FALSE ;

	UGenCon	*MainNode		= (UGenCon *) theRL->GetMainNode() ;
	UGenCon	*OutputNode		= (UGenCon *) theRL->GetOutputNode() ;

	double	 ImgWidth		= MainNode->GetDoubleValue(_T("IWidth:")) ;
	double	 ImgLines		= MainNode->GetDoubleValue( _T("IHeight:")) ;
	
	double	 ONPaperWidth	= OutputNode->GetDoubleValue(_T("PaperWidth:")) ;
	double	 ONPaperAdvance	= OutputNode->GetDoubleValue(_T("PaperAdvance:")) ;

	double	 PaperWidth		= gPrinterSetupGC->GetDoubleValue(_T("PaperWidth")) ;
	double	 PaperAdvance	= gPrinterSetupGC->GetDoubleValue(_T("PaperAdvance")) ;

	if( PaperWidth == 0.0 )		{ PaperWidth = ONPaperWidth ; }
	if( PaperAdvance == 0.0 )	{ PaperAdvance = ONPaperAdvance ; }

	if( PaperWidth == 0.0 || PaperAdvance == 0.0 )
	{
		//	THEN DON'T BOTHER CHECKING
		return( TRUE ) ; 
	}

	long	 SpillOverType	= gPrinterSetupGC->GetLongValue(_T("SpillOverType")) ;
	double	 SpillOverAmt	= gPrinterSetupGC->GetDoubleValue(_T("SpillOverAmt")) ;

	if( SpillOverType == 1L )
	{
		PaperWidth		*= SpillOverAmt ;
		PaperAdvance	*= SpillOverAmt ;
	}

	if( SpillOverType == 2L )
	{
		PaperWidth		+= SpillOverAmt ;
	}

	if( CompareDoubles( ImgWidth, ImgLines ) < 0 )			{ SwapDoubles( &ImgWidth, &ImgLines ) ; }
	if( CompareDoubles( PaperWidth, PaperAdvance ) < 0 )	{ SwapDoubles( &PaperWidth, &PaperAdvance ) ; }

	if( CompareDoubles( ImgWidth, PaperWidth ) <= 0 &&
		CompareDoubles( ImgLines, PaperAdvance ) <= 0 )
	{
		FitsOnPaper = TRUE ;
	}

	if( FitsOnPaper == FALSE )
	{
		SessionLogDirect( _T("****\tREBatch.ImageFitsOnPaper: ImgWidth: %lf, ImgHeight: %lf"), ImgWidth, ImgLines ) ;
		SessionLogDirect( _T("****\tREBatch.ImageFitsOnPaper: PaperWidth: %lf, PaperAdvance: %lf"), PaperWidth, PaperAdvance ) ;
		SessionLogDirect( _T("****\tREBatch.ImageFitsOnPaper: ONPaperWidth: %lf, ONPaperAdvance: %lf"), ONPaperWidth, ONPaperAdvance ) ;
	}

	return( FitsOnPaper ) ;
}


//	IF UseOverrides IS SET, THEN UPDATE THE OUTPUT NODE
int DoQueueOverRides( UGenCon *thePage, URenderList *theRL )
{
//	theRL->WriteJob( _T("C:\\Temp\\JobrOverRides_1.txt")) ;		//	TBD DEBUG

	URenderNode	*theRN = theRL->GetOutputNode() ;
	if( theRN )
	{
		if( gPrinterSetupGC->GetLongValue(_T("UseOverrides")))
		{
			long	 NodeRotation		= theRN->GetLongValue(_T("Rotation:")) ;
			double	 NodeRotated		= theRN->GetDoubleValue(_T("Rotated:")) ;	//	CRT / LED
			long	 NodeSharpen		= theRN->GetLongValue(_T("Sharpen:")) ;

			long	 SetupChannel		= gPrinterSetupGC->GetLongValue(_T("ChannelOR")) ;
			double	 SetupResolution	= gPrinterSetupGC->GetLongValue(_T("ResolutionOR")) ;
			long	 SetupRotation		= gPrinterSetupGC->GetLongValue(_T("DeltaRotation")) ;
			long	 SetupSharpen		= gPrinterSetupGC->GetLongValue(_T("DeltaSharpen")) ;
			double	 SetupPaperWidth	= gPrinterSetupGC->GetDoubleValue(_T("PaperWidthOR")) ;
			TCHAR	*SetupPaperSurf		= gPrinterSetupGC->GetStringValue(_T("PaperSurfaceOR")) ;
			long	 SetupPrtrResize	= gPrinterSetupGC->GetLongValue(_T("PrinterResizeOR")) ;

			//	SETUP Rotation GETS ADDED TO NODE ROTATION
			if( NodeRotation == 0L )	{ NodeRotation = NodeRotated ; }
			if( NodeRotation == 1 )		{ NodeRotation =  90L ; }
			
			NodeRotation = NodeRotation + SetupRotation ;
			theRN->SetLongValue( _T("Rotation:"), NodeRotation ) ;

			NodeRotated = NodeRotated + SetupRotation ;
			theRN->SetDoubleValue( _T("Rotated:"), NodeRotated ) ;

			if( SetupResolution > 5.0 )
			{
				theRN->SetDoubleValue( _T("XRes:"), SetupResolution ) ;
				thePage->SetDoubleValue( _T("Resolution:"), SetupResolution ) ; 
			}

			if( SetupSharpen > 0L )		
				{ theRN->SetLongValue(_T("Sharpen:"), NodeSharpen + SetupSharpen ) ; }

			if( SetupChannel > 0L )
				{ theRN->SetLongValue(_T("OEMPrinterChannel:"), SetupChannel ) ; }

			if( SetupPaperWidth > 0.0 )
			{
				theRN->SetDoubleValue( _T("PaperWidth:"), SetupPaperWidth ) ; 
				thePage->SetDoubleValue( _T("PaperWidth"), SetupPaperWidth ) ;
				gPrinterSetupGC->SetDoubleValue( _T("PaperWidth"), SetupPaperWidth ) ;
			}

			if( SetupPaperSurf )	
				{ theRN->SetLongValue( _T("OEMPrinterSurface:"), GetPaperSurfaceNumber( SetupPaperSurf ) ) ; }

			if( SetupPrtrResize > 0L )
				{ theRN->SetLongValue(_T("PrinterResize:"), SetupPrtrResize ) ; }

			//	LET'S TRY TO LEFT JUSTIFY THIS IMAGE
			//	THIS ASSUMES THAT THE MAIN NODE WILL BE FILLED.
/*			URenderNode *MainNode = theRL->GetMainNode() ;			**** THIS CODE BREAKS THE ROTATED: CODE (ABOVE) ! ****
			if( MainNode )
			{
				double	MainLeft	= MainNode->GetDoubleValue(_T("IX:")) ;
				double	MainTop		= MainNode->GetDoubleValue(_T("IY:")) ;
				double	MainWidth	= MainNode->GetDoubleValue(_T("IWidth:")) ;
				double	MainHeight	= MainNode->GetDoubleValue(_T("IHeight:")) ;

				double	PaperWidth	= theRN->GetDoubleValue( _T("PaperWidth:")) ;
				long	Rotation	= theRN->GetLongValue( _T("Rotated:")) ;

				double	NormArea	= 10000.0 ;
				double	RotArea		= 10000.0 ;

				if( MainHeight <= PaperWidth )	{ NormArea = MainWidth * PaperWidth ; }
				if( MainWidth  <= PaperWidth )	{ RotArea  = MainHeight * PaperWidth ; }

				if( NormArea < RotArea )
				{
					MainNode->SetDoubleValue( _T("IHeight:"), PaperWidth ) ;
					theRN->SetLongValue( _T("Rotation:"), 0L ) ;
					theRN->SetLongValue( _T("Rotated:"), 0L ) ;
				}
				if( RotArea < NormArea )
				{
					MainNode->SetDoubleValue( _T("IWidth:"), PaperWidth ) ;
					theRN->SetLongValue( _T("Rotation:"), 90L ) ;
					theRN->SetLongValue( _T("Rotated:"), 90L ) ;
				}
			}
*/
		}
	}

	return( TRUE ) ;
}

long GetPaperSurfaceNumber( TCHAR *SurfaceText )
{
	if( stricmp( SurfaceText, _T("Other")) == 0 )					{ return(  1L ) ; }
	if( stricmp( SurfaceText, _T("Matte")) == 0 )					{ return(  2L ) ; }
	if( stricmp( SurfaceText, _T("Semi Matte")) == 0 )				{ return(  3L ) ; }
	if( stricmp( SurfaceText, _T("Glossy")) == 0 )					{ return(  4L ) ; }
	if( stricmp( SurfaceText, _T("Smooth Luster")) == 0 )			{ return(  5L ) ; }
	if( stricmp( SurfaceText, _T("Ultra Smooth Hi Luster")) == 0 )	{ return(  6L ) ; }
	if( stricmp( SurfaceText, _T("Fine Grained Luster")) == 0 )		{ return(  7L ) ; }
	if( stricmp( SurfaceText, _T("Silk")) == 0 )					{ return(  8L ) ; }
	if( stricmp( SurfaceText, _T("Luster")) == 0 )					{ return(  9L ) ; }
	if( stricmp( SurfaceText, _T("Deep Matte")) == 0 )				{ return( 10L ) ; }
	if( stricmp( SurfaceText, _T("High Gloss")) == 0 )				{ return( 11L ) ; }
	return( 0L ) ;
}

int WeCanParse()
{
	if( gREStatus == RE_SUSPENDED )
	{
		return( FALSE ) ;
	}

	long	ParseAheadQty = gRELookAhead->GetLongValue(_T("ParseAhead")) ;

	if( gParsedQueue )
	{
		long	AlreadyParsed = gParsedQueue->GetNumEntries() ;

		if( gLogAmount >= 5 )
		{
			SessionLogDirect(_T("REBatchThread.WeCanParse: AlreadyParsed: %ld, ParseAheadQty: %ld"),
										AlreadyParsed, ParseAheadQty ) ;
		}

		if( AlreadyParsed >= ParseAheadQty )
		{
			return( FALSE ) ;
		}
	}
	return( TRUE ) ;
}

//	IF WE HAVE A PAGE THAT IS NOT A PACKAGE
//		ADD THE PAGE TO THE CURRENT PACKAGE.
//	IF THIS IS THE END OF ORDER PAGE, THEN
//		GET THE LAST PACKAGE AND CREATE THE
//		PAGE FOR THE PACKAGE.

//	KEEP THE LAST IMAGE PATH FOR THE "IMAGE BREAK" FEATURE
TCHAR	gLastImagePath[1024] ;

int HandlePaperFill( URenderList *theRL, UGenCon *aPage )
{
	long	IsPackage = aPage->GetLongValue(_T("IsPackage")) ;
	if( IsPackage == FALSE )
	{
		if( gLogAmount >= 5 )
		{
			SessionLogDirect( _T("****\tREBatchThread.HandlePaperFill: P%09ld Is Not a Package"),
											aPage->GetLongValue(_T("JobID"))) ;
		}

		UGenCon	*theOutputNode	= (UGenCon *) theRL->GetOutputNode( 0 ) ;
		long	PkgCode = theOutputNode->GetLongValue(_T("MultiPunch:")) ;
		long	IsEndOfOrder = FALSE ;
		long	PackageCount ;

		//	WE NEED TO UPDATE THE PAGE'S PROFILE SO THAT WE DO NOT APPLY COLOR PROFILE TWICE. 06/07/05
		TCHAR *ICCProfile = gPrinterSetupGC->GetStringValue(_T("ICCProfile")) ;
		if( ICCProfile )
		{
			if( *ICCProfile )
			{
				TCHAR	InputProfileName[1024] ;
	//			GetImageCorrections()->GetEditSpaceProfileName(InputProfileName);
				UImageCorrections *theImageCorr = GetImageCorrections(NULL,NULL) ;
				theImageCorr->GetEditSpaceProfileName(InputProfileName) ;
				theOutputNode->SetAttrValue(_T("ImageOutputProfile:"), InputProfileName ) ;
			}
		}



		//	HANDLE IMAGE BREAK HERE !
		long ImageBreak = gPrinterSetupGC->GetLongValue(_T("BreakOnNewImage")) ;
		if( ImageBreak )
		{
			if( IsNewImage(theRL) )
			{
				CreatePackagePage( PkgCode, IsEndOfOrder ) ;
			}
		}

//=============================================================================
		AddPageToPaperFill( theRL, aPage, 1L ) ;
//=============================================================================

		//	IF THIS IS THE LAST PAGE OF THE ORDER
		//	GET THE PKGCODE (IF ANY) AND CREATE THE PACKAGE
		if( aPage->GetLongValue(_T("EndOfOrder")))
		{
			if( gLogAmount >= 8 )
			{
				SessionLogDirect( _T("****\tREBatchThread.HandlePaperFill: Is End Of Order")) ;
			}

			//	GET THE LAST PACKAGE AND ADD IT TO THE END OF THE PAGE LIST !
			TCHAR	*OrderID = aPage->GetStringValue(_T("OrderID")) ;
			gCurrentBatch->SetAttrValue(_T("OrderID"), OrderID ) ;

			IsEndOfOrder = TRUE ;
			CreatePackagePage( PkgCode, IsEndOfOrder ) ;

			if( gLogAmount > 5 )
			{
				SessionLogDirect( _T("****\tREBatchThread.HandlePaperFill: Back From Handle Layout Page.")) ;
			}
		}
	}
	else	//	IsPackage == TRUE
	{
		if( gLogAmount >= 9 )
		{
			SessionLogDirect( _T("****\tREBatchThread.HandlePaperFill: Is a Package.  We shouldn't be here Anymore!")) ;
		}
	}
}


int IsNewImage(URenderList *theRL)
{
	int			 NewImage		= FALSE ;
	int			 MainHasImage	= FALSE ;
	URenderNode *theMainNode = theRL->GetMainNode() ;

	TCHAR		*SrcImg = theMainNode->GetStringValue(_T("IFile:")) ;
	if( SrcImg )
	{
		if( *SrcImg )
		{
			MainHasImage = TRUE ;
			if( stricmp( SrcImg, gLastImagePath ) != 0 )
			{
				NewImage = TRUE ;
				strcpy( gLastImagePath, SrcImg ) ;
			}
		}
	}

	if( MainHasImage == FALSE )
	{
		int			 IncludeMain = FALSE ;
		URenderNode *theImgNode  = theRL->GetNextPromptedImageNode( theMainNode, IncludeMain ) ;
		if( theImgNode )
		{
			SrcImg = theImgNode->GetStringValue(_T("IFile:")) ;
			if( stricmp( SrcImg, gLastImagePath ) != 0 )
			{
				NewImage = TRUE ;
				strcpy( gLastImagePath, SrcImg ) ;
			}
		}
	}

	return( NewImage ) ;
}

//	GETS THE OUTPUT FILE NAME FOR EACH PAGE INCLUDED IN THE PACKAGE
//	AND SETS UP THE PACKAGE IFILEs: TO REFERENCE THOSE FILE NAMES.
int UpdateFileNames( URenderList *theRL, UGenCon *thePkg )
{

	UList	*PkgPages = thePkg->GetChildren() ;
	if( PkgPages == NULL )	{ return( FALSE ) ; }

	UListIterator	*anIter = new UListIterator( PkgPages ) ;
	if( anIter == NULL )	{ return( FALSE ) ; }

	UGenCon			*aPkgPage  = (UGenCon *) anIter->GetFirst() ;
	while( aPkgPage )
	{
		ReplaceIFileWithImagePath( theRL, aPkgPage ) ;

		aPkgPage  = (UGenCon *) anIter->GetNext() ;
	}

	delete anIter ;

	return( TRUE ) ;
}

//	THIS REPLACES THE RENDER LISTS IFILE WITH THE PACKAGE PAGES IMAGE PATH.
int ReplaceIFileWithImagePath( URenderList *theRL, UGenCon *PkgPage )
{
	long	 NodeID ;
	TCHAR	 PageID[64] ;
	TCHAR	*JobPath ;

	TCHAR	*ImagePath = PkgPage->GetStringValue(_T("ImagePath")) ;

	if( ImagePath == NULL )		{ return( FALSE ) ; }
	if( ImagePath[0] == 0x00 )	{ return( FALSE ) ; }

	//	GET THE PageID WHICH IS THE PLACEHOLDER IN THE JOB FOR THIS PATH
	long	JobID = PkgPage->GetLongValue(_T("JobID")) ;
	sprintf( PageID, _T("P%09ld"), JobID ) ;

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("****\tREBatch.ReplaceRLsIFileWithPkgPageImagePath: Replacing %s, with %s"),
						PageID, ImagePath ) ;
	}

	//	NOW WALK THROUGH THE RENDER LIST TO REPLACE THE PAGEID WITH THE PACKAGE'S IMAGEPATH
	UList	*theList = theRL->GetCurrentRenderList() ;
	if( theList )
	{
		//	FIND THE FIRST NODE (INTID: = 10001)
		UListIterator	*anIter = new UListIterator( theList ) ;
		URenderNode		*aNode  = (URenderNode *) anIter->GetFirst() ;
		while( aNode )
		{
			NodeID = aNode->GetLongValue(_T("INTID:")) ;
			if( NodeID == 10001L ) { break ; }
			aNode  = (URenderNode *) anIter->GetNext() ;
		}

		while( aNode )
		{
			JobPath = aNode->GetStringValue(_T("IFILE:")) ;
			if( JobPath )
			{
				if( stricmp( JobPath, PageID ) == 0 )
				{
					NodeID = aNode->GetLongValue(_T("INTID:")) ;

					if( gLogAmount >= 8 )
					{
						SessionLogDirect( _T("****\tREBatch.ReplaceRLsIFileWithPkgPageImagePath: Replacing in Node: %ld"),
											NodeID ) ;
					}

					aNode->SetAttrValue(_T("IFILE:"), ImagePath ) ;
					break ;
				}
			}
			aNode  = (URenderNode *) anIter->GetNext() ;
		}

		delete anIter ;
	}
	return( TRUE ) ;
}


UIC	*GetTheUIC(UGenCon *thePage)
{
	UIC		*theUIC = new UIC ;
	if( theUIC == NULL )
	{
		TCHAR	PageIDString[128] ;
		GetPageIDString( aPage, PageIDString ) ;
		sprintf( Msg, _T("REBatchThread.GetTheUIC: Error: Creating UIC for %s."), PageIDString ) ;
		AddError( thePage, Msg ) ;
	}
	theUIC->SetPrintPage( thePage ) ;

	//	BE SURE TO SET UP THE PARSER FOR RUNNING ATTENDED OR NOT ATTENDED.
	long	RunMode = gPrinterSetupGC->GetLongValue(_T("RunAttended")) ;
	if( RunMode == 0 )	{ RunMode = 2 ; }
	theUIC->SetRunMode( RunMode ) ;

	return( theUIC ) ;
}

void GetFilePathNameAndExt( TCHAR *Source, TCHAR *FilePath, TCHAR *FileName, TCHAR *FileExtn )
{
	TCHAR	Src[2048] ;
	strcpy( Src, Source ) ;

	FileExtn[0] = 0 ;
	FileName[0] = 0 ;
	FilePath[0] = 0 ;

	if( strchr( Src, 0x2E ) )
	{
		GetLastToken( Src, FileExtn, 0x2E ) ;	//	"." GET THE EXTENSION
	}

	if( strchr( Src, 0x5C ) )
	{
		GetLastToken( Src, FileName, 0x5C ) ;	//	"\" GET THE BASE FILE NAME
		strcpy( FilePath, Src ) ;				//		GET THE PATH
	}
	else
	{
		strcpy( FileName, Src ) ;
	}

}

void GetLastToken( TCHAR *Source, TCHAR *Dst, int SrchChar )
{
	long	SrcPos = strlen( Source ) - 1L ;
	long	DstPos = 0L ;

	Dst[DstPos] = 0x00 ;

	while( SrcPos >= 0L && Source[SrcPos] != SrchChar )
	{
		SrcPos-- ;
	}

	if( SrcPos >= 0L )
	{
		Source[SrcPos] = 0x00 ;
		SrcPos++ ;

		while( Source[SrcPos] )
		{
			Dst[DstPos] = Source[SrcPos] ;
			SrcPos++ ;
			DstPos++ ;
		}
		Dst[DstPos] = 0x00 ;
	}
}

URenderList	*ParseTheJob( UGenCon *thePage, UIC *theUIC )
{
	int		 Result = FALSE ;
	TCHAR	 Msg[1024] ;
	TCHAR	 PageIDString[128] ;
	UList	*RenderLists = NULL ;

	TCHAR	*FileName = thePage->GetStringValue(_T("JobPath")) ;
	
	if( gLogAmount >= 1 )
	{
		SessionLogDirect( _T("REBatchThread.ParseTheJob: Start Parsing Page: \"%s\""), thePage->GetName()) ;
	}
//=============================================================================
	//													CheckLib IsJob	Unicode	  Trigger
	RenderLists = theUIC->ParseFile( FileName, NULL,		0,		1,		0,		NULL ) ;
	Result = theUIC->GetLastError()	;
//=============================================================================

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("REBatchThread.ParseTheJob: Done  Parsing Page: \"%s\""), thePage->GetName()) ;
	}

	if( thePage->GetLongValue(_T("IsPackage")))
	{
		DeleteThisFile( FileName ) ;		//	DEBUG DO NOT DELETE THIS FILE. 		QQ1QQ
	}

	if( RenderLists == NULL )
	{
		//	enum { SUCCESS=0, PARSE_ERROR = -1, FILE_NOT_FOUND = -2, UNKNOWN_ERROR = -3 } ;
		Result = theUIC->GetLastError() ;

		SessionLogDirect( _T("****\tREBatch.ParseTheJob: Result of UIC->ParseFile: %ld"), Result ) ;

		if( Result == theUIC->GetErrorCodeFromString(_T("PARSE_ERROR")))
		{
			AddParseError( thePage, FileName, _T("REBatchThread.ParseTheJob: Error: Could not parse job \"%s\" for %s.")) ;
		}
		if( Result == theUIC->GetErrorCodeFromString(_T("FILE_NOT_FOUND")))
		{
			AddParseError( thePage, FileName, _T("REBatchThread.ParseTheJob: Error: Could not read job \"%s\" for %s.")) ;
		}
		if( Result == theUIC->GetErrorCodeFromString(_T("UNKNOWN_ERROR")))
		{
			AddParseError( thePage, FileName, _T("REBatchThread.ParseTheJob: Error: Unknown error. \"%s\" for %s.")) ;
		}

		return( NULL ) ;
	}

	URenderList	*theRenderList = RenderLists->GetAt(0) ;

	if( theRenderList )
	{
		URenderNode *JobType = theRenderList->FindNodeByID( -8999 ) ;
		if( JobType )
		{
			JobType->SetLongValue( _T("RenderPage"),(long) thePage ) ;
		}

		thePage->SetLongValue(_T("URenderList"), theRenderList ) ;
		thePage->SetLongValue(_T("UIC"), theUIC ) ;

		AdjustRLForPrinterModel( theRenderList ) ;
	}
	else
	{
		AddParseError( thePage, FileName, _T("REBatchThread.ParseTheJob: Error: Could not parse job (2) \"%s\" for %s.")) ;
	}

//	theRenderList->WriteJob( _T("C:\\Temp\\RenderListJob.txt")) ;	//	DEBUG DEBUG DEBUG QWERTY ZXCVB

	return( theRenderList ) ;
}

int AdjustRLForPrinterModel( URenderList *theRL )
{
	TCHAR	*PrinterModel = gPrinterSetupGC->GetStringValue(_T("PrinterModel")) ;
	long	 NodeID		  = GetNodeIDFromPrinterModel( PrinterModel ) ;
	long	 CurrentNodeID ;

	long	 Copies			= 1L ;
	long	 Rotated		= 0L ;
	double	 PaperWidth		= 10.0 ;
	double	 PaperAdvance	= 10.0 ;
	double	 Resolution		= 0.0 ;
	double	 XRes			= 0.0 ;
	TCHAR	*QueueName		= gPrinterSetupGC->GetStringValue(_T("QueueName")) ;
	TCHAR	*SaveName		= _T("") ;
	TCHAR	*FileType		= _T("Jpeg") ;
	TCHAR	 SaveThisName[2048] ;

	TCHAR	*AfterSaveName	= _T("") ;

	long	 PaperFill = gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;

	UList	*theList = theRL->GetCurrentRenderList() ;

	UGenCon *OrigEnabledNode = GetEnabledOutputNode( theList ) ;

	if( OrigEnabledNode )
	{
		Copies			= OrigEnabledNode->GetLongValue(_T("Copies:")) ;
		Rotated			= OrigEnabledNode->GetLongValue(_T("Rotated:")) ;
		PaperWidth		= OrigEnabledNode->GetDoubleValue(_T("PaperWidth:")) ;
		PaperAdvance	= OrigEnabledNode->GetDoubleValue(_T("PaperAdvance:")) ;
		Resolution		= OrigEnabledNode->GetDoubleValue(_T("Resolution:")) ;
		XRes			= OrigEnabledNode->GetDoubleValue(_T("XRes:")) ;
		SaveName		= OrigEnabledNode->GetStringValue(_T("SaveName:")) ;

		if( SaveName )
		{
			strcpy( SaveThisName, SaveName ) ;
		}

		FileType		= OrigEnabledNode->GetStringValue(_T("SaveFileType:")) ;

		OrigEnabledNode->SetLongValue(_T("Enabled:"), 0L ) ;
	}


	UListIterator	*anIter = new UListIterator( theList ) ;
	URenderNode		*aNode  = (URenderNode *) anIter->GetFirst() ;
	while( aNode )
	{
		CurrentNodeID = aNode->GetLongValue(_T("INTID:")) ;

		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("****\tREBatch.AdjustRLForPrinterModel: NodeID: %ld, SaveThisName Retrieved: [%s]"),
								CurrentNodeID, SaveThisName ) ;
		}
		
		switch( CurrentNodeID )
		{
			case	-9002L	:	//	DISK/RP30/RR30
			case	-9003L	:	//	SFCRT/LFCRT/KPDM/KPDM II
			case	-9004L	:	//	LED
			case	-9030L	:	//	WINDOWS DRIVER PRINTER
				if( CurrentNodeID == NodeID )
				{
					aNode->SetLongValue(_T("Enabled:"), 1L ) ;
					aNode->SetAttrValue(_T("QueueName:"), QueueName ) ;

					if( PaperFill )
					{
						aNode->SetLongValue(_T("Copies:"), Copies ) ;
						aNode->SetLongValue(_T("Rotated:"), Rotated ) ;
						aNode->SetDoubleValue(_T("PaperWidth:"), PaperWidth ) ;
						aNode->SetDoubleValue(_T("PaperAdvance:"), PaperAdvance ) ;
						aNode->SetDoubleValue(_T("Resolution:"), Resolution ) ;
						aNode->SetDoubleValue(_T("XRes"), XRes ) ; 
						aNode->SetAttrValue(_T("SaveName:"), SaveThisName ) ;
						aNode->SetAttrValue(_T("SaveFileType"), FileType ) ;
					}
				}
				break ;
		}
		aNode  = (URenderNode *) anIter->GetNext() ;
	}
	delete anIter ;

	return( TRUE ) ;
}


UGenCon *GetEnabledOutputNode( UList *theList )
{
	UGenCon *EnabledNode = NULL ;
	long	 NodeID ;
	long	 Enabled ;
	UListIterator	*anIter = new UListIterator( theList ) ;
	URenderNode		*aNode = (URenderNode *) anIter->GetFirst() ;
	while( aNode )
	{
		NodeID = aNode->GetLongValue(_T("INTID:")) ;
		switch( NodeID )
		{
			case	-9002L	:	//	DISK/RP30/RR30
			case	-9003L	:	//	SFCRT/LFCRT/KPDM/KPDM II
			case	-9004L	:	//	LED
			case	-9030L	:	//	WINDOWS DRIVER PRINTER
				Enabled = aNode->GetLongValue(_T("Enabled:")) ;
				if( Enabled )
				{
					EnabledNode = aNode ;
				}
		}
		aNode = (URenderNode *) anIter->GetNext() ;
	}
	delete anIter ;
	return( EnabledNode ) ;
}


long GetNodeIDFromPrinterModel( TCHAR *PrinterModel )
{
	if( stricmp( PrinterModel, _T("Disk")) == 0 )			{ return( -9002L ) ; }
	if( stricmp( PrinterModel, _T("Kodak CRT")) == 0 )		{ return( -9003L ) ; }
	if( stricmp( PrinterModel, _T("Kodak LED")) == 0 )		{ return( -9004L ) ; }
	if( stricmp( PrinterModel, _T("Kodak LFCRT")) == 0 )	{ return( -9003L ) ; }
	if( stricmp( PrinterModel, _T("Kodak RP30")) == 0 )		{ return( -9002L ) ; }
	if( stricmp( PrinterModel, _T("Kodak RR30")) == 0 )		{ return( -9002L ) ; }
	if( stricmp( PrinterModel, _T("RR30")) == 0 )			{ return( -9002L ) ; }
	if( stricmp( PrinterModel, _T("KPDM")) == 0 )			{ return( -9003L ) ; }
	if( stricmp( PrinterModel, _T("KPDM II")) == 0 )		{ return( -9003L ) ; }
	if( stricmp( PrinterModel, _T("Windows Printer")) == 0)	{ return( -9030L ) ; }
	if( stricmp( PrinterModel, _T("NT Printer")) == 0 )		{ return( -9030L ) ; }
	if( stricmp( PrinterModel, _T("Durst")) == 0 )			{ return( -9002L ) ; }
	if( stricmp( PrinterModel, _T("Noritsu")) == 0 )		{ return( -9002L ) ; }
	return( 0L ) ;
}


void AddParseError( UGenCon *thePage, TCHAR *FileName, TCHAR *Format )
{
	TCHAR	 Msg[1024] ;
	TCHAR	 PageIDString[128] ;

	GetPageIDString( thePage, PageIDString ) ;
	sprintf( Msg, Format, FileName, PageIDString ) ;
	AddError( thePage, Msg ) ;
}

//=============================================================================
//=============================================================================
//========================  PAPER FILL ROUTINES  ==============================
//=============================================================================
//=============================================================================

int SetupPaperFill( UGenCon *PrinterSetup )
{
	if( PrinterSetup->GetLongValue(_T("PaperFill")))
	{
		double	PaperWidth = PrinterSetup->GetDoubleValue(_T("PaperWidth")) ;
		double	MaxAdvance = PrinterSetup->GetDoubleValue(_T("PaperAdvance")) ;
		double	MinAdvance = 0.5 ;

		SetArbitraryPageSize( PaperWidth, MinAdvance, MaxAdvance ) ;
	}

	return( TRUE ) ;
}

//	ADDS THE PAGE TO THE REQUESTED PAPER FILL ALGORITHM.
//	IF SUCCESSFUL
//		SET PAGE TO NO PRINT
//	ELSE NOT SUCCESSFULLY ADDED
//		GET THE PREVIOUS PACKAGE AND CREATE THE
//		PAGE FOR THE PACKAGE.
int AddPageToPaperFill( URenderList *theRenderList, UGenCon *thePage, long Level )
{
	int		 Result = TRUE ;
	int		 DeleteAfter = TRUE ;
	int		 PaperFillAlgorithm = gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;

	UGenCon *theLayout ;
	UGenCon	*MainNode		= (UGenCon *) theRenderList->GetMainNode() ;
	UGenCon	*theOutputNode	= (UGenCon *) theRenderList->GetOutputNode( 0 ) ;

	double	 Width  = MainNode->GetDoubleValue(_T("IWidth:")) ;
	double	 Height = MainNode->GetDoubleValue( _T("IHeight:")) ;

	TCHAR	 PageIDString[128] ;
	GetPageIDString( thePage, PageIDString ) ;

	long	OutQty	= theOutputNode->GetLongValue( _T("Copies:")) ;
	long	OIQty	= thePage->GetLongValue(_T("OrderItemQty")) ;
	long	Qty		= OutQty * OIQty ;
	long	IsEndOfOrder	= FALSE ;
	long	IsLastPage		= thePage->GetLongValue(_T("EndOfOrder")) ;
	long	PackageCount ;

	theOutputNode->SetLongValue(_T("Copies:"), Qty ) ;	//	IS THIS RIGHT ????  TBD

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.AddPageToPaperFill: OutNodeQty: %ld, OIQty: %ld, NewQty: %ld"),
					OutQty, OIQty, Qty ) ;
	}

	long	PkgCode = theOutputNode->GetLongValue(_T("MultiPunch:")) ;

	TCHAR	*OrderID = thePage->GetStringValue(_T("OrderID")) ;
	gCurrentBatch->SetAttrValue(_T("OrderID"), OrderID ) ;

	UGenCon	*aPage = thePage ;
	long	 NumPkgPrints ;
	TCHAR	 Msg[1024] ;

	while( Qty >= 1 )
	{
		if( Qty > 1 )	{ DeleteAfter = FALSE ; }
		else			{ DeleteAfter = TRUE ;	}

		if( PaperFillAlgorithm == 1 )				//	LUCHT
		{
			Result = AddLuchtPage( aPage, PageIDString, OrderID, Width, Height, DeleteAfter ) ;
		}

		if( PaperFillAlgorithm == 2 )				//	ARBITRARY
		{
			Result = AddArbitraryPage( aPage, PageIDString, OrderID, Width, Height, DeleteAfter ) ;
		}

		if( gLogAmount >= 3 )
		{
			SessionLogDirect( _T("****\tREBatch.AddPageToPaperFill: PageID: %s, Result: %d, Qty: %ld"),
								PageIDString, Result, Qty ) ;
		}

		if( Result == FALSE )	//	WE COULD NOT ADD THE PAGE TO THE PACKAGE
		{
//=============================================================================
			CreatePackagePage( 0L, IsEndOfOrder ) ;	//	BECAUSE THIS PAGE DID NOT GET IN THE PACKAGE !
//			CreatePackagePage( PkgCode, IsEndOfOrder ) ;
//=============================================================================

			if( gLogAmount >= 3 )
			{
				SessionLogDirect( _T("****\tREBatch.AddPageToPaperFill: Note: Adding Page: %09ld to next package."),
														aPage->GetLongValue(_T("JobID"))) ;
			}

			if( PaperFillAlgorithm == 1 )			//	LUCHT
			{
				Result = AddLuchtPage( aPage, PageIDString, OrderID, Width, Height, DeleteAfter ) ;
			}

			if( PaperFillAlgorithm == 2 )			//	ARBITRARY
			{
				Result = AddArbitraryPage( aPage, PageIDString, OrderID, Width, Height, DeleteAfter ) ;
			}

			if( Result == FALSE )
			{
				//	WE CANNOT PRINT THIS PAGE !	TBD
				sprintf( Msg, _T("ERROR: Cannot add Page \"%09ld\" to package."),
									aPage->GetLongValue(_T("JobID"))) ;

				AddError( aPage, Msg ) ;
				HandleParseError( aPage ) ;
				Qty = 1 ;

				//	FALL THROUGH HERE
			}
			else
			{
				gPaperFillPageList->InsertBack( aPage ) ;	//	NEW 12/21/04 (FOR LUCHT)
			}
		}
		else
		{
			if( Result == -1 )
			{
				//	WE CANNOT PRINT THIS PAGE !	TBD
				sprintf( Msg, _T("ERROR: Cannot add Page \"%09ld\" to package."),
									aPage->GetLongValue(_T("JobID"))) ;

				AddError( aPage, Msg ) ;
				HandleParseError( aPage ) ;
				Qty = 1 ;

				//	FALL THROUGH HERE
			}
//			gPaperFillPageList->InsertBack( aPage ) ;	//	NEW 12/21/04 (FOR LUCHT)
		}

		if( gLogAmount > 5 )
		{
			SessionLogDirect( _T("****\tREBatchThread.AddPageToPaperFill: After Add Page Result: %ld"), Result ) ;
		}

		//	TELL ANY SCRIPTS THAT THIS PAGE SHOULD NOT BE PRINTED.
		aPage->SetLongValue(_T("PrintThisPage"), 0L ) ;
		Qty-- ;
	}

	if( IsLastPage )
	{
		CreatePackagePage( PkgCode, TRUE ) ;
	}

	return( TRUE ) ;
}

//	GET THE PACKAGE FROM THE REQUESTED PAPER FILL ALGORITHM
//	CREATE THE PAGE FOR THE NEW PACKAGE
//	INSERT THE PAGE IN THE PAGE LIST
//	PARSE THE NEW PAGE
//	PUT THE PAGE IN THE PARSED QUEUE.
int CreatePackagePage( long PkgCode, long IsEndOfOrder )
{
	int		 PaperFillAlgorithm = gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;
	UGenCon *thePackage ;

//	IS THIS NEEDED FOR LUCHT ?
//	What if the page has already been rendered ?
	if( gPaperFillHoldQueue->GetNumEntries() == 0 )
	{
		//	DO NOT ADD A PACKAGE IF THERE ARE NO IMAGES IN IT.
		SessionLogDirect( _T("****\tREBatch.CreatePackagePage: Note: No pages in the Paper Fill Hold Queue.") ) ;
//		return( FALSE ) ;
	}

	if( PaperFillAlgorithm == 1 )				//	LUCHT
	{
		thePackage = GetLuchtPackage() ;
		if( thePackage && gLogAmount >= 8 )
		{
			SessionLogDirect(_T("****\tREBatch.CreatePackagePage: PackageCode: %ld <<*****"),
						thePackage->GetLongValue(_T("PackageCode"))) ;
			DumpCStack(_T("****\tREBatch.CreatePackagePage")) ;
		}
	}

	if( PaperFillAlgorithm == 2 )				//	ARBITRARY
	{
		thePackage = GetArbitraryPackage() ;
	}

	if( thePackage )
	{
		if( gLogAmount >= 8 )
		{
			thePackage->Dump(_T("****\tREBatch.CreatePackagePage: The Package Layout")) ;
			DumpLayoutData( thePackage ) ;	//	DEBUG
		}

		gPagesToGo++ ;

		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("****\tREBatch.CreatePackagePage: PagesToGo: %ld"), gPagesToGo ) ;
		}

//		if( PaperFillAlgorithm == 2 )	//	THIS DOESN'T WORK !!!	QWERTY
//		{
//			thePackage = Optimize( thePackage ) ;
//		}

		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("****\tREBatch.CreatePackagePage: Orig PkgCode: %ld, New PkgCode: %ld"),
							thePackage->GetLongValue(_T("PackageCode")), PkgCode ) ;
		}

		if( PkgCode )	{ thePackage->SetLongValue(_T("PackageCode"), PkgCode ) ; }

		//	CREATE A PAGE FOR THE NEW LAYOUT AND PUT IT IN THE gPageList
//=============================================================================
		UGenCon *NewPage = CreatePage( thePackage, IsEndOfOrder ) ;
//=============================================================================

		//	INSERT THE PAGE SO IT WILL EVENTUALLY BE DELETED.
		gPaperFillPackages->InsertBack( NewPage ) ;		//	NEW 11/03/04 TBD

		//	IF END OF ORDER, FORCE LAST PAGE TO DELETE AFTER.
		if( IsEndOfOrder )
		{
			ForceDeleteAfter(NewPage) ;
			NewPage->SetLongValue( _T("EndOfOrder"), TRUE ) ;
		}

		//	PARSE THE NEW PAGE
		UIC	*theUIC = GetTheUIC(NewPage) ;
		if( theUIC == NULL )			{ return( FALSE ) ; }

		URenderList	*theRL = ParseTheJob( NewPage, theUIC ) ;
		if( theRL == NULL )
		{
			//	HANDLE THE ERROR HERE !		TBD
			SessionLogDirect( _T("****\tREBatch.CreatePackagePage: Error: No RenderList from NewPage: P%09ld"), 
				NewPage->GetLongValue(_T("JobID"))) ;
		}

		if( theRL )
		{
			theRL->SetIsPaperFillJob( TRUE ) ;
		}

		//	NOW MOVE ALL THE PAGES IN THE HOLD QUEUE TO THE PARSED QUEUE
		UList			*Pages = NewPage->GetChildren() ;
		if( Pages )
		{
			long			 PageState ;
			UListIterator	*anIter = new UListIterator( Pages ) ;
			UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
			while( aPage )
			{
				if( gLogAmount >= 7 )
				{
					SessionLogDirect( _T("****\tREBatch.CreatePackagePage: Moving Page P%09ld from PFHoldQueue to ParsedQueue"), aPage->GetLongValue(_T("JobID"))) ;
				}

				//	ONLY PLACE PAGE IN PARSED QUEUE IF IN PF_HOLD STATE
				PageState = aPage->GetLongValue(_T("State")) ;
				gPaperFillHoldQueue->RemoveItem( aPage ) ;
				if( PAGE_PF_HOLD == PageState )
				{
					aPage->SetLongValue(_T("State"), PAGE_PARSED ) ;
					aPage->SetLongValue(_T("PrintStatus"), PAGE_PARSED ) ;

					if( IsPageInList( aPage, gParsedQueue ) == FALSE )
						{ gParsedQueue->EnQueue( aPage ) ; }
				}
				aPage  = (UGenCon *) anIter->GetNext() ;
			}
			delete anIter ;
		}

		//	PLACE THE NEWLY PARSED PAGE IN THE PARSED QUEUE.
		NewPage->SetLongValue(_T("State"), PAGE_PARSED ) ;
		NewPage->SetLongValue(_T("PrintStatus"), PAGE_PARSED ) ;
		gParsedQueue->EnQueue( NewPage ) ;

		if( gLogAmount >= 8 )
		{
			DumpList(gParsedQueue) ;
		}

		delete thePackage ;
	}
	return( TRUE ) ;
}

int IsPageInList( UGenCon *thePage, UList *theList )
{
	int	Result = FALSE ;

	UListIterator	*anIter = new UListIterator( theList ) ;
	UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
	while( aPage )
	{
		if( aPage == thePage )
		{
			Result = TRUE ;
			break ;
		}
		aPage  = (UGenCon *) anIter->GetNext() ;
	}

	delete anIter ;
	return( Result ) ;
}

int ForceDeleteAfter(UGenCon *NewPage)
{
	int		 Result = FALSE ;

	UList	*PkgPages = NewPage->GetChildren() ;

	if( PkgPages )
	{
		UListIterator	*anIter = new UListIterator( PkgPages ) ;
		UGenCon			*LastPage = anIter->GetLast() ;
		delete anIter ;

		if( LastPage )
		{
			LastPage->SetLongValue(_T("DeleteAfter"), 1L ) ;
			Result = TRUE ;
			if( gLogAmount >= 9 )
			{
				LastPage->Dump(_T("****\tREBatchThread.ForceDeleteAfter: aPage Setting DeleteAfter:")) ;
			}
		}
	}
	return( Result ) ;
}

//	SOME DEBUG CODE...
void DumpList(UList *aList)
{
	SessionLogDirect( _T("****\tREBatchThread.DumpList\t****")) ;
	TCHAR			*PageID ;
	long			 Count = 0L ;
	TCHAR			*PageState ;
	long			 State ;

	UListIterator	*anIter = new UListIterator( aList ) ;
	UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
	while( aPage )
	{
		PageID = aPage->GetStringValue(_T("PageID")) ;
		State  = aPage->GetLongValue(_T("State")) ;
		PageState = _T("Unknown") ;
		switch( State )
		{
			case	PAGE_READY		:	PageState = _T("Ready") ;		break ;
			case	PAGE_PARSED		:	PageState = _T("Parsed") ;		break ;
			case	PAGE_PROGRAMMED	:	PageState = _T("Programmed") ;	break ;
			case	PAGE_RENDERED	:	PageState = _T("Rendered") ;	break ;
			case	PAGE_CANCELLED	:	PageState = _T("Cancelled") ;	break ;
			case	PAGE_COMPLETE	:	PageState = _T("Complete") ;	break ;
			case	PAGE_ERROR		:	PageState = _T("Error") ;		break ;
			case	PAGE_PF_HOLD	:	PageState = _T("PF_Hold") ;		break ;
		}

		SessionLogDirect( _T("\t\t\t%04ld\tPageID: \"%-10.10s\"\t%s"), Count++, PageID, PageState ) ;
		aPage  = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;
	SessionLogDirect( _T("****\tREBatchThread.DumpList\t****")) ;
}

//	CREATES A PAGE TO RENDER FOR THE PACKAGE
UGenCon *CreatePage( UGenCon *theLayout, long IsEndOfOrder )
{
	if( gLogAmount > 7 )
	{
		SessionLogDirect( _T("****\tREBatchThread.CreatePage: for Layout: \"%s\""), theLayout->GetName()) ;
	}

	UGenCon	*thePage = new UGenCon(GetDataDictionary(_T("DDREPageInfo"))) ;
	if( thePage == NULL )	{ return( NULL ) ; }

	TCHAR	 NewJobID[32] ;
//	int Result = GenerateUniqueID( TCHAR *Type, TCHAR *result, TCHAR *format = NULL,long HowMany = 1 );
	int Result = GenerateUniqueID( _T("PrintJobID"), NewJobID, NULL, 1L ) ;

	if( gLogAmount > 3 )
	{
		SessionLogDirect( _T("*\tREBatchThread.CreatePage: New Job ID: %s"), NewJobID ) ;
	}

	TCHAR	PageID[256] ;
	TCHAR	LayoutPath[4096] ;
	TCHAR	TempPath[1024] ;

	thePage->SetParent( gCurrentBatch ) ;
	
	long	 NumPkgPrints	= gCurrentBatch->GetLongValue(_T("NumPkgPrints")) + 1L ;
	TCHAR	*BatchID		= gCurrentBatch->GetStringValue(_T("BatchID")) ;
	TCHAR	*OrderID		= gCurrentBatch->GetStringValue(_T("OrderID")) ;

	thePage->SetName( NewJobID ) ;
	thePage->SetAttrValue( _T("PageID"), NewJobID ) ;
	thePage->SetLongValue( _T("JobID"), atoi(NewJobID)) ;
	theLayout->SetLongValue(_T("Quantity"), 1L ) ;

//=============================================================================
	//	WRITE THE NEW LAYOUT TO DISK !
	long		 ThreadID	 = gREThread->GetThreadID() ;
	GetTemporaryFilePath( TempPath ) ;
	sprintf( LayoutPath, _T("%s\\J%s_%03ld.txt"), TempPath, NewJobID, Clock() % 1000 ) ;
	WriteTheLayout( LayoutPath, theLayout ) ;
//=============================================================================
//	FOR DEBUGGING
	if( gLogAmount >= 7 )
	{
		TCHAR	DebugLayoutPath[1024] ;
		sprintf( DebugLayoutPath, _T("%s\\J%s_%03ld_1.txt"), TempPath, NewJobID, Clock() % 1000 ) ;
		WriteTheLayout( DebugLayoutPath, theLayout ) ;
		SessionLogDirect( _T("****\tREBatch.CreatePage: DebugLayoutPath: \"%s\"."), DebugLayoutPath ) ;
	}
//=============================================================================

	long	TotalPrints = gCurrentBatch->GetLongValue(_T("TotalPrints")) ;
	gCurrentBatch->SetLongValue(_T("TotalPrints"), TotalPrints + 1L ) ;

	gCurrentBatch->SetLongValue( _T("NumPkgPrints"), NumPkgPrints ) ;

	thePage->SetLongValue( _T("PrintNumber"),	NumPkgPrints ) ;

	thePage->SetAttrValue( _T("BatchID"), BatchID ) ;
	thePage->SetAttrValue( _T("OrderID"), OrderID ) ;
	thePage->SetAttrValue( _T("JobID"), NewJobID ) ;
	thePage->SetLongValue( _T("Quantity"), 1L ) ;
	
	thePage->SetLongValue( _T("OrderItemQty"), 1L ) ;

	thePage->SetLongValue( _T("OrderItemID"), NumPkgPrints ) ;
	thePage->SetLongValue( _T("PrintThisPage"), 1L ) ;
	thePage->SetLongValue( _T("State"),	PAGE_READY ) ;
	thePage->SetLongValue( _T("PrintStatus"), PAGE_READY ) ;
	thePage->SetAttrValue( _T("JobPath"), LayoutPath ) ;
	thePage->SetLongValue( _T("IsPackage"), 1L ) ;

	//	ADD THE BARCODE HERE
	long	PkgCode = theLayout->GetLongValue(_T("PackageCode")) ;
	if( PkgCode )
	{
		TCHAR	BarCode[64] ;
		int	PackageCut = gPrinterSetupGC->GetLongValue(_T("PackageCut")) ;

		//	WHEN WE ARE READY TO HANDLE MULTIPLE COPIES, THIS NEEDS TO BE CHANGED.
		if( IsEndOfOrder )	{ PkgCode |= 0x80 ; }	//	NEEDS TO BE DONE BY IPS.

		if( PackageCut == 1 )	//	BarCode
		{
			GetBarCode( PkgCode, BarCode ) ;
			thePage->SetAttrValue( _T("BarCode"), BarCode ) ;
			thePage->SetLongValue( _T("BarCodeType"), 1L ) ;	//	0 For None, 1 For Full, 2 For the Intermediate
		}
		thePage->SetLongValue(_T("PkgCode"), PkgCode ) ;
	}

	AddLayoutPagesToPackage( thePage, theLayout ) ;

	return( thePage ) ;
}



//	MOVES PAGES FROM THE LAYOUT TO THE PAGE WITHOUT DELETING
//	OR COPYING THE PAGES.  THAT MEANS WE HAVE TWO POINTERS TO
//	THE SAME PAGE.  ONE IN THE LAYOUT AND ONE IN THE PACKAGE PAGE.
int AddLayoutPagesToPackage( UGenCon *thePkg, UGenCon *theLayout )
{
	UGenCon	*RenderPage ;

	UList	*LayoutPageList = theLayout->GetChildren() ;
	if( LayoutPageList )
	{
		if( gLogAmount >= 5 )
		{
			SessionLogDirect( _T("****\tREBatchThread.AddLayoutPagesToPackage: Number of Slots in layout: %ld"),
									LayoutPageList->GetNumEntries()) ;
		}

		long			 NodeID = 10001L ;
		UListIterator	*anIter = new UListIterator( LayoutPageList ) ;
		UGenCon			*anImageSlot = (UGenCon *) anIter->GetFirst() ;
		while( anImageSlot )
		{
			RenderPage  = anImageSlot->GetLongValue(_T("RenderPage")) ;

			if( RenderPage )
			{
				if( gLogAmount >= 5 )
				{
					SessionLogDirect( _T("****\tREBatchThread.AddLayoutPagesToPackage: NodeID: %ld Render Page: %s"),
									NodeID, RenderPage->GetName() ) ;
				}

				RenderPage->SetLongValue( _T("NodeID"), NodeID ) ;

				thePkg->AddChildBack( RenderPage ) ;
				RenderPage->SetParent( gCurrentBatch ) ;
			}
			else
			{
				if( gLogAmount >= 5 )
				{
					SessionLogDirect( _T("****\tREBatchThread.AddLayoutPagesToPackage: a Slots Render Page: None") ) ;
				}
			}

			NodeID++ ;
			anImageSlot = (UGenCon *) anIter->GetNext() ;
		}
		delete anIter ;
	}
	return( TRUE ) ;
}


void GetTemporaryFilePath( TCHAR *TempPath )
{
	//	DETERMINE WHERE TO PUT THE TEMPORARY IMAGE FILES
	long	 TempPathSize = 1024 ;

	int result = GetEnvironmentVariable( _T("TMP"), TempPath, TempPathSize ) ;

	if( result == 0 )
	{
		sprintf( TempPath, _T("%s\\Temp"), GetApplicationDirectory() ) ;
	}
	
	//	MAKE SURE THE PATH EXISTS
	CreateFullDirectoryPath( TempPath ) ;
}

TCHAR *GetImageID( URenderList *theRenderList )
{
	UList	*NodeList = theRenderList->GetCurrentRenderList() ;
	UListIterator	*anIter = new UListIterator( NodeList ) ;
	UGenCon			*aNode  = (UGenCon *) anIter->GetFirst() ;
	long			 NodeID ;
	TCHAR			*ImageID ;
	while( aNode )
	{
		NodeID = aNode->GetLongValue(_T("INTID:")) ;
		if( NodeID == -9001L || NodeID > 0L )
		{
			if( aNode->GetStringValue(_T("IPrompt:")))
			{
				ImageID = aNode->GetStringValue(_T("IFile:")) ;
				if( ImageID )
				{
					break ;
				}
			}
		}
		aNode  = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;
	return( ImageID ) ;
}


int	AddError( UGenCon *thePage, TCHAR *Msg )
{
	UList	*ErrorList = thePage->GetLongValue(_T("RenderErrorList")) ;
	if( ErrorList == NULL )
	{
		ErrorList = new UList ;
		thePage->SetLongValue(_T("RenderErrorList"), ErrorList ) ;
	}

	int	Result = FALSE ;
	UGenCon	*ErrorGC = GetErrorMsgGC() ;
	if( ErrorGC )
	{
		ErrorGC->SetAttrValue( _T("Text"), Msg ) ;
		ErrorList->InsertBack( ErrorGC ) ;
		Result = TRUE ;
	}
	SessionLogDirect( Msg ) ;
	return( Result ) ;
}


int ProgramAJob()
{
	TCHAR	 Msg[1024] ;
	TCHAR	 TempPath[2048] ;
	TCHAR	 FilePath[2048] ;
	TCHAR	 PageIDString[128] ;
	TCHAR	*PageID = _T(" ") ;

	PIEIF	*thePieInterface ;
	PIE		*thePie ;
	int		 Result = FALSE ;

	if( gREStatus != RE_RUNNING )		{ return( FALSE ) ; }

	if( WeCanProgram() == FALSE )		{ return( FALSE ) ; }

	UGenCon	*aPage = gParsedQueue->DeQueue() ;
	if( aPage == NULL )					{ return( FALSE ) ; }

	PageID				= aPage->GetStringValue(_T("PageID")) ;
	long	 PageState	= aPage->GetLongValue(_T("State")) ;

	GetPageIDString( aPage, PageIDString ) ;

	if( gLogAmount >= 7 )
	{
		sprintf( Msg, _T("****\tREBatchThread.ProgramAJob: %s"), PageIDString ) ;
		SessionLogDirect( Msg ) ;
	}

	if( PageState != PAGE_PARSED )
	{	//	CAN GET HERE IF THE PAGE HAS BEEN CANCELLED OR HAD AN ERROR.
		gErrorJobQueue->EnQueue( aPage ) ;
		SessionLogDirect( _T("****\tREBatchThread.ProgramAJob: Error: Page: \"%s\", PageState: %ld, should be 2."), 
														aPage->GetName(), PageState ) ;

		aPage->Dump(_T("****\tREBatchThread.ProgramAJob: PAGE NOT PARSED.")) ;

//		PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program another Job
		
		return( FALSE ) ;
	}

	//	NOW LET'S PROGRAM THE JOB
	thePieInterface = GetThePieIF() ;
	if( thePieInterface == NULL )
	{
//		PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program another Job
		return( FALSE ) ; 
	}


	thePie = GetPie() ;
	if( thePie == NULL )			
	{
		delete thePieInterface ; 

//		PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program another Job
		
		return( FALSE ) ; 
	}


	if( gLogAmount >= 5 )
	{
		SessionLogDirect(_T("****\tREBatch.ProgramAJob: Page: P%09ld, PIE: 0x%08lX"),
										aPage->GetLongValue(_T("JobID")), thePie ) ;
	}

	//	DO WE ALWAYS WANT TO SAY UNATTENDED AND THEN HANDLE ALL THE ERRORS
	//	HERE !	THAT MIGHT BE THE BEST APPROACH TO THIS.	TBD
	thePie->SetRunningAttended( FALSE ) ;
	
	if( gStatusGC )
	{
		thePie->SetRenderStatusGC( gStatusGC ) ;
	}


	UIC			*theUIC = aPage->GetLongValue(_T("UIC")) ;
	URenderList	*theRenderList = aPage->GetLongValue(_T("URenderList")) ;

	if( theRenderList == NULL )	//	WHY DO WE GET HERE ?????  QWERTY TBD
	{
		SessionLogDirect( _T("****\tREBatchThread.ProgramAJob: Page: \"%s\", UIC: 0x%08lX, RL: 0x%08lX."),
						PageID, theUIC, theRenderList ) ;
		delete thePieInterface ;
		delete thePie ;

//		PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program another Job
		
		return( FALSE ) ;
	}

//=============================================================================
	FixTheOutputNode( theRenderList, aPage ) ;
//=============================================================================

//	Result = RunScript( _T("PreProgramScript") ) ;		NOT YET WORKING

//=============================================================================
	//	IF WE ARE RUNNING PAPER FILL, THEN UPDATE THE SOURCE FILE NAMES

	if( aPage->GetLongValue(_T("IsPackage")))
	{
		UpdateFileNames( theRenderList, aPage ) ;

//	THE FOLLOWING IS FOR DEBUG PURPOSES...		TBD	DEBUG DEBUG
//			GetTemporaryFilePath( TempPath ) ;
//			sprintf( FilePath, _T("%s\\%s_%06ld.txt"),
//						TempPath, aPage->GetStringValue(_T("PageID")), Clock() ) ;
//			theRenderList->WriteJob( FilePath ) ;
//	...THE ABOVE IS FOR DEBUG PURPOSES

		if( gLogAmount >= 8 )
		{
			aPage->Dump(_T("****\tREBatchThread.ProgramAJob: aPage WritePackageCompleteData:")) ;
		}

	}
//=============================================================================

	theUIC->SetTraceMode(0) ;
	Result = thePieInterface->Init( theUIC, thePie, 0L ) ;

	double	PPI =  aPage->GetDoubleValue(_T("Resolution")) ;
	thePieInterface->SetPPI( PPI ) ;

	if( gLogAmount >= 8 )
	{
		SessionLogDirect( _T("****\tREBatchThread.ProgramAJob: After Init: PIEIF: 0x%08lX, UIC: 0x%08lX, PIE: 0x%08lX, PPI: %lf"),
					thePieInterface, theUIC, thePie, PPI ) ;
	}
	
//=============================================================================
	Result = thePieInterface->DoList( theRenderList, 1L ) ;
//=============================================================================

	if( Result == FALSE )
	{
		SessionLogDirect( _T("****\tREBatchThread.ProgramAJob: ERROR: Could not program page: P%09ld."),
						aPage->GetLongValue(_T("JobID")) ) ;
		delete thePieInterface ;
		delete thePie ;

//		PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program another Job
		
		return( FALSE ) ;
	}

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.ProgramAJob: Page: P%09ld, Setting Pie: 0x%08lX"),
						aPage->GetLongValue(_T("JobID")), thePie ) ;
	}

//=============================================================================
	aPage->SetLongValue( _T("Pie"), thePie ) ;
//=============================================================================

	if( gLogAmount >= 3 )
	{
		GetTemporaryFilePath( TempPath ) ;
		sprintf( FilePath, _T("%s\\RE_PieList.txt"), TempPath ) ;
		thePie->PIESaveToFile( FilePath ) ;
	}

//=============================================================================
	Result = SetupPage( aPage ) ;
//=============================================================================

	if( Result == FALSE )
	{
		SessionLogDirect( _T("****\tREBatchThread.ProgramAJob: ERROR: Could not setup page: P%09ld for output script."),
						aPage->GetLongValue(_T("JobID")) ) ;
		delete thePieInterface ;
		delete thePie ;
		aPage->SetLongValue( _T("Pie"), NULL ) ;

//		PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program another Job
		
		return( FALSE ) ;
	}

	if( thePieInterface )
	{
		delete thePieInterface ;
		thePieInterface = NULL ;
	}

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.ProgramAJob: Success: Page: \"%s\""), PageID ) ;
	}

	MovePageTo( aPage, gParsedQueue, gProgrammedQueue ) ;
	aPage->SetLongValue( _T("State"), PAGE_PROGRAMMED ) ;
	aPage->SetLongValue( _T("PrintStatus"), PAGE_PROGRAMMED ) ;

//	PostAThreadMessage( gThisThread, REM_BATCH_PRGRM_JOB,  0L, 0L ) ;	//	Program another Job

	return( FALSE ) ;
}

int WeCanProgram()
{
	if( gREStatus == RE_SUSPENDED )
	{
		return( FALSE ) ;
	}

	long	ProgramAheadQty = gRELookAhead->GetLongValue(_T("ProgramAhead")) ;

	if( gProgrammedQueue )
	{
		long	AlreadyProgrammed = gProgrammedQueue->GetNumEntries() ;

		if( gLogAmount >= 5 )
		{
			SessionLogDirect(_T("REBatchThread.WeCanProgram: AlreadyProgrammed: %ld, ProgramAheadQty: %ld"),
										AlreadyProgrammed, ProgramAheadQty ) ;
		}

		if( AlreadyProgrammed >= ProgramAheadQty )
		{
			return( FALSE ) ;
		}
	}
	return( TRUE ) ;
}

PIEIF	*GetThePieIF()
{
	PIEIF	*thePieInterface = new PIEIF ;
	if( thePieInterface == NULL )
	{
		sprintf( Msg,  _T("****\tREBatchThread.ProgramAJob: ERROR: Could not create the PIE Interface for %s."), PageIDString ) ;
		AddError( aPage, Msg ) ;
	}
	return( thePieInterface ) ;
}


PIE *GetPie()
{
	PIE	*thePie = new PIE ;
	if( thePie == NULL )
	{
		sprintf( Msg,  _T("****\tREBatchThread.ProgramAJob: Page: ERROR: Could not create the PIE for %s."), PageIDString ) ;
		AddError( aPage, Msg ) ;
	}

	return( thePie ) ;
}

int FixTheOutputNode( URenderList *theRenderList, UGenCon *aPage )
{
	int		Result = TRUE ;
	URenderNode	*theOutputNode = theRenderList->GetOutputNode( 0 ) ;
	if( theOutputNode )
	{
		Result = GetOutputFileName( theOutputNode ) ;

		TCHAR *OutFileName = theOutputNode->GetStringValue(_T("SaveName:")) ;
		aPage->SetAttrValue( _T("ImagePath"), OutFileName ) ;	//	TBD TBD TBD 11/03/04

		if( gLogAmount >= 3 )
		{
			SessionLogDirect( _T("****\tREBatch.FixTheOutputNode: Setting Page %s's ImagePath to: \"%s\"."),
								aPage->GetName(), OutFileName ) ;
		}

		//	FIX UP THE PRINT QUANTITY
		long	Copies = theOutputNode->GetLongValue(_T("Copies:")) ;
		long	OrderItemQty = aPage->GetLongValue(_T("OrderItemQty")) ;
		theOutputNode->SetLongValue(_T("Copies:"), Copies * OrderItemQty ) ;

		if( gLogAmount >= 3 )
		{
			SessionLogDirect( _T("****\tREBatchThread.FixTheOutputNode: Copies: %ld, OrderItemQty: %ld, Total: %ld"),
									Copies, OrderItemQty, Copies * OrderItemQty ) ;
		}


		//	CompressionQuality:		NEW 05/17/05
		long	 NodeQuality		= theOutputNode->GetLongValue(_T("CompressionQuality:")) ;
		long	 SetupQuality		= gPrinterSetupGC->GetLongValue(_T("QualityOR")) ;

		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("****\tREBatch.FixTheOutputNode: NodeQuality: %ld, SetupQuality: %ld"), NodeQuality, SetupQuality ) ;
		}

		if( SetupQuality == 0L )	{ SetupQuality = 100L ; }			//	DEFAULT TO 100 %
		if( NodeQuality == 0L )		{ NodeQuality = SetupQuality ; }
		theOutputNode->SetLongValue( _T("CompressionQuality:"), NodeQuality ) ;

		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("****\tREBatch.FixTheOutputNode: Final NodeQuality: %ld"), NodeQuality ) ;
		}


		//	FIX UP THE RESOLUTION
		double Resolution = GetResolution( theOutputNode ) ;

		if( gLogAmount >= 1 )
		{
			SessionLogDirect( _T("****\tREBatch.FixTheOutputNode: Back From GetResolution: %lf"), Resolution ) ;
		}

		theOutputNode->SetDoubleValue( _T("XRes:"), Resolution ) ;
		theOutputNode->SetDoubleValue( _T("YRes:"), Resolution ) ;
		theOutputNode->SetDoubleValue( _T("Resolution:"), Resolution ) ;
		aPage->SetDoubleValue( _T("Resolution"), Resolution) ;

		if( gPrinterSetupGC->GetLongValue(_T("PaperFill")) == FALSE )
		{
			//	DO NOT SET THE BORDERLESS FLAG IF RUNNING PAPER FILL.
			//	FIX THE BORDERLESS FLAG
			long Borderless = theOutputNode->GetLongValue(_T("Borderless:")) ;
			aPage->SetLongValue(_T("Borderless"), Borderless ) ;
		}
		else
		{
			aPage->SetLongValue(_T("Borderless"), FALSE ) ;
		}

		long Deferred = theOutputNode->GetLongValue(_T("Deferred:")) ;
		aPage->SetLongValue(_T("Deferred"), Deferred ) ;

		//	FIX UP THE CENTER FLAG
		long  XOff = theOutputNode->GetLongValue( _T("XOff:") ) ;
		long  YOff = theOutputNode->GetLongValue( _T("YOff:") ) ;
		if( theOutputNode->GetLongValue(_T("INTID:")) == -9004 )	//	IF IT IS AN LED
		{
			if( XOff == -1L && YOff == -1L )
				{ aPage->SetLongValue(_T("Center"), 1L ) ; }
		}
		else
		{
//			if( XOff == -1L && YOff == -1L )
//			{
				aPage->SetLongValue( _T("Center"), 1L ) ;		//	ALWAYS SET CENTER FOR CRT (AND OTHERS ?)
//			}
//			else
//			{
//				fImageAttrs->SetDoubleValue( _T("StartingHorCoordinate"), XOff ) ;
//				fImageAttrs->SetDoubleValue( _T("StartingVerCoordinate"), YOff ) ;
//			}
		}

		//	FIX THE LED IDPUNCH FLAG
		long IDPunch = theOutputNode->GetLongValue(_T("IDPunch:")) ;
		aPage->SetLongValue( _T("IDPunch"), IDPunch ) ;

		//	FIX THE WINDOWS PRINTER PrintRecord OR Configuration
		GetWinPrinterConfiguration(theOutputNode) ;

	}
	else
	{
		sprintf( Msg. _T("****\tREBatchThread.FixTheOutputNode: Cannot get output node for %s."), PageIDString ) ;
		SessionLogDirect( Msg ) ;
		Result = FALSE ;
	}
	return( Result ) ;
}

void GetWinPrinterConfiguration(URenderNode *theOutputNode)
{
	TCHAR	*PrintRecordName = theOutputNode->GetStringValue(_T("PrintRecord:")) ;
	if( PrintRecordName == NULL )
	{
		PrintRecordName = gPrinterSetupGC->GetStringValue(_T("Configuration")) ;
		theOutputNode->SetAttrValue(_T("PrintRecord:"), PrintRecordName ) ;
	}
	else
	{
		if( *PrintRecordName == 0x00 )
		{
			PrintRecordName = gPrinterSetupGC->GetStringValue(_T("Configuration")) ;
			theOutputNode->SetAttrValue(_T("PrintRecord:"), PrintRecordName ) ;
		}
	}
}


//	THERE ARE TWO FIELDS IN THE OUTPUT NODE FOR RESOLUTION DEPENDING ON PRINTER "XRes:" and "Resolution:"
//	WE USE THE "Resolution" IN THE QUEUE WHEN PAPER FILLING.
//	IF THE "UseOverrides" flag is TRUE AND WE HAVE A VALID RESOLUTION, IT SHOULD OVERRIDE THE JOB.
double GetResolution( URenderNode *theOutputNode )
{
	double	Resolution		= 0.0 ;
	long	PaperFill		= gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;
	long	UseOverrides	= gPrinterSetupGC->GetLongValue(_T("UseOverrides")) ;

	//	GET THE JOB RESOLUTION
	Resolution	= theOutputNode->GetDoubleValue( _T("XRes:")) ;
	if( Resolution < 10.0 )
		{ Resolution = theOutputNode->GetDoubleValue(_T("Resolution:")) ; }

	if( gLogAmount >= 1 )
	{
		SessionLogDirect( _T("****\tREBatch.GetResolution: OutputNode: %lf"), Resolution ) ;
	}

	//	IF WE ARE OVERRIDING THE JOB AND WE HAVE A VALID RESOLUTION, THEN USE IT
	if( UseOverrides )
	{
		double ORResolution = gPrinterSetupGC->GetDoubleValue(_T("ResolutionOR")) ;
		if( ORResolution >= 10.0 )
			{ Resolution = ORResolution ; }
	}

	if( gLogAmount >= 1 )
	{
		SessionLogDirect( _T("****\tREBatch.GetResolution: After OverRides: %lf"), Resolution ) ;
	}

	//	IF NO RESOLUTION IN THE OUTPUT NODE OR WE ARE PAPERFILLING, DEFAULT TO THE QUEUE RESOLUTION
	if( Resolution < 10.0 || PaperFill )
		{ Resolution = gPrinterSetupGC->GetDoubleValue(_T("Resolution")) ; }

	if( gLogAmount >= 1 )
	{
		SessionLogDirect( _T("****\tREBatch.GetResolution: After PaperFill: %lf"), Resolution ) ;
	}


	//	SETUP THE WINDOWS PRINTER
	TCHAR	*PrintRecord = theOutputNode->GetStringValue(_T("PrintRecord:")) ;
	if( PrintRecord == NULL )
	{
		PrintRecord = gPrinterSetupGC->GetStringValue(_T("Configuration")) ;
	}
	else
	{
		if( *PrintRecord == 0x00 )
		{
			PrintRecord = gPrinterSetupGC->GetStringValue(_T("Configuration")) ;
		}
	}


	if( PrintRecord )
	{
		if( *PrintRecord )
		{
			TCHAR	 ConfigPath[2048] ;
			TCHAR	*PrinterName = gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
			TCHAR	*PrinterModel = gPrinterSetupGC->GetStringValue(_T("PrinterModel")) ;
			PropertySheetPath( ConfigPath, PrinterModel, PrinterName, PrintRecord ) ;

			if( gLogAmount >= 1 )
			{
				SessionLogDirect( _T("****\tREBatch.GetResolution ConfigPath: %s"), ConfigPath ) ;
			}
		
			TCHAR	 PhysPrinterName[1024] ;
			double PrinterResolution = GetWinPrinterName( ConfigPath, PhysPrinterName ) ;
			if( Resolution < 10 )
			{
				Resolution = PrinterResolution ;
			}

			if( PrinterResolution < Resolution )
			{
				Resolution = PrinterResolution ;
			}
		}
	}

	if( gLogAmount >= 1 )
	{
		SessionLogDirect( _T("****\tREBatch.GetResolution (Returning): After PrintRecord: %lf"), Resolution ) ;
	}

	return( Resolution ) ;
}


int GetOutputFileName( URenderNode *theOutputNode )
{
	int		Result = FALSE ;

	TCHAR *NodeFileName	= theOutputNode->GetStringValue(_T("SaveName:")) ;
	TCHAR *FileType		= theOutputNode->GetStringValue(_T("SaveFileType:")) ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("**\tREBatch.GoutOutputFileName: FileName: \"%s\", Type: \"%s\""),
							NodeFileName, FileType ) ;
	}

	if( NodeFileName )
	{
		if( strlen( NodeFileName ) > 0 )
		{
			if( strlen( FileType ) > 0 )
			{
				Result = TRUE ;
			}
		}
	}

	if( Result == FALSE )
	{
		TCHAR *PtrFileName  = gPrinterSetupGC->GetStringValue(_T("OutputPath")) ;
		FileType			= gPrinterSetupGC->GetStringValue(_T("OutputFileType")) ;

		if( gLogAmount >= 4 )
		{
			SessionLogDirect( _T("REBatchThread.GetOutputFileName (PrinterSetup): File: \"%s\", Type: \"%s\"."), PtrFileName, FileType ) ;
		}

		if( stricmp( FileType, _T("0")) == 0 )	{ FileType = _T("TIFF") ; }
		if( stricmp( FileType, _T("1")) == 0 )	{ FileType = _T("JPEG") ; }

		if( gLogAmount >= 4 )
		{
			SessionLogDirect( _T("REBatchThread.GetOutputFileName (PrinterSetup): File: \"%s\", Type: \"%s\"."), PtrFileName, FileType ) ;
		}

		if( PtrFileName )
		{
			if( strlen( PtrFileName ) > 0 )
			{
				theOutputNode->SetAttrValue(_T("SaveName:"), PtrFileName ) ;
				if( strlen( FileType ) > 0 )
				{
					theOutputNode->SetAttrValue(_T("SaveFileType:"), FileType ) ;
				}
				Result = TRUE ;
			}
		}
	}

	if( Result == FALSE )
	{
		//	DO WE MAKE UP A NAME ?
		SessionLogDirect( _T("****\tREBatchThread.GetOutputFileName: ERROR: No Filename specified.") ) ;
		TCHAR	FilePath[1024] ;
		TCHAR	TmpPath[1024] ;
		int numCharsInBuf = GetEnvironmentVariable(_T("TMP"), TmpPath, 1024 ) ;
		if( numCharsInBuf )
		{
			sprintf( FilePath, _T("%s\\[-].jpg"), TmpPath ) ;
			theOutputNode->SetAttrValue(_T("SaveName:"), FilePath ) ;
			SessionLogDirect( _T("****\tREBatchThread.GetOutputFileName: theOutputNode: Output FileName Created: \"%s\"."), FilePath ) ;
		}
	}

	if( gLogAmount >= 7 )
	{
		NodeFileName = theOutputNode->GetStringValue(_T("SaveName:")) ;
		SessionLogDirect( _T("****\tREBatchThread.GetOutputFileName: theOutputNode: Output FileName: \"%s\"."), NodeFileName ) ;
	}

	return( Result ) ;
}

int GetFileType( URenderNode *theOutputNode )
{
	int		Result = FALSE ;

	TCHAR *FileType		= theOutputNode->GetStringValue(_T("SaveFileType:")) ;

	if( FileType )
	{
		if( strlen( FileType ) > 0 )
		{
			Result = TRUE ;
		}
	}

	if( Result == FALSE )
	{
		FileType = gPrinterSetupGC->GetStringValue(_T("OutputFileType")) ;
		if( FileType )
		{
			if( strlen( FileType ) > 0 )
			{
				theOutputNode->SetAttrValue(_T("SaveFileType:"), FileType ) ;
				Result = TRUE ;
			}
		}
	}

	if( Result == FALSE )
	{
		FileType = _T("Jpeg") ;
		SessionLogDirect( _T("REBatchThread.GetFileType: ERROR: No FileType Specified. Setting To: %s"), FileType ) ;
		theOutputNode->SetAttrValue(_T("SaveFileType:"),FileType ) ;
	}

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("REBatchThread.GetFileType: FileType From Node: \"%s\"."), FileType ) ;
	}

	return( Result ) ;
}


//	SETS UP THE DATA FOR THE PRINT COMPLETE AND ORDER COMPLETE SCRIPTS.
int SetupPage( UGenCon *thePage )
{
	TCHAR	Tmp[1024] ;
	TCHAR	TmpFilePath[2048] ;

	URenderList	*aRL = thePage->GetLongValue(_T("URenderList")) ;
	if( aRL == NULL )	{	return( FALSE ) ; }

	UGenCon	*MainNode = aRL->GetMainNode() ;
	if( MainNode == NULL )	{ return( FALSE ) ; }

	UGenCon	*OutNode = aRL->GetOutputNode() ;
	if( OutNode == NULL )	{ return( FALSE ) ; }

	TCHAR *OutFileName = OutNode->GetStringValue(_T("ExpandedSaveName")) ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("####>>>> REBatchThread.SetupPage: ExpandedSaveName: \"%s\"."), OutFileName ) ;
	}

	if( OutFileName == NULL )	//	WE HAVE A PROBLEM !
	{
		SessionLogDirect( _T("REBatchThread.SetupPage: Error: OutputFileName is NULL.")) ;
		TCHAR	*FileType = OutNode->GetStringValue(_T("SaveFileType:")) ;
		TCHAR	*ExeDirectory = GetExeDirectory() ;
		sprintf( TmpFilePath, _T("%s\\TempImageOutput\\Img%ld"), ExeDirectory, Clock()) ;

		if( stricmp( FileType, _T("JPEG")) == 0 )	{ strcat( TmpFilePath, _T(".jpg")) ; }
		else										{ strcat( TmpFilePath, _T(".tif")) ; }
		OutFileName = TmpFilePath ;
		SessionLogDirect( _T("REBatchThread.SetupPage: Made up name \"%s\"."), OutFileName ) ;
	}


	//	NEED TO DEFINE JUST THE FOLDER NOT THE FILE NAME
	TCHAR	FilePath[2048] ;
	TCHAR	FileName[280] ;
	TCHAR	FileExtn[32] ;
	GetFilePathNameAndExt( OutFileName, FilePath, FileName, FileExtn ) ;
	long	Result = CreateFullDirectoryPath(FilePath) ;
	
	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("REBatchThread.SetupPage: CreateFullDirectory Result: %ld"), Result ) ;
		SessionLogDirect( _T("****\tREBatchThread.SetupPage: Output Expanded FileName: \"%s\"."), OutFileName ) ;
	}

	double	Width = MainNode->GetDoubleValue(_T("IWidth:")) ;
	double	Lines = MainNode->GetDoubleValue(_T("IHeight:")) ;

	TCHAR	ProductDesc[64] ;
	GetProductDescription( Width, Lines, ProductDesc ) ;
	thePage->SetAttrValue( _T("ProductDesc"), ProductDesc ) ;

	if( Width < Lines )
	{
		thePage->SetDoubleValue( _T("ShortDimension"), Width ) ;
		thePage->SetDoubleValue( _T("LongDimension"), Lines ) ;
	}
	else
	{
		thePage->SetDoubleValue( _T("ShortDimension"), Lines ) ;
		thePage->SetDoubleValue( _T("LongDimension"), Width ) ;
	}

	thePage->SetAttrValue( _T("Units"), _T("INCH")) ;
	thePage->SetLongValue( _T("Quantity"), OutNode->GetLongValue(_T("Copies:"))) ;

	thePage->SetLongValue(_T("OutputNode"), OutNode ) ;

	if( gLogAmount >= 3 )
	{
		SessionLogDirect( _T("**\tREBatchThread.SetupPage: Page: %ld, OutFileName: \"%s\"."),
									thePage->GetLongValue(_T("JobID")), OutFileName ) ;
	}

	thePage->SetAttrValue(_T("ImagePath"), OutFileName ) ;

	long	PaperSurface = 	OutNode->GetLongValue(_T("OEMPrinterSurface:")) ;
	
	if( PaperSurface == 0L )
	{
		TCHAR *PaperSurfTxt = gPrinterSetupGC->GetStringValue(_T("PaperSurface")) ;
		PaperSurface = GetPaperSurfaceNumber( PaperSurfTxt ) ;
	}

	thePage->SetAttrValue(_T("FileFormat"),			OutNode->GetStringValue(_T("SaveFileType:"))) ;
	thePage->SetLongValue(_T("PrinterChannel"),		OutNode->GetLongValue(_T("OEMPrinterChannel:"))) ;
	thePage->SetLongValue(_T("PaperSurface"),		OutNode->GetLongValue(_T("OEMPrinterSurface:"))) ;
	thePage->SetLongValue(_T("OEMPrinterChannel"),	OutNode->GetLongValue(_T("OEMPrinterChannel:"))) ;
	thePage->SetLongValue(_T("OEMPrinterSurface"),	PaperSurface ) ;
	thePage->SetLongValue(_T("ReproMode"),			OutNode->GetLongValue(_T("ReproMode:"))) ;
	thePage->SetLongValue(_T("PrinterResize"),		OutNode->GetLongValue(_T("PrinterResize:"))) ;
	thePage->SetDoubleValue( _T("PaperWidth"),		OutNode->GetDoubleValue(_T("PaperWidth:"))) ;

	//	SETUP THE WINDOWS PRINTER
	TCHAR	*PrintRecord = OutNode->GetStringValue(_T("PrintRecord:")) ;
	if( PrintRecord == NULL )
	{
		PrintRecord = gPrinterSetupGC->GetStringValue(_T("Configuration")) ;
	}
	else
	{
		if( *PrintRecord == 0x00 )
		{
			PrintRecord = gPrinterSetupGC->GetStringValue(_T("Configuration")) ;
		}
	}

	thePage->SetAttrValue( _T("PrintRecord"), PrintRecord ) ;
	if( PrintRecord )
	{
		if( *PrintRecord )
		{
			TCHAR	 ConfigPath[2048] ;
			TCHAR	*PrinterName = gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
			TCHAR	*PrinterModel = gPrinterSetupGC->GetStringValue(_T("PrinterModel")) ;
			PropertySheetPath( ConfigPath, PrinterModel, PrinterName, PrintRecord ) ;
			thePage->SetAttrValue(_T("PrintRecordPath"), ConfigPath ) ;

			TCHAR	 PhysPrinterName[1024] ;
			double Resolution = GetWinPrinterName( ConfigPath, PhysPrinterName ) ;
			thePage->SetAttrValue(_T("WinPhysPrinterName"), PhysPrinterName ) ;
			thePage->SetDoubleValue(_T("WinPhysPrinterRes"), Resolution ) ;
	//		thePage->SetDoubleValue( _T("Resolution"), Resolution ) ;		WRONG  FIX
		}
	}

	TCHAR	*PaperPack = GetPaperPack( OutNode ) ;
	thePage->SetAttrValue(_T("PaperPackPath"), PaperPack ) ;

	TCHAR	*CalLut = GetPrintLut( OutNode ) ;
	thePage->SetAttrValue(_T("CalLutPath"), CalLut ) ;

	
	OutNode->GetAttrValue( _T("ExpandedCDSaveName"), Tmp ) ;
	thePage->SetAttrValue(_T("ExpandedCDSaveName"), Tmp ) ;

	UIC		*theUIC = thePage->GetLongValue(_T("UIC")) ;
	if( theUIC )
	{
		TCHAR	Line1[128] ;
		TCHAR	Line2[128] ;
		int	ScreenDisplay = FALSE ;
		theUIC->GetAnnotationText( 1L, Line1, Line2, ScreenDisplay ) ;
		strcat( Line1, _T("\n")) ;
		strcat( Line1, Line2 ) ;
		thePage->SetAttrValue(_T("BackPrintMessage1"), Line1 ) ;

		theUIC->GetAnnotationText( 2L, Line1, Line2, ScreenDisplay ) ;
		strcat( Line1, _T("\n")) ;
		strcat( Line1, Line2 ) ;
		thePage->SetAttrValue(_T("BackPrintMessage2"), Line1 ) ;
	}
	else
	{
		thePage->Dump(_T("The Page's UIC is NULL ????????  QQQ")) ;
	}

	if( gPrinterSetupGC->GetLongValue(_T("PaperFill")) == FALSE )
	{
		TCHAR	 BarCode[64] ;
		long	 PackageCut	 = gPrinterSetupGC->GetLongValue(_T("PackageCut")) ;
		long	 PackageCode = OutNode->GetLongValue(_T("MultiPunch:")) ;
//		long	 PackageCode = thePage->GetLongValue(_T("PkgCode")) ;

		if( PackageCode && PackageCut == 1 )	//	BARCODE WITHOUT PAPER FILL ?????
		{
			GetBarCode( PackageCode, BarCode ) ;
			thePage->SetAttrValue( _T("BarCode"), BarCode ) ;
			thePage->SetLongValue( _T("BarCodeType"), 1L ) ;	//	0 For None, 1 For Full, 2 For the Intermediate
		}

		if( PackageCode && PackageCut == 2 )	//	MULTIPUNCH WITHOUT PAPER FILL ?????	tbd  qwerty
		{
			thePage->SetLongValue(_T("PkgCode"), PackageCode ) ;
		}
	}

	thePage->SetAttrValue(_T("COLORSPACE"), _T("SRGB")) ;
	thePage->SetLongValue(_T("DELETEONCOMPLETE"), TRUE ) ;

	return( TRUE ) ;
}


TCHAR	*GetPaperPack(URenderNode *OutputNode )
{
	TCHAR	*PaperPack = OutputNode->GetStringValue(_T("PaperCalTable:")) ;
	if( PaperPack == NULL )
	{
		PaperPack = gPrinterSetupGC->GetStringValue(_T("PaperPackPath")) ;
	}
	else
	{
		if( *PaperPack == 0x00 )
		{
			PaperPack = gPrinterSetupGC->GetStringValue(_T("PaperPackPath")) ;
		}
	}
	return( PaperPack ) ;
}

TCHAR	*GetPrintLut(URenderNode *OutputNode )
{
	TCHAR	*PrintLut = OutputNode->GetStringValue(_T("Lookup:")) ;
	if( PrintLut == NULL )
	{
		PrintLut = gPrinterSetupGC->GetStringValue(_T("CalLutPath")) ;
	}
	else
	{
		if( *PrintLut == 0x00 )
		{
			PrintLut = gPrinterSetupGC->GetStringValue(_T("CalLutPath")) ;
		}
	}
	return( PrintLut ) ;
}


TCHAR	*GetProductDescription( double Width, double Length, TCHAR *Result )
{
	TCHAR	WTemp[64] ;
	TCHAR	LTemp[64] ;

	sprintf( WTemp, _T("%2.1lf"), Width ) ;
	sprintf( LTemp, _T("%2.1lf"), Length ) ;

	StripDotZero( WTemp ) ;
	StripDotZero( LTemp ) ;

	sprintf( Result, _T("%sx%s"), WTemp, LTemp ) ;
	return( Result ) ;
}

void StripDotZero( TCHAR *Buf )
{
	int	Pos = 0 ;
	while( Buf[Pos] )
	{
		if( Buf[Pos] == 0x2E )			//	'.'
		{
			if( Buf[Pos+1] == 0x30 )	//	'0'
			{
				Buf[Pos] = 0x00 ;
				return ;
			}
		}
		Pos++ ;
	}
}

//	THIS ROUTINE WILL CREATE A CIThread TO HANDLE THE ACTUAL RENDER.
int RenderAJob()
{
	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("****\tREBatchThread.RenderAJob: gPagesRendering: %ld"),
						gPagesRendering->GetNumEntries() ) ;
	}

	int		Result = FALSE ;

	if( gREStatus != RE_RUNNING )		{ return( FALSE ) ; }

//	if( gPageRendering )
	if( gPagesRendering->GetNumEntries() >= gNumSimultaneousRenders )		//	CHANGE '1' FOR ALLOWING RENDERING OF MORE THAN ONE SIMULTANEOUSLY.
	{
		//	WE ARE CURRENTLY RENDERING ANOTHER PAGE
		//	SO GET OUT !
		
//		PostAThreadMessage( gThisThread, REM_BATCH_RENDER_JOB, 0L, 0L ) ;	//	Render a Job

		return( FALSE ) ;
	}

	if( WeCanRender() == FALSE )
	{
//		PostAThreadMessage( gThisThread, REM_BATCH_RENDER_JOB, 0L, 0L ) ;	//	Render a Job
		return( FALSE ) ; 
	}

	UGenCon *thePage = gProgrammedQueue->DeQueue() ;

	if( thePage )
	{
		if( thePage->GetLongValue(_T("State")) != PAGE_PROGRAMMED )
		{
			//	WE CAN GET HERE IF A PAPER FILL PAGE GOT CANCELLED (OR AN ERROR)
			gErrorJobQueue->EnQueue( thePage ) ;
//			PostAThreadMessage( gThisThread, REM_BATCH_RENDER_JOB, 0L, 0L ) ;	//	Render a Job
			return( FALSE ) ;
		}

//=============================================================================
		Result = RunPreRenderScript() ;
//=============================================================================

		PIE	*thePie = thePage->GetLongValue(_T("Pie")) ;	//	WE SHOULDN'T NEED TO PUT THIS HERE
		if( thePie == NULL )								//	BUT IT DOES WORK.  TBD FIGURE OUT WHY
		{													//	AND FIX IT CORRECTLY.
//			PostAThreadMessage( gThisThread, REM_BATCH_RENDER_JOB, 0L, 0L ) ;	//	Render a Job
			return( FALSE ) ;	//	MUST HAVE BEEN ALREADY RENDERED. TBD ?????
		}
		
		//	UPDATE THE BATCH INFORMATION FOR THE LATEST ITEM BEING RENDERED.
		TCHAR	*OrderID = thePage->GetStringValue(_T("OrderID")) ;
		gCurrentBatch->SetAttrValue( _T("OrderID"), OrderID ) ;

		long	 ItemID = thePage->GetLongValue(_T("OrderItemID")) ;
		gCurrentBatch->SetLongValue( _T("OrderItemID"), ItemID ) ;
		gCurrentBatch->SetLongValue( _T("JobID"), thePage->GetLongValue(_T("JobID"))) ;

		if( gLogAmount >= 5 )		//	TBD  DEBUG 10/19/04  was 5
		{
			SessionLogDirect( _T("****\tREBatchThread.RenderAJob: P%09ld, PageState: %ld, Pie: 0x%08lX"),
						thePage->GetLongValue(_T("JobID")), thePage->GetLongValue(_T("State")), thePie ) ;
		}

		//	WE HAVE A PAGE TO RENDER

//		UpdateJobRecord( thePage, PRINTING ) ;	//	SET TO PRINTING IN PARSE A JOB
		CIThread *thePieThread = StartPieThread(thePage) ;
		if( thePieThread )
		{
			gPageRendering = thePage ;
			gPagesRendering->EnQueue( thePage ) ;

			thePage->SetLongValue(_T("BatchThread"), gThisThread ) ;
			thePage->SetLongValue(_T("PieThread"),   thePieThread ) ;

			//	START THE RENDERING
			PostAThreadMessage( thePieThread, REM_PIE_SET_PAGE, 0L, thePage ) ;

			if( gStatusGC->GetLongValue(_T("QtyRendered")) == 0L )
			{
				PostAThreadMessage( thePieThread, REM_PIE_ADVERTIZE, 0L, 0L ) ;
			}

			//	START THE RENDERING
			PostAThreadMessage( thePieThread, REM_PIE_START_RENDER, 0L, 0L ) ;
		}
	}
	else
	{
		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("****\tREBatchThread.RenderAJob: After Dequeue gPageRendering: %0ld"),
							gPagesRendering->GetNumEntries() ) ;
		}
	}

//	PostAThreadMessage( gThisThread, REM_BATCH_RENDER_JOB, 0L, 0L ) ;	//	Render a Job

	return( TRUE ) ;
}


long RunPreRenderScript()
{
	long	 Result = FALSE ;
	TCHAR	 Path[2048] ;
	TCHAR	 FuncCall[1024] ;

	TCHAR	*PreRenderScript = gPrinterSetupGC->GetStringValue(_T("BIStartPrintingScript")) ;
	if( PreRenderScript )
	{
		if( *PreRenderScript )
		{
			sprintf( FuncCall, _T("Init(0x%08lX);"), gCurrentBatch ) ;
			Result = CallScript( BatchCompleteScript, FuncCall ) ;
		}
	}

	//	RUN THE USER'S ORDER COMPLETE SCRIPT
	PreRenderScript = gPrinterSetupGC->GetStringValue(_T("StartPrintingScript")) ;
	if( PreRenderScript )
	{
		if( *PreRenderScript )
		{
			GetScriptPath( PreRenderScript, Path ) ;
			sprintf( FuncCall, _T("Init(0x%08lX);"), gCurrentBatch ) ;	//	NOTE ';' MANDATORY FOR KPL!

			Result = CallScript( Path, FuncCall ) ;
		}
	}
	return( Result ) ;
}

//	WE NEED TO WAIT UNTIL ALL OTHER RENDERS ARE COMPLETE BEFORE WE CAN START
//	THE LAST JOB OF THE BATCH.  THIS IS BECAUSE THE RIMAGE WRITER REQUIRES
//	THE LAST JOB OF THE BATCH TO PERFORM SPECIAL FUNCTIONS TO MAKE THE
//	CD / DVD CORRECTLY.

int WeCanRender()
{
	if( gREStatus == RE_SUSPENDED ) { return( FALSE ) ; }


	long	NumberRendering = gPagesRendering->GetNumEntries() ;
	if( gPagesToGo <= 3 && NumberRendering > 0 )	{ return( FALSE ) ; }


	long	AlreadyRendered = 0L ;
	long	RenderAheadQty = gRELookAhead->GetLongValue(_T("RenderAhead")) ;

	if( HaveResponseScript() == FALSE )
	{
		if( gRenderedQueue )
		{
			AlreadyRendered = gRenderedQueue->GetNumEntries() ;
		}
	}

	if( gPrinterSetupGC->GetLongValue(_T("PaperFill")))
	{
		if( AlreadyRendered <= 20L )
		{
			return( TRUE ) ;
		}
	}

	if( gLogAmount >= 5 )
	{
		SessionLogDirect(_T("REBatchThread.WeCanRender: AlreadyRendered: %ld, RenderAheadQty: %ld"),
									AlreadyRendered, RenderAheadQty ) ;
	}

	if( AlreadyRendered >= RenderAheadQty )
	{
		return( FALSE ) ;
	}

	return( TRUE ) ;
}


int RunPrintCompleteScript(UGenCon *thePage)
{
	int		 Result = FALSE ;
	long	 LastPageID = 0L ;
	TCHAR	 Path[2048] ;

	long	 PageID		= thePage->GetLongValue(_T("JobID")) ;
	long	 PageState	= thePage->GetLongValue(_T("State")) ;

	if( PageState != PAGE_ERROR )
	{
		//	RUN THE BUILT IN FUNCTION
		TCHAR	 FuncCall[1024] ;
		TCHAR	*PrintCompleteScript = gPrinterSetupGC->GetStringValue(_T("BIPrintCompleteScript")) ;
		if( PrintCompleteScript )
		{
			if( *PrintCompleteScript )
			{
				if( gStatusGC->GetLongValue(_T("QtyRendered")) == 0L )
				{
					CallScript( PrintCompleteScript, _T("Advertize()")) ;
				}

				sprintf( FuncCall, _T("Init(0x%08lX, 0x%08lX);"), gCurrentBatch, thePage ) ;
				Result = CallScript( PrintCompleteScript, FuncCall ) ;
			}
		}

		//	RUN THE USER'S FUNCTION (IF ANY)
		PrintCompleteScript = gPrinterSetupGC->GetStringValue(_T("OnPrintComplete")) ;
		if( gLogAmount >= 2L )
		{
			SessionLogDirect( _T("****\tREBatch.RunPrintCompleteScript: \"%s\"."), PrintCompleteScript ) ;
		}

		if( PrintCompleteScript )
		{
			if( *PrintCompleteScript )
			{
				//	QWERTY TBD FOR NOW TO SEE IF WE CAN RUN QSS PRINTER...
				thePage->SetLongValue(_T("CommandSent"), FALSE ) ;

				GetScriptPath( PrintCompleteScript, Path ) ;
				sprintf( FuncCall, _T("Init(0x%08lX);"), gCurrentBatch ) ;	//	NOTE ';' MANDATORY FOR KPL!
				Result = CallScript( Path, FuncCall ) ;
			}
		}
	}

	thePage->SetLongValue(_T("CommandSent"), 1L ) ;

	return( Result ) ;
}



CIThread *StartPieThread(UGenCon *thePage)
{
	TCHAR		 FileName[2048] ;
	TCHAR		*ExeDirectory = GetExeDirectory() ;

	sprintf( FileName, _T("%s\\Common\\REPieThread.txt"), ExeDirectory) ;

	CIThread	*theThread = new CIThread ;
	if( theThread )
	{
		theThread->SetRegisterName(_T("REPieRenderThread")) ;
		int Result = theThread->Setup(FileName, NULL, -2L, 500L, thePage, gCheckTextLibFirst ) ;

		if( Result == FALSE )
		{
			AddError( thePage, _T("****\tREBatchThread.RenderAJob: Could not start Render Thread")) ;
			delete theThread ;
			return( NULL ) ;
		}
	}
	else
	{
		AddError( thePage, _T("****\tREBatchThread.RenderAJob: Could not start Render Thread")) ;
	}

	return( theThread ) ;
}


//	UPDATES THE JOBQUEUE
//	MOVES PAGE TO THE "RENDERED" QUEUE.
//	RUNS PRINT COMPLETE SCRIPT IF NOT PART OF A PACKAGE
//	UPDATES PAGESTOGO AND QUANTITY RENDERED.
//	DELETES PIE AND UIC
//	SAVES PAGE GENCON TO DISK.
int HandleSuccessfulRender( UGenCon *thePage )
{
	int		 Result ;
	TCHAR	 PageIDString[128] ;

	long	PageState = thePage->GetLongValue(_T("State")) ;

	if( gLogAmount >= 3 )
	{
		SessionLogDirect( _T("REBatchThread.HandleSuccessfulRender: Page: \"%s\", PageState: %ld"), 
					thePage->GetName(), PageState ) ;
	}

	if( PAGE_PROGRAMMED != PageState )
	{
		return( 0 ) ;
	}

	long	IsPaperFill = gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;
	long	IsPackage	= thePage->GetLongValue( _T("IsPackage")) ;
	long	ResponseScriptExists = HaveResponseScript() ;

	HandleAfterAffects( thePage ) ;

	GetPageIDString( thePage, PageIDString ) ;

	if( gLogAmount >= 7 )		//	TBD  DEBUG 10/19/04 was 7
	{
		SessionLogDirect( _T("****\tREBatchThread.HandleSuccessfulRender: PageID: \"%s\"."), PageIDString ) ;
	}

	//	CLEAN UP THE EXTRA STUFF WE USED
	PIE		*thePie = thePage->GetLongValue(_T("Pie")) ;
	if( thePie )
	{
		delete thePie ;
		thePage->SetLongValue(_T("Pie"), NULL ) ;
	}

	if( IsPaperFill == FALSE )	//	For Paper Fill NOT Done here because the RL goes away too soon.
	{							//	Done in CleanUpPaperFill called when package is successfully rendered.
		DeleteUIC( thePage ) ;
	}

	//	WE DELETE THE PAGE HERE
	if( (IsPaperFill && IsPackage == FALSE) || ResponseScriptExists )	//	NEW 01/05/05
	{
		SavePage( thePage ) ;
	}
	
	if( ResponseScriptExists )
	{
		//	IF NOT PAPER FILL || PAPERFILL WITH A PACKAGE
		//	SAY THE IMAGE WAS RENDERED.
		if( IsPaperFill )
		{
			if( IsPackage == FALSE )	//	ELSE STATUS STAYS AT PRINTING
			{
				UpdateJobRecord( thePage, SAVED ) ;
			}
		}
		else
		{
				UpdateJobRecord( thePage, SAVED ) ;		//	NEW 03/22/05
		}

		gRenderedQueue->EnQueue( thePage ) ;
		thePage->SetLongValue(_T("State"), PAGE_RENDERED ) ;
		thePage->SetLongValue( _T("PrintStatus"), PAGE_RENDERED ) ;
	//	UpdateOrderItemsRecord(thePage, COMPLETED ) ;
	}
	else	//	NO RESPONSE SCRIPT
	{
		thePage->SetLongValue(_T("State"), PAGE_COMPLETE ) ;
		thePage->SetLongValue( _T("PrintStatus"), 13 ) ;
		UpdateJobRecord( thePage, COMPLETED ) ;
		UpdateOrderItemsRecord(thePage, COMPLETED ) ;
		gCompletedQueue->EnQueue( thePage ) ;
	}		//	END NO RESPONSE SCRIPT

	if( gREStatus == RE_RUNNING || gREStatus == RE_SUSPENDED )
	{
		HandlePrintComplete(thePage) ;
	}

//	gPageRendering = NULL ;
	gPagesRendering->RemoveItem( thePage ) ;

	gPagesToGo-- ;
	long QtyRendered = gStatusGC->GetLongValue(_T("QtyRendered")) ;
	QtyRendered++ ;
	gStatusGC->SetLongValue(_T("QtyRendered"), QtyRendered ) ;

	SessionLogDirect( _T("****\tREBatchThread RenderComplete: Success P%09ld Qty Rendered: %ld"), 
		thePage->GetLongValue(_T("JobID")), QtyRendered ) ;

	return( QtyRendered ) ;
}


int HandlePrintComplete(UGenCon *thePage)
{
	long	IsPaperFill = gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;
	long	IsPackage	= thePage->GetLongValue( _T("IsPackage")) ;
	int		Result ;

	if( IsPaperFill == FALSE )
	{
		//	RUN PRINT COMPLETE SCRIPT IF NOT DOING PAPER FILL
		UGenCon *aPageToPrint = SequenceCompletedPages( thePage ) ;
		if( aPageToPrint )
		{
			Result = RunPrintCompleteScript(aPageToPrint) ;
			HandleOnPrintCompleteError( aPageToPrint ) ;

			while( aPageToPrint )
			{
				aPageToPrint = SequenceCompletedPages( NULL ) ;
				if( aPageToPrint )
				{
					Result = RunPrintCompleteScript(aPageToPrint) ;
					HandleOnPrintCompleteError( aPageToPrint ) ;
				}
			}
		}

	}
	else	//	RUNNING PAPER FILL
	{
		//	ONLY RUN PRINT COMPLETE SCRIPT IF WE HAVE A PACKAGE
		if( IsPackage )
		{
			if( gLogAmount >= 5 )
			{
				SessionLogDirect( _T("****\tREBatchThread.HandleSuccessfulRender: Running Print Complete on PF Package. PageID: \"%s\"."), PageIDString ) ;
			}

			//	RUN THE PRINT COMPLETE SCRIPT FOR PAPER FILL PACKAGES...
			UGenCon *aPageToPrint = SequenceCompletedPages( thePage ) ;
			if( aPageToPrint )
			{
				RunPFillCompleteScript(aPageToPrint) ;
				HandleOnPrintCompleteError( aPageToPrint ) ;

				while( aPageToPrint )
				{
					aPageToPrint = SequenceCompletedPages( NULL ) ;
					if( aPageToPrint )
					{
						Result = RunPFillCompleteScript(aPageToPrint) ;
						HandleOnPrintCompleteError( aPageToPrint ) ;
					}
				}
			}

			//	HANDLE PAPER FILL CLEAN UP...
			//	READ THE PACKAGE COMPLETE DATA AND UPDATE ACCORDINGLY.
			CleanUpPaperFill(thePage) ;

		}
	}	//	END RUNNING PAPER FILL

}

int HandleOnPrintCompleteError( UGenCon *thePage )
{
	int	Result = FALSE ;
	//	REPORT OnPrintComplete ERROR
	long	ErrorCode = thePage->GetLongValue(_T("ResponseCode")) ;
	if( ErrorCode )
	{
		thePage->SetLongValue(_T("ErrorCode"), ErrorCode ) ;
		thePage->SetLongValue(_T("ErrorType"), 4L ) ;
		TCHAR	*ErrorText = thePage->GetStringValue(_T("ResponseText")) ;
		thePage->SetAttrValue(_T("ErrorText"), ErrorText ) ;

		Result = HandlePrintError( thePage ) ;
	}
	return( Result ) ;
}


//	TAKE THE COMPLETED PAGES AND PLACE THEM TEMPORARILY
//	IN A LIST SO THAT WE MAY OUTPUT THE PAGES TO THE 
//	PRINTER IN ORDER.
UGenCon *SequenceCompletedPages( UGenCon *thePage )
{
	long	PrintPageNumber = 0L ;
	if( thePage )
	{
		PrintPageNumber = thePage->GetLongValue( _T("PrintNumber") ) ;
		if( PrintPageNumber == gNextCompletePage )
		{
//			SessionLogDirect( _T("****\tREBatch.SequenceCompletedPages: Returning Current Page: %s"), thePage->GetName()) ;

			gNextCompletePage++ ;
			return( thePage ) ;
		}
		gCompleteList->InsertBack( thePage ) ;

//		SessionLogDirect( _T("****\tREBatch.SequenceCompletedPages: Placed Page: %s in gCompleteList"), thePage->GetName()) ;
		
		return( NULL ) ;
	}

	UListIterator	*anIter = new UListIterator( gCompleteList ) ;
	UGenCon			*aPage  = anIter->GetFirst() ;
	while( aPage )
	{
		PrintPageNumber = aPage->GetLongValue(_T("PrintNumber")) ;
		if( PrintPageNumber == gNextCompletePage )
		{
//			SessionLogDirect( _T("****\tREBatch.SequenceCompletedPages: Returning Page: %s, from list"), thePage->GetName()) ;
			gCompleteList->RemoveItem( aPage ) ;
			gNextCompletePage++ ;
			delete anIter ;
			return( aPage ) ;
		}
		aPage = anIter->GetNext() ;
	}
	delete anIter ;

//	SessionLogDirect( _T("****\tREBatch.SequenceCompletedPages: Returning No Page from list")) ;

	return( NULL ) ;
}

int HandleAfterAffects( UGenCon *thePage )
{
	int	Success ;
	URenderList	*theRL  = thePage->GetLongValue(_T("URenderList")) ;
	if( theRL )
	{
		theRL->HandleAfterAffects(&Success) ;
	}
	return( Success ) ;
}


int RunPFillCompleteScript(UGenCon *thePage)
{
	int Result ;

	int	PackageCut			= gPrinterSetupGC->GetLongValue(_T("PackageCut")) ;
	int	PaperFillAlgorithm	= gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;

	if( PaperFillAlgorithm == 2 || PackageCut != 1 )	//	Arbitrary || Not BarCode
	{
		if( gLogAmount >= 8 )
		{
			DumpList(gPaperFillPackages) ;	//	DEBUG DEBUG
		}

		UList	*OriginalPageList = gCurrentBatch->GetChildren() ;
		gCurrentBatch->SetChildren( gPaperFillPackages ) ;
		Result = RunPrintCompleteScript(thePage) ;
		gCurrentBatch->SetChildren( OriginalPageList ) ;
		return( Result ) ;
	}

	//	LUCHT PAPER FILL WITH BARCODE

	long	PageID = thePage->GetLongValue(_T("JobID")) ;

	if( gLogAmount >= 8 )
	{
		DebugPrintPages( gPaperFillPackages, _T("RunPFillCompleteScript") ) ;
	}

	long	TotalPackages = gPaperFillPackages->GetNumEntries() ;

	long	StartPage = -1L ;
	long	NumPackages = GetNumEntriesNotSent( PageID, gPaperFillPackages, &StartPage ) ;

	if( gLogAmount >= 8 )
	{
		SessionLogDirect( _T("****\tREBatch.RunPFillCompleteScript: Running LUCHT Print Complete Script")) ;
		SessionLogDirect( _T("****\tREBatch.RunPFillCompleteScript: TotalPackages: %ld NumPackages: %ld, StartPage: %ld, PagesToGo: %ld"), 
									TotalPackages, NumPackages, StartPage, gPagesToGo ) ;
	}

	if( NumPackages > 8 || gPagesToGo < 2 )
	{
		UGenCon	*aPage ;

		SetupIntermediateBarCodes( StartPage, NumPackages, gPaperFillPackages ) ;

		//	RUN THE COMPLETE SCRIPT FOR UP TO 9 PACKAGES
		long			 CommandSent ;
		long			 Count = 0L ;
		UListIterator	*anIter = new UListIterator( gPaperFillPackages ) ;
		UGenCon			*aPkg	= (UGenCon *) anIter->GetFirst() ;
		while( aPkg )
		{
			CommandSent = aPkg->GetLongValue(_T("CommandSent")) ;
			if( CommandSent == 0L )
			{
				RunPrintCompleteScript( aPkg ) ;
				Count++ ;
				if( Count >= NumPackages )	{ break ; }
			}
			aPkg	= (UGenCon *) anIter->GetNext() ;
		}
		delete anIter ;

		return( TRUE ) ;
	}
	return( FALSE ) ;
}

int MarkPageCommandSent()
{
	UGenCon *aPrint = GetCompletePrint( gCurrentBatch ) ;
	if( aPrint )
	{
		if( gLogAmount >= 8 )
		{
			SessionLogDirect( _T("****\tREBatch.MarkPageCommandSent: PageID: %s"),
										aPrint->GetStringValue(_T("PageID"))) ;
		}
		aPrint->SetLongValue(_T("CommandSent"), TRUE ) ;
	}
}

UGenCon *GetCompletePrint(UGenCon *Order)
{
	UList			*thePrints = Order->GetChildren() ;
	UListIterator	*anIter = new UListIterator( thePrints ) ;
	UGenCon			*aPrint = (UGenCon *) anIter->GetFirst() ;
	long			 CommandSent ;

	while( aPrint )
	{
		CommandSent = aPrint->GetLongValue(_T("CommandSent")) ;
		if( CommandSent == FALSE )
		{
			delete anIter ;
			return( aPrint ) ;
		}

		aPrint = (UGenCon *) anIter->GetNext() ;
	}
	
	if( aPrint == NULL )
	{
		aPrint = (UGenCon *) anIter->GetLast() ;
	}

	delete anIter ;
	return( aPrint ) ;
}


int DebugPrintPages( UList *PageList, TCHAR *Msg )
{
	SessionLogDirect( _T("**\tREBatchThread.DebugPrintPages: %s"), Msg ) ;
	UListIterator	*anIter = new UListIterator( PageList ) ;
	UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
	while( aPage )
	{
		aPage->Dump( aPage->GetName() ) ;
		aPage  = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;
}

int GetNumEntriesNotSent( long LastRenderedPageID, UList *Packages, long *theStartPage )
{
	long	PageCount = 0L ;
	long	Count = 0L ;
	long	StartPage = -1L ;
	
	long	PageID ;
	long	CommandSent ;

	UListIterator	*anIter = new UListIterator( Packages ) ;
	UGenCon			*aPkg = (UGenCon *) anIter->GetFirst() ;
	while( aPkg )
	{
		PageID = aPkg->GetLongValue(_T("JobID")) ;
		CommandSent = aPkg->GetLongValue(_T("CommandSent")) ;

		if( gLogAmount >= 6 )
		{
			SessionLogDirect( _T("####>>>> REBatchThread.GetNumEntriesNotSent: PageID: %ld, CommandSent: %ld"),
										PageID, CommandSent ) ;
		}

		if( CommandSent == 0L )
		{
			if( StartPage == -1L )	{ StartPage = PageCount ; }
			Count++ ;
		}

		if( PageID == LastRenderedPageID )	{ break ; }

		PageCount++ ;
		aPkg = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;

	*theStartPage = StartPage ;

	return( Count ) ;
}

int SetupIntermediateBarCodes( long StartPage, long NumPackages, UList *Packages )
{
	TCHAR	BCString[128] ;
	int		FirstTime = TRUE ;
	long	PageID ;

	UListIterator	*anIter = new UListIterator( Packages ) ;
	UGenCon			*aPkg = (UGenCon *) anIter->GetAt(StartPage) ;
	while( aPkg )
	{
		GetBarCodeString( StartPage, NumPackages, Packages, BCString ) ;

		PageID = aPkg->GetLongValue(_T("JobID")) ;

		if( gLogAmount >= 6 )
		{
			SessionLogDirect( _T("****\tREBatch.SetupIntermediateBarCodes: NumPackages: %ld, StartPage: %ld, PageID: %ld, BCString: \"%s\""),
										NumPackages, StartPage, PageID, BCString ) ;
		}

		aPkg->SetAttrValue(_T("BarCode"), BCString ) ;
		if( FirstTime )
		{
			aPkg->SetLongValue( _T("BarCodeType"), 1L ) ;	//	0 For None, 1 For Full, 2 For the Intermediate
			FirstTime = FALSE ;
		}
		else
		{
			aPkg->SetLongValue( _T("BarCodeType"), 2L ) ;	//	0 For None, 1 For Full, 2 For the Intermediate
		}

		StartPage++ ;
		NumPackages-- ;

		if( NumPackages == 0 )	{ break ; }

		aPkg = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;

	return( TRUE ) ;
}

TCHAR *GetBarCodeString( long StartPage, long NumPackages, UList *Packages, TCHAR *BCString )
{
	long	Count = 0L ;
	long	PageState ;

	BCString[0] = 0x00 ;
	TCHAR	*BarCode ;

	UListIterator	*anIter = new UListIterator( Packages ) ;
	UGenCon			*aPkg = (UGenCon *) anIter->GetAt(StartPage) ;
	while( aPkg )
	{
		PageState = aPkg->GetLongValue(_T("State")) ;
		if( PageState != PAGE_ERROR )
		{
			if( Count >= NumPackages )	{ break ; }

			BarCode = aPkg->GetStringValue(_T("BarCode")) ;
			if( BarCode )
			{
				strcat( BCString, BarCode ) ;
			}

			Count++ ;
		}
		aPkg = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;

	return( BCString ) ;
}

//	WE HAVE SUCCESSFULLY RENDERED A PACKAGE SO CLEAN UP
//	EVERYTHING ABOUT THE PACKAGE AND IT'S PRE-RENDERED PAGES.

int CleanUpPaperFill( UGenCon *thePkg )
{
	long			 ThreadID	= gREThread->GetThreadID() ;
	long			 JobID		= thePkg->GetLongValue(_T("JobID")) ;
	UIC				*theUIC ;
	UGenCon			*aPage ;
	TCHAR			 FilePath[1024] ;
	TCHAR			 FullFilePath[2048] ;
	UListIterator	*anIter ;

	//	BE SURE TO CLEAN UP ANY LINGERING UICs OF SOURCE PAGES
	UList			*theChildren = thePkg->GetChildren() ;
	if( theChildren )
	{
		long	aJobID ;
		long	aLastJobID = 0L ;

		UGenCon	*anOtherPage ;

		anIter = new UListIterator( theChildren ) ;
		aPage = (UGenCon *) anIter->GetFirst() ;
		while( aPage )
		{
			//	CLEAN UP THE UIC FOR THE INDIVIDUAL PAGES NOW THAT WE ARE DONE WITH THEM
			DeleteUIC( aPage ) ;

			if( HaveResponseScript() == FALSE )	//	01/04/05 ONLY DO THIS IF THERE IS no RESPONSE SCRIPT
			{
				aJobID = aPage->GetLongValue(_T("JobID")) ;

				CleanPageFile( aJobID ) ;
//				anOtherPage = LoadPage( aJobID ) ;
//				if( anOtherPage )
//				{
//					ZeroUIC( anOtherPage ) ;
//					delete anOtherPage ;
//				}

				if( aLastJobID != aJobID )
				{
					DeleteRecordFromJobQueue( aPage ) ;
				}
				aLastJobID = aJobID ;
			}
			aPage = (UGenCon *) anIter->GetNext() ;
		}
		delete anIter ;
	}


	//	HANDLE THE DELETE AFTER KEYWORD
	URenderList *theRL = thePkg->GetLongValue(_T("URenderList")) ;
	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("**\tREBatchThread.CleanUpPaperFill: URenderList: 0x%lX"), theRL ) ;
	}

	if( theRL )
	{
		long			 NodeID = 10001 ;
		TCHAR			*ImagePath ;

		UGenCon	*aNode = theRL->FindNodeByID( NodeID ) ;
		while( aNode )
		{
			if( gLogAmount >= 7 )
			{
				SessionLogDirect( _T("**\tREBatchThread.CleanUpPaperFill: NodeID: %ld"), NodeID ) ;
			}

			if( aNode->GetLongValue(_T("DeleteAfter:")))
			{
				ImagePath = aNode->GetStringValue(_T("IFile:")) ;
				if( gLogAmount >= 7 )
				{
					SessionLogDirect( _T("****\tREBatch.CleanUpPaperFill: Deleting ImagePath: \"%s\""), ImagePath ) ;
				}
				if( ImagePath )
				{
					DeleteThisFile( ImagePath ) ;
				}
			}
			NodeID++ ;
			aNode = theRL->FindNodeByID( NodeID ) ;
		}
	}

	//	CLEAN UP THIS PACKAGE'S UIC
	DeleteUIC( thePkg ) ;

	if( HaveResponseScript() == FALSE)	//	01/04/05 ONLY DO THIS IF THERE IS no RESPONSE SCRIPT
	{
		CleanPageFile( aJobID ) ;
//		aPage = LoadPage( JobID ) ;
//		if( aPage )
//		{
//			ZeroUIC( aPage ) ;
//			delete aPage ;
//		}
	}

	return( TRUE ) ;
}



//	THIS ROUTINE MOVES THE PRINTED PAGE FROM THE
//	RENDERED QUEUE TO THE COMPLETE QUEUE.
int	HandleSuccessfulPrint( UGenCon *thePage )
{
	if( thePage == NULL )	{ return( FALSE ) ; }

	if( gLogAmount >= 4 )			//	TBD  DEBUG 10/19/04 was 4
	{
		SessionLogDirect( _T("****\tREBatchThread.HandleSuccessfulPrint: JobID: P%09ld"), thePage->GetLongValue(_T("JobID"))) ;
	}

	if( HaveResponseScript())
	{
		gRenderedQueue->RemoveItem( thePage ) ;
		gCompletedQueue->EnQueue( thePage ) ;
		thePage->SetLongValue(_T("State"), PAGE_COMPLETE ) ;
		thePage->SetLongValue( _T("PrintStatus"), 13 ) ;

		//	IF PAPER FILL THEN SAY ALL THE ASSOCIATED PAGES ARE COMPLETE !
		if( gPrinterSetupGC->GetLongValue(_T("PaperFill")))
		{
			UList	*PFPages = thePage->GetChildren() ;

			if( gLogAmount >= 4 )
			{
				SessionLogDirect( _T("****\tREBatchThread.HandleSuccessfulPrint: PFPages: 0x%lX"), PFPages) ;
			}

			if( PFPages )
			{
				UListIterator	*anIter = new UListIterator( PFPages ) ;
				UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
				while( aPage )
				{
					if( gLogAmount >= 5 )
					{
						SessionLogDirect( _T("****\tREBatchThread.HandleSuccessfulPrint: JobID: %ld"), aPage->GetLongValue(_T("JobID"))) ;
					}

					gRenderedQueue->RemoveItem( aPage ) ;
					gCompletedQueue->EnQueue( aPage ) ;
					aPage->SetLongValue(_T("State"), PAGE_COMPLETE ) ;
					aPage->SetLongValue( _T("PrintStatus"), 13 ) ;

					aPage  = (UGenCon *) anIter->GetNext() ;
				}
				delete anIter ;
			}
		}
	}
	return( TRUE ) ;
}

int HaveResponseScript()
{
	TCHAR	*ResponseScript = gPrinterSetupGC->GetStringValue(_T("BIResponseScript")) ;
	if( ResponseScript )
	{
		if( *ResponseScript )
		{
			return( TRUE ) ;
		}
	}
	return( FALSE ) ;
}

/*
//	PAGE STATES
int			 PAGE_READY			= 1 ;
int			 PAGE_PARSED		= 2 ;
int			 PAGE_PROGRAMMED	= 3 ;
int			 PAGE_RENDERED		= 4 ;
int			 PAGE_CANCELLED		= 5 ;
int			 PAGE_COMPLETE		= 6 ;
int			 PAGE_ERROR			= 7 ;
int			 PAGE_PF_HOLD		= 8 ;
*/

//	THE PARSE DID NOT WORK FOR SOME REASON
int HandleParseError( UGenCon *thePage )
{
	SessionLogDirect( _T("****\tREBatchThread.HandleParseErr: Page: P%09ld"), 
		thePage->GetLongValue(_T("JobID"))) ;

	int		Result ;
	int		UserAction ;

	if( gLogAmount >= 8 )
	{
		DumpCStack(_T("****\tREBatch.HandleParseError")) ;
	}

	long	PageState = thePage->GetLongValue(_T("State")) ;

//	SessionLogDirect( _T("****\tREBatch.HandleParseError: PageState: %ld"), PageState ) ;

	if( PAGE_ERROR == PageState || PAGE_CANCELLED == PageState )
	{
		return( 0 ) ;
	}

	UpdateJobRecord( thePage, ERROR ) ;
	
//	gPageRendering = NULL ;		Don't do this for a parsing error !!!
	gPagesToGo-- ;

	thePage->SetLongValue( _T("State"), PAGE_ERROR ) ;
	thePage->SetLongValue( _T("ErrorCode"), 2L ) ;
	gErrorJobQueue->EnQueue( thePage ) ;

	UList	*theErrors = (UList *) thePage->GetLongValue(_T("RenderErrorList")) ;
	if( theErrors )
	{
		int				 RunAttended = gPrinterSetupGC->GetLongValue(_T("RunAttended")) ;
		UGenCon			*anError = (UGenCon *) theErrors->GetAt(0L) ;
		if( anError )
		{
			TCHAR		*ErrorText = anError->GetStringValue(_T("Text")) ;
			if( ErrorText )
			{
				if( gLogAmount >= 5 )
				{
					SessionLogDirect( _T("****\tREBatchThread.HandleParseErr: P%09ld, Attended: %ld, \"%s\""),
												thePage->GetLongValue(_T("JobID")), RunAttended, ErrorText ) ;
				}

				thePage->SetAttrValue( _T("ErrorText"), ErrorText ) ;

				if( RunAttended )
				{
	//=============================================================================
					gREStatus = RE_SUSPENDED ;
					gSuspendType |= RE_ERR_SUSPEND ;
					UserAction = ShowDialog( ErrorText, 4L, REM_BATCH_PARSE_RESPONSE, thePage ) ;
	//=============================================================================
				}
			}
		}
	}

	PIE		*thePie = thePage->GetLongValue(_T("Pie")) ;
	if( thePie )
	{
		delete thePie ; 
		thePage->SetLongValue(_T("Pie"), NULL ) ;
	}

	if( theErrors )
	{
		delete theErrors ;
		thePage->SetLongValue(_T("RenderErrorList"), 0L ) ;
	}

	DeleteUIC( thePage ) ;


	return( TRUE ) ;
}


long HandleParseResponse( long UserAction )
{
	switch(UserAction)
	{
		case	1	:	//	RETRY
			break ;
		case	2	:	//	CANCEL PAGE
//			HandlePrinterError( thePage, 2L ) ;	//	JUST CANCEL THE PAGE AND KEEP GOING
			break ;
		case	3	:	//	CANCEL ORDER
			CancelThisOrder(gCurrentBatch) ;
			break ;
		case	4	:	//	CANCEL BATCH
			CancelThisBatch(gCurrentBatch) ;
			break ;
	}
	return( TRUE ) ;
}

int HandleRenderCancel( UGenCon *thePage )
{
	int		Result ;
	TCHAR	PageIDString[128] ;

	if( PAGE_ERROR == thePage->GetLongValue(_T("State")))
	{
		return( 0 ) ;
	}

	GetPageIDString( thePage, PageIDString ) ;

	SessionLogDirect( _T("****\tREBatchThread.HandleRenderCancel: Cancelling %s"), PageIDString ) ;

	UpdateJobRecord( thePage, READY ) ;
//	UpdateJobRecord( thePage, CANCELLED ) ;

//	gPageRendering = NULL ;
	gPagesRendering->RemoveItem( thePage ) ;
	gPagesToGo-- ;

	thePage->SetLongValue( _T("State"), PAGE_CANCELLED ) ;
	thePage->SetLongValue( _T("ErrorCode"), 1L ) ;
	thePage->SetAttrValue( _T("ErrorText"), _T("Cancelled.")) ;
	gErrorJobQueue->EnQueue( thePage ) ;

	//	CLEAN UP THE EXTRA STUFF WE USED
	PIE		*thePie = thePage->GetLongValue(_T("Pie")) ;
	if( thePie )
	{
		delete thePie ; 
		thePage->SetLongValue(_T("Pie"), NULL ) ;
	}

	UList	*theErrors = thePage->GetLongValue(_T("RenderErrorList")) ;
	if( theErrors )
	{
		delete theErrors ;
		thePage->SetLongValue(_T("RenderErrorList"), 0L ) ;
	}

	DeleteUIC( thePage ) ;

	return( TRUE ) ;
}


int HandleRenderError( UGenCon *thePage )
{
	int		 Result ;
	int		 UserAction ;

	TCHAR	 PageIDString[1024] ;
	TCHAR	*ErrorText ;

	if( gLogAmount >= 0 )
	{
		DumpCStack(_T("****\tREBatch.HandleRenderError")) ;
	}

	long	PageState = thePage->GetLongValue(_T("State")) ;
	if( PAGE_ERROR == PageState || PAGE_CANCELLED == PageState )
	{
		return( 0 ) ;
	}

	GetPageIDString( thePage, PageIDString ) ;

	SessionLogDirect( _T("****\tREBatchThread.HandleRenderErr: Error: %s"), PageIDString ) ;

	gStatusGC->Dump(_T("REBatch.HandleRenderError: RenderStatus")) ;

	UpdateJobRecord( thePage, ERROR ) ;
	
//	gPageRendering = NULL ;
	gPagesRendering->RemoveItem( thePage ) ;

	gPagesToGo-- ;

	thePage->SetLongValue( _T("State"), PAGE_ERROR ) ;
	thePage->SetLongValue( _T("ErrorCode"), 2L ) ;
	gErrorJobQueue->EnQueue( thePage ) ;

	UList	*theErrors = (UList *) thePage->GetLongValue(_T("RenderErrorList")) ;
	if( theErrors )
	{
		int				 RunAttended = gPrinterSetupGC->GetLongValue(_T("RunAttended")) ;
		UGenCon			*anError = (UGenCon *) theErrors->GetAt(0L) ;
		if( anError )
		{
			ErrorText = anError->GetStringValue(_T("Text")) ;
			if( ErrorText )
			{
				if( gLogAmount >= 5 )
				{
					SessionLogDirect( _T("****\tREBatchThread.HandleRenderErr: %s Attended: %ld, \"%s\""),
												PageIDString, RunAttended, ErrorText ) ;
				}

				thePage->SetAttrValue( _T("ErrorText"), ErrorText ) ;

				if( RunAttended )
				{
	//=============================================================================
					gREStatus = RE_SUSPENDED ;
					gSuspendType |= RE_ERR_SUSPEND ;
					UserAction = ShowDialog( ErrorText, 4L, REM_BATCH_RENDER_RESPONSE, thePage ) ;
	//=============================================================================
				}
			}
		}
	}

	PIE		*thePie = thePage->GetLongValue(_T("Pie")) ;
	if( thePie )
	{
		delete thePie ; 
		thePage->SetLongValue(_T("Pie"), NULL ) ;
	}

	theErrors = thePage->GetLongValue(_T("RenderErrorList")) ;
	if( theErrors )
	{
		delete theErrors ;
		thePage->SetLongValue(_T("RenderErrorList"), 0L ) ;
	}

	DeleteUIC( thePage ) ;

	//	IF THIS IS THE LAST PAGE AND WE ARE DOING PAPER FILL, THEN
	//	WE HAVE SOME MORE CLEAN-UP TO DO...
	//	TBD QWERTY TBD

	return( TRUE ) ;
}

int HandleRenderResponse(UGenCon *thePage, long UserAction)
{
	switch(UserAction)
	{
		case	1	:	//	RETRY
			break ;
		case	2	:	//	CANCEL PAGE
//			HandlePrinterError( thePage, 2L ) ;	//	JUST CANCEL THE PAGE AND KEEP GOING
			CancelPage( thePage ) ;
			break ;
		case	3	:	//	CANCEL ORDER
			CancelThisOrder(gCurrentBatch) ;
			gPagesToGo = 0L ;
			break ;
		case	4	:	//	CANCEL BATCH
			CancelThisBatch(gCurrentBatch) ;
			gPagesToGo = 0L ;
			break ;
	}
}

void CancelPage( UGenCon *thePage )
{
	if( thePage )
	{
		long	PageID = thePage->GetLongValue(_T("JobID")) ;
		if( thePage->GetLongValue(_T("IsPackage")))
		{
			UList	*SrcPages = thePage->GetChildren() ;
			if( SrcPages )
			{
				UListIterator	*anIter = new UListIterator( SrcPages ) ;
				UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
				while( aPage )
				{
					PageID = aPage->GetLongValue(_T("JobID")) ;
					UpdateJobRecord( aPage, CANCELLED ) ;
					CleanPageFile( PageID ) ;
					aPage = (UGenCon *) anIter->GetNext() ;
				}
				delete anIter ;
			}
		}
		else	//	NOT A PAPER FILL PACKAGE
		{
			if( gPrinterSetupGC->GetLongValue(_T("PaperFill")))
			{
				//	DETERMINE WHICH PAGES BELONG TO THIS
				//	PAPER FILL PACKAGE AND CANCEL ALL THE ONES
				//	THAT ARE NOT IN ANOTHER PACKAGE (NOT YET DONE).
				CancelPaperFillPackage( thePage ) ;
			}

			UpdateJobRecord( thePage, CANCELLED ) ;
		}
	}
}

//	WALK THROUGH THE PAPER FILL PACKAGES AND
//	FIND ALL PACKAGES WITH THE BAD IMAGE AND
//	CANCEL THE PACKAGES.
int CancelPaperFillPackage( UGenCon *thePage )
{
	UListIterator	*anIter = new UListIterator( gPaperFillPackages ) ;
	UGenCon			*aPkg	= (UGenCon *) anIter->GetFirst() ;
	while( aPkg )
	{
		CancelPaperFillPage( aPkg, thePage ) ;
		aPkg	= (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;
	return( TRUE ) ;
}

//	IF THE CANCELLED PAGE IS IN THIS PACKAGE, THEN CANCEL THE PACKAGE.
UGenCon *CancelPaperFillPage( UGenCon *aPkg, UGenCon *thePage )
{
	UList			*theSrcPages = aPkg->GetChildren() ;
	if( theSrcPages )
	{
		UListIterator	*anIter = new UListIterator( theSrcPages ) ;
		UGenCon			*aPage	= (UGenCon *) anIter->GetFirst() ;
		while( aPage )
		{
			if( aPage == thePage )
			{
				aPkg->SetLongValue(_T("State"), CANCELLED ) ;

				//	NOW GO THROUGH THE CANCELLED PACKAGE
				//	AND IF THE PAGES ARE NOT IN A GOOD PACKAGE
				//	CANCEL THEM.	TBD.


			}
			aPage	= (UGenCon *) anIter->GetNext() ;
		}
		delete anIter ;
	}
	return( thePage ) ;
}

int CleanPageFile( long PageID )
{
	UGenCon *aPage = LoadPage(PageID) ;

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("**\tREBatch.CleanPageFile: PageID: %09ld, aPage: 0x%08lX"),
							PageID, aPage ) ;
	}

	if( aPage )
	{
		aPage->SetLongValue(_T("UIC"), NULL ) ;
		aPage->SetLongValue(_T("URenderList"), NULL ) ;
		aPage->SetLongValue(_T("Pie"), NULL ) ;

//		TCHAR	*ImagePath = aPage->GetStringValue(_T("ImagePath")) ;

//		SessionLogDirect( _T("**\tREBatch.CleanPageFile: PageID: %09ld, ImagePath: \"%s\""),
//							PageID, ImagePath ) ;
//		if( ImagePath )
//		{
//			DeleteThisFile( ImagePath ) ;
//		}

		delete aPage ;
	}
	return( TRUE ) ;
}


int HandlePrintError( UGenCon *thePage )
{
	int		Result ;
	TCHAR	PageIDString[1024] ;

	long	UserAction ;

	GetPageIDString( thePage, PageIDString ) ;

	//	TBD: IF THE PRINTER REPORTS AN ERROR (OR CANCEL) DO WE WANT TO
	//			SET THE JOB RECORD TO CANCELLED, ERROR, OR READY?

	UpdateJobRecord( thePage, ERROR ) ;
	
	gErrorJobQueue->EnQueue( thePage ) ;

	int		 RunAttended = gPrinterSetupGC->GetLongValue(_T("RunAttended")) ;

	long	 ErrorCode = thePage->GetLongValue(_T("ErrorCode")) ;
	long	 ErrorType = thePage->GetLongValue(_T("ErrorType")) ;
	TCHAR	*ErrorText = thePage->GetStringValue(_T("ErrorText")) ;

	thePage->SetLongValue(_T("State"), PAGE_ERROR ) ;
	thePage->SetLongValue( _T("PrintStatus"), PAGE_ERROR ) ;

	SessionLogDirect( _T("****\tREBatchThread HandlePrintError: Error: Page: %ld, ErrorCode: %ld, ErrorType: %ld, \"%s\"."),
					thePage->GetLongValue(_T("JobID")), ErrorCode, ErrorType, ErrorText ) ;

	if( RunAttended )
	{
		gREStatus = RE_SUSPENDED ;
		gSuspendType |= RE_ERR_SUSPEND ;
//=============================================================================
		ShowDialog( ErrorText, ErrorType, REM_BATCH_PRINTER_RESPONSE, thePage ) ;
//=============================================================================
	}
	else
	{
		HandlePrinterError( thePage, 2L ) ;	//	JUST CANCEL THE PAGE AND KEEP GOING
	}

	return( TRUE ) ;
}

int HandlePrinterResponse( UGenCon *thePage, long UserAction )
{
	//	WE NEED TO HANDLE (RETRY, CANCEL PAGE, CANCEL BATCH)	TBD

	HandlePrinterError( thePage, UserAction ) ;

	switch( UserAction )
	{
		case	1	:	//	RETRY
			if( thePage )
			{
				thePage->SetLongValue(_T("CommandSent"), 0L ) ;
				thePage->SetLongValue(_T("ResponseCode"), 0L ) ;
				thePage->SetAttrValue(_T("ResponseText"), _T(" ")) ;
				UGenCon *BatchInfo = thePage->GetParent() ;
				if( BatchInfo )
				{
					long	TotalPages = BatchInfo->GetLongValue(_T("TotalPrints")) ;
					BatchInfo->SetLongValue(_T("TotalPrints"), TotalPages + 1L ) ;
					BatchInfo->SetLongValue(_T("ErrorType"),  0L ) ;
					BatchInfo->SetLongValue(_T("ErrorCode"), 0L ) ;
					BatchInfo->SetAttrValue(_T("ErrorMsg"),  _T(" ") ) ;
				}
				HandleSuccessfulRender( thePage ) ;
			}
			else
			{
				SessionLogDirect( _T("****REBatch.HandlePrinterResponse. ERROR: We got here with out a Render Page.")) ;
			}
			break ;
		case	2	:	//	CANCEL PAGE
// DONE ABOVE	HandlePrinterError( thePage, 2L ) ;	//	JUST CANCEL THE PAGE AND KEEP GOING
			break ;
		case	3	:	//	CANCEL ORDER
			PostAThreadMessage( gThisThread, REM_BATCH_CANCEL_BATCH, 0L, 0L ) ;
			break ;
		case	4	:	//	CANCEL BATCH
			PostAThreadMessage( gThisThread, REM_BATCH_CANCEL_BATCH, 0L, 0L ) ;
			break ;
	}

	return( TRUE ) ;
}

int HandlePrinterError(UGenCon *thePage, long UserAction)
{
	TCHAR	 FuncCall[1024] ;
	long	 PageID = thePage->GetLongValue(_T("JobID")) ;
	TCHAR	*ResponseScript = gPrinterSetupGC->GetStringValue(_T("BIResponseScript")) ;
	sprintf( FuncCall, _T("PerformUserAction( 0x%08lX, %ld, 0x%08lX, %ld ) ;"),
				gPrinterSetupGC, UserAction, gCurrentBatch, PageID ) ;
	int Result = CallScript( ResponseScript, FuncCall ) ;

	SessionLogDirect( _T("REBatchThread.HandlePrinterErr: %ld = %s"), Result, FuncCall ) ;

	return( Result ) ;
}


int MovePageTo( UGenCon *aPage, UList *FromQueue, UQueue *ToQueue )
{
	FromQueue->RemoveItem( aPage ) ;
	ToQueue->EnQueue( aPage ) ;

	return( TRUE ) ;
}

UGenCon	*GetErrorMsgGC()
{
	UGenCon	*ErrorGC = new UGenCon( GetDataDictionary( _T("DDText"))) ;
	if( ErrorGC == NULL )
	{
		SessionLogDirect( _T("****\tREBatchThread: GetErrorMsgGC: Error: Could not get GenCon.")) ;
	}
	return( ErrorGC ) ;
}

void HandleBatchComplete()
{
	TCHAR	*BatchID = gCurrentBatch->GetStringValue(_T("BatchID")) ;

	if( gREStatus >= RE_SHUTTING_DOWN )	{ return ; }

	gREStatus = RE_SHUTTING_DOWN ;

	if( gLogAmount >= 0 )
	{
		SessionLogDirect( _T("****\tREBatchThread.HandleBatchComplete: Batch: %s"), BatchID ) ;
	}

	//	SAY THAT THIS BATCH NAME IS THE ORDER ID
	TCHAR	*OrderID = gCurrentBatch->GetStringValue(_T("OrderID")) ;
	if( OrderID == NULL )
	{
		OrderID = _T("None") ;
	}

	gCurrentBatch->SetName( OrderID ) ;

	//	RUN THE BUILT IN FUNCTION
	int	PaperFillAlgorithm	= gPrinterSetupGC->GetLongValue(_T("PaperFill")) ;
	UList	*OriginalPageList ;

	TCHAR	 Path[2048] ;
	TCHAR	 FuncCall[1024] ;
	TCHAR	*BatchCompleteScript = gPrinterSetupGC->GetStringValue(_T("BIOrderCompleteScript")) ;
	if( BatchCompleteScript )
	{
		if( *BatchCompleteScript )
		{
			//	IF PAPER FILL WE NEED TO UPDATE THE CHILD LIST.

			if( PaperFillAlgorithm )	//	Arbitrary || LUCHT
			{
				OriginalPageList = gCurrentBatch->GetChildren() ;
				gCurrentBatch->SetChildren( gPaperFillPackages ) ;
				sprintf( FuncCall, _T("Init(0x%08lX);"), gCurrentBatch ) ;
				CallScript( BatchCompleteScript, FuncCall ) ;
				gCurrentBatch->SetChildren( OriginalPageList ) ;
			}
			else
			{
				sprintf( FuncCall, _T("Init(0x%08lX);"), gCurrentBatch ) ;
				CallScript( BatchCompleteScript, FuncCall ) ;
			}
		}
	}

	//	RUN THE USER'S ORDER COMPLETE SCRIPT
	BatchCompleteScript = gPrinterSetupGC->GetStringValue(_T("OnOrderComplete")) ;
	if( BatchCompleteScript )
	{
		if( *BatchCompleteScript )
		{
			GetScriptPath( BatchCompleteScript, Path ) ;
			sprintf( FuncCall, _T("Init(0x%08lX);"), gCurrentBatch ) ;	//	NOTE ';' MANDATORY FOR KPL!

			if( PaperFillAlgorithm )	//	Arbitrary || LUCHT
			{
				OriginalPageList = gCurrentBatch->GetChildren() ;
				gCurrentBatch->SetChildren( gPaperFillPackages ) ;
				CallScript( Path, FuncCall ) ;
				gCurrentBatch->SetChildren( OriginalPageList ) ;
			}
			else
			{
				CallScript( Path, FuncCall ) ;
			}
		}
	}

	//	THE BATCH WILL BE CLEANED UP BY THE RETHREAD
	//	SO JUST BAIL OUT OF HERE !
	PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;
}

/*
void HandleOrderComplete()
{
	TCHAR	*OrderCompleteScript = gPrinterSetupGC->GetStringValue(_T("OnOrderComplete")) ;
	if( OrderCompleteScript )
	{
		if( *OrderCompleteScript )
		{
			TCHAR	FuncCall[1024] ;
			sprintf( FuncCall, _T("Init(0x%08lX, 0x%08lX)"), gPrinterSetupGC, thePage ) ;
			CallScript( OrderCompleteScript, FuncCall ) ;
		}
	}
}
*/

/*
//	PAGE STATES
int			 PAGE_READY			= 1 ;
int			 PAGE_PARSED		= 2 ;
int			 PAGE_PROGRAMMED	= 3 ;
int			 PAGE_RENDERED		= 4 ;
int			 PAGE_CANCELLED		= 5 ;
int			 PAGE_COMPLETE		= 6 ;
int			 PAGE_ERROR			= 7 ;
int			 PAGE_PF_HOLD		= 8 ;
*/

//	WE MUST CANCEL THE PAGE.
//	SO... UPDATE THE DATABASE AND
//		  ADJUST FOR THE NEXT IMAGE TO BE PRINTED (IF THERE IS ONE)
int CancelThisPage( UGenCon *thePage )
{
	int	Result = gPagesRendering->RemoveItem( thePage ) ;
	if( Result )
	{
		PIE	*thePie = thePage->GetLongValue(_T("Pie")) ;
		if( thePie )
		{
			thePie->Cancel( TRUE ) ;
		}

//		UpdateJobRecord( thePage, CANCELLED ) ;	DONE IN HandleRenderCancel
	}
	return( Result ) ;
}


int CancelThisOrder( UGenCon *theBatch )
{
	long	WholeBatch = 0L ;
	CancelJobQueueOrder(WholeBatch) ;
	gREStatus = RE_SHUTTING_DOWN ;
	HandleShutDown() ;
}

//	WE MUST CANCEL THE WHOLE BATCH (MULTIPLE ORDERS)
//	SO...	UPDATE THE DATABASE FOR THE BATCH AND
//			SHUTDOWN THIS THREAD.
int CancelThisBatch( UGenCon *theBatch )
{
	long	WholeBatch = 1L ;
	CancelJobQueueOrder(WholeBatch) ;
	gREStatus = RE_SHUTTING_DOWN ;
	HandleShutDown() ;
}


//	WE MUST CANCEL THE ORDER.
//	SO... UPDATE THE DATABASE AND
//		  ADJUST FOR THE NEXT IMAGE TO BE PRINTED (IF THERE IS ONE)
int CancelThisOrderX( UGenCon *theBatch )
{
	long	WholeBatch = 0L ;
	CancelJobQueueOrder(WholeBatch) ;

	//	WHAT DO WE DO WITH THE PAGES IN THIS ORDER ?		TBD
	//	HOW DO WE GET TO THE START OF THE NEXT ORDER (IF THERE IS ONE?)
	//	IF THERE ARE NO MORE ORDERS, WE SHOULD JUST SHUT DOWN.

	TCHAR			*PageOrderID ;
	long			 PageState ;
	TCHAR			*OrderID  = theBatch->GetStringValue(_T("OrderID")) ;
	UList			*thePages = theBatch->GetChildren() ;
	UListIterator	*anIter = new UListIterator( thePages ) ;
	UGenCon			*aPage = anIter->GetFirst() ;
	while( aPage )
	{
		PageOrderID = aPage->GetStringValue(_T("OrderID")) ;
		if( stricmp( PageOrderID, OrderID ) == 0 )
		{
			//	WE ARE WORKING ON THE SAME BATCH

			PageState = aPage->GetLongValue(_T("State")) ;

			if( PageState == PAGE_READY )	//	NOT PARSED YET, SO
			{
				gPageListPos++ ;
			}

			if( PageState != PAGE_COMPLETE &&
				PageState != PAGE_ERROR     )
			{
				aPage->SetLongValue(_T("State"), PAGE_CANCELLED) ;
				aPage->SetLongValue( _T("PrintStatus"), PAGE_CANCELLED ) ;
				gPagesToGo-- ;	//	DECREMENT PAGES TO GO
			}
		}
		aPage = anIter->GetNext() ;
	}
	delete anIter ;
}




//	IF WE GOT HERE, WE NEED TO SHUT DOWN IMMEDIATELY
//	IF WE ARE WAITING FOR THE END OF THE BATCH, THIS
//	THREAD WILL NEVER HEAR ABOUT IT !
void HandleShutDown()
{
	TCHAR	 PageIDString[1024] ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.HandleShutDown: gREStatus: %ld, PagesRendering: %ld"),
					gREStatus, gPagesRendering->GetNumEntries() ) ;
	}

	if( gREStatus == RE_SHUTTING_DOWN )
	{
		//	SHUT DOWN NOW !						TBD
		if( gPagesRendering->GetNumEntries() )
		{
			gPagesToGo = gPagesRendering->GetNumEntries() ;

			GetPageIDString( gPageRendering, PageIDString ) ;

			if( gLogAmount >= 5 )
			{
				SessionLogDirect( _T("****\tREBatchThread.HandleShutDown: PagesRendering: %ld"), 
								gPagesRendering->GetNumEntries() ) ;
			}

			//	TELL THE PIE THREADs TO CANCEL
			CancelPagesRendering() ;
		}
		else
		{
			gPagesToGo = 0 ;
		}
	}
}


int CancelPagesRendering()
{
	PIE		*thePie ;
	UListIterator	*anIter = new UListIterator( gPagesRendering ) ;
	UGenCon			*aPage  = anIter->GetFirst() ;
	while( aPage )
	{
		thePie = (PIE *) aPage->GetLongValue(_T("Pie")) ;
		if( thePie )
		{
			thePie->Cancel(TRUE) ;
		}
		aPage  = anIter->GetNext() ;
	}
	delete anIter ;
	return( TRUE ) ;
}


// StringList( PrintStatusList,New,InListOrder,AddStrings,
//	~Hold~,~Ready~,~Reserved~,~Printing~,~Completed~,~Saved~,~Error~,~Cancelled~,~Pending~, ~Loaded~, ~Parsed~ );
//	  0		  1			2			3		4			5		6		7			8		   9		10

void RestoreJobQueueToStatus(long Status)
{
	int		 Result = FALSE ;

	if( Status == 7 )	//	Cancelled
	{
		Status = 1L ;	//	Ready
	}


	TCHAR	 *theQuery = malloc( 2048 * 2 ) ;	//	THIS WILL BE FREED BY RECEIVER

	//	NOT SAVED, COMPLETED, ERROR, CANCELLED, OR PENDING
//	TCHAR	*theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = %ld WHERE BatchID = '%s' AND PrintStatus > 0 AND PrintStatus < 4") ;

	TCHAR	*theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = %ld	WHERE BatchID = '%s' AND \
						   (PrintStatus	= 1		OR\
							PrintStatus	= 2		OR\
							PrintStatus = 3		OR\
							PrintStatus = 9		OR\
							PrintStatus = 10	)") ;	//	NOT HOLD, COMPLETED, ERROR, CANCELLED, OR PENDING

	TCHAR	*BatchID ;
	if( gCurrentBatch )
	{
		BatchID = gCurrentBatch->GetStringValue( _T("BatchID")) ;

		sprintf( theQuery, theUpdateCmd, Status, BatchID ) ;

		if( gLogAmount >=5 )
		{
			SessionLogDirect( _T("****\tREBatchThread.RestoreJobQueueToStatus: SQL: [%s]"), theQuery) ;
		}

		CIThread	*theREThread = gStatusGC->GetLongValue(_T("REThread")) ;
		if( theREThread )
		{
			Result = PostAThreadMessage( theREThread, REM_DB_SQL, 0L, theQuery ) ;
			if( Result == FALSE )	{ free( theQuery ) ; }
		}

	}
}

void CancelJobQueueOrder(long CancelBatch)
{
	int		 Result		= FALSE ;
	TCHAR	*theQuery	= malloc( 2048 * 2 ) ;	//	THIS WILL BE FREED BY RECEIVER
	TCHAR	*theUpdateCmd ;

	if( CancelBatch )
	{
		theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = %ld\
							WHERE BatchID = '%s' AND \
						   (PrintStatus	= 1		OR\
							PrintStatus	= 2		OR\
							PrintStatus = 3		OR\
							PrintStatus = 5		OR\
							PrintStatus = 9		OR\
							PrintStatus = 10	)") ;	//	NOT HOLD, COMPLETED, ERROR, CANCELLED, OR PENDING
	}
	else
	{
		theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = %ld\
							 WHERE BatchID = '%s' AND OrderID = '%s' AND\
						   (PrintStatus	= 1		OR\
							PrintStatus	= 2		OR\
							PrintStatus = 3		OR\
							PrintStatus = 5		OR\
							PrintStatus = 9		OR\
							PrintStatus = 10	)") ;	//	NOT HOLD, COMPLETED, ERROR, CANCELLED, OR PENDING
	}

	if( gCurrentBatch )
	{
		TCHAR	*BatchID = gCurrentBatch->GetStringValue( _T("BatchID")) ;
		TCHAR	*OrderID = gCurrentBatch->GetStringValue( _T("OrderID")) ;

		if( CancelBatch )
		{
			sprintf( theQuery, theUpdateCmd, CANCELLED, BatchID ) ;
		}
		else
		{
			sprintf( theQuery, theUpdateCmd, CANCELLED, BatchID, OrderID ) ;
		}

		if( gLogAmount >= 5 )
		{
			SessionLogDirect( _T("****\tREBatchThread.RestoreJobQueueToStatus: SQL: [%s]"), theQuery) ;
		}

		CIThread	*theREThread = gStatusGC->GetLongValue(_T("REThread")) ;
		if( theREThread )
		{
			Result = PostAThreadMessage( theREThread, REM_DB_SQL, 0L, theQuery ) ;
			if( Result == FALSE )	{ free( theQuery ) ; }
		}
	}
}


void HandleStatusRequest()
{
	TCHAR	DateAndTime[64] ;

	if( gCurrentBatch == NULL )	{ return ; }

	TCHAR	*BatchID = gCurrentBatch->GetStringValue(_T("BatchID")) ;
	TCHAR	*OrderID = gCurrentBatch->GetStringValue(_T("OrderID")) ;
	long	 ItemID	 = gCurrentBatch->GetLongValue(_T("OrderItemID")) ;
	long	 JobID	 = gCurrentBatch->GetLongValue(_T("JobID")) ;

	if( gREStatus == RE_RUNNING )
	{
		gStatusGC->SetAttrValue( _T("Status"), _T("Rndr")) ;
	}

	if( gREStatus == RE_SUSPENDED )
	{
		if( gSuspendType & RE_THRT_SUSPEND )
		{
			gStatusGC->SetAttrValue( _T("Status"), _T("Throttled")) ;
		}
		else
		{
			gStatusGC->SetAttrValue( _T("Status"), _T("Susp")) ;
		}
	}

	gStatusGC->SetAttrValue( _T("Batch"), BatchID ) ;
	gStatusGC->SetAttrValue( _T("Order"), OrderID ) ;
	gStatusGC->SetLongValue( _T("Item"),  ItemID ) ;
	gStatusGC->SetLongValue( _T("JobID"), JobID ) ;

	GetTimeNow( DateAndTime, _T("%H:%M:%S")) ;
	gStatusGC->SetAttrValue( _T("Time"), DateAndTime ) ;

	gStatusGC->SetAttrValue(_T("RenderStatus"), _T("Parsing") ) ;

}

TCHAR	*GetPageIDString( UGenCon *thePage, TCHAR *ResultString )
{
	strcpy( ResultString, _T("No Page.")) ;
	if( thePage )
	{
		long	 JobID		= thePage->GetLongValue(_T("JobID")) ;
		sprintf( ResultString, _T("P%09ld"), JobID ) ;
	}

	return( ResultString ) ;
}



long CallScript( TCHAR *ScriptName, TCHAR *FuncCall )
{
	long	Result = FALSE ;
	TCHAR	FilePath[2048] ;
	TCHAR	FileName[280] ;
	TCHAR	FileExtn[32] ;

	if( gLogAmount >= 8 )
	{
		SessionLogDirect( _T("****\tREBatchThread.CallScript: \"%s\", \"%s\"."), ScriptName, FuncCall ) ;
	}
	
	GetFilePathNameAndExt( ScriptName, FilePath, FileName, FileExtn ) ;

	if( FileName[0] == 'C' && FileName[1] == '_' )
	{
		if( gLogAmount >= 3 )
		{
			SessionLogDirect( _T("****\tREBatchThread.Calling C Script: \"%s\", \"%s\"."), ScriptName, FuncCall ) ;
		}

		Result = CallCScript( ScriptName, FuncCall ) ;
	}
	else
	{
		//	BUILD THE FUNCTION CALL
		if( gLogAmount >= 3 )
		{
			SessionLogDirect( _T("****\tREBatchThread.Calling KPL Script: \"%s\", \"%s\"."), ScriptName, FuncCall ) ;
		}
		Result = CallKPLScript( ScriptName, FuncCall ) ;
	}
	return( Result ) ;
}

//	CALL A SCRIPT HERE !
long CallCScript( TCHAR *ScriptName, TCHAR *FuncCall )
{
	long Result = FALSE ;
	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("****\tREBatchThread.CallCScript: \"%s\", \"%s\"."), ScriptName, FuncCall ) ;
	}

	TCHAR		 ScriptPath[2048] ;
	GetScriptPath( ScriptName, ScriptPath ) ;

	UCInterpreter *Interp = new UCInterpreter ;
	if( Interp )
	{
		Interp->SetCheckTextLibFirst( gCheckTextLibFirst ) ;
		Result = Interp->InterpretC( ScriptPath ) ;
		Result = Interp->CallBack( FuncCall ) ;
		Result = Interp->GetLongReturn() ;
		delete Interp ;
	}
	return( Result ) ;
}


long CallKPLScript( TCHAR *ScriptName, TCHAR *FuncCall )
{
	long	Result = 0L ;

	TCHAR	ScriptPath[2048] ;

	GetScriptPath( ScriptName, ScriptPath ) ;

	UIC		*theUIC = new UIC ;
	if( theUIC )
	{
		//										CheckLib IsJob	Unicode	  Trigger
		theUIC->ParseFile( ScriptPath, NULL,		0,		0,		0,		FuncCall ) ;

		TCHAR	*TxtResult = theUIC->GetScriptReturnValue() ;
		if( TxtResult )
		{
			if( *TxtResult )
			{
				Result = atoi( TxtResult ) ;
			}
		}
		//	DELETE THE INSTRUCTION CLASS OBJECT SO WE HAVE NO MEMORY LEAKS.
		delete theUIC ;
	}
	return( Result ) ;
}


TCHAR	*GetScriptPath( TCHAR *ScriptName, TCHAR *Path )
{
	int		 IsDirectory ;

	if( FileOrDirectoryExists( ScriptName, &IsDirectory ) )
	{
		strcpy( Path, ScriptName ) ;
		return( Path ) ;
	}

	TCHAR	*ShareDirectory = GetShareDirectory() ;
	sprintf( Path, _T("%s\\Scripts\\%s"), ShareDirectory, ScriptName ) ;
	if( FileOrDirectoryExists( Path, &IsDirectory ) )
	{
		return( Path ) ;
	}

	TCHAR	*ExeDirectory = GetExeDirectory() ;
	sprintf( Path, _T("%s\\Scripts\\%s"), ExeDirectory, ScriptName ) ;
	if( FileOrDirectoryExists( Path, &IsDirectory ) )
	{
		return( Path ) ;
	}

	strcpy( Path, ScriptName ) ;

	return( Path ) ;
}


int	DeleteThisFile( TCHAR *FilePath )
{
	int	Result = FALSE ;

	if( FilePath )
	{
		if( *FilePath )
		{
			Result = unlink( FilePath ) ;
			if( Result )
			{
				//	HANDLE THE ERROR
				TCHAR	Msg[1024] ;
				int		ErrNo = errno(Msg) ;
				SessionLogDirect( _T("**\tREThread.DeleteThisFile: Error %ld \"%s\" deleting \"%s\""),
								ErrNo, Msg, FilePath ) ;
			}
		}
	}
	return( Result ) ;
}

int SavePage( UGenCon *thePage )
{
	UREUtils	*REUtils = new UREUtils ;
	int Result = REUtils->SavePage( thePage, gLogAmount ) ;
	delete REUtils ;
	return( Result ) ;
}

int SavePageX( UGenCon *thePage )
{
	TCHAR	*AttrName ;
	TCHAR	 AttrValue[2048] ;
	TCHAR	 FilePath[1024] ;
	TCHAR	 ModifiedValue[2048] ;

	if( thePage == NULL )				{ return( FALSE ) ; }

	TCHAR	*ExeDirectory = GetExeDirectory() ;

	sprintf( FilePath, _T("%s\\Pages"), ExeDirectory ) ;
	CreateFullDirectoryPath( FilePath ) ;

	sprintf( FilePath, _T("%s\\Pages\\P%09ld.page"), ExeDirectory, thePage->GetLongValue(_T("JobID"))) ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.SavePage: File: \"%s\""), FilePath ) ;
	}

	UDataDict	*theDict = thePage->GetDataDict() ;

	char		*fp = fopen( FilePath, _T("w")) ;
	if( fp )
	{
		TCHAR			*GCName = thePage->GetName() ;
		TCHAR			*DDName = theDict->GetName() ;

		fprintf( fp, _T("//\tREBatch\n\n")) ;
		fprintf( fp, _T("Create \"%s\" Using \"%s\"\n{\n"), GCName, DDName ) ;
		UListIterator	*anIter = new UListIterator( theDict ) ;
		UAttribute		*anAttr = (UAttribute *) anIter->GetFirst() ;
		while( anAttr )
		{
			AttrName = anAttr->GetName() ;

			if( stricmp( AttrName, _T("BackPrintMessage1")) != 0 &&
				stricmp( AttrName, _T("BackPrintMessage2")) != 0  )
			{
				if( thePage->AttrChanged( AttrName ))
				{
					thePage->GetAttrValue( AttrName, AttrValue ) ;
					GetModifiedValue( AttrValue, ModifiedValue ) ;
					fprintf( fp, _T("\t%-24.24s\t\"%s\"\n"), AttrName, ModifiedValue ) ;
				}
			}

			anAttr = (UAttribute *) anIter->GetNext() ;
		}

		fprintf( fp, _T("%c\n"), 0x0x7D) ;
		delete anIter ;

		//	IF THIS IS A PACKAGE, WRITE OUT THE JOB IDs OF THE PAGES THAT MAKE UP THE PACKAGE
		//	AS WELL AS WHETHER OR NOT WE ARE DONE WITH THE PAGE.		NEW TBD 01/03/05
		
		if( thePage->GetLongValue(_T("IsPackage")))
		{
			long	 PageID ;
			TCHAR	*ImagePath ;
			long	 DeleteAfter ;

			UList	*thePkgPages = thePage->GetChildren() ;
			anIter = new UListIterator( thePkgPages ) ;
			UGenCon	*aPage = (UGenCon *) anIter->GetFirst() ;

			fprintf( fp, _T("\n{")) ;

			while( aPage )
			{
				PageID		= aPage->GetLongValue(_T("JobID")) ;
				fprintf( fp, _T("\n\tJobID %ld\n"), PageID ) ;
				aPage = (UGenCon *) anIter->GetNext() ;
			}
			fprintf( fp, _T("%c"), 0x7D ) ;

			delete anIter ;
		}

		fclose(fp) ;
		return( TRUE ) ;
	}
	return( FALSE ) ;
}

int  GetModifiedValue( TCHAR *SrcValue, TCHAR *DstValue )
{
	long	SrcPos = 0L ;
	long	DstPos = 0L ;

	while( SrcValue[SrcPos] )
	{
		if( SrcValue[SrcPos] == 0x22 )	//	DOUBLE QUOTE
		{
			DstValue[DstPos] = 0x5C ;	//	BACKSLASH
			DstPos++ ;
		}

		if( SrcValue[SrcPos] == 0x5C )	//	BACKSLASH
		{
			DstValue[DstPos] = 0x5C ;	//	ADD ANOTHER BACKSLASH
			DstPos++ ;
		}

		DstValue[DstPos] = SrcValue[SrcPos] ;
		DstPos++ ;
		SrcPos++ ;
	}
	DstValue[DstPos] = 0x00 ;
	return( TRUE ) ;
}


void GetHexString( TCHAR *SrcValue, TCHAR *HexString )
{
	TCHAR	*HexChars = _T("0123456789ABCDEF") ;
	long	 HexPos = 0L ;
	long	 SrcPos = 0L ;
	long	 Value ;

	while( SrcValue[SrcPos] )
	{
		Value = SrcValue[SrcPos] ;	SrcPos++ ;
		HexString[HexPos] = HexChars[((Value & 0xF000) >> 12)]	;	HexPos++ ;
		HexString[HexPos] = HexChars[((Value & 0x0F00) >>  8)]	;	HexPos++ ;
		HexString[HexPos] = HexChars[((Value & 0x00F0) >>  4)]	;	HexPos++ ;
		HexString[HexPos] = HexChars[((Value & 0x000F))]		;	HexPos++ ;
		HexString[HexPos] = 0x0020 ; HexPos++ ;
	}
	HexString[HexPos] = 0x0000 ;
}


void GetQuoteCharacter( TCHAR *String, TCHAR *QuoteChar )
{
	QuoteChar[0] = 0x00 ;
	QuoteChar[1] = 0x00 ;

	if( strchr( String, 0x22 ) == NULL )	{ QuoteChar[0] = 0x22 ; return ; }	//	"
	if( strchr( String, 0x27 ) == NULL )	{ QuoteChar[0] = 0x27 ; return ; }	//	'
	if( strchr( String, 0x60 ) == NULL )	{ QuoteChar[0] = 0x60 ; return ; }	//	`
	if( strchr( String, 0x7C ) == NULL )	{ QuoteChar[0] = 0x7C ; return ; }	//	|
	if( strchr( String, 0x7E ) == NULL )	{ QuoteChar[0] = 0x7E ; return ; }	//	~
	if( strchr( String, 0x21 ) == NULL )	{ QuoteChar[0] = 0x21 ; return ; }	//	!
	if( strchr( String, 0x23 ) == NULL )	{ QuoteChar[0] = 0x23 ; return ; }	//	#
	QuoteChar[0] = 0x25 ;	//	%
}

UGenCon *LoadPage( long PageID )
{
	TCHAR	*AttrName ;
	TCHAR	 AttrValue[2048] ;
	TCHAR	 Token[1024] ;
	TCHAR	 GCName[64] ;
	TCHAR	 DDName[64] ;
	TCHAR	 FilePath[1024] ;

	TCHAR	*ExeDirectory = GetExeDirectory() ;

	sprintf( FilePath, _T("%s\\Pages\\P%09ld.page"), ExeDirectory, PageID ) ;

	UGenCon	*theGC = NULL ;

	if(  FilePath == NULL )	{ return( theGC ) ; }
	if( *FilePath == 0x00 )	{ return( theGC ) ; }

	if( gLogAmount >= 4 )
	{
		SessionLogDirect( _T("****\tREBatchThread.LoadPage: File: \"%s\""), FilePath ) ;
	}

	TCHAR	*Text = GetFile( FilePath, 0 ) ;
	if( Text )
	{
		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("REThread.LoadPage: Text: \"%s\""), Text ) ;
		}

		UParser	*theParser = new UParser ;
		theParser->SetText( Text ) ;
		theParser->SetProcessBackSlashes(TRUE) ;

		theParser->GetToken( Token ) ;
		if( stricmp( Token, _T("Create")) == 0 )
		{
			
			theParser->GetToken( GCName ) ;				//	GC Name
			theParser->GetToken( Token ) ;				//	Using
			theParser->GetToken( DDName ) ;				//	DD Name

			theGC = new UGenCon( GetDataDictionary( DDName )) ;
			if( theGC )
			{
				theGC->SetName( GCName ) ;
				theParser->GetToken(Token) ;			//	'OPEN BRACE'
				theParser->GetToken( Token ) ;			//	ATTR NAME

				while( *Token )
				{
					if( *Token == 0x7D ) {	break ;	}

						//	ALLOWS QUOTES IN IMAGE PATH
//					theParser->GetUntil( 0x0A, AttrValue, FALSE ) ;
//					theParser->GetDelimitedToken( AttrValue ) ;
					theParser->GetToken( AttrValue ) ;

					theGC->SetAttrValue( Token, AttrValue ) ;
					theParser->GetToken( Token ) ;
				}

				//	AT THIS POINT, CHECK TO SEE IF THIS IS A PACKAGE
				//	IF A PACKAGE THEN READ THE ORIGINAL IMAGE DATA
				if( theGC->GetLongValue(_T("IsPackage")))
				{
					ReadOriginalPages( theParser, theGC ) ;
				}	//	if( IsPackage )
			}	//	if( theGC )
		}	//	if( Create )

		theParser->SetText( NULL ) ;
		delete theParser ;
		free( Text ) ;

		DeleteThisFile( FilePath ) ;
	}

	if( theGC )
	{
		UList	*theErrors = theGC->GetLongValue(_T("RenderErrorList")) ;
		if( theErrors )
		{
			delete theErrors ;
			theGC->SetLongValue(_T("RenderErrorList"), 0L ) ;
		}
	}
	return( theGC ) ;
}

int ReadOriginalPages( UParser *theParser, UGenCon *thePkg )
{
	TCHAR	 Token[2048] ;
	UGenCon	*OrigPage ;
	long	 JobID ;

	theParser->GetToken(Token) ;	//	'OPEN BRACE'
	theParser->GetToken(Token) ;
	while( *Token != 0x7D )			//	'CLOSE BRACE'
	{
		OrigPage = new UGenCon( GetDataDictionary( _T("DDPaperFillResponse"))) ;
		if( OrigPage )
		{
			if( stricmp( Token, _T("JobID")) == 0 )
			{
				JobID = theParser->GetLong() ;
				OrigPage->SetLongValue(_T("JobID"), JobID ) ;
				theParser->GetToken(Token) ;
			}

			thePkg->AddChildBack( OrigPage ) ;

		}	//	if( OrigPage )
	}	//	while( *Token != 'CLOSE BRACE' )
	return( TRUE ) ;
}

int DeleteUIC( UGenCon *aPage )
{
	UIC *theUIC = aPage->GetLongValue(_T("UIC")) ;
	if( theUIC )
	{
		delete theUIC ;
		aPage->SetLongValue(_T("UIC"), NULL ) ;
		aPage->SetLongValue(_T("URenderList"), NULL ) ;	//	DELETED WHEN DELETING THE UIC
	}
	return( TRUE ) ;
}

int ZeroUIC( UGenCon *aPage )
{
	aPage->SetLongValue(_T("UIC"), NULL ) ;
	aPage->SetLongValue(_T("URenderList"), NULL ) ;	//	DELETED WHEN DELETING THE UIC
	return( TRUE ) ;
}

int PostAThreadMessage( CIThread *theThread, long MsgNum, long wParam, long lParam )
{
	int		Result = 0 ;
	int		Count  = 0 ;
	int		LastError = 0 ;

	long	ThreadID = theThread->GetThreadID() ;

	while( Result == 0 )
	{
		Result = theThread->PostThreadMessage( MsgNum, wParam, lParam ) ;
		if( Result == 0 )
		{
			LastError = GetLastError() ;
			SessionLogDirect( _T("REBatchThread.PostAThreadMessage(0x%08lX, %ld, %ld): Failed: Thread: 0x%08lX, ThreadID: 0x%08lX, Error: %d"),
					MsgNum, wParam, lParam, theThread, ThreadID, LastError ) ;
			Sleep( 1000 ) ;
		}

		Count++ ;

		if( Count > 5 )
		{
			break ;
		}
	}

	return( Result ) ;
}


//=============================================================================
//=============================================================================
//========================== DATABASE INTERFACE ===============================
//=============================================================================
//=============================================================================

int	UpdateJobRecord(UGenCon *thePage, long PrintStatus )
{
	int		 Result		= TRUE ;
	TCHAR	*UpdateCmd	= _T("UPDATE JobQueue Set PrintStatus = %ld WHERE JobID = '%s'") ;
	TCHAR	*theQuery	= malloc( 2048 * 2 ) ;	//	THIS WILL BE FREED BY THE RECEIVER

//	if( PrintStatus == 7 )	//	Cancelled
//	{
//		PrintStatus = 1L ;	//	Ready		CALLER NOW DECIDES !
//	}

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("****\tREBatchThread.UpdateJobRecord: thePage: 0x%08lX"), thePage ) ;
	}

	//	TBD  thePage can be NULL if we had an error reading the job file !!!!!!
	TCHAR	*PageID = thePage->GetStringValue(_T("PageID")) ;
	sprintf( theQuery, UpdateCmd, PrintStatus, PageID ) ;

	CIThread	*theREThread = gStatusGC->GetLongValue(_T("REThread")) ;
	if( theREThread )
	{
		Result = PostAThreadMessage( theREThread, REM_DB_SQL, 0L, theQuery ) ;
		if( Result == FALSE )	{ free( theQuery ) ; }
	}

	return( Result ) ;
}

int	UpdateOrderItemsRecord(UGenCon *thePage, long PrintStatus )
{
	int		 Result		= TRUE ;

	TCHAR	 DateTime[128] ;
	GetSortableTimeNow(DateTime) ;

	TCHAR	*PrinterName	= gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
	TCHAR	*OrderID		= thePage->GetStringValue(_T("OrderID")) ;
	long	 OrderItemID	= thePage->GetLongValue(_T("OrderItemID")) ;

	TCHAR	*UpdateCmd	= _T("UPDATE OrderItems SET PrintCount=PrintCount+1, PrinterName = '%s', PrintStatus = %d, TimePrinted = '%s', Remake = 0 WHERE OrderID = '%s' AND ID = %ld") ;
	TCHAR	*theQuery	= malloc( 2048 * 2 ) ;	//	THIS WILL BE FREED BY THE RECEIVER

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("****\tREBatchThread.UpdateOrderItemsRecord: thePage: 0x%08lX"), thePage ) ;
	}

	//	TBD  thePage can be NULL if we had an error reading the job file !!!!!!
	TCHAR	*PageID = thePage->GetStringValue(_T("PageID")) ;
	sprintf( theQuery, UpdateCmd, PrinterName, PrintStatus, DateTime, OrderID, OrderItemID ) ;

	CIThread	*theREThread = gStatusGC->GetLongValue(_T("REThread")) ;
	if( theREThread )
	{
		Result = PostAThreadMessage( theREThread, REM_DB_SQL, 0L, theQuery ) ;
		if( Result == FALSE )	{ free( theQuery ) ; }
	}

	return( Result ) ;
}

int DeleteRecordFromJobQueue( UGenCon *thePage )
{
	int		Result = FALSE ;

	CIThread	*theREThread = gStatusGC->GetLongValue(_T("REThread")) ;
	if( theREThread )
	{
		Result = PostAThreadMessage( theREThread, REM_DELETE_JOB_RECORD, 0L, thePage ) ;
	}
	return( Result ) ;
}

/*	OLD WAY
int DeleteRecordFromJobQueue( long JobID )
{
	int		Result = FALSE ;

	CIThread	*theREThread = gStatusGC->GetLongValue(_T("REThread")) ;
	if( theREThread )
	{
		Result = PostAThreadMessage( theREThread, REM_DELETE_JOB_RECORD, 0L, JobID ) ;
	}
	return( Result ) ;
}
*/
//=============================================================================
//=============================================================================
//=========================== DIALOG INTERFACE ================================
//=============================================================================
//=============================================================================

/*
Dictionary: DDMessageDialog
	Fields:	Name		xPosition		Type	long		// < 0 means center
	Fields:	Name		yPosition		Type	long		// < 0 means center
	Fields:	Name		ThreadID		Type	long
	Fields:	Name		Modal			Type	long
	Fields: Name		ResumeThread	Type	long		// a CWinThread to resume
	Fields:	Name		Hwnd			Type	long		// Dialog HWND
	Fields:	Name		ThreadWindow	Type	long
	Fields:	Name		ThreadMessage	Type	long		// WM_Whatever		
	Fields:	Name		Title			Type	text
	Fields:	Name		DialogHelpPage	Type	text
	Fields:	Name		Message1		Type	text
	Fields:	Name		Message2		Type	text
	Fields:	Name		DefaultButton	Type	long
	Fields:	Name		Button0			Type	text		//	THIS IS THE CLOSE DIALOG BUTTON
	Fields:	Name		Button0Response	Type	text
	Fields:	Name		Button0ToolTip	Type	text
	Fields:	Name		Button1			Type	text
	Fields:	Name		Button1Response	Type	text
	Fields:	Name		Button1ToolTip	Type	text
	Fields:	Name		Button2			Type	text
	Fields:	Name		Button2Response	Type	text
	Fields:	Name		Button2ToolTip	Type	text
	Fields:	Name		Button3			Type	text
	Fields:	Name		Button3Response	Type	text
	Fields:	Name		Button3ToolTip	Type	text
	Fields:	Name		Button4			Type	text
	Fields:	Name		Button4Response	Type	text
	Fields:	Name		Button4ToolTip	Type	text
	Fields:	Name		ButtonPressed	Type	long
	Fields:	Name		MaxButtonWidth	Type	long
	Fields:	Name		MaxButtonHeight	Type	long
	Fields:	Name		WantsDetails	Type	long
	Fields:	Name		AlwaysDisplay	Type	long
	Fields:	Name		UpdateMessage	Type	long
;
*/


long ShowDialog( TCHAR *theMsg, long MsgType, long ResponseMessage, UGenCon *thePage )
{
	UGenCon *MsgDlg = new UGenCon( GetDataDictionary( _T("DDMessageDialog"))) ;
	MsgDlg->SetAttrValue( _T("Title"), _T("REBatch Error")) ;
	MsgDlg->SetLongValue( _T("xPosition"), 250L ) ;
	MsgDlg->SetLongValue( _T("yPosition"), 150L ) ;
	MsgDlg->SetAttrValue( _T("Message1"), theMsg ) ;
	MsgDlg->SetLongValue( _T("ThreadID"), gThisThread->GetThreadID() ) ;
	MsgDlg->SetLongValue( _T("ThreadMessage"), REM_BATCH_MESSAGE_RESPONSE ) ;
	MsgDlg->SetLongValue( _T("ReturnThisGC"), TRUE ) ;
	MsgDlg->SetLongValue( _T("ResponseMessage"), ResponseMessage ) ;
	MsgDlg->SetLongValue( _T("RenderPage"), thePage ) ;

	if( MsgType > 4L || MsgType < 0 )	{ MsgType = 2L ; }

	switch( MsgType )
	{
		case	0	:	//	JOB PARSING OR RENDERING ERROR
//			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
//			MsgDlg->SetAttrValue( _T("Button1"), _T("Oh...") ) ;
//			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Cancel") ) ;
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Retry") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Retry") ) ;

			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Page") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelPage") ) ;

			MsgDlg->SetAttrValue( _T("Button3"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button3Response"), _T("CancelBatch") ) ;
			break ;

		case	1	:	//	PRINTING INFORMATIONAL MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Retry") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Retry") ) ;

			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelBatch") ) ;
			break ;

		case	2	:	//	PRINTING WARNING MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Cancel Page") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("CancelPage") ) ;

			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelBatch") ) ;
			break ;

		case	3	:	//	PRINTING ERROR MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Retry") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Retry") ) ;

			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelBatch") ) ;
			break ;

		case	4	:	//	PRINTING ERROR MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Cancel Page") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("CancelPage") ) ;

			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelBatch") ) ;
			break ;
	}

	SessionLogDirect( _T("****\tREBatch.ShowDialog: \"%s\""), theMsg ) ;

	if( gShuttingDown || gREStatus >= RE_SHUTTING_DOWN )
	{
		return( FALSE ) ;
	}

	CIThread	*theDlgThread = gStatusGC->GetLongValue(_T("DlgThread")) ;
	if( theDlgThread )
	{
		PostAThreadMessage( theDlgThread, REM_RE_SIREN, 0L, 0L ) ;
	}

//=============================================================================
	MsgDlg->SetLongValue(_T("UseOrigGC"), TRUE ) ;
	MessageDialog( MsgDlg, FALSE ) ;
//=============================================================================

//	delete MsgDlg ;	//	WE WILL CLEAN THIS UP IN MessageDialogReply WHEN IT IS
					//	RETURNED FROM THE MessageDialog.

}

long MessageDialogReply(UGenCon *MsgDlg)
{
	long	UserAction = 0L ;
	if( MsgDlg )
	{
		long	ButtonPressed = MsgDlg->GetLongValue(_T("ButtonPressed")) ;
		TCHAR	ResponseAttrName[32] ;
		sprintf( ResponseAttrName, _T("Button%dResponse"), ButtonPressed ) ;

		TCHAR	*Response = MsgDlg->GetStringValue(ResponseAttrName) ;

		if( Response )
		{
			if( stricmp( Response, _T("Retry")) == 0 )			{ UserAction = 1L ; }
			if( stricmp( Response, _T("CancelPage")) == 0 )		{ UserAction = 2L ; }
			if( stricmp( Response, _T("CancelOrder")) == 0 )	{ UserAction = 3L ; }
			if( stricmp( Response, _T("CancelBatch")) == 0 )	{ UserAction = 4L ; }
		}

		long RenderPage		 = MsgDlg->GetLongValue( _T("RenderPage")) ;
		long ResponseMessage = MsgDlg->GetLongValue( _T("ResponseMessage")) ;

		PostAThreadMessage( gThisThread, ResponseMessage, RenderPage, UserAction ) ;

		SessionLogDirect( _T("****\tREBatchThread.ShowDialog: User Selected: \"%s\""), Response ) ;

		delete MsgDlg ;
	}
	else
	{
		SessionLogDirect( _T("****\tREBatch.MessageDialogReply: ERROR: We got here with no MsgDlg GenCon.")) ;
	}


	if( gSuspendType & RE_ERR_SUSPEND )		{ gSuspendType -= RE_ERR_SUSPEND ; }
	if( gSuspendType <= 0 )					{ gREStatus = RE_RUNNING ; gSuspendType = 0 ; }


	return( UserAction ) ;
}

//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================
int IsREPieThreadRunning(long ThreadHandleToFind)
{
	int		FoundThread = FALSE ;
	UGenCon *theThreads = (UGenCon *) GetTreeObject( _T("GenCons"), _T("Threads")) ;
	if( theThreads )
	{
		UListIterator	*anIter = new UListIterator(theThreads->GetChildren()) ;
		if( anIter )
		{
			long	ThreadHandle ;
			UGenCon	*aThread = (UGenCon *) anIter->GetFirst() ;
			while( aThread )
			{
				ThreadHandle = aThread->GetLongValue(_T("ThreadHandle")) ;
				if( ThreadHandle == ThreadHandleToFind )
				{
					FoundThread = TRUE ;
					break ;
				}
			}
			delete anIter ;
		}
	}
	return( FoundThread ) ;
}

//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================

//	FOR THIS EXCEPTION HANDLER TO WORK, THERE SHOULD BE A DDTEXT GENCON ON THE
//	DATA TREE DESCRIBING WHERE THE SCRIPT CRASHED.  WE SHOULD OUTPUT THE MESSAGE
//	TO THE SESSION LOG, CLEAN UP THE TREE, AND POST MESSAGES TO THE APPROPRIATE
//	THREADS TO KEEP THEM MOVING.

int ExceptionHandler()
{
	if( gNewWay )
	{
		int Result = gREBatch->ExceptionHandler() ;
		return( Result ) ;
	}

	SessionLogDirect( _T("REBatchThread.ExceptionHandler: Inside: REBatchThread: 0x%08lX, Pages: %ld"),
			gREThread, gPagesRendering->GetNumEntries() ) ;

	DumpCStack(_T("****\tREBatch.ExceptionHandler")) ;

	UGenCon *theMsgGC = PluckTreeObject(_T("CRunTimeError"), _T("[GenCons]")) ;

	if( gShuttingDown || gREStatus >= RE_SHUTTING_DOWN )
	{
		if( theMsgGC )	{ delete theMsgGC ; }

		return( TRUE ) ;
	}

	if( theMsgGC )
	{
		TCHAR	*theMsg = theMsgGC->GetStringValue(_T("Text")) ;
		SessionLogDirect( _T("REBatchThread.ExceptionHandler: The Error Message: \"%s\"."),
							theMsg ) ;

		ShowDialog( theMsg, 0L, REM_BATCH_EXCEPTION_RESPONSE, 0L ) ;

		delete theMsgGC ;
	}

	return( TRUE ) ;
}

int HandleExceptionResponse(long UserAction)
{
	//	IF THERE IS A PAGE BEING RENDERED, WE BETTER STOP IT.
	//	THE CANCEL WILL STOP THE PIE THREAD.
	CancelPagesRendering() ;

	//	MAKE THIS THREAD GO AWAY AND
	//	NOTIFY THE RETHREAD THAT THE BATCH IS COMPLETE (DONE IN EXIT INSTANCE.)
	if( gShuttingDown == FALSE )
	{
		PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;
	}
	return( TRUE ) ;
}

//=============================================================================
/*
Dictionary:	DDPaperFillPage
	Fields:	Name	PkgPage					Type	Long
	Fields:	Name	DeleteAfter				Type	Long
	;
*/

DumpLayoutData( UGenCon *theLayout ) 	//	DEBUG
{
	UGenCon			*aPage ;
	theLayout->Dump(_T("Dumping Layout Data:")) ;
	UListIterator	*anIter = new UListIterator( theLayout->GetChildren()) ;
	UGenCon			*aSlot  = (UGenCon *) anIter->GetFirst() ;
	while( aSlot )
	{
		aPage = aSlot->GetLongValue(_T("RenderPage")) ;
		if( aPage )
		{
			SessionLogDirect( _T("Page Of Layout: \"%s\""), aPage->GetName()) ;
		}
		else
		{
			SessionLogDirect( _T("Page Of Layout: \"None\"")) ;
		}
		aSlot  = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;
}

int DumpCStack(TCHAR *Where)
{
	UCInterpreter *ThisCInterp = THIS() ;
	TCHAR	*StackText = ThisCInterp->GetStackText() ;
	SessionLogDirect( _T("REBatchThread.%s: Stack:\n%s"), Where, StackText ) ;
	free( StackText ) ;
	return( TRUE ) ;
}

//=============================================================================
//=============================================================================

//	DEBUGGER2 CODE

TCHAR	gScriptName[2048] ;	//	SO WE KNOW WHAT TO REMOVE LATER

int HangDebugTargetGC()
{
	UCInterpreter	*theCI = THIS() ;

	TCHAR			 ScriptName[2048] ;
	GetScriptName( theCI, ScriptName ) ;

	UGenCon			*theDebugGC = new UGenCon( GetDataDictionary(_T("DDDebugScript"))) ;

	if( theDebugGC )
	{
		theDebugGC->SetName( ScriptName ) ;
		theDebugGC->SetLongValue( _T("CInterpreter"), theCI ) ;
		theDebugGC->SetLongValue( _T("CInterpThread"), gThisThread ) ;
	}

	strcpy( gScriptName, ScriptName ) ;

	HangTreeObject( theDebugGC, _T("[DebugScripts Scripts]")) ;

	return( TRUE ) ;
}

TCHAR	*GetScriptName( UCInterpreter *theCI, TCHAR *ScriptName )
{
	UList			*ScriptFiles	= theCI->GetScriptFiles() ;
	UListIterator	*anIter			= new UListIterator( ScriptFiles ) ;
	UScriptFile		*aFile			= (UScriptFile *) anIter->GetFirst() ;

	*ScriptName = 0x00 ;

	if( aFile )
	{
		TCHAR *ScriptPath = aFile->GetPath() ;
		if( ScriptPath )
		{
			TCHAR	FileName[2048] ;
			TCHAR	FilePath[2048] ;
			TCHAR	FileExtn[64] ;

			GetFilePathNameAndExt( ScriptPath, FilePath, FileName, FileExtn ) ;
			sprintf( ScriptName, _T("%s.%s"), FileName, FileExtn ) ;
		}
	}
	delete anIter ;
	return( ScriptName ) ;
}

int RemoveDebugTargetGC()
{
	UGenCon *theDebugGC = PluckTreeObject( gScriptName, _T("[DebugScripts Scripts]")) ;
	delete theDebugGC ;
	return(TRUE) ;
}

//=============================================================================
//=============================================================================


//=============================================================================
//=============================================================================
//====================== ARBITRARY PAPER FILL =================================
//=============================================================================
//=============================================================================

#include "[E]\\CommonText\\ArbitraryPaperFillInclude.txt"


//=============================================================================
//=============================================================================
//======================== LUCHT PAPER FILL ===================================
//=============================================================================
//=============================================================================

#include "[E]\\CommonText\\LuchtPaperFillInclude.txt"


//=============================================================================
//=============================================================================
//================== GENERAL PAPER FILL ROUTINES ==============================
//=============================================================================
//=============================================================================

#include "[E]\\CommonText\\GeneralPaperFillInclude.txt"


//=============================================================================
//=============================================================================
