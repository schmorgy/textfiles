// Kpars Queue Grid View Functions

Include: ~FormattingRoutines~;

IncludeClass(BaseClass);
IncludeClass(BaseOrder);
IncludeClass(BaseThread);

Class( YBGen,Extends,BaseClass,
			Member,MapTableName,Str,~YBSIFieldMap~,
			Member,YBTableName,Str,~YearbookDefs~,
			Member,YBInstTableName,Str,~ExportYBSetups~,
			Member,YBFieldsTableName,Str,~YearbookFields~,
			Member,LabInfoTableName,Str,~SchoolLabInfo~,
			Member,fYearbookID,Str,~~,
			Member,fInfoType,Str,~~,
			Member,fReadMePath,Str,~~,
			Member,fReadMeFilePath,Str,~~,
			Member,fGroupFields,Str,~~,
			Member,fGroupBy,Str,~~,
			Member,fSortBy,Str,~~,
			Member,fImageSize,Str,~~,
			Member,fImageWidth,Numeric,640,
			Member,fImageLength,Numeric,800,
			Member,fProfile,Str,~srgb~,
			Member,fEmbedProfile,Numeric,1,
			Member,fResolution,Numeric,300,
			Member,FromScript,Numeric,0,
			Member,fFileNameType,Numeric,0,
			Member,fOrderItemID,Numeric,1,
			Member,fCropAdjustment,Numeric,100,
			Member,fCompressionQuality,Numeric,90,
			Member,fRImageEnabled,Numeric,0,
			Member,fRImageJobID,Str,~~,
			Member,fRImageCDPath,Str,~~,
			Member,fRImageTemplate,Str,~~,
			Member,fProcessAfter,Str,~~,
			Member,fProcessAfterFile,Str,~~,
			Member,fDeleteAfterRImage,Numeric,0,
			Member,fGroupsPerCD,Numeric,12,
			Member,fQueueName,Str,~~,
			Member,fPoseSource,Numeric,0,
			Member,fPoseField,Str,~~,
			Member,fPoseValue,Str,~~,
			Member,fAllPoses,Numeric,0,
			Member,fSchoolName,Str,~~,
			Member,fCancel,Numeric,0,
			Member,fExportOnBlank,Numeric,1,
			Member,fAutoCropSrcX,Numeric,50,
			Member,fAutoCropSrcY,Numeric,50,
			Member,fAutoCropDstX,Numeric,50,
			Member,fAutoCropDstY,Numeric,50,
			Member,fAutoCropWidth,Numeric,100,
			Member,fAutoCropLength,Numeric,100,
			
			// Chroma Key Stuff
			Member,fChromaKeyBGIDOption,Str,~~,
			Member,fProductType,Str,~~,
			Member,fDP2BGId,Str,~~,
			Member,fRed,Numeric,0,
			Member,fGreen,Numeric,0,
			Member,fBlue,Numeric,0
);


	 
VOID YBGen::YBGen()
{
}

VOID YBGen::!YBGen()
{
}

VOID YBGen::DefineMessages()
{
	BaseHtml::DefineMessages();
	LoadTranslationFile( ExportToYearbook,ExportToYearbook,ExportToYearbook );
	LoadTranslationFile(~Administration\ProblemReport~,ProblemReport,ProblemReport);
}

VOID	YBGen::YearbookID(value)		{ fYearbookID = ~<value>~; }
VOID	YBGen::SchoolName(value)		{ fSchoolName = ~<value>~; }

VOID	YBGen::JobNumber(value)			{ fJobNumber = ~<value>~; }

VOID	YBGen::GroupFields(value)		{ fGroupFields = ~<value>~ ; }

VOID	YBGen::ImageSize(size)			{ fImageSize = ~<size>~ ; }
VOID	YBGen::ImageWidth(size)			{ fImageWidth = Numeric( ~<size>~ ); }
VOID	YBGen::ImageLength(size)		{ fImageLength = Numeric( ~<size>~ ); }

VOID	YBGen::Resolution(res)			{ fResolution = Numeric( ~<res>~ ); }
VOID	YBGen::CropAdjustment(adj)		{ fCropAdjustment = Numeric( <adj> ); }
VOID	YBGen::CompressionQuality(qual) { fCompressionQuality = Numeric( ~<qual>~ ); }

VOID	YBGen::Profile(prof)			{ fProfile = ~<prof>~; }
VOID	YBGen::EmbedProfile(emb)		{ fEmbedProfile = Numeric( ~<emb>~ ); }

VOID	YBGen::PoseSource(value)		{ fPoseSource = <value>; }
VOID	YBGen::PoseField(field)			{ fPoseField = ~<field>~; }
VOID	YBGen::PoseValue(value)			{ fPoseValue = ~<value>~; }
VOID	YBGen::AllPoses(value)			{ fAllPoses = Numeric( ~<value>~ ); }

VOID	YBGen::RImageEnabled(v)			{ fRImageEnabled = Numeric(~<v>~); }
VOID	YBGen::RImageCDPath(path)		{ fRImageCDPath = ~<path>~; }
VOID	YBGen::RImageTemplate(s)		{ fRImageTemplate = ~<s>~; }
VOID	YBGen::GroupsPerCD(v)			{ fGroupsPerCD = Numeric( ~<v>~ ); }
VOID	YBGen::ProcessAfterFile(s)		{ fProcessAfterFile = ~<s>~; }
VOID	YBGen::ProcessAfter(&s)			{ fProcessAfter = STR ( <s> ); }
VOID	YBGen::LastJobInBatch(v)		{ fLastJobInBatch = Numeric(~<v>~); }
VOID	YBGen::DeleteAfterRImage(value)	{ fDeleteAfterRImage = Numeric(~<value>~); }
VOID	YBGen::QueueName(s)				{ fQueueName = ~<s>~; }
VOID	YBGen::Cancel(v)				{ fCancel =  Numeric( ~<v>~ ); }
STR		YBGen::GetBatchID()				{ return ~<fBatchID>~; }
VOID	YBGen::ExportOnBlank(value)	{ fExportOnBlank  = <value>; }
VOID	YBGen::AutoCropSrcX(v)			{ fAutoCropSrcX = Numeric( ~<v>~ ); }
VOID	YBGen::AutoCropSrcY(v)			{ fAutoCropSrcY = Numeric( ~<v>~ ); }
VOID	YBGen::AutoCropDstX(v)			{ fAutoCropDstX = Numeric( ~<v>~ ); }
VOID	YBGen::AutoCropDstY(v)			{ fAutoCropDstY = Numeric( ~<v>~ ); }
VOID	YBGen::AutoCropWidth(v)			{ fAutoCropWidth = Numeric( ~<v>~ ); }
VOID	YBGen::AutoCropLength(v)		{ fAutoCropLength = Numeric( ~<v>~ ); }

VOID	YBGen::ChromaKeyBGIDOption(v)	{ fChromaKeyBGIDOption = ~<v>~; }
VOID	YBGen::ProductType(v)			{ fProductType = ~<v>~; }
VOID	YBGen::DP2BGId(v)				{ fDP2BGId = ~<v>~; }
VOID	YBGen::Red(v)					{ fRed = ~<v>~; }
VOID	YBGen::Green(v)					{ fGreen = ~<v>~; }
VOID	YBGen::Blue(v)					{ fBlue = ~<v>~; }

VOID	YBGen::GetRImageJobID()	{ fRImageJobID = <fRImageEnabled> ? UniqueRImageJobID() : ~~; }

VOID YBGen::SetDbConnection( &dBase )
{
	ForgetPrivate( fConnection );
	
	ADO( fConnection );
	
	if ( DefinedAndNotNull(dBase) )
	{
		fConnection( Is,dBase,Private );
	}
	else
	{
		fConnection( Connect,Private );
	}
}


VOID YBGen::GroupBy( value )
{
	if ( DefinedAndNotNull( value ) )
	{
		fGroupBy = ~<value>~;
	}

}

VOID YBGen::SortBy( value )
{
	if ( DefinedAndNotNull( value ) )
	{
		fSortBy = ~<value>~;
	}

}

NUMERIC YBGen::GenReadmeFile( outputPath, JobNumber, Comments )
{
	ReportStatus( ~Creating ReadmeFile.~ );

	if ( !DefinedAndNotNULL( fSchoolName ) )
	{
		return ReportError( ~YBGen::GenReadmeFile  No SchoolName defined~ );
	}

	if ( !DefinedAndNotNULL( outputPath ) )
	{
		return ReportError( ~YBGen::GenReadmeFile  No outputPath defined~ );
	}
	fReadMePath = ~<outputPath>~;
	
	if ( !Files( DirectoryExists, ~<fReadMePath>~ ) )
	{
		if ( !Directory( Create,~<fReadMePath>~ ) )
		{
			return ReportError( ~Could not create directory: <fReadMePath>~ );
		}
	}

	if ( !SimilarStr( ~<fSchoolName>~,~~ ) )
	{
		fReadMePath = ~<outputPath>\<fSchoolName>~;
	}

	if ( !Files( DirectoryExists, ~<fReadMePath>~ ) )
	{
		if ( !Directory( Create,~<fReadMePath>~ ) )
		{
			return ReportError( ~Could not create directory: <fReadMePath>~ );
		}
	}

	if ( !Files( DirectoryExists, ~<fReadMePath>\VOL1~ ) )
	{
		if ( !Directory( Create,~<fReadMePath>\VOL1~ ) )
		{
			return ReportError( ~Could not create directory: <fReadMePath>\VOL1~ );
		}
	}

	fReadMeFilePath = ~<fReadMePath>\VOL1\ReadMe.txt~;

	if ( !DefinedAndNotNULL( fYearbookID ) )
	{
		return ReportError( ~YBGen::GenReadmeFile  No YearbookID defined~ );
	}

	setComments  = ~~;
	if ( DefinedAndNotNULL( Comments ) )
	{
		setComments = ~<Comments>~;
	}

	setJobNumber  = ~~;
	if ( DefinedAndNotNULL( JobNumber ) )
	{
		setJobNumber = ~<JobNumber>~;
	}

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		return FALSE;
	}

	if ( !File( fReadMeFile,Open,~<fReadMeFilePath>~,Create,Write ) )	
	{
		return ReportError( ~Failed to create <fReadMeFilePath>~ );
	}
	Private( fReadMeFile );

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		fReadMeFile( Close );
		return FALSE;
	}

	if ( !BuildReadMePart1() )
	{
		ReportError( ~Failed to write first part of ReadMe file.~ );
		fReadMeFile( Close );
		return False;
	}

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		fReadMeFile( Close );
		return FALSE;
	}

	if ( !BuildReadMePart2() )
	{
		ReportError( ~Failed to write second part of ReadMe file.~ );
		fReadMeFile( Close );
		return False;
	}

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		fReadMeFile( Close );
		return FALSE;
	}

	if ( !SimilarStr( ~<fGroupFields>~, ~~ )  )
	{
		fReadMeFile( WriteLine,~[Group Fields]=<fGroupFields>~ );
	}

	if ( !SimilarStr( ~<fGroupBy>~, ~~ )  )
	{
		fReadMeFile( WriteLine,~[Group By]=<fGroupBy>~ );
	}
	if ( !SimilarStr( ~<fSortBy>~, ~~ )  )
	{
		fReadMeFile( WriteLine,~[Sort By]=<fSortBy>~ );
	}

	if ( SimilarStr( ~<fGroupBy>~,~~ ) && SimilarStr( ~<fSortBy>~,~~ ) )
	{
		fReadMeFile( WriteLine,~[Sort By]=Grade,Last Name~ );
	}

	if ( !BuildReadMePart3() )
	{
		ReportError( ~Failed to write third part of ReadMe file.~ );
		fReadMeFile( Close );
		return False;
	}

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		fReadMeFile( Close );
		return FALSE;
	}

	if ( !BuildReadMePart4( ~<setJobNumber>~,~<setComments>~ ) )
	{
		ReportError( ~Failed to write fourth part of ReadMe file.~ );
		fReadMeFile( Close );
		return False;
	}

	fReadMeFile( Close );
	ForgetPrivate( fReadMeFile );

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		return FALSE;
	}

	return TRUE;	
}


NUMERIC YBGen::GenYearbookSetup( SchoolName, YearbookID, outputPath, JobNumber, Comments, QueueName, RImageEnabled, RImageTemplate, DeleteAfterRImage )
{
	FromScript	= TRUE;
	if ( !DefinedAndNotNULL( YearbookID ) )
	{
		return ReportError( ~YBGen::GenReadmeFileAsync:  No YearbookID defined~ );
	}

	fYearbookID = ~<YearbookID>~;
	fSchoolName = ~<SchoolName>~;

	if ( DefinedAndNotNull( QueueName ) )
	{
		fQueueName		= ~<QueueName>~;
	}

	if ( DefinedAndNotNull( RImageEnabled ) )
	{
		fRImageEnabled		= Numeric( ~<RImageEnabled>~ );
	}

	if ( DefinedAndNotNull( RImageTemplate ) )
	{
		fRImageTemplate		= ~<RImageTemplate>~;
	}

	if ( DefinedAndNotNull(DeleteAfterRImage))
	{
		fDeleteAfterRImage	= Numeric( ~<DeleteAfterRImage>~ );
	}

	GetYBDefsFields();

	return GenReadmeFile( ~<outputPath>~, ~<JobNumber>~, ~<Comments>~ );
}

NUMERIC YBGen::BuildReadMePart1()
{
	if ( !SimilarStr( ~<fImageSize>~,~~ ))
	{
		fReadMeFile( WriteLine,~[Image Size]=<fImageSize>~ );
	}
	fReadMeFile( WriteLine,~[Color Mode]=RGB~ );
	
	if ( !SimilarStr( ~<fSchoolName>~,~~ ) )
	{
		fReadMeFile( WriteLine,~[School Name]=<fSchoolName>~ );
	}
	
	return TRUE;
}

NUMERIC YBGen::GetYBDefsFields()
{
	Query = ~Select * from <YBTableName> Where YearbookID='<fYearbookID>'~;
	
	if ( !PGenConList( List,Connection,fConnection,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return ReportError( ~Failed to read the yearbook definition from the database.  <theErr>~ );
	}

	fieldCount = List( ChildCount );

	List( GetFirst,ybdata );
	fGroupFields	= ~<$pcon.ybdata[GroupFields]>~;
	fGroupBy		= ~<$pcon.ybdata[GroupBy]>~ ;
	fImageSize		= ~<$pcon.ybdata[ImageSize]>~;
	fSortBy			= ~<$pcon.ybdata[SortBy]>~;

	fImageWidth		= ~<$pcon.ybdata[ImageWidth]>~;
	fImageLength	= ~<$pcon.ybdata[ImageLength]>~;
	fResolution		= ~<$pcon.ybdata[Resolution]>~;
	fCompressionQuality = ~<$pcon.ybdata[CompressionQuality]>~;

	if ( SimilarStr( ~<fImageSize>~, ~~ ) )
	{
		return TRUE;
	}
	
	if ( Numeric( ~<fImageSize>~ ) == 0 )
	{
		fImageSize = ~Small~;
	}
	else if ( Numeric( ~<fImageSize>~ ) == 1 )
	{
		fImageSize = ~Large~;
	}


	return TRUE;
}

NUMERIC YBGen::BuildReadMePart2()
{
	Query = ~Select * from <YBFieldsTableName> Where YearbookID='<fYearbookID>' Order By Sequence~;
	
	if ( !PGenConList( List,Connection,fConnection,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return ReportError( ~Failed to read the yearbook fields from the database.  <theErr>~ );
	}

	fieldCount = List( ChildCount ) - 8;

	fReadMeFile( WriteLine,~[# Fields]=<fieldCount>~ );

	Count = 1;
	while ( List( GetNext,ybField ) )
	{
		ContinueIf( SimilarStr( ~<$pcon.ybField[FieldName]>~,~NamingType~,~FileNameField~,~PoseSource~,~PoseField~,~PoseValue~,~SIPoseField~,~SIPoseValue~,~ExportWithBlanks~ ) );
		fReadMeFile( WriteLine,~[Field Definition #<count>]=<$pcon.ybField[FieldName]>~ );
		<++Count>;
	}

	return TRUE;
}


NUMERIC YBGen::BuildReadMePart3()
{
	Query = ~Select * from <LabInfoTableName>~;
	
	if ( !PGenConList( List,Connection,fConnection,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return ReportError( ~Failed to read the yearbook fields from the database.  <theErr>~ );
	}

	
	while ( List( GetNext,ybInfo ) )
	{
		fReadMeFile( WriteLine,~[Lab Name]=<$pcon.ybInfo[LabName]>~ );
		fReadMeFile( WriteLine,~[Lab Location]=<$pcon.ybInfo[Location]>~ );
		fReadMeFile( WriteLine,~[Lab Contact Name]=<$pcon.ybInfo[ContactName]>~ );
		fReadMeFile( WriteLine,~[Lab Contact Email]=<$pcon.ybInfo[Email]>~ );
		fReadMeFile( WriteLine,~[Lab Contact Phone]=<$pcon.ybInfo[Phone]>~ );
	}

	return TRUE;
}


NUMERIC YBGen::BuildReadMePart4( JobNumber, Comments )
{
	if ( !SimilarStr( ~<JobNumber>~, ~~ ) )
	{
		fReadMeFile( WriteLine,~[Photo Job Number]=<JobNumber>~ );
	}

	fReadMeFile( WriteLine,~[Date Created]=<$Date.Date>~ );
	if ( !SimilarStr( ~<Comments>~, ~~ ) )
	{
		fReadMeFile( WriteLine,~[Comments]=<Comments>~ );
	}
	
	if ( !SimilarStr( ~<fProfile>~, ~~ ) )
	{
		fReadMeFile( WriteLine,~[ICC]=<fProfile>~ );
	}

	return TRUE;
}

NUMERIC YBGen::ReportError( msg )
{
	if ( !IsMainThread() )
	{
		Invoke( ErrorMsg,~<msg>~ );
		ExportThreadFailure();
	}
	
	Log( Session,~Generate Yearbook Error: <msg>~ );
	return FALSE;
}

NUMERIC YBGen::ReportProgress( msg )
{
	if ( !IsMainThread() )
	{
		Invoke( ShowProgress,~<msg>~ );
	}
	
	return Log( Session,~Yearbook progress: <msg>~ );
}

NUMERIC YBGen::ReportStatus( msg )
{
	if ( !<FromScript> )
	{
		Invoke( StatusMsg,~<msg>~ );
	}
	Log( Session,~Yearbook status: <msg>~ );

	return TRUE;
}


NUMERIC YBGen::GenYBOutput( OrdersList )
{
	ReportStatus( ~Building Yearbook to Subject Info table mapping.~ );


	InfoType = ~~;
	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		return FALSE;
	}

	if ( !VerifyOrderInfo( ~<OrdersList>~, InfoType ) )
	{
		return FALSE;
	}
	
	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		return FALSE;
	}

	mapCount = VerifyYBMap( ~<InfoType>~ );
	if ( <mapCount> < 3 )
	{
		ReportError( ~There is no field mapping between <fYearbookID> and SubjectInfo<InfoType>~ );
		return FALSE;
	}
	
	ForgetPrivate( fSIFieldList );

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		return FALSE;
	}

	StringList( fSIFieldList, New );
	Private( fSIFieldList );
	if ( !BuildYBSIMap( ~<InfoType>~ ) )
	{
		ReportError( ~<Failed to generate subject info field list for index file.~ );
		return FALSE;
	}
	ForgetPrivate( fIndexFile );
	ForgetPrivate( fMasterFile );
	ForgetPrivate( fMasterFolders );
	ForgetPrivate( IndexPath );
	ForgetPrivate( MasterPath );

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		return FALSE;
	}

	IndexPath = ~<fReadMePath>\VOL1\Index.txt~;
	if ( !File( fIndexFile,Open,~<IndexPath>~,Create,Write ) )	
	{
		return ReportError( ~Failed to create <IndexPath>~ );
	}
	MasterPath = ~<fReadMePath>\VOL1\Master.txt~;
	if ( !File( fMasterFile,Open,~<MasterPath>~,Create,Write ) )	
	{
		fIndexPath( Close );
		return ReportError( ~Failed to create <MasterPath>~ );
	}
	Private( IndexPath );
	Private( fIndexFile );
	Private( MasterPath );
	Private( fMasterFile );

	ProcessImages( ~<OrdersList>~, ~<InfoType>~  );

	return TRUE;
}

NUMERIC YBGen::VerifyOrderInfo( OrdersList, &InfoType )
{
	query = ~Select Distinct InfoType from Orders WHERE ID in (<OrdersList>)~;
	if ( !PGenConList( List,Connection,fConnection,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		ReportError( ~Failed to read the Orders from the database.  <theErr>~ ); 
		return FALSE;
	}

	infoCount = List( ChildCount );

	if ( <infoCount> > 1 )
	{
		ReportError( ~There are multiple Subject Info Types associated with the orders in <OrdersList>. Select orders that use the same Info Type.~ );
		return FALSE;
	}

	// allow for default subject info (blank type)
	if ( <infoCount> > 0 )
	{
		List( GetFirst,infodata );
		InfoType = ~<$pcon.infodata[InfoType]>~;
	}
	
	return <infoCount>;
}

NUMERIC YBGen::VerifyYBMap( InfoType )
{
	query = ~Select Count(1) from YBSIFieldMap where YearbookID='<fYearbookID>' AND InfoType='<InfoType>'~;
	fConnection( GetValuesFor,~<query>~, count );

	return <count>;
}

NUMERIC YBGen::ProcessImages( OrdersList, InfoType  )
{
//	RImageJobID = UniqueRImageJobID();

	BatchID = UniquePrintBatchID();
	VolumeCount = 0;
	Volume = ~VOL1~;
	FileNameCriteria = ~~;

	ToPath				=	<fRImageEnabled> ? ~<fRImageCDPath>~ : ~~;
	DeleteAfterRImage	=	<fRImageEnabled> ? <fDeleteAfterRImage> : FALSE;

	Fields = ~Images.Path,Images.OrderID as ImgOrderID,SubjectInfo<InfoType>.*~;
	if ( <fPoseSource> == 0 )
	{
		PoseField = ~Images.<fPoseField>~;
		Fields = ~<fPoseField>,<Fields>~;
		NumericDataType = IsNumericType( ~Images~,~<fPoseField>~ );
	}
	else
	{
		PoseField = ~SubjectInfo<InfoType>.<fPoseField>~;
		NumericDataType = IsNumericType( ~SubjectInfo<InfoType>~,~<fPoseField>~ );
	}

	JoinFields = ~(images.SubjectID = SubjectInfo<InfoType>.SubjectID)~;
	PoseClause = ~~;
	JoinClause = ~~;
	OrderByClause = ~~;
	ShootDescClause = ~Select ShootDescID from Orders where ID in (<OrdersList>)~;
	SIOrderClause = ~(SubjectInfo<InfoType>.OrderID in (<OrdersList>) OR SubjectInfo<InfoType>.OrderID in (<ShootDescClause>))~;

	if ( <fAllPoses> )
	{
		JoinClause = ~LEFT OUTER JOIN SubjectInfo<InfoType> on <JoinFields>~;
		AuditJoinClause = ~INNER JOIN SubjectInfo<InfoType> on <JoinFields>~;
		if ( !<NumericDataType> )
		{
			if ( SimilarStr( ~<fPoseValue>~,~~ ) )
			{
				AuditPoseClause = ~AND <PoseField> IS NULL~;
			}
			else
			{
				AuditPoseClause = ~AND <PoseField> = '<fPoseValue>'~;
			}
		}
		else
		{
			AuditPoseClause = ~AND <PoseField> = <fPoseValue>~;
		}
	}
	else
	{
		JoinClause = ~INNER JOIN SubjectInfo<InfoType> on <JoinFields>~;
		if ( !<NumericDataType> )
		{
			if ( SimilarStr( ~<fPoseValue>~,~~ ) )
			{
				PoseClause = ~AND <PoseField> IS NULL~;
			}
			else
			{
				PoseClause = ~AND <PoseField> = '<fPoseValue>'~;
			}
		}
		else
		{
			PoseClause = ~AND <PoseField> = <fPoseValue>~;
		}
	}

	WhereClause = ~Images.OrderID in (<OrdersList>) AND <SIOrderClause> <PoseClause> <FileNameCriteria>~;

	GroupingFields = ~~;
	GroupByClause = BuildSortList( ~<InfoType>~, GroupingFields );

	if ( SimilarStr( ~<GroupByClause>~,~~ ) && !SimilarStr( ~<fGroupBy>~,~~ ) && !SimilarStr( ~<SortBy>~,~~ ) )
	{
		return FALSE;
	}

	DataQuery = ~Select <Fields> from Images <JoinClause> Where <WhereClause> <GroupByClause>~;
	
	// audit for the index file contents (verify images with pose fields as specified exist in the database)
	if ( <fAllPoses> )
	{
		AuditWhereClause = ~Images.OrderID in (<OrdersList>) AND <SIOrderClause> <AuditPoseClause>~;
		AuditQuery = ~Select count(*) from Images <AuditJoinClause> Where <AuditWhereClause>~;
		TotalRecords = fConnection(RecordCountFor, ~<AuditQuery>~);

		if ( <TotalRecords> < 1 )
		{
			if ( Defined( fIndexFile ) )
			{
				fIndexFile( Close );
			}
			if ( Defined( fMasterFile ) )
			{
				fMasterFile( Close );
			}
			Log( session,~<AuditQuery>~ );
			return ReportError( ~No data was returned for SubjectInfo<InfoType> for the Yearbook '<fYearbookID>' with the given criteria. Check the SessionLog for details.~ ); 
		}
	}

	if ( <fFileNameType> )
	{
		AuditWhereClause = ~Images.OrderID in (<OrdersList>) AND <SIOrderClause> AND (SubjectInfo<InfoType>.<fFileNameField> Is NULL OR SubjectInfo<InfoType>.<fFileNameField> = '' )~;
		AuditQuery = ~Select count(*) from Images <JoinClause> Where <AuditWhereClause>~;
		TotalRecords = fConnection(RecordCountFor, ~<AuditQuery>~);

		if ( <TotalRecords> > 0 && !<fExportOnBlank> )
		{
			if ( Defined( fIndexFile ) )
			{
				fIndexFile( Close );
			}
			if ( Defined( fMasterFile ) )
			{
				fMasterFile( Close );
			}
			Log( session,~<AuditQuery>~ );
			return ReportError( ~There were <TotalRecords> records in SubjectInfo<InfoType> in which the file name field '<fFileNameField>' is blank.~ ); 
		}

		AuditWhereClause = ~Images.OrderID in (<OrdersList>) AND <SIOrderClause> AND SubjectInfo<InfoType>.<fFileNameField> Is Not NULL~;
		AuditQuery = ~Select count(*) from Images <JoinClause> Where <AuditWhereClause> <PoseClause>~;
		TotalRecords = fConnection(RecordCountFor, ~<AuditQuery>~);

		AuditWhereClause = ~Images.OrderID in (<OrdersList>) AND <SIOrderClause> AND SubjectInfo<InfoType>.<fFileNameField> Is Not NULL~;
		AuditQuery = ~Select DISTINCT SubjectInfo<InfoType>.<fFileNameField> from Images <JoinClause> Where <AuditWhereClause> <PoseClause>~;
		UniqueRecords = fConnection(RecordCountFor, ~<AuditQuery>~);

		if ( <UniqueRecords> < <TotalRecords> )
		{
			if ( Defined( fIndexFile ) )
			{
				fIndexFile( Close );
			}
			if ( Defined( fMasterFile ) )
			{
				fMasterFile( Close );
			}
			Log( session,~<AuditQuery>~ );
			return ReportError( ~The selected file name field '<fFileNameField>' results in duplicate file names. Choose a field with unique entries or Numeric.~ ); 
		}

		FileNameCriteria = ~ AND SubjectInfo<InfoType>.<fFileNameField> IS NOT NULL~;
	}

	DataQuery = ~Select <Fields> from Images <JoinClause> Where <WhereClause>  <FileNameCriteria> <GroupByClause>~;

	if ( <fCancel> )
	{
		ReportError( ~Cancelled.~ );
		return FALSE;
	}

	if ( !PGenConList( List,Connection,fConnection,Cursor,Forward,QUERY,~<DataQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		ReportError( ~Failed to read the Subject Info data from the database.  <theErr>~ ); 
		return FALSE;
	}

	TotalRecords = List( ChildCount );

	if ( <TotalRecords> < 1 )
	{
		Log( session,~<DataQuery>~ );
		return ReportError( ~No data was returned for SubjectInfo<InfoType> for the Yearbook '<fYearbookID>' with the given criteria. Check the SessionLog for details.  <theErr>~ ); 
	}

	fileName0 = 0;	// naming type => numeric
	fileName1 = ~~;	// naming type => field name
	LastFolder = ~zzz999~;
	group = ~~;

	if ( <fCancel> )
	{
		return ReportError( ~Cancelled.~ );
	}

	FolderPath			= ~<fReadMePath>\<Volume>~;
	if ( !SimilarStr( ~<fGroupBy>~,~~ ) )
	{
		MasterFoldersPath = ~<fReadMePath>\<Volume>\Folders.txt~;
		if ( !File( fMasterFolders,Open,~<MasterFoldersPath>~,Create,Write ) )	
		{
			return ReportError( ~Failed to create <MasterFoldersPath>~ );
		}
		Private( MasterFoldersPath );
		Private( fMasterFolders );
	}

	groupCount = <fGroupsPerCD> + 1;	// forces the first CD to be created
	count = 0;
	ErrorCount = 0;
	while ( List( GetNext,info ) )
	{
		if ( <fCancel> )
		{
			break;
		}

		group = BuildGroupName( info, ~<GroupingFields>~ );
		if ( ~<group>~ != ~<LastFolder>~ )
		{
			if ( <groupCount++> > <fGroupsPerCD> )
			{
				<++VolumeCount>;
				Volume = ~VOL<VolumeCount>~;
				if ( !StartNewCD( ~<BatchID>~,~<fReadMePath>\<Volume>~,<DeleteAfterRImage>,~<$pcon.info[ImgOrderID]>~,~<Volume>~ ) )
				{
					<++ErrorCount>;
					ReportError( ~Could setup RImage job~ );
					break;
				}
				groupCount = 2;
			}
			if ( !SimilarStr( ~<group>~,~~ ) )
			{
				FolderPath = ~<fReadMePath>\<Volume>\<group>~;
				if ( !Files( DirectoryExists, ~<FolderPath>~ ) )
				{
					if ( !Directory( Create,~<FolderPath>~ ) )
					{
						<++ErrorCount>;
						ReportError( ~Could not create directory: <FolderPath>~ );
						break;

					}
				}

				fMasterFolders( WriteLine, ~<group>~ );
				FolderFilePath = ~<FolderPath>\<group>.txt~;

				if ( Defined( fFolderFile ) )
				{
					fFolderFile( Close );
				}
				ForgetPrivate( fFolderFile );

				if ( !File( fFolderFile,Open,~<FolderFilePath>~,Create,Write ) )	
				{
					<++ErrorCount>;
					ReportError( ~Failed to create <FolderFilePath>~ );
					break;
				}
				Private( fFolderFile );

				if ( !AddRImageFile( ~<BatchID>~,~\<group>\<group>.txt~, ~<FolderFilePath>~,<DeleteAfterRImage> ) )
				{
					fRImageJobID = ~~;
					ReportError( ~Failed to add <FolderFilePath> to the RImage file list~);
					break;
				}
			}

			LastFolder = ~<group>~;

		}

		if ( <fFileNameType> )
		{
			fileName1 = ~<$pcon.info[<fFileNameField>]>~;
			fileName1 = ~<$Str.<fileName1>.FileName.WithoutExt>~;
		}
		else
		{
			fileName0 = Format( ~<++fileName0>~, ~%05d~ );
		}
		
		fMasterFile( WriteString, ~<Volume>	<group>	<fileName<fFileNameType>>.jpg~ );

		if ( SimilarStr( ~<$pcon.info[<fPoseField>]>~,~<fPoseValue>~) )
		{
			fIndexFile( WriteString, ~<Volume>	<group>	<fileName<fFileNameType>>.jpg~ );
			if ( Defined( fFolderFile ) )
			{
				fFolderFile( WriteString, ~<Volume>	<group>	<fileName<fFileNameType>>.jpg~ );
			}
		}

		fSIFieldList( SetPosition, ~BeforeFirst~ );
		while ( fSIFieldList( GetNextString,field ) )
		{
			fMasterFile( WriteString, ~	<$pcon.info[<field>]>~ );
			if ( SimilarStr( ~<$pcon.info[<fPoseField>]>~,~<fPoseValue>~) )
			{
				fIndexFile( WriteString, ~	<$pcon.info[<field>]>~ );
				if ( Defined( fFolderFile ) )
				{
					fFolderFile( WriteString, ~	<$pcon.info[<field>]>~ );
				}
			}
		}

		fMasterFile( CRLF );
		fIndexFile( CRLF );
		if ( Defined( fFolderFile ) )
		{
			fFolderFile( CRLF );
		}

		Path = ~<$pcon.info[Path]>~;
		OrderID = ~<$pcon.info[OrderID]>~;
		LastEntry = <++count> == <TotalRecords>;
		outFile = ~<FolderPath>\<fileName<fFileNameType>>.jpg~;
	
		if ( <fCancel> )
		{
			break;
		}

		if ( !SimilarStr( ~<group>~,~~ ) )
		{
			ToPath = ~<fRImageCDPath>\<group>\<fileName<fFileNameType>>.jpg~;
		}
		else
		{
			ToPath = ~<fRImageCDPath>\<fileName<fFileNameType>>.jpg~;
		}

		QueueJobFor( ~<$pcon.info[Path]>~,~<outFile>~,<LastEntry>,~<fRImageJobID>~,~<ToPath>~,<DeleteAfterRImage>,~<$pcon.info[OrderID]>~,~<BatchID>~ );
	}

	if ( <fCancel> )
	{
		CleanupDatabase( ~<fRImageJobID>~,~<BatchID>~ );
		return ReportError( ~Cancelled.~ );
	}

	if ( <ErrorCount> > 0 )
	{
		CleanupDatabase( ~<fRImageJobID>~,~<BatchID>~ );
		return FALSE;
	}

	Cmd = ~Update JobQueue Set PrintStatus = 1 Where BatchID = '<BatchID>' AND PrintStatus = 8~;

	if ( !fConnection( Cmd,~<Cmd>~ ) )
	{
		fConnection( GetErrorDescription,theErr );
		CleanupDatabase( ~<fRImageJobID>~,~<BatchID>~ );
		return ReportError(~Cmd Failed.  <theErr>.  <Cmd>~ );
	}

	if ( Defined( fIndexFile ) )
	{
		fIndexFile( Close );
	}
	if ( Defined( fMasterFile ) )
	{
		fMasterFile( Close );
	}

	if ( Defined( fMasterFolders ) )
	{
		fMasterFolders( Close );
	}

	if (Defined( fFolderFile ) )
	{
		fFolderFile( Close );
	}

	while ( <VolumeCount> > 1 )
	{
		VolumePath = ~<fReadMePath>\VOL<VolumeCount>~;
		Files( Copy, ~<fReadMeFilePath>~, ~<VolumePath>\Readme.txt~ );
		Files( Copy, ~<IndexPath>~, ~<VolumePath>\Index.txt~ );
		Files( Copy, ~<MasterPath>~, ~<VolumePath>\Master.txt~ );
		if ( Defined( ~<MasterFoldersPath>~ ) )
		{
			Files( Copy, ~<MasterFoldersPath>~, ~<VolumePath>\Folders.txt~ );
		}
		<--VolumeCount>;
	}

	if ( !<FromScript> )
	{
		BatchComplete( ~<BatchID>~,~<count>~,~<fRImageJobID>~ );
		ExportComplete( <count> );
	}

	return TRUE;
}

STR YBGen::BuildGroupName( &info, GroupingFields )
{
	folder = ~~;

	count = 0;
	numTokens = GetTokens(~<GroupingFields>~,~,~);

	if ( <numTokens> < 1 )
	{
		return ~<folder>~;
	}

	// Build folder name String
	i = 0;
	while ( <i++> < <numTokens>)
	{
		field = SimilarStr( ~<$pcon.info[<Token<i>>]>~,~~ ) ? ~NO<Token<i>>~ : ~<$pcon.info[<Token<i>>]>~ ;

		if ( SimilarStr( ~<folder>~,~~ ) )
		{
			folder = ~<field>~;
		}
		else
		{
			folder = ~<folder>_<field>~;
		}
	}

	return ~<folder>~;
}

STR YBGen::BuildSortList( InfoType, &GroupingFields )
{
	clause = ~~;

	count = 0;
	numTokens = GetTokens(~<fGroupBy>~,~,~);

	// Build sorting string from GroupBy,SortBy
	i = 0;
	while ( <i++> < <numTokens>)
	{
		lookupField = String( TrimLeftRight,~<Token<i>>~ );

		field = MapYBtoSI( ~<InfoType>~, ~<lookupField>~ );
		if ( !SimilarStr( ~<field>~,~~ ) )
		{
			if ( !SimilarStr( ~<clause>~,~~ ) )
			{
				clause = ~<clause>,SubjectInfo<InfoType>.<field>~;
				GroupingFields = ~<GroupingFields>,<field>~;
			}
			else
			{
				clause = ~Order By SubjectInfo<InfoType>.<field>~;
				GroupingFields = ~<field>~;
			}
		}
		else
		{
			ReportError(~There is no subject info field mapped to the Group By field <lookupField>. The Yearbook output will not be created correctly.~ );
			return ~~;
		}
	}

	count = 0;
	numTokens = GetTokens(~<fSortBy>~,~,~);

	// Build Header String and determine tab positions
	i = 0;
	FirstNameIncluded = FALSE;
	while ( <i++> < <numTokens> )
	{
		lookupField = String( TrimLeftRight,~<Token<i>>~ );
		ContinueIf( SimilarStr( ~<lookupField>~,~First Name~ ) && <FirstNameIncluded> );

		field = MapYBtoSI( ~<InfoType>~, ~<lookupField>~ );
		if ( !SimilarStr( ~<field>~,~~ ) )
		{
			if ( !SimilarStr( ~<clause>~,~~ ) )
			{
				clause = ~<clause>,SubjectInfo<InfoType>.<field>~;
			}
			else
			{
				clause = ~Order By SubjectInfo<InfoType>.<field>~;
			}

			// if we're sorting by last name, add a first name sort so the kids
			//  show up alphabetically
			if ( SimilarStr( ~<lookupField>~,~Last Name~ ) && !<FirstNameIncluded> )
			{
				field = MapYBtoSI( ~<InfoType>~, ~First Name~ );
				if ( !SimilarStr( ~<field>~,~~ ) )
				{
					clause = ~<clause>,SubjectInfo<InfoType>.<field>~;
					FirstNameIncluded = TRUE;
				}
			}
		}
		else
		{
			ReportError(~There is no subject info field mapped to the Sort By field <lookupField>.  The Yearbook output will not be created correctly.~ );
			return ~~;
		}
	}

	if ( <numTokens> == 0 )
	{
		field = MapYBtoSI( ~<InfoType>~, ~Grade~ );
		if ( !SimilarStr( ~<field>~,~~ ) )
		{
			if ( !SimilarStr( ~<clause>~,~~ ) )
			{
				clause = ~<clause>,SubjectInfo<InfoType>.<field>~;
			}
			else
			{
				clause = ~Order By SubjectInfo<InfoType>.<field>~;
			}
		}

		field = MapYBtoSI( ~<InfoType>~, ~Last Name~ );
		if ( !SimilarStr( ~<field>~,~~ ) )
		{
			if ( !SimilarStr( ~<clause>~,~~ ) )
			{
				clause = ~<clause>,SubjectInfo<InfoType>.<field>~;
			}
			else
			{
				clause = ~Order By SubjectInfo<InfoType>.<field>~;
			}
		}
	}

	return ~<clause>~;
}


NUMERIC YBGen::IsNumericType( TableName,field )
{
	ReturnOnFailure( GenCon( TableDefinitions,GetFrom,~TableDefinitions~,~[Database]~ ) );

	if ( !TableDefinitions( GetByName,~<TableName>~,TableDef ) )
	{
		return FALSE;
	}
	
	if ( !GenCon( Fields,Is,TableDef(GetNumeric,Fields)) )
	{
		return FALSE;
	}
	
	if ( !Fields( GetByName,~<field>~,ColumnDef ) )
	{
		return FALSE;
	}

	ColumnDef( GetValue,~Definition~,Definition );

	Substr( ~<Definition>~,0,4,type );
	if ( SimilarStr( ~<type>~,~TEXT~,~CHAR~ ) )
	{
		return FALSE;
	}


	return TRUE;
}

NUMERIC YBGen::StartNewCD( BatchID, VolumePath, DeleteAfter, OrderID, Volume)
{
	GetRImageJobID();
	if ( !ExportToRImage( ~<BatchID>~,~<OrderID>~,~<Volume>~ ) )
	{
		return FALSE;
	}

	if ( <fRimageEnabled> )
	{
		if ( !AddRImageFile( ~<BatchID>~,~\Readme.txt~, ~<VolumePath>\ReadMe.txt~,<DeleteAfter> ) )
		{
			fRImageJobID = ~~;
			ReportError( ~Failed to add <VolumePath>\ReadMe.txt to the RImage file list~ );
			return FALSE;
		}
		if ( !AddRImageFile( ~<BatchID>~,~\Index.txt~, ~<VolumePath>\Index.txt~,<DeleteAfter> ) )
		{
			fRImageJobID = ~~;
			ReportError( ~Failed to add <VolumePath>\Index.txt to the RImage file list~ );
			return FALSE;
		}

		if ( !SimilarStr( ~<fGroupBy>~,~~ ) )
		{
			if ( !AddRImageFile( ~<BatchID>~,~\Folders.txt~, ~<VolumePath>\Folders.txt~,<DeleteAfter> ) )
			{
				fRImageJobID = ~~;
				ReportError( ~Failed to add <VolumePath>\Folders.txt to the RImage file list~ );
				return FALSE;
			}
		}
		if ( !AddRImageFile( ~<BatchID>~,~\Master.txt~, ~<VolumePath>\Master.txt~,<DeleteAfter> ) )
		{
			fRImageJobID = ~~;
			ReportError( ~Failed to add <VolumePath>\Master.txt to the RImage file list~ );
			return FALSE;
		}

	}
	return TRUE;
}


NUMERIC YBGen::ExportToRImage( BatchID, OrderID, Volume )
{
	ReturnOnSuccess( !<fRImageEnabled> );
	ReturnOnSuccess( IsNull( ~<fRImageTemplate>~ ) );
	
	Query = ~Select * from RImageTemplates Where ID = '<fRImageTemplate>'~;

	if ( !PGenConList( TemplatesList,Connection,fConnection,GetRecordFor,~<Query>~,TemplateRecord ) )
	{
		TemplatesList( GetErrorDescription,0,theErr );
		return ReportError( ~Failed to get the Template record for '<fRImageTemplate>'.  <theErr>~ );
	}

	Query = ~Select * from RImageEditListTemplates Where ID = '<fRImageTemplate>'~;

	if ( !PGenConList( StaticFiles,Connection,fConnection,Cursor,Static,Query,~<Query>~ ) )
	{
		StaticFiles( GetErrorDescription,0,theErr );
		return ReportError( ~Failed to get the Edit List template for <fRImageTemplate>  <theErr>~ );
	}

	BasePath = ~~;

	if ( !AddRImageJob( TemplateRecord,~<OrderID>~,~<Volume>~ ) )
	{ 
		CleanupDatabase( ~<fRImageJobID>~,~<BatchID>~ );
		return FALSE;
	}

	if ( !AddRImageOtherFiles( ~<BatchID>~,StaticFiles ) )
	{ 
		CleanupDatabase( ~<fRImageJobID>~,~<BatchID>~ );
		return FALSE;
	}
	
	return TRUE;
}


NUMERIC YBGen::AddRImageJob( &TemplateRecord, OrderID, Volume )			// SETUP THE MAIN RIMAGE JOB IN THE RIMAGEORDERS TABLE
{
	Query = ~Select * From RImageOrders Where ID = '<fRImageJobID>'~;

	if ( !PGenConList( List,Connection,fConnection,GetRecordFor,~<Query>~,NewRecord ) )
	{
		List( GetErrorDescription,0,theErr );
		return ReportError( ~Failed to add a record to the RImageOrders table for ID <fRImageJobID>.  <theErr>~ );
	}

	if ( !NewRecord( UpdateFrom,TemplateRecord ) )
	{
		return ReportError( ~Failed to update the RImageOrders record for ID <fRImageJobID>.  <theErr>~ );
	}

	NewRecord( Set,ID,~<fRImageJobID>~ );
	NewRecord( Set,Writer,~<$pcon.TemplateRecord[Writer]>~ );
	Now = Time();
	NewRecord( Set,SubmitDate,~<Now>~ );
	NewRecord( Set,Progress,~0~ );
	NewRecord( Set,OrderID,~<OrderID>~ );	
	NewRecord( Set,Volume,~<Volume>~ );

	if ( !List( Update ) )
	{
		List( GetErrorDescription,0,theErr );
		return ReportError( ~Failed to update RImageOrders table for ID <fRImageJobID>.  <theErr>~ );
	}

	Query = ~SELECT * FROM RImageMergeTemplates WHERE ID = '<$pcon.TemplateRecord[ID]>' Order By FieldNumber~;

	if ( !PGenConList( MergeList,Connection,fConnection,cursor,Forward,Query,~<Query>~ ) )
	{
		MergeList( GetErrorDescription,0,theErr );
		return ReportError( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
	}
	
	// Setup some variables so that the RImageMacros will expand correctly
	
	while ( MergeList( GetNext,Item ) )
	{
		Data = ~<$pcon.Item[FieldData]>~;	// THE RIMAGE MACROS WILL RESOLVE HERE.

		if ( !IsNull( ~<Data>~ ) )			// GET CHUNK ONLY WORKS ONCE ON LONGTEXT FIELDS
		{
			fConnection( Cmd,~Insert Into RImageMerge(ID,FieldNumber,FieldData) values('<fRImageJobID>',<$pcon.Item[FieldNumber]>,'<Data>')~ );
		}
	}
	
	return TRUE;
}

NUMERIC YBGen::AddFileToRImageList( BatchID,ToPath,FromPath,DeleteAfter )
{
	if ( <fRImageEnabled> )
	{
		Values = ~'<fRImageJobID>','<ToPath>','<FromPath>',<DeleteAfter>~;
		Cmd = ~Insert Into RImageEditList(ID,ToPath,FromPath,DeleteAfter) Values(<Values>)~;

		if ( !fConnection( Cmd, ~<Cmd>~ ) )
		{
			fConnection( GetErrorDescription,theErr );
			CleanupDatabase( ~<fRImageJobID>~,~<BatchID>~ );
			return ReportError(~Cmd Failed.  <theErr>.  <Cmd>~ );
		}
	}

	return TRUE;
}


NUMERIC YBGen::AddRImageOtherFiles( BatchID,&StaticEditList )		// ADD THE STATIC FILES FROM THE EDIT LIST TEMPLATE
{
	if ( <fRImageEnabled> )
	{
		while ( StaticEditList( GetNext,Item ) )
		{
			if ( !AddRImageFile( ~<BatchID>~,~<$pcon.Item[ToPath]>~,~<$pcon.Item[FromPath]>~, FALSE ) )
			{
				return FALSE;
			}
		}
	}

	return TRUE;
}


NUMERIC YBGen::AddRImageFile(  BatchID,ToPath,FromPath,DeleteAfter )	// ADD A FILE TO BE EXPORTED
{
	if ( <fRImageEnabled> )
	{
		ToPath = IsNULL(~<ToPath>~) ? ~\~ : ~<ToPath>~;

		Cmd = ~Insert Into RImageEditList(ID,ToPath,FromPath,DeleteAfter) Values('<fRImageJobID>','<ToPath>','<FromPath>',<DeleteAfter>)~;

		if ( !fConnection( Cmd,~<Cmd>~ ) )
		{
			fConnection( GetErrorDescription,theErr );
			CleanupDatabase( ~<fRImageJobID>~,~<BatchID>~ );
			return ReportError( ~Failed to add to the edit list for RImage Job <fRImageJobID>. <Cmd>. <theErr>~ );
		}
	}

	return TRUE;
}


NUMERIC YBGen::CleanupDatabase( RImageJobID,BatchID )				// GET RID OF THE EDIT LIST AND JOB
{
	if ( Defined( fFolderFile ) )
	{
		fFolderFile( Close );
	}
	if ( Defined( fIndexFile ) )
	{
		fIndexFile( Close );
	}
	if ( Defined( fMasterFile ) )
	{
		fMasterFile( Close );
	}
	if ( Defined( fMasterFolders ) )
	{
		fMasterFolders( Close );
	}

	ForgetPrivate( fFolderFile );
	ForgetPrivate( fIndexFile );
	ForgetPrivate( fMasterFile );
	ForgetPrivate( fMasterFolders );

	if ( !IsNULL( ~<RImageJobID>~ ) && !SimilarStr( ~<RImageJobID>~,~~ ) )	// CLEAN THE RIMAGE STUFF
	{
		fConnection( Cmd,~Delete From RImageEditLists Where ID = '<RImageJobID>'~ );
		fConnection( Cmd,~Delete From RImageOrders Where ID = '<RImageJobID>'~ );
	}

	if ( !IsNULL( ~<BatchID>~ ) )		//  CLEAN THE JOBQUEUE
	{
		fConnection( Cmd,~Delete From JobQueue Where BatchID = '<BatchID>'~ );
	}

	return TRUE;
}

STR YBGen::MapYBtoSI( InfoType, YbField )
{
	SIField = ~~;

	query = ~Select SIFieldName from YBSIFieldMap Where YearbookID='<fYearbookID>' AND InfoType='<InfoType>' AND FieldName='<YbField>'~;

	fConnection( GetValuesFor,~<query>~,SIField );
	return ~<SIField>~;
}


NUMERIC YBGen::BuildYBSIMap( InfoType )
{
	Query = ~Select FieldName,Sequence from YearbookFields Where YearbookID='<fYearbookID>' Order By Sequence~;

	if ( !PGenConList( List,Connection,fConnection,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		ReportError( ~Failed to read the Yearbook / Subject Info field map from the database.  <theErr>~ ); 
		return FALSE;
	}

	Count = List( ChildCount );

	while ( List( GetNext,field ) )
	{
		YbField = ~<$pcon.field[FieldName]>~;
		SIFieldName = MapYBtoSI( ~<InfoType>~, ~<YbField>~ );
		
		if ( Numeric( ~<$pcon.field[Sequence]>~ ) < 4 )
		{
			ContinueIf( SimilarStr( ~<$pcon.field[FieldName]>~,~Volume Name~,~Image Folder~,~Image File Name~ ) );
			if ( SimilarStr( ~<YbField>~,~FileNameField~ ) )
			{
				fFileNameField = ~<SIFieldName>~;
				Private( fFileNameField );
			}
			else if ( SimilarStr( ~<YbField>~,~NamingType~ ) )
			{
				fFileNameType = Numeric( ~<SIFieldName>~ );
			}
			else if ( SimilarStr( ~<YbField>~,~PoseSource~ ) )
			{
				fPoseSource = Numeric( ~<SIFieldName>~ );
			}
			else if ( SimilarStr( ~<YbField>~,~PoseField~ ) )
			{
				fPoseField = ~<SIFieldName>~;
			}
			else if ( SimilarStr( ~<YbField>~,~PoseValue~ ) )
			{
				fPoseValue = ~<SIFieldName>~;
			}
			else if ( SimilarStr( ~<YbField>~,~SIPoseField~ ) )
			{
				SIPoseField = ~<SIFieldName>~;
			}
			else if ( SimilarStr( ~<YbField>~,~SIPoseValue~ ) )
			{
				SIPoseValue = ~<SIFieldName>~;
			}
			else if ( SimilarStr( ~<YbField>~,~ExportWithBlanks~ ) )
			{
				fExportOnBlank = Numeric( ~<SIFieldName>~ );
			}
			continue;
		}
		fSIFieldList( AddString, ~<SIFieldName>~ );
	}

	if ( <fPoseSource> == 1 )
	{
		fPoseField = ~<SIPoseField>~;
		fPoseValue = ~<SIPoseValue>~; 
	}

	return TRUE;
}

NUMERIC YBGen::QueueJobFor( Image,OutFilePath,LastEntry,RImageJobID,ToPath,DeleteAfterRImage,AppOrderID,BatchID )
{
	if ( IsNull( ~<Image>~ ) )
	{
		ReportError(~No image to export~ );
		return FALSE;
	}

	JobID = 0;

	JobPath = CreateJobPath(JobID);

	if ( IsNull( ~<JobPath>~ ) )
	{
		ReportError( ~Couldn't create a unique job path~ );
		return FALSE;
	}


	if ( !CreateAJob( ~<JobPath>~,~<Image>~,~<OutFilePath>~,~<LastEntry>~,~<RImageJobID>~,~<ToPath>~,<DeleteAfterRImage>,~<AppOrderID>~ ) )
	{
		return FALSE;
	}

	if ( !AddJobToDatabase( ~<JobPath>~,~<JobID>~,~<BatchID>~ ) )
	{
		return FALSE;
	}

	ReportProgress( ~Queued Job <JobID> for <Image>~ );

	return TRUE;
}


NUMERIC YBGen::CreateAJob( JobPath,ImagePath,OutFilePath,LastEntry,RImageJobID,ToPath,DeleteAfterRImage,AppOrderID )
{
	ImageWidth  = <fImageWidth> / <fResolution>;
	ImageHeight = <fImageLength> / <fResolution>;

	ImageCropX	= 50;
	ImageCropY	= 50;
	ImageCropWidth = 100;
	ImageCropHeight = 100;

	if ( <fCropAdjustment> != 100)	
	{
		cropX = 50;
		cropY = 50;
		cropW = 100;
		cropL = 100;
		Rotation = 0;
		if ( ImageCorrections( GetCrop,~<ImagePath>~,cropX,cropY,cropW,cropH,Rotation ) )
		{

			ImageCropX = <cropX>;
			ImageCropY = <cropY>;
			ImageCropWidth = <cropW>  * 100 / <fCropAdjustment>;
			ImageCropHeight = <cropH> * 100 / <fCropAdjustment>;
			if ( <ImageCropWidth> == 0 )	{ ImageCropHeight = ImageCropWidth = 100;}
			if ( <ImageCropHeight> == 0 ){ ImageCropHeight = ImageCropWidth = 100;}
			if ( <ImageCropX> == 0 )	{ ImageCropX = ImageCropY = 50;}
			if ( <ImageCropY> == 0 )	{ ImageCropX = ImageCropY = 50;}

			cropAspectRatio = <cropW> / <cropH>;
			if ( <ImageCropWidth> > 100 )
			{
				if ( <cropAspectRatio> < 1.0 )
				{
					ImageCropWidth = <ImageCropHeight> * <cropAspectRatio>;
				}
				else
				{
					ImageCropX = 50;
					ImageCropWidth = 100.;
					ImageCropHeight =  <ImageCropWidth> / <cropAspectRatio>;
				}
			}

			if ( <ImageCropHeight> > 100 )
			{
				if ( <cropAspectRatio> < 1.0 )
				{
					ImageCropHeight = 100;
					ImageCropWidth = <ImageCropHeight> * <cropAspectRatio>;
				}
				else
				{
					ImageCropHeight =  <ImageCropWidth> / <cropAspectRatio>;
				}
			}

			origTopPos = <cropY> - 0.5 * <cropH>;
			modTopPos  = <cropY> - 0.5 * <ImageCropHeight>;
			
			ImageCropY = <cropY> - ( <modTopPos> - <origTopPos> );
			if ( <ImageCropY> + <ImageCropHeight> * .5 > 100.0 )
			{
				ImageCropY = 100.0 - <ImageCropHeight> * .5;
			}
			else if ( <ImageCropY> - <ImageCropHeight> * .5 < 0.0 )
			{
				ImageCropY = <ImageCropHeight> * .5;
			}
		}
	}

	if ( !File( Job,Open,~<JobPath>~,Create,Write ) )	// CREATE AND OPEN THE JOB
	{
		ReportError( ~Could not create the job file <JobPath>~  );
		return FALSE;
	}

	if ( !File( Job, UnicodeOutput ) )	// Unicode for Japanese text is necessary
	{
		return FALSE;
	}
	
	if ( <fChromaKeyBGIDOption> == 3 || <fChromaKeyBGIDOption> == 4 )	// CustomerBackground or SubjectInfo
	{
		ProductType = IsNull(~<fProductType>~) ? ~YearBook~ : ~<fProductType>~;
	}	
	else
	{
		ProductType = ~YearBook~;
	}

	Job( ~FileType: Job ;~ );

	Job( CRLF,WRITELINE,~Macros:   |Macros.txt|~ );

	Job( CRLF,WRITELINE,~UnitOfMeasure: Inches;~ );
	
	Job( CRLF,WRITELINE,~ProductInfo:~ );
    Job( CRLF,WRITELINE,~	ProductType: |<ProductType>|~ );

	Job( CRLF,WRITELINE,~SaveMetaData: 1;~ );  // Not needed until V9.1. Does not work yet in V9.0

	Job( CRLF,WRITELINE,~BeginInclude();~ );

	Job( CRLF,WRITELINE,~DesiredFileType = |JPEG|;~ );

	Job( CRLF,WRITELINE,~RImageJobID = |<RImageJobID>|;~ );
	Job( CRLF,WRITELINE,~OrderID = |<AppOrderID>|;~ );

	++CDPathSequence;

	Job( CRLF,WRITELINE,~CDPathSequence = |<CDPathSequence>|;~ );

	MACROSOFF

	Job( CRLF,WRITELINE,~STR IncrementingCDPathSequence( NumDigits )	{ return Format( |<CDPathSequence>|,|%0<NumDigits>ld| ); }~ );

	MACROSON

	Job( CRLF,WRITELINE,~NUMERIC AddImageToRImageEditList()~ );	
	Job( ~{~ );
	Job( ~	GenCon( PrintComplete,IsPrintPage,PrintComplete );~ );
	Job( ~	PrintComplete( Get,IMAGEPATH,FromPath );~ );
	Job( ~	Log( Session, |FromPath: <FromPath>; ToPath: <ToPath>| );~ );
	Job( ~	if ( !ADO( dBase,Connect,Cmd,|Insert Into RImageEditList(ID,ToPath,FromPath,DeleteAfter) Values('<RImageJobID>','<ToPath>','<FromPath>',<DeleteAfterRImage>)| ) )~ );
	Job( ~	{~ );
	Job( ~		Log( Session, |Could not add <FromPath> to the EditList for RImageJob for ID = <RImageJobID>| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	Job( CRLF,WRITELINE,~NUMERIC ReleaseRImageJob()~ );	
	Job( ~{~ );
	Job( ~	if ( !ADO( dBase,Connect,Cmd,|Update RImageOrders Set Progress = 1 Where ID = '<RImageJobID>'| ) )~ );
	Job( ~	{~ );
	Job( ~		Log( Session, |Could not release the RImageJob for ID = <RImageJobID>| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	if ( <LastEntry> )
	{
		UserProcessAfterFile = ~~;

		if ( !IsNULL( ~<fProcessAfterFile>~ ) )
		{
			Job( CRLF,WRITELINE,~OptionalInclude( |<UserProcessAfterFile>| );~ );
		}

	}

	Job( CRLF,WRITELINE,~EndInclude();~ );
	
	Job( CRLF,WRITELINE,~Main:~ );
	Job( ~	IWidth: <ImageWidth>;~ );
	Job( ~	IHeight: <ImageHeight>;~ );
	Job( ~	IColor: 0 255 255 255;~ );

	Job( CRLF,WRITELINE,~IL: 1~ );
	Job( ~	IFile: |<ImagePath>|;~ );
	Job( ~	ILocation: 0 0 <ImageWidth> <ImageHeight>;~ );

	if ( <fCropAdjustment> != 100 )
	{
		Job( ~	OverrideImageCrop: 1~ );
		Job( ~	ImagecropX: <ImageCropX>~ );
		Job( ~	ImagecropY: <ImageCropY>~ );
		Job( ~	ImagecropWidth: <ImageCropWidth>~ );
		Job( ~	ImagecropHeight: <ImageCropHeight>~ );
	}

	Job( ~	AutoCrop: |<fAutoCropSrcX>| |<fAutoCropSrcY>| |<fAutoCropDstX>| |<fAutoCropDstY>| |<fAutoCropWidth>| |<fAutoCropLength>|~ );

	if ( <fChromaKeyBGIDOption> == 0 )				// Export with using the Rules for Yearbook
	{
		// Nothing special to do.  The ProductType will be set to YearBook and the Rules will kick in
	}
	if ( <fChromaKeyBGIDOption> == 1 )				// Export with transparency
	{
		Job( ~	NoMergeBackground:	1;~ );			// Will show on a solid color background
		Job( ~	IColor:	0,<fRed>,<fGreen>,<fBlue>;~ );	
	}
	else if ( <fChromaKeyBGIDOption> == 2 )			// Export using a dp2 background id to find the background
	{
		Job( ~	ChromaKeyBGID:	|<fDP2BGId>|;~ );
	}
	else if ( <fChromaKeyBGIDOption> == 3 )			// Export using a customer background id to find the background
	{	
		Job( ~	ChromaKeyBGID:	|<fDP2BGId>|;~ );	// The DP2 BGID was previously looked up from the Customer BGID
	}
	else if ( <fChromaKeyBGIDOption> == 4 )			// Export using a the subjectinfo to find the background
	{					
		Job( ~	ChromaKeyBGID:	|<$@func.BackgroundIDForImage(`<ImagePath>`,`<fProductType>`)>|~ );
	}
	else if ( <fChromaKeyBGIDOption> == 5 )			// Export the image original green screen image with no masking
	{		
		Job( ~	NoMergeBackground:	1;~ );			
		Job( ~	UseUnkeyedImage:	1;~ );
	}
	
	Job( CRLF,WRITELINE,~Saveimage:~ );
	Job( ~	QueueName:		|<fQueueName>|;~ );
	Job( ~	Copies:			1;~ );
	Job( ~	Enabled:		1;~ );
	Job( ~	Savefiletype:	|JPEG|;~ );
	Job( ~	CompressionQuality:		|<fCompressionQuality>|;~ );

	Job( ~	xRes:			<fResolution>;~ );

	if ( !SimilarStr( ~<fProfile>~, ~~ ) )
	{
		Job( ~	ImageOutputProfile:	|<fProfile>|;~ );
	}

	if ( <fEmbedProfile> )
	{
		Job( ~	EmbedProfileInOutputImage:	1;~ );
	}
	else
	{
		Job( ~	EmbedProfileInOutputImage:	0;~ );
	}

	ProcessAfterString = ~~;

	Job( ~	Savename:	|<OutFilePath>|;~ );
	
	if ( !IsNull(~<RImageJobID>~) )
	{
		ProcessAfterString = STR ( AddImageToRImageEditList(); );
	}

	if ( <LastEntry> )
	{
		if ( !IsNULL( ~<RImageJobID>~ ) )
		{
			ProcessAfterString = STR ( <ProcessAfterString> ReleaseRImageJob(); );
		}

		UserProcessAfter = STR ( <fProcessAfter> );

		if ( !IsContentsNULL( UserProcessAfter ) )
		{
			ProcessAfterString = STR ( <ProcessAfterString> ; <UserProcessAfter>; );
		}
	}


	Job( ~	ProcessAfter: |<ProcessAfterString>|~ );

	Job( Close );

	return TRUE;
}



NUMERIC YBGen::AddJobToDatabase( JobPath,JobID,BatchID,OrderID )
{
	while ( TRUE )
	{
		Now = Time();

		Fields = ~JobPath,QueueName,SubmitDate,BatchID,OrderID,OrderSequence,OrderItemID,OrderItemQty,OrderItemSequence,JobID,PrintStatus,Priority,Owner~;

		Values = ~'<JobPath>','<fQueueName>',<Now>,'<BatchID>','<OrderID>',1,
					<fOrderItemID>,1,<fOrderItemID++>,'<JobID>',8,50,'<$App.UserName>'~;

		Cmd = ~Insert Into JobQueue(<Fields>) Values(<Values>)~;

		if ( fConnection( Cmd,~<cmd>~ ) )
			break;

		fConnection( GetErrorNumber,err,GetErrorDescription,theErr );

		if ( !fConnection( ErrorIs,<err>,~Duplicate~) )
		{	
			ReportError( ~Failed to add job to the JobQueue.  <Cmd>.  <theErr>~ );
			return FALSE;
		}
	}

	return TRUE;
}

STR  YBGen::CreateJobPath(&JobID)
{
	JobPath = ~<$App.ShareDirectory>\SchoolYBJobs~;
	Directory( Create,~<JobPath>~ );

	JobPath = ~<JobPath>\<fSchoolName>~;
	Directory( Create,~<JobPath>~ );

	while ( TRUE )
	{

		JobID = UniqueJobID();

		JobName = ~Job_<JobID>~;

		if ( !Files( FileExists,~<JobPath>\<JobName>~ ) )
			break;
	}

	return ~<JobPath>\<JobName>~;
}

OptionalInclude( ~<$App.ShareDirectory>\Scripts\ScriptOverrides\YbOutputUtils.txt~ );

