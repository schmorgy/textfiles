// GroupHndl.txt
//		Globals:	WhichInfoDesc	- Which InfoDesc displaying info for
//					WhichSubjectsOrderID - OrderID to search the SubjectInfo table with
//					WhichInfoType	- InfoType for the SubjectInfo table for WhichOrderID
//					WhichOrderID	- the selected order ID the Groups were generated by
//					WhichSortName	- the selected Sort Name the Groups were generated by
//					GrpCmdList		- List of command to add to querys for the qroups

// Most of these functions are called from a Thread. 
// It is assumed the thread has a function ShowWarning(msg) to display Warning msgs.
// and that nonThreads do not have these function.

Tab = Chr(9);
MaxQueryLength = 1400;

Define:	GroupsMessages Using DDSymbol
	Fields:	Value	~These strings are Groups related strings used by the user interface.~
	Contains:
	{
		Define: Title				using DDText	Fields: Text ~Group Handling Data~
		Define: NoGrpsTitle			using DDText	Fields: Text ~~
		Define: NoHeaders			using DDText	Fields:	Text ~~
		Define: None				using DDText	Fields: Text ~None~
		Define: OrderTxt			using DDText	Fields: Text ~Order ID~
		Define: SortTxt				using DDText	Fields:	Text ~Group by~
		Define: SortTypeText		using DDText	Fields: Text ~Type~
		Define: GroupsTxt			using DDText	Fields: Text ~Groups~
		Define: GenerateTxt			using DDText	Fields: Text ~Generate~
		Define: SubjectInfoTxt		using DDText	Fields: Text ~View Subject~
		Define: ImagesTxt			using DDText	Fields: Text ~View Images~
		Define: CloseTxt			using DDText	Fields: Text ~Close~
		Define: GenerateToolTip		using DDText	Fields:	Text ~Generate a new list of groups~
		Define: SubjectInfoToolTip	using DDText	Fields:	Text ~View SubjectInfo for the selected group~
		Define: ImagesToolTip		using DDText	Fields:	Text ~View images for the selected group~
		Define: CloseToolTip		using DDText	Fields:	Text ~Close the dialog~
		Define: NoOrders			using DDText	Fields: Text ~No Orders defined~
		Define: NoSorts				using DDText	Fields: Text ~No Sorts defined~
		Define: NoGrpSelected		using DDText	Fields: Text ~No Group Selected~
		Define: NumGroups			using DDText	Fields: Text ~%1 Groups~
		Define: NumRecords			using DDText	Fields: Text ~#~
		Define: AllRecordsChoice	using DDText	Fields: Text ~All Records~
		Define: ImagesOnlyChoice	using DDText	Fields: Text ~Images Only~
		Define: NoImagesChoice		using DDText	Fields: Text ~No Images~
		Define: DuplicatesChoice	using DDText	Fields: Text ~Duplicate Images~
		Define: DialogAlreadyOpen	using DDText	Fields: Text ~Dialog Already Open.~
		Define: TooManyImagesForQuery using DDText	Fields: Text ~There are too many images in the group to be displayed.\nDo you want to display all images for the order instead of the group?~
		Define: InfoTypeDifferent	using DDText	Fields: Text ~SubjectInfo table for Order is different than one which generated the groups.\nGroup's InfoType is: %1    Order's InfoType is: %2    (Recall blank is default table)\n\nYou must Generate the groups first for the new Order.~
	}

// Hang:	GroupsMessages	~[STRINGS]~ ;  No need to hang these



Include: ~FormattingRoutines~;
Include: ~Utilities2~;


VOID DefineGroupsDialog()
{

	if ( !DictionaryExists(GroupsDialog) )
	{
		Dictionary: GroupsDialog
			Fields: Name	theOrder	Type Text;
			Fields: Name	theSort		Type Text;
			Fields: Name	theGroup	Type Text;
			Fields: Name	theSortType	Type Text;

		StringList: Name		OrderChoices
			Fields:	String	Translate(GroupsMessages,None)
		Hang:	OrderChoices	~[STRINGS]~

		StringList: Name		SortChoices
			Fields:	String	Translate(GroupsMessages,None)
		Hang:	SortChoices		~[STRINGS]~

		StringList: Name		SortTypeChoices
			Fields:	String	Translate(GroupsMessages,AllRecordsChoice)
//			Fields:	String	Translate(GroupsMessages,ImagesOnlyChoice)
			Fields:	String	Translate(GroupsMessages,NoImagesChoice)
//			Fields:	String	Translate(GroupsMessages,DuplicatesChoice)
		Hang:	SortTypeChoices		~[STRINGS]~

	}

	Define: DlgGroupsData Using GroupsDialog;

	Left = 5; Top = 5;
	hGap = 4; vGap = 2;  xtraGap = 10;
	ButtonHeight = 20;		ButtonWidth = 70;  // Fits 12 chars
	StaticTextWidth = 50;	StaticTextHeight = 20;
	StaticStringWidth = 500; StaticTitleWidth = 300;
	// OrderID Chars(30), SortName Chars(63), 
	OrderBoxWidth = 90;		ComboBoxLength = 20 * 4;
	ListBoxWidth = 350;		ListBoxHeight = 20 * 10;
	SortBoxWidth = 250;

	x = $Left;				y = $Top;
	DialogLeft = App( thisApp,MainWindow,GetClientWidth ) / 2;
	DialogWidth = 400;
	DialogHeight = 400;

	Define: DlgGroupDefinition	Using	DDWinDef
            Fields: Position			0 180 $DialogWidth $DialogHeight
                    Title				Translate( GroupsMessages,Title )
                    TypeName			~Dialog~
					WantsMinimizeBox	TRUE
					StatusBar			~2 60 40~
					HACTIONSTEXT		ACTION SHOWHELPPAGE ( KPISHelpFile "GroupsData.htm" ) 
                    OACTIONSTEXT		ACTION EXEC ( CloseDialog() ) ;
 
		Contains: InListOrder
		{
			Define: OrderTxt	Using	DDWinCtrlDef	AsSymbol	OrderTxt
				Fields: TypeName	StaticText
						Text		Translate(GroupsMessages, OrderTxt)
						RightJustified	TRUE
						Position	$x,$y,
									$StaticTextWidth, $StaticTextHeight ;
			
			Define: OrderComboBox	Using	DDWinCtrlDef AsSymbol OrderComboBox
				Fields:	TypeName	SComboBox
						Position	OrderTxt(GetRight,Position) + $hGap,
									OrderTxt(GetTop,Position),
									$OrderBoxWidth, $ComboBoxLength
						GenConName	THIS
						GenConField ~theOrder~
						DropDownActionsText	ACTION EXEC ( GetOrderList() )
						IActionsText	~[GetList(OrderChoices) Get]~
						DActionsText	~[Save Exec("OnOrderChanges()")]~
						OActionsText	~[Save]~;

			Define: SortTxt	Using	DDWinCtrlDef	AsSymbol	SortTxt
				Fields: TypeName	StaticText
						Text		Translate(GroupsMessages, SortTxt)
						RightJustified	TRUE
						Position	OrderComboBox(GetRight,Position) + 3*$hGap,
									OrderComboBox(GetTop,Position),
									$StaticTextWidth, $StaticTextHeight ;
			
			Define: SortComboBox	Using	DDWinCtrlDef AsSymbol SortComboBox
				Fields:	TypeName	SComboBox
						Position	SortTxt(GetRight,Position) + $hGap,
									SortTxt(GetTop,Position),
									$SortBoxWidth, $ComboBoxLength
						GenConName	THIS
						GenConField ~theSort~
						DropDownActionsText	ACTION EXEC ( GetSortList() )
						IActionsText	~[GetList(SortChoices) Get]~
						DActionsText	~[Save]~
						OActionsText	~[Save]~;

			Define: SortTypeComboBox	Using	DDWinCtrlDef AsSymbol SortTypeComboBox
				Fields:	TypeName	SComboBox
						Position	SortComboBox(GetRight,Position) - $SortBoxWidth/2,
									SortTxt(GetBottom,Position) + $vGap*3,
									$SortBoxWidth/2, $ComboBoxLength
						GenConName	THIS
						GenConField ~theSortType~
						IActionsText	~[GetList(SortTypeChoices) Get]~
						DActionsText	~[Save Exec("OnSortTypeChanges()")]~
						OActionsText	~[Save]~;

			Define: SortTypeTxt	Using	DDWinCtrlDef	AsSymbol	SortTypeTxt
				Fields: TypeName	StaticText
						Text		Translate(GroupsMessages, SortTypeText)
						RightJustified	TRUE
						Position	SortTypeComboBox(GetLeft,Position) - ($StaticTextWidth + $hGap),
									SortTxt(GetBottom,Position) + $vGap*3,
									$StaticTextWidth, $StaticTextHeight ;
			
			Define: TitleTxt	Using	DDWinCtrlDef	AsSymbol	TitleTxt
				Fields: TypeName	StaticText
						IACTIONSTEXT	ACTIONS ( Get )
						TEXT		Translate( GroupsMessages,NoGrpsTitle)
						Position	OrderTxt(GetLeft,Position),
									OrderTxt(GetBottom,Position) + $vGap*4,
									$StaticTitleWidth, $StaticTextHeight ;
			
			Define: HeadersTxt	Using	DDWinCtrlDef	AsSymbol	HeadersTxt
				Fields: TypeName	StaticText
						IACTIONSTEXT	ACTIONS ( Get )
						TEXT		Translate( GroupsMessages,NoHeaders)
						Position	TitleTxt(GetLeft,Position) + $StaticTextWidth + $hGap,
									TitleTxt(GetBottom,Position) + $vGap*2,
									$StaticStringWidth, $StaticTextHeight ;
			
			Define: GroupsPrompt Using DDWinCtrlDef AsSymbol GroupsPrompt
				Fields:	TypeName		StaticText
						TEXT			Translate( GroupsMessages,GroupsTxt)
						RightJustified	TRUE
						Position		TitleTxt(GetLeft,Position),
										HeadersTxt(GetBottom,Position) + 2*$vGap,
										$StaticTextWidth, $StaticTextHeight ;

			Define: GroupsListBox Using DDWinCtrlDef AsSymbol GroupsListBox
				Fields:	TypeName		ListBox
						Position		GroupsPrompt(GetRight,Position) + $hGap,
										GroupsPrompt(GetTop,Position),
										$ListBoxWidth, $ListBoxHeight
						GenConField		~theGroup~
						GenConName		THIS
//						IActionsText	ACTIONS ( GetList(GroupsList))
						DActionsText	ACTIONS ( Save )
						OActionsText	ACTIONS ( Save );

			Define: GenerateButton	Using	DDWinCtrlDef AsSymbol	GenerateButton
				Fields: TypeName	Button
						Text		Translate(GroupsMessages, GenerateTxt)
						Position	GroupsPrompt(GetLeft, Position),
									GroupsListBox(GetBottom,Position) + $vGap*2,
									$ButtonWidth, $ButtonHeight
						DActionsText	ACTION EXEC ( OnGenerateButton() )
						IsTabStop	1
						IsEnabled	T
						Tooltip		Translate(GroupsMessages, GenerateToolTip);

			Define: SubjectInfoButton	Using	DDWinCtrlDef AsSymbol	SubjectInfoButton
				Fields: TypeName	Button
						Text		Translate(GroupsMessages, SubjectInfoTxt)
						Position	GenerateButton(GetRight, Position) + $hGap*2 + $xtraGap,
									GenerateButton(GetTop,Position),
									$ButtonWidth, $ButtonHeight
						DActionsText	ACTION EXEC ( OnSubjectInfoButton() )
						IsTabStop	2
						IsEnabled	T
						Tooltip		Translate(GroupsMessages, SubjectInfoToolTip);

			Define: ImagesButton	Using	DDWinCtrlDef AsSymbol	ImagesButton
				Fields: TypeName	Button
						Text		Translate(GroupsMessages, ImagesTxt)
						Position	SubjectInfoButton(GetRight, Position) + $hGap*2,
									SubjectInfoButton(GetTop,Position),
									$ButtonWidth, $ButtonHeight
						DActionsText	ACTION EXEC ( OnImagesButton() )
						IsTabStop	3
						IsEnabled	T
						Tooltip		Translate(GroupsMessages, ImagesToolTip);

			Define: CloseButton	Using	DDWinCtrlDef AsSymbol	CloseButton
				Fields: TypeName	Button
						Text		Translate(GroupsMessages, CloseTxt)
						Position	ImagesButton(GetRight, Position) + $hGap*2 + $xtraGap,
									ImagesButton(GetTop,Position),
									$ButtonWidth, $ButtonHeight
						DActionsText	ACTION EXEC ( CloseDialog() )
						IsTabStop	3
						IsEnabled	T
						Tooltip		Translate(GroupsMessages, CloseToolTip);
		};

//		DialogWidth = DlgGroupDefinition(GetMaxRight,Position) + $hGap*3;
//		DialogHeight = DlgGroupDefinition(GetMaxBottom,Postion) + $vGap + 25;
		DialogWidth = SortComboBox(GetRight,Position) + $hGap*3;
		DialogHeight = CloseButton(GetBottom,Position) + $vGap + 25;
				
		DlgGroupDefinition(Set,Position,~10 140 <DialogWidth> <DialogHeight>~ );

		GenDlg(dlg, Definition, DlgGroupDefinition,Data,DlgGroupsData,Document,$Doc.This,New,Temporary);
		Global(dlg,DlgGroupDefinition,DlgGroupsData);

}

VOID CloseDialog()
{
	dlg( end );
	Exit();
}


NUMERIC GetOrderList()
{

	// only want to get Original Orders, can't use "Type" field as not guarenteed to be "original"	
	theQuery = ~Select ID From Orders Where ShootDescID = '<WhichInfoDesc>' AND  ImagesOrderID IS NULL Order By ID~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<theQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate(DBMessages,QueryFailed,~<theQuery>~,~<theErr>~) );
	}

	List( MakeStringList,OrdersChoices,ID );
	dlg( SetControlFromStringList,OrderComboBox,OrdersChoices,NoSelection );

	dlg( GetInput );
	return TRUE;
}


NUMERIC GetSortList()
{

	GetSubjectOrderIDInfoType(~<$con.DlgGroupsData[theOrder]>~, infoType, tempSubjOrderId);

	theQuery = ~Select Name From Sorts Where Type in ('Any SubjectInfo','SubjectInfo<infoType>') Order by Sequence,Name~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<theQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate(DBMessages,QueryFailed,~<theQuery>~,~<theErr>~) );
	}

	List( MakeStringList,SortByChoices,NAME,FALSE);
	dlg( SetControlFromStringList,SortComboBox,SortByChoices,NoSelection );

	// this GetInput is needed here since update list if Order id changed,
	// ensure if previous value has been removed from list, current one displayed is stored in sortChoice
	dlg( GetInput );

	return TRUE;
}


NUMERIC GetSortOrderBy( &theOrderBy )
{

	theOrderBy = ~SubjectID~;


	return TRUE;
}


// Called when the pull down for OrderID changes
// Update the sort list for the InfoType for this order
NUMERIC OnOrderChanges()
{

	GetSubjectOrderIDInfoType(~<$con.DlgGroupsData[theOrder]>~, infoType, tempSubjOrderId);
	if (~<infoType>~ != ~<WhichInfoType>~)
	{
//		dlg(SetControlValue, TitleTxt, ~~);
//		dlg(SetControlValue, HeadersTxt, ~~);
//		if ( !dlg(ListBox,GroupsListBox,ResetContent) )
//			{ return Warning( Translate(CompJobMessages, ErrorResettingListBox, ~<Groups>~) );}

		GetSortList();
	}
	else
	{
	}

	return TRUE;

}



NUMERIC GetSortBy( theSortName, &theSortBy, &theRestriction )
{
	theQuery = ~Select Sort,Restriction From Sorts Where Name = '<theSortName>'~;
	Success = Ado( dBase,Connect,GetValuesFor,~<theQuery>~,theSortBy,theRestriction ) != FALSE;

	return <Success>;
}
 

VOID OnSortTypeChanges()
{
	if (~<$con.DlgGroupsData[theSortType]>~ == Translate(GroupsMessages,AllRecordsChoice))  // All Records
	{
		dlg( EnableControls,TRUE,SubjectInfoButton );	
		dlg( EnableControls,TRUE,ImagesButton );	
	}
	else if (~<$con.DlgGroupsData[theSortType]>~ == Translate(GroupsMessages,NoImagesChoice))  // No Images
	{
		dlg( EnableControls,TRUE,SubjectInfoButton );	
		dlg( EnableControls,FALSE,ImagesButton );	
	}

}

// OrderDlvrblDoc.txt no longer calls GenerateGroups, because of fix for problem KPRO00004382, problem described as follows:
// Page Break takes precedence over Sort in deliverable. When using the deliverable with a four up product, 
// you want the order item to change on the page break but also sort the order items by the sort, 
// which in this case is grade / home room. What happens is that the page break (sort) is how the order items are sorted.
// KPRO00004382.  See change between version 37 and 38 of OrderDlvrblDoc.txt
NUMERIC GenerateGroups(SubjectOrderID,infoType,SortName,&count,&theHdrString,&TabStops)    // Called by a THREAD
{

	ForgetGlobal(GrpCmdList,GroupsList,GrpCmdNoRestrictionList);

	if ( !GetSortBy(~<SortName>~, theSortby,theRestriction) )
	{
		return DoWarning( Translate(DBMessages,QueryFailed,~<SortName>~) );
	}

	// DlgGroupsData is not defined if routine called from CompJobGen
	if ( ( !Defined( DlgGroupsData )) || (~<$con.DlgGroupsData[theSortType]>~ == Translate(GroupsMessages,AllRecordsChoice)) ) // All Records
	{
		if (~<theRestriction>~ == ~~)
		{
			theQuery = ~Select count(1), <theSortby>  from SubjectInfo<infoType> Where OrderID = '<SubjectOrderID>' Group by <theSortby>~;
		}
		else
		{
			theQuery = ~Select count(1), <theSortby>  from SubjectInfo<infoType> Where OrderID = '<SubjectOrderID>' AND <theRestriction> Group by <theSortby>~;
		}
	}
	else if (~<$con.DlgGroupsData[theSortType]>~ == Translate(GroupsMessages,NoImagesChoice))  // No Images
	{
		imagesOrderId = ~<$con.DlgGroupsData[theOrder]>~;
		if (~<theRestriction>~ == ~~)
		{
//			theQuery = ~Select count(1), <theSortby> From SubjectInfo<infoType> Where SubjectInfo<infoType>.Orderid = '<SubjectOrderID>' AND NOT Exists (Select OrderID,SubjectID From Images Where Orderid='<imagesOrderId>' and SubjectInfo<infoType>.SubjectID = Images.SubjectID) Group by <theSortby>~;
			theQuery = ~Select count(1), <theSortby> From SubjectInfo<infoType> Where SubjectInfo<infoType>.Orderid = '<SubjectOrderID>' AND NOT Exists (Select SubjectID From Images Where Orderid='<imagesOrderId>' and SubjectInfo<infoType>.SubjectID = Images.SubjectID) Group by <theSortby>~;
		}
		else
		{
//			theQuery = ~Select count(1), <theSortby> From SubjectInfo<infoType> Where SubjectInfo<infoType>.Orderid = '<SubjectOrderID>' AND NOT Exists (Select OrderID,SubjectID From Images Where Orderid='<imagesOrderId>' and SubjectInfo<infoType>.SubjectID = Images.SubjectID) AND <theRestriction> Group by <theSortby>~;
			theQuery = ~Select count(1), <theSortby> From SubjectInfo<infoType> Where SubjectInfo<infoType>.Orderid = '<SubjectOrderID>' AND NOT Exists (Select SubjectID From Images Where Orderid='<imagesOrderId>' and SubjectInfo<infoType>.SubjectID = Images.SubjectID) AND <theRestriction> Group by <theSortby>~;
		}
	}

            // Can't get Cursor,Forward since go throug data 2X - failed with Forward
//*** 12/10 had Lock,ReadOnly,Cursor,Forward
	if ( !PGenConList( List,Connect,Cursor,Static,QUERY,~<theQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return DoWarning( Translate(DBMessages,QueryFailed,~<theQuery>~,~<theErr>~) );
	}

	count = List( NumEntries );
	if (<count> < 1)
	{	return TRUE; }

	StringList(GroupsList,New);
	StringList(GrpCmdList,New);
	StringList(GrpCmdNoRestrictionList,New);

	count = 0;
	numTokens = GetTokens(~<theSortby>~,~, ~);


	// Build Header String and determine tab positions
	i = 0;
	NextTabStop = 1;
	TabStops = ~~;
	theHdrString = ~~;
	while ( <i++> < <numTokens>)
	{
		if (<NextTabStop> > 1)
		{
			TabStops =  ~<TabStops>~ == ~~ ? ~<NextTabStop>~ : ~<TabStops>,<NextTabStop>~;
		}
		//	FieldLength is max length of data found in List for the field
		FieldLength = List(GetMaxFieldData,<Token<i>>);
		NextTabStop = <NextTabStop> + <FieldLength> + 1;  // 2 spaces between fields
		theHdrString = ~<theHdrString>~ == ~~ ? ~<Token<i>>~ : ~<theHdrString><Tab><Token<i>>~;
	}
	// Add Count(1) field
	NextTabStop = <NextTabStop> + 5;
	TabStops =  ~<TabStops>~ == ~~ ? ~<NextTabStop>~ : ~<TabStops>,<NextTabStop>~;
	CountHdr = Translate(~#~);
	theHdrString = ~<theHdrString><Tab><CountHdr>~;


	// Build list
	more = List( GetFirst,theRecord );
	while ( <more> )
	{
		theDsplyString = ~~;
		theCmdString = ~~;
		i = 0;
		while ( <i++> < <numTokens>)
		{
			theField = ~<$pcon.theRecord[<Token<i>>].SQLSafe>~;

			if (<i> == 1)
			{
				theDsplyString = ~<theField>~;
			}
			else
			{
				theDsplyString = ~<theDsplyString><Tab><theField>~;
			}
			if (~<theField>~ == ~~)
			{
				theCmdString = ~<theCmdString>~ == ~~ ? ~<Token<i>> IS NULL~ : ~<theCmdString> AND <Token<i>> IS NULL~;
			}
			else
			{
				theCmdString = ~<theCmdString>~ == ~~ ? ~<Token<i>> = '<theField>'~ : ~<theCmdString> AND <Token<i>> = '<theField>'~;
			}

		}

		theCmdStringNoRestriction = ~<theCmdString>~;
		if (~<theRestriction>~ != ~~)
		{
			theCmdString = ~<theCmdString> AND <theRestriction>~;
		}

		theField = ~<$pcon.theRecord[#0]>~;
		theDsplyString = ~<theDsplyString><Tab>:<theField>~;

		GroupsList(AddString,~<theDsplyString>~);
		GrpCmdList(AddString,~<theCmdString>~);
		GrpCmdNoRestrictionList(AddString,~<theCmdStringNoRestriction>~);
		++count;
		more = List( GetNext,theRecord );
	}

	Global( GrpCmdList );
	Global( GroupsList );
	Global( GrpCmdNoRestrictionList );

	return TRUE;
}

STR RemoveCommasFromCaseStatement( SortList )
{
	numTokens = GetTokens(~<SortList>~,~,~);
	if (<numTokens> < 2)
	{
		return ~<SortList>~;
	}

	j = 1;
	inCase = -1;
	outCase = -1;

	while (<j> <= <numTokens> )
	{
		if (SimilarStr(~<token<j>>~,Case))
		{
			inCase = <j>;
			outCase = <j>;
		}
		else if ( <inCase> > 0 && SimilarStr(~<token<j>>~,End))
		{
			outCase = <j>;
		}
		<j++>;
	}

	// check for no Case statement or a Case without an End
	// (if user had a field named Case for example)
	if (<inCase> < 0 || <inCase> == <outCase>)
	{
		return (~<SortList>~);
	}
	
	i = 2;
	newSortList = ~<token1>~;

	while ( <i> <= <numTokens> )
	{
		if ( <i> > <inCase> && <i> <= <outCase> )
		{
			newSortList = ~<newSortList> <token<i>>~;
		}
		else
		{
			newSortList = ~<newSortList>,<token<i>>~;
		}
		<i++>;
	}	
	return ~<newSortList>~;
}

STR RemoveDuplicateColumns( SortList )
{
	numTokens = GetTokens(~<SortList>~,~, ~);

	j = <numTokens>;

	while (<j> > 1 )
	{
		i = <j> - 1;
		while ( <i> > 0 )
		{
			if ( ~<token<j>>~ == ~<token<i-->>~ )
			{
				token<j> = ~~;
				break;
			}
		}
		<j-->;
	}

	i = 2;
	newSortList = ~<token1>~;

	while ( <i> <= <numTokens> )
	{
		if ( ~<token<i>>~ != ~~ )
		{
			newSortList = ~<newSortList>,<token<i>>~;
		}
		<i++>;
	}
	return ~<newSortList>~;
}
NUMERIC BuildFieldList( GroupBy )
{
	count = 0;
	numTokens = GetTokens(~<GroupBy>~,~, ~);

	while ( <count++> < <numTokens> )
	{
		TokenValue<count> = ~~;
		Global( TokenValue<count> );
		Global( Token<count> );
	}
	
	return <numTokens>;
}

NUMERIC CleanUpFieldList( numTokens )
{
	while ( <count++> < <numTokens> )
	{
		ForgetGlobal( TokenValue<count> );
		ForgetGlobal( Token<count> );
	}
	
	return TRUE;
}

// if a field value does not match current settings for page break
//  reset the rest of the token values (for the next page break) and
//  reset the position of the list
//  otherwise, add the item to a new list for the page
NUMERIC  BuildPageList( &List,numTokens,&more )
{
	match = TRUE;
	count = 0;

	CreatePageList();
	PageList( Open );

	more = List( GetNext,Item );
	while ( <match> && <more> )
	{
		i = 0;

		while ( <i++> < <numTokens> )
		{
			theValue = ~<$pcon.Item[<Token<i>>]>~;
			if ( ~<theValue>~ != ~<TokenValue<i>>~ )
			{
				match = FALSE;
			}

			if ( !<match> )
			{
				TokenValue<i> = ~<theValue>~;
			}
		}

		if ( <match> )
		{
			PageList( AddNew, Row ); 
			Row( SetValue,Path,~<$pcon.Item[Path]>~ );

			more = List( GetNext, Item );
			<++count>;
		}
		else
		{
//			pos = List( GetPosition );
			List( GetPrev, Item );
		}
	}

	return <count>;
}

NUMERIC CreatePageList()
{
	ForgetGlobal( PageList );
	PGenConList( PageList, Create );
	PageList( Open );

	PageList( AppendField,~Path~,~CHAR~,~255~,TRUE );

	Global( PageList );

	return TRUE;
}

// Code for GroupHndl.txt
NUMERIC OnGenerateButton()
{
	WhichOrderID = ~<$con.DlgGroupsData[theOrder]>~;
	WhichSortName = ~<$con.DlgGroupsData[theSort]>~;
	GetSubjectOrderIDInfoType(~<WhichOrderID>~, WhichInfoType, WhichSubjectsOrderID);

	retVal = GenerateGroups(~<WhichSubjectsOrderID>~,~<WhichInfoType>~,~<WhichSortName>~,count,theHdrString,TabStops);

	if ( !<retVal> )
	{	return FALSE; }

	dlg( SetStatus,0,Translate( GroupsMessages,NumGroups,<count> ) );
	dlg(SetControlValue, TitleTxt, ~SubjectInfo<WhichInfoType>: <WhichSubjectsOrderID> <WhichSortName>~);

	ExpandedHeader = ExpandTabString(~<theHdrString>~,~<TabStops>~);
//	dlg(SetControlValue, HeadersTxt, ~<ExpandedHeader>~);
	GetSortBy(~<WhichSortName>~, theSortby,theRestriction);
	dlg(SetControlValue, HeadersTxt, ~<theSortby>   :<$con.DlgGroupsData[theSortType]> <WhichOrderID>~);
//	dlg(SetControlValue, HeadersTxt, ~~);
	DlgGroupsData(SetValues,theGroup,~~);

	if (<count> < 1)
	{ return !dlg(ListBox,GroupsListBox,ResetContent);	}

	dlg( ListBox,GroupsListBox,SetTabStops,<TabStops>);
//	dlg( StaticText,HeadersTxt,SetTabStops,<TabStops>); // DOES NOT WORK TO APPLY TO TEXT
	return dlg(SetControlFromStringList,GroupsListBox,GroupsList);

}


NUMERIC GetCmdQualifier(&theCmd)
{
	theGroup = ~<$con.DlgGroupsData[theGroup]>~;

	if (~<theGroup>~ != ~~)
	{
		Index = dlg( ListBox,GroupsListBox,GetSelectedIndex );
		GrpCmdList(GetStringAt,<Index>,theCmd);
	}

	else
	{  return FALSE; }

	return TRUE;
}

NUMERIC OnSubjectInfoButton()
{
	theOrderId = ~<WhichOrderID>~;
	if ( doNewWay() )
	{
		GetSubjectOrderIDInfoType(~<$con.DlgGroupsData[theOrder]>~, infoType, tempSubjOrderId);
		if (~<infoType>~ != ~<WhichInfoType>~)
		{
			return Warning( Translate(GroupsMessages,InfoTypeDifferent,~<WhichInfoType>~,~<infoType>~) );
		}
		theOrderId = ~<$con.DlgGroupsData[theOrder]>~;
	}
	// old way - uses order and infoType values from when "Generate"

	if (!GetCmdQualifier(theCmd))
	{  return Warning(Translate(GroupsMessages, NoGrpSelected) );  }

	GetSortOrderBy(OrderBy);
	// in Query, don't put in infoType as Init() of SubjectInfoDoc will fill it in

	if (~<$con.DlgGroupsData[theSortType]>~ == Translate(GroupsMessages,AllRecordsChoice))  // All Records
	{
		theQuery = ~Select * From SubjectInfo<WhichInfoType> Where OrderID = '<WhichSubjectsOrderID>' AND <theCmd> Order By <OrderBy>~;
	}
	else if (~<$con.DlgGroupsData[theSortType]>~ == Translate(GroupsMessages,NoImagesChoice))  // No Images
	{
//		theQuery = ~Select * From SubjectInfo<WhichInfoType> Where OrderID = '<WhichSubjectsOrderID>' AND NOT Exists (Select OrderID,SubjectID From Images Where Orderid='<theOrderId>' and SubjectInfo<WhichInfoType>.SubjectID = Images.SubjectID) AND <theCmd> Order By <OrderBy>~;
		theQuery = ~Select * From SubjectInfo<WhichInfoType> Where OrderID = '<WhichSubjectsOrderID>' AND NOT Exists (Select SubjectID From Images Where Orderid='<theOrderId>' and SubjectInfo<WhichInfoType>.SubjectID = Images.SubjectID) AND <theCmd> Order By <OrderBy>~;
	}

	OpenMethod = KeyState( RSHIFT ) ? Open : OpenOnce;
	Actions = ACTION Doc ( ~SubjectInfo~ <OpenMethod> SubjectInfoDoc "Init2( ~<WhichSubjectsOrderID>~,~<WhichInfoType>~,~<theQuery>~ );" );
	PerformActions( Actions );

	return TRUE;
}


NUMERIC OnImagesButton()
{
	theOrderID = ~<WhichOrderID>~;

	if ( doNewWay() )
	{
		GetSubjectOrderIDInfoType(~<$con.DlgGroupsData[theOrder]>~, infoType, tempSubjOrderId);
		if (~<infoType>~ != ~<WhichInfoType>~)
		{
			return Warning( Translate(GroupsMessages,InfoTypeDifferent,~<WhichInfoType>~,~<infoType>~) );
		}
		theOrderID = ~<$con.DlgGroupsData[theOrder]>~;
	}
	// old way - uses order and infoType values from when "Generate"

	if (!GetCmdQualifier(theCmd))
	{  return Warning(Translate(GroupsMessages, NoGrpSelected) );  }

	GetSortOrderBy(OrderBy);

	theQuery = ~Select * From SubjectInfo<WhichInfoType> Where OrderID = '<WhichSubjectsOrderID>' AND <theCmd> Order By <OrderBy>~;
	if ( !PGenConList( List,Connect,Lock,ReadOnly,Cursor,Forward,QUERY,~<theQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate(DBMessages,QueryFailed,~<theQuery>~,~<theErr>~) );
	}

	CountSubjInfo = List( NumEntries );
	List(MakeSQLList,IdList,TRUE,SubjectID);
	QueryLength = strlen( ~<IdList>~ ) + 90 + 23;
	if (<QueryLength> > <MaxQueryLength>)
	{
		Log( Session,~Groups - SubjectInfoOrderID: <WhichSubjectsOrderID>  Command: <theCmd>  Request to View Images for selected group query too long (<QueryLength> chars).~ );

		if ( MessageBox( Translate(GroupsMessages,TooManyImagesForQuery),YESNO ) != YES )
		{ return FALSE; }
		theQuery = ~Select * From Images Where OrderID = '<theOrderID>'~;
	}
	else
	{
		List(MakeSQLList,IdList,TRUE,SubjectID);
		theQuery = ~Select * From Images Where OrderID = '<theOrderID>' And SubjectID In (<IdList>)~;
	}

	AsImages = TRUE;
//	AsImages = FALSE;
	WhichDoc = <AsImages> ? ~ImagesDoc~ : ~ImagesDataDoc~;

	OpenMethod = KeyState( RSHIFT ) ? Open : OpenOnce;
	Actions = ACTION Doc ( ~Images~ <OpenMethod> <WhichDoc> "Init( ~<theOrderID>~,<AsImages>,~<theQuery>~,0 );" );
	PerformActions( Actions );

	return TRUE;
}



NUMERIC OpenGroupsDialog(theShootDescID)
{

	if ( !Defined( dlg ) )
	{
		DefineGroupsDialog();
		WhichOrderID = ~~;
		WhichSortName = ~~;
		WhichInfoDesc = ~<theShootDescID>~;
		WhichSubjectsOrderID = ~~;
		WhichInfoType = ~~;
		Global( WhichInfoDesc,WhichOrderID,WhichSortName,WhichSubjectsOrderID,WhichInfoType );

		GetOrderList();
		GetSortList();

	}

	else
	{
		// or should I overwrite this one
		Warning(Translate(GroupsMessages,DialogAlreadyOpen) );
	}	
	return TRUE;
}


// should probably move this function(ality) into functions.cpp
// used in CompJobGen.txt
STR ExpandTabString(SourceString, TabPositions)
{

	TabCount = GetTokens(~<TabPositions>~, ~,~);
	if (<TabCount> < 1)
	{	return ~<SourceString>~;	}

	i = 0;
	while (<i++> < <TabCount>)
	{
		TabPos<i> = <Token<i>>;
	}

	StrCount = GetTokens(~<SourceString>~, ~<Tab>~);
	if (<StrCount> < 1)
	{	return ~<SourceString>~;	}

	j = 0;
	if (String(BeginsWith,~<Tab>~, ~<SourceString>~) == ~~)
	{	DestString = ~<Token1>~;
		++j;	
	}
	else
	{	DestString = ~~;	}

	i = 0;
	while ((<i> < <TabCount>) && (<j> < <StrCount>))
	{
		++i;
		++j;
		len = strlen(~<DestString>~);

		if (<TabPos<i>> > <len> )
		{
			Blanks = RepeatStr(<TabPos<i>> - <len>,~ ~);
		}
		else
		{	Blanks = ~~;	}
		
		DestString = ~<DestString><Blanks><Token<j>>~;
	}

	while (<j> < <StrCount>)
	{
		++j;
		DestString = ~<DestString><Token<j>>~;
	}

	return ~<DestString>~;

}


NUMERIC DoWarning( Msg )
{
	if ( FunctionDefined(ShowWarning) ) // Thread's function
	{	Invoke( ShowWarning,~<Msg>~ );	}

	else
	{	Warning( ~<Msg>~ );	}

	return FALSE;

}
