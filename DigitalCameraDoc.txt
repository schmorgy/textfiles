Include: ~UtilityRoutines~;
Include: ~DigitalCameraCommon~;
IncludeClass( BaseMenu );


/***************************************************************************************************/
NewRedSetting = ~~;
NewGreenSetting = ~~;
NewBlueSetting = ~~;
NewNoiseReduction = ~~;
NRRadiusSupported = FALSE;
NRStrengthThresholdSupported = FALSE;
balanceSupported = FALSE;
clickBalanceSupported = FALSE;
LastBalanceType = ~~;
LastImageDocument = 0;

StatusMessage = ~~;

DialogWidth = 500;		
DialogHeight = 605;

LeftX = hGap = vGap = 10;
CurrentY = $vGap;

TabWidth = $DialogWidth - $hGap * 2;
TabHeight = 265;

GroupBoxWidth = <TabWidth> - 20;
GroupBoxHeight = 50;
GroupBoxLeft = <LeftX> + 4;

EditTextHeight = 20;
EditTextWidth = 250;
StaticTextHeight = 20;
ComboBoxHeight = 160;

ButtonWidth = 75;
ButtonHeight = 15;
ButtonGap = 5;

SmallButtonWidth = 20;
SmallButtonHeight = 20;

/* A question came up on 9/15/04 about how the information in the digital camera file can be tied to the subject
information table.  Here is Chrystie's Rakvica's explanation:
The photographer gets a file from the school (grade, teacher, school ID#, name, etc...), or creates one.
The photographer then creates the barcoded cards with each student's name, school ID#, grade, etc.., and the student's school ID as the barcode.
When the student gets their picture taken, the photographer scans their assigned barcoded data into the camera before the picture is taken, and now the students unique assigned barcoded number is stored in the student's raw image file(s).
Both the file with the school student data and the raw camera files are sent to the lab for use with DP2.
DP2 imports in the student data into the SubjectInfo table for the school, using the student ID#, in this example, as the Subject ID.
DP2 then imports in the raw camera files, where the operator from the Digital Camera Import function has checked the "Automatically load the Image Description field ...." indicating the SubectID field.
Thus, as each raw camera file is imported into DP2, the value in the Image Description field is stored in the Images' table "SubjectID" field.
Now the Image is linked to the appropriate SubjectInfo table entry for the school, and packages, composites, etc can be created.
*/


/***************************************************************************************************/
Tree( Location,~[DICTIONARIES]~,Name,DDCameraDialogData,PluckAndFree );

if (!DictionaryExists(DDCameraDialogData))
{
	Dictionary: DDCameraDialogData
		Fields: Name ICCProfile					Type Text 

		Fields:	Name Exposure					Type Double LowValue ~-2~ HighValue 2 
		Fields: Name ExposureMax				Type Double
		Fields: Name ExposureMin				Type Double

		Fields: Name AppSharpenAmount			Type Double
		Fields: Name AppSharpAmountMin			Type Double
		Fields: Name AppSharpAmountMax			Type Double
		
		Fields: Name AppSharpenRadius			Type Double
		Fields: Name AppSharpRadiusMin			Type Double
		Fields: Name AppSharpRadiusMax			Type Double

		Fields: Name AppSharpenThreshold		Type Double
		Fields: Name AppSharpThresholdMin		Type Double
		Fields: Name AppSharpThresholdMax		Type Double

		Fields:	Name Balance					Type Long	LowValue 0 HighValue 3

		Fields:	Name NRType						Type Text
		Fields: Name NRStrengthThreshold		Type Long	LowValue 0 HighValue 100
		Fields: Name NRRadius					Type Long	LowValue 0 HighValue 100
		
		// RGB Triplets for balance functions 
		Fields: Name Red						Type  Long	LowValue (-999)	HighValue 999
		Fields: Name Green						Type  Long	LowValue (-999)	HighValue 999
		Fields: Name Blue						Type  Long	LowValue (-999)	HighValue 999

		// Used for click balance
		Fields:	Name CenterPtCol				Type Long
		Fields:	Name CenterPtRow				Type Long
		Fields:	Name ApertureSize				Type Long

		// Also used for click balance
		Fields:	Name ClickBalanceRed			Type Long
		Fields:	Name ClickBalanceGreen			Type Long
		Fields:	Name ClickBalanceBlue			Type Long

		// Determine whether we want to preview all of the click operations
		Fields: Name PreviewAllClickBalances	Type Long		// checkbox value

		// Used for the PICIO crop function
		Fields:	Name Top						Type Long
		Fields:	Name Left						Type Long
		Fields:	Name Bottom						Type Long
		Fields:	Name Right						Type Long
		
		Fields:	Name Lighting					Type Long
		Fields:	Name Look						Type Text

		Fields: Name Directory					Type Text
		Fields:	Name OrderImages				Type Text

		// The Digital Camera Setup:
		Fields:	Name DCSetup					Type Text	// list value
		Fields:	Name SaveFileType				Type Text
		Fields:	Name FileExtension				Type Text
		Fields:	Name JPEGQuality				Type Long	LowValue 0	HighValue 100
		Fields: Name EnableRawFileSharpening	Type Long	// Checkbox Value
		Fields:	Name OverrideDeltaSharpening	Type Long	// checkbox value
		Fields:	Name DeltaSharpeningValue		Type Long	// actual delta sharpening value
		Fields: Name UseWorkingspaceProfile		Type Long
		Fields:	Name AlternateOutputProfile		Type Text

		Fields: Name RenderSuccessNotification	Type Text
		Fields: Name RenderFailureNotification	Type Text
		Fields: Name ThreadCompleteNotification	Type Text
		Fields: Name RefreshNotification		Type Text
		Fields: Name StatusProcessingFile		Type Text
		Fields: Name StatusProcessingPreview	Type Text

		Fields: Name AutoQueueOnImport			Type Long		// checkbox value
		Fields:	Name ImportSetup				Type Text		// list value
		
		Fields: Name AutoQueueOnCmds			Type Long		// checkbox value
		Fields:	Name CommandsSetup				Type Text		// list value

		Fields: Name AutoStartBackgroundQueue	Type Long		// checkbox value
		Fields: Name QueueTimerInterval			Type Long	LowValue 10 HighValue 110
		
		// For the General Options tab
		Fields:	Name LoadImageDescription		Type Long		// checkbox value
		Fields:	Name ImageDescriptionField		Type Text		// list value

		Fields:	Name HighLevelLogging			Type Long		// checkbox value

		Fields: Name PreviewImageSize			Type Long	LowValue 200 HighValue 1000	// Size of the preview image
		Fields:	Name Resolution					Type Long
;

	StringList:	Name ~CameraOutputFileTypes~
		Fields: String	~TIFF~
		Fields: String	~JPEG~
	Hang:	CameraOutputFileTypes	~[STRINGS]~

	StringList:	Name ~CameraOutputFileExtensions~
		Fields: String	~.tif~
		Fields: String	~.jpg~;
	Hang:	CameraOutputFileExtensions	~[STRINGS]~

	StringList:	Name ~ImageDescriptionOutputFields~
		Fields: String	~AlternateID~
		Fields: String	~Description~
		Fields: String	~SubjectID~
	Hang:	ImageDescriptionOutputFields	~[STRINGS]~
}

	Define: DlgData Using DDCameraDialogData
	Fields:	Balance 0
			Lighting 1
			JPEGQuality					100
			EnableRawFileSharpening		0
			OverrideDeltaSharpening		0
			DeltaSharpeningValue		0
			UseWorkingspaceProfile		1
			AlternateOutputProfile		~~
			Look						0
			RenderSuccessNotification	~RenderSuccessNotify(%s);~
			RenderFailureNotification	~RenderFailureNotify(%s);~
			ThreadCompleteNotification	~ThreadProcessingComplete();~
			RefreshNotification			~RefreshLists();~
			StatusProcessingFile		~ProcessingToFile(%s);~
			StatusProcessingPreview		~ProcessingPreview(%s);~
			SaveFileType					~TIFF~
			FileExtension				~.tif~
			ExposureMax					2
			ExposureMin					~-2~
			QueueTimerInterval			10
			Resolution					0
			PreviewImageSize			660

			PreviewAllClickBalances		0

			NRType						0
			NRStrengthThreshold			0
			NRRadius					100

			AppSharpenAmount			0
			AppSharpAmountMin			0
			AppSharpAmountMax			0
			
			AppSharpenRadius			0
			AppSharpRadiusMin			0
			AppSharpRadiusMax			0
			
			AppSharpenThreshold			0
			AppSharpThresholdMin		0
			AppSharpThresholdMax		0
			;

/***************************************************************************************************/
if (!DictionaryExists(DDScannerImageData))
{
	Dictionary: DDScannerImageData
		Fields:	Name ImageBuffer				Type long
		Fields:	Name ImageWidth					Type long
		Fields:	Name ImageHeight				Type long
		Fields:	Name ImageDepth					Type long
		Fields: Name ImageLayout				Type Text;
}

	Define: ImageData Using DDScannerImageData 
	Fields: ImageBuffer					0
			ImageWidth					0
			ImageHeight					0
			ImageDepth					0
			ImageLayout					~~;
	Global( ImageData );

/***************************************************************************************************/
if (!DictionaryExists(DDNoiseReductionData))
{
//	{/*"Off",*/ KVTPICPROCNoiseFilterModeOff, TRUE},
//	{/*"Basic",*/ KVTPICPROCNoiseFilterModeBasic, FALSE},
//	{/*"Advanced",*/ KVTPICPROCNoiseFilterModeChroma, FALSE},
//	{/*"Advanced with Moire Reduction",*/ KVTPICPROCNoiseFilterModeMoire, FALSE},
//	{/*"Advanced",*/ KVTPICPROCNoiseFilterModeChromaWithRadius, FALSE},
//	{/*"Advanced with Moire Reduction",*/ KVTPICPROCNoiseFilterModeMoireWithRadius, FALSE}
//	{/*"Expert",*/ KVTPICPROCNoiseFilterModeExpert, FALSE}
//	{/*"Basic with Radius",*/ KVTPICPROCNoiseFilterModeBasicWithRadius, FALSE}
	Dictionary: DDNoiseReductionData
		Fields:	Name NROff						Type long
		Fields:	Name NRBasic					Type long
		Fields:	Name NRChroma					Type long
		Fields:	Name NRMoire					Type long
		Fields: Name NRChromaRadius				Type long
		Fields:	Name NRMoireRadius				Type long;
		Fields:	Name NRExpert					Type long;
		Fields:	Name NRBasicRadius				Type long;
}

	Define: NoiseReductionData Using DDNoiseReductionData 
	Fields: NROff					1
			NRBasic					0
			NRChroma				0
			NRMoire					0
			NRChromaRadius			0
			NRMoireRadius			0
			NRExpert				0
			NRBasicRadius			0;
	Global( NoiseReductionData );

/***************************************************************************************************/
if (!DictionaryExists(DDQueueItemData))
{
	Dictionary: DDQueueItemData
		Fields: Name SrcPicPathID				Type Text
		Fields: Name OrderID					Type Text
		Fields: Name Roll						Type Text
		Fields: Name Frame						Type Text
		Fields:	Name MaxOutputDimension			Type long

		Fields: Name OutputType					Type Text
		Fields:	Name JPEGQuality				Type long
		Fields: Name EnableRawFileSharpening	Type Long	// Checkbox Value
		Fields:	Name OverrideDeltaSharpening	Type Long	// checkbox value
		Fields:	Name DeltaSharpeningValue		Type Long	// actual delta sharpening value

		Fields: Name OutputPathName				Type Text
		Fields: Name LowResPathName				Type Text
		Fields: Name WorkingSpaceProfileName	Type Text
		Fields: Name InputProfilePath			Type Text

		Fields:	Name ImageBuffer				Type long
		Fields:	Name ImageBufferWidth			Type long
		Fields:	Name ImageBufferHeight			Type long
		Fields:	Name ImageBufferDepth			Type long
		Fields: Name ImageBufferLayout			Type Text
		Fields: Name RenderedPathName			Type Text
		
		Fields:	Name LoadImageAttributes		Type long
		Fields:	Name ImageDescriptionField		Type Text
		Fields:	Name TruncationLength			Type long
		;
}
	
	Define: QueueItemData Using DDQueueItemData 
	Fields: SrcPicPathID				~~
			OrderID						~~
			Roll						~~
			Frame						~~
			MaxOutputDimension			~660~

			OutputType					~~
			JPEGQuality					0
			DeltaSharpeningValue		0
			OutputPathName				~~
			LowResPathName				~~
			WorkingSpaceProfileName		~~
			InputProfilePath			~~

			ImageBuffer					0
			ImageBufferWidth			0
			ImageBufferHeight			0
			ImageBufferDepth			0
			ImageBufferLayout			~~
			RenderedPathName			~~;


/***************************************************************************************************/
VOID DefineDialog()
{
	x = 5;
	y = 5;

	ScreenWidth = App( thisApp,MainWindow,GetClientWidth );
	DialogLeft = ($ScreenWidth * .9) - 90 - $DialogWidth;
	if (<DialogLeft> < 0)
	{
		DialogLeft = 0;
	}
	DialogTop = 8;

    Define: DigitalCameraDlgDefinition Using DDWinDef
            Fields: Position			$DialogLeft $DialogTop $DialogWidth $DialogHeight
                    Title				~Kodak DCR Import~
                    TypeName			~Dialog~
					StatusBar			~1 100~
					WantsMinimizeBox	TRUE
					RClickDnActionsText ACTION Exec ( RightClickIn() )
					HActionsText		ACTION SHOWHELPPAGE ( KPISHelpFile "DC_Import.htm" )
					OACTIONSTEXT		ACTION EXEC ( CloseDialog() )
					KEYBOARDACTIONSTEXT	 ACTION EXEC ( OnKeyDown() );

	Contains: InListOrder
	{
        Define: TabWindow Using DDWinCtrlDef AsSymbol TabWindow
                Fields: Position	<x>, <y>, <TabWidth>, <TabHeight>
                        TypeName	TabCtrl
                        Text		~TCS_HOTTRACK | TCS_MULTILINE | TCS_TOOLTIPS~
						KEYBOARDACTIONSTEXT	 ACTION EXEC ( OnKeyDown() )
        Contains: InListOrder
        {
			tab = 0;
			DefineColorTab(<++tab>, x, y, hGap, vGap, TabWidth, TabHeight);
			
			DefineImageAdjustTab(<++tab>, x, y,hGap, vGap, TabWidth, TabHeight);

			DefineFiltersTab(<++tab>, x, y, hGap, vGap, TabWidth, TabHeight);

			DefineOutputTab(<++tab>, x, y, hGap, vGap, TabWidth, TabHeight);

			DefineDCQueueOptionsTab(<++tab>, x, y, hGap, vGap, TabWidth, TabHeight);

			DefineDCOptionsTab(<++tab>, x, y, hGap, vGap, TabWidth, TabHeight);
		}

		yStart = TabWindow(GetBottom, Position);
		DefineDialogControls(yStart, TabWidth);
	}

	Global( DigitalCameraDlgDefinition );
}


/***************************************************************************************************/
NUMERIC DefineColorTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
 	Define: Tab<tab> Using DDWinCtrlDef
			Fields: Text	~Color~
			TypeName		Tab
			Tooltip			Translate(~Setup the general color settings~)
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "DC_Color.htm" )	
			
		Contains: INLISTORDER
		{

// This is just here to get around the spurrious DACTIONSTEXT issue.
			Define: EmptyPrompt Using DDWinCtrlDef AsSymbol EmptyPrompt
			Fields: POSITION		<LeftX> + 8, $hGap*4 + 20, 40,20
					TEXT			~~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					
// NOTE: PUT GROUP BOX DEFINITIONS AFTER THE CONTROL DEFINITION, OTHERWISE THE TOOLTIPS WON'T BE VISIBLE!!
								
			Define: DaylightButton Using DDWinCtrlDef AsSymbol DaylightButton
			Fields:	POSITION		<LeftX> + 20, 50, 75, 20
					TOOLTIP			~Use Daylight Camera Profile~
					TYPENAME		~RadioButton~ 
					TEXT			~Daylight~
					RADIOTRUEVALUE	~0~
					GENCONNAME		THIS
					GENCONFIELD		~Lighting~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( CheckButton(DaylightButton) UncheckButton(TungstenButton) UncheckButton(FluorescentButton) UncheckButton(FlashButton) "Exec(OnLightingChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					
			Define: TungstenButton Using DDWinCtrlDef AsSymbol TungstenButton
			Fields:	POSITION		DaylightButton(GetRight,Position) + $hGap, DaylightButton(GetTop,Position), 75, 20
					TOOLTIP			~Use Tungsten Camera Profile~
					TYPENAME		~RadioButton~ 
					TEXT			~Tungsten~
					RADIOTRUEVALUE	~1~
					GENCONFIELD		~Lighting~
					GENCONNAME		THIS
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS (  CheckButton(TungstenButton) UncheckButton(DaylightButton) UncheckButton(FluorescentButton) UncheckButton(FlashButton) "Exec(OnLightingChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					
			Define: FluorescentButton Using DDWinCtrlDef AsSymbol FluorescentButton
			Fields:	POSITION		TungstenButton(GetRight,Position) + $hGap, TungstenButton(GetTop,Position), 75, 20
					TOOLTIP			~Use Fluorescent Camera Profile~
					TYPENAME		~RadioButton~ 
					TEXT			~Fluorescent~
					RADIOTRUEVALUE	~3~
					GENCONNAME		THIS
					GENCONFIELD		~Lighting~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS (  CheckButton(FluorescentButton) UncheckButton(TungstenButton) UncheckButton(DaylightButton) UncheckButton(FlashButton) "Exec(OnLightingChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					
			Define: FlashButton	Using DDWinCtrlDef AsSymbol FlashButton
			Fields:	POSITION		FluorescentButton(GetRight,Position) + $hGap, FluorescentButton(GetTop,Position), 75, 20
					TOOLTIP			~Use Flash Camera Profile~
					TYPENAME		~RadioButton~ 
					TEXT			~Flash~
					RADIOTRUEVALUE	~2~
					GENCONNAME		THIS
					GENCONFIELD		~Lighting~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS (  CheckButton(FlashButton) UncheckButton(TungstenButton) UncheckButton(FluorescentButton) UncheckButton(DaylightButton) "Exec(OnLightingChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					
			Define: LightingGroupBox Using DDWinCtrlDef
			Fields:	TypeName	GroupBox
					Position	<GroupBoxLeft>, $hGap*3,  <GroupBoxWidth>, <GroupBoxHeight>
					Text		~Lighting Settings~
					
			Define: BalancePreset Using DDWinCtrlDef AsSymbol BalancePreset
			Fields:	POSITION		DaylightButton(GetLeft, Position), FlashButton(GetBottom, Position)+30, 75, 20	 //<LeftX> + 20, 150, 50, 20
					TOOLTIP			~Use Preset Balance Values~
					TYPENAME		~RadioButton~ 
					TEXT			~Preset~
					RADIOTRUEVALUE	~0~
					GENCONNAME		THIS
					GENCONFIELD		~Balance~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( CheckButton(BalancePreset) UncheckButton(BalanceClick) UncheckButton(BalanceCustom) UncheckButton(BalanceAuto) "Exec(OnBalanceChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					
			Define: BalanceCustom Using DDWinCtrlDef AsSymbol BalanceCustom
			Fields:	POSITION		BalancePreset(GetRight,Position) + $hGap, BalancePreset(GetTop,Position), 75, 20
					TOOLTIP			~Retrieve Custom Balance Setting in Camera~
					TYPENAME		~RadioButton~ 
					TEXT			~Custom~
					RADIOTRUEVALUE	~2~
					GENCONNAME		THIS
					GENCONFIELD		~Balance~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( CheckButton(BalanceCustom) UncheckButton(BalanceClick) UncheckButton(BalancePreset) UncheckButton(BalanceAuto) "Exec(OnBalanceChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					
			Define: BalanceAuto	Using DDWinCtrlDef AsSymbol BalanceAuto
			Fields:	POSITION		BalanceCustom(GetRight,Position) + $hGap, BalanceCustom(GetTop,Position), 75, 20
					TOOLTIP			~Invoke Auto Balance Feature within the Camera~
					TYPENAME		~RadioButton~ 
					TEXT			~Auto~
					RADIOTRUEVALUE	~3~
					GENCONNAME		THIS
					GENCONFIELD		~Balance~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( CheckButton(BalanceAuto) UncheckButton(BalanceClick) UncheckButton(BalanceCustom) UncheckButton(BalancePreset) "Exec(OnBalanceChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					
			Define: BalanceClick Using DDWinCtrlDef AsSymbol BalanceClick
			Fields:	POSITION		BalanceAuto(GetRight,Position) + $hGap, BalanceAuto(GetTop,Position), 75, 20
					TOOLTIP			~Apply Click Balance values~
					TYPENAME		~RadioButton~ 
					TEXT			~Click~
					RADIOTRUEVALUE	~1~
					GENCONNAME		THIS
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( CheckButton(BalanceClick) UncheckButton(BalancePreset) UncheckButton(BalanceCustom) UncheckButton(BalanceAuto) "Exec(OnBalanceChanged())")
					OACTIONSTEXT	ACTIONS ( Save )
					GENCONFIELD		~Balance~
					IsEnabled		F

			Define: PreviewAllClickBalancesCheckBox Using DDWinCtrlDef AsSymbol PreviewAllClickBalancesCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	BalancePreset(GetLeft, Position), BalancePreset(GetBottom,Position) + 3, 350, 15
					GENCONFIELD ~PreviewAllClickBalances~
					GENCONNAME	THIS
					TEXT		~Preview all selected images when performing a Click Balance~
					DActionsText ~[ Save "Exec(OnPreviewAllClickChanged())" ]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
 					TOOLTIP		~Check this box if you would like to see an updated preview of all selected images when performing a click balance.~;

			Define: BalanceGroupBox Using DDWinCtrlDef
			fields:	TypeName		GroupBox
					Position		<GroupBoxLeft>, $hGap*3 + 50, <GroupBoxWidth>, <GroupBoxHeight> + 20	// <GroupBoxLeft>, $hGap*3 + 100, <GroupBoxWidth>, <GroupBoxHeight>
					Text			~Balance Options~;
	
			CurrentX = <LeftX> + 30;
			CurrentY = PreviewAllClickBalancesCheckBox(GetBottom,Position) + 25;

			CurrentY = ColorControl( Translate( Red ),Red,$CurrentX,$CurrentY,$hGap,dlgData(GetAttrInfo, Red, LowValue),dlgData(GetAttrInfo, Red, HighValue) );
			CurrentY = ColorControl( Translate( Green ),Green,$CurrentX,$CurrentY,$hGap,dlgData(GetAttrInfo, Green, LowValue),dlgData(GetAttrInfo, Green, HighValue) );
			CurrentY = ColorControl( Translate( Blue ),Blue,$CurrentX,$CurrentY,$hGap,dlgData(GetAttrInfo, Blue, LowValue),dlgData(GetAttrInfo, Blue, HighValue) );

			Define: RGBGroupBox Using DDWinCtrlDef
			Fields:	TypeName		GroupBox
					TOOLTIP			~These controls provide a fine adjustment of the white point used for balance. They do not adjust absolute RGB values. If you wish to adjust absolute RGB values only, then you may use Adjust Images once the image has been rendered to 8-bits.~
					Position		<GroupBoxLeft>, $hGap*3 + 120, <GroupBoxWidth>, <GroupBoxHeight> * 1.6
					Text			~White Point Adjustments~;
		}

	return TRUE;
}

/***************************************************************************************************/
NUMERIC DefineImageAdjustTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	Define: Tab<tab> Using DDWinCtrlDef
			Fields: Text	~Image Adjustment~
			TypeName		Tab
			Tooltip			Translate(~Image Adjustment Controls~)
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "DC_ImageAdjust.htm" )	

		Contains: INLISTORDER
		{
			StaticWidth = 70;	ScanAreaWidth = 50;  ControlWidth = ($ScanAreaWidth)*4;

			Define: ExposurePrompt Using DDWinCtrlDef AsSymbol ExposurePrompt
			Fields: POSITION		<LeftX> + 8, 50, 40,20
					TEXT			~~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText

			Define: ExposureMinStatic Using DDWinCtrlDef AsSymbol ExposureMinStatic
			Fields: POSITION		ExposurePrompt(GetRight,Position) + 4, ExposurePrompt(GetTop,Position), 10,20
					TEXT			~-2~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					IsTabStop		FALSE
					Mask			~#####~
					AllowedChars	~-~
					PromptChar		~ ~
					GENCONFIELD		ExposureMin
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )

			Define: ExposureSlider Using DDWinCtrlDef AsSymbol ExposureSlider
			Fields: DACTIONSTEXT    ACTIONS ( Save "Exec(OnExposureChanged())" Update(ExposureField) )
					GENCONFIELD		Exposure
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		ExposureMinStatic(GetRight,Position) + 4, ExposureMinStatic(GetTop,Position), $ControlWidth,20 
					TOOLTIP			~Adjust Exposure~
					TYPENAME		~SLIDER~ 
					UNITS			.1

			Define: ExposureMaxStatic Using DDWinCtrlDef AsSymbol ExposureMaxStatic
			Fields: POSITION		ExposureSlider(GetRight,Position), ExposureSlider(GetTop,Position),10,20
					TEXT			~2~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					IsTabStop		FALSE
					Mask			~#####~
					AllowedChars	~-~
					PromptChar		~ ~
					GENCONFIELD		ExposureMax
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )

 			Define: ExposureMinusButton Using DDWinCtrlDef AsSymbol ExposureMinusButton
			Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeExposure(-0.1, TRUE); OnExposureChanged();)" Update(ExposureSlider) )
					POSITION		ExposureMaxStatic(GetRight,Position) + $hGap + 10, ExposureMaxStatic(GetTop,Position) - 4, <SmallButtonWidth>, <SmallButtonHeight>
					TOOLTIP			~Decrease the Exposure by 0.1 Stop~
					TYPENAME		~Button~ 
					TEXT			~-~

			Define: ExposurePlusButton Using DDWinCtrlDef AsSymbol ExposurePlusButton
			Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeExposure(0.1, TRUE); OnExposureChanged();)" Update(ExposureSlider) )
					POSITION		ExposureMinusButton(GetRight,Position) + $hGap, ExposureMinusButton(GetTop,Position), <SmallButtonWidth>, <SmallButtonHeight>
					TOOLTIP			~Increase the Exposure by 0.1 Stop~
					TYPENAME		~Button~ 
					TEXT			~+~

			Define: ExposureZeroButton Using DDWinCtrlDef AsSymbol ExposureZeroButton
			Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeExposure(~0~, FALSE))" Update(ExposureSlider) "Exec(OnExposureChanged())")
					POSITION		ExposurePlusButton(GetRight,Position) + $hGap, ExposurePlusButton(GetTop,Position), <SmallButtonWidth>, <SmallButtonHeight>
					TOOLTIP			~Set the Exposure to zero~
					TYPENAME		~Button~ 
					TEXT			~0~;

			Define: ExposureField Using DDWinCtrlDef AsSymbol ExposureField
			Fields: DACTIONSTEXT	ACTIONS ( Save Update(ExposureSlider)  )
					GENCONFIELD		Exposure
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		ExposureZeroButton(GetRight,Position)+$hGap*2,ExposureZeroButton(GetTop,Position)+2, 20, 20 
					TOOLTIP			~Exposure~
					DECIMALPLACES	1
					TYPENAME		StaticText
					
			Define: ExposureGroupBox Using DDWinCtrlDef AsSymbol ExposureGroupBox
			fields:	TypeName		GroupBox
					Position		<GroupBoxLeft>, $hGap*3, <GroupBoxWidth>, <GroupBoxHeight>
					Text			~Exposure Compensation~;


			Define: LookProfilesComboBox Using DDWinCtrlDef AsSymbol LookProfilesComboBox 
			Fields: TypeName        SComboBox
					Position		ExposurePrompt(GetLeft,Position) + 20, ExposureMinStatic(GetBottom, Position) + 30, <EditTextWidth>,<ComboBoxHeight>
					DropDownActionsText	ACTION EXEC ( UpdateLookProfileList(Look, LookProfilesComboBox) )
					DActionsText	ACTIONS ( Save "Exec(OnLookChanged())" )
					OActionsText	ACTIONS ( Save )
					GenConName		THIS
					GenConField		~Look~
					Tooltip			~Select which Look Profile to use.~

			Define: LookGroupBox Using DDWinCtrlDef
			Fields:	TypeName		GroupBox
					Position		<GroupBoxLeft>, ExposureMinStatic(GetBottom, Position) + 10, <GroupBoxWidth>, <GroupBoxHeight>
					Text			~Look Profile Settings~;

			
		xStart = ExposurePrompt(GetLeft,Position);
		yStart = LookProfilesComboBox(GetBottom,Position);	
		}

	return TRUE;
}

/***************************************************************************************************/
NUMERIC DefineFiltersTab ( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	Define: Tab<tab> Using DDWinCtrlDef
			Fields: Text	~Filters~
			TypeName		Tab
			Tooltip			Translate(~Image Filter Modifications~)
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "DC_Filters.htm" )	

		Contains: INLISTORDER
		{
			xStart = $x;
			yStart = $y;

			yStart = NoiseReductionButtons(<tab>,x,y,hGap,vGap,TabWidth,TabHeight,xStart,yStart,200);

			yStart = SharpenButtons(<tab>,x,y,hGap,vGap,TabWidth,TabHeight,xStart,yStart,200 );
		}

	return TRUE;
}

/***************************************************************************************************/
NUMERIC NoiseReductionButtons(tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight,&xstart,&ystart,ControlWidth)
{
		Define: HighResNoteStatic Using DDWinCtrlDef AsSymbol HighResNoteStatic
		Fields: Position		<LeftX> + 10, 35, 450, 30
				TEXT			~Note: Noise Reduction and Sharpening are only applied when rendering to an 8-bit file or when previewing at the highest resolution.~
				RIGHTJUSTIFIED	FALSE
				TYPENAME		StaticText

		Define: NoiseReductionComboBox Using DDWinCtrlDef AsSymbol NoiseReductionComboBox 
				Fields: TypeName		SComboBox 
						Position		<LeftX> + 50, HighResNoteStatic(GetBottom, Position) + 17, 300, 150
						IActionsText    ~[Get]~
						DActionsText	~[Save Exec("OnNoiseReductionChanged()")]~
						OActionsText    ~[Save]~
						GenConName       THIS
						GenConField      ~NRType~
						Tooltip          ~Adjusts the file's Noise Reduction Type~

			Define: ThresholdStatic Using DDWinCtrlDef AsSymbol ThresholdStatic
			Fields: POSITION		<LeftX> + 15, NoiseReductionComboBox(GetTop, Position) + $vGap*3, 100, 20
					TEXT			~Strength/Threshold:~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
		
			Define: NRThresholdCurrentStatic Using DDWinCtrlDef AsSymbol NRThresholdCurrentStatic
			Fields: POSITION		ThresholdStatic(GetRight,Position) + 15, ThresholdStatic(GetTop,Position), 15, 20
					DACTIONSTEXT	ACTIONS ( Save Update(ThresholdSlider)  )
					GENCONFIELD		NRStrengthThreshold
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					TOOLTIP			~The current Noise Reduction Strength/Threshold~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText

			Define: ThresholdSlider Using DDWinCtrlDef AsSymbol ThresholdSlider
			Fields: GENCONFIELD		NRStrengthThreshold
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save Exec("OnNRStrengthThresholdChanged()") Update(NRThresholdCurrentStatic))
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		NRThresholdCurrentStatic(GetRight, Position) + 50, NRThresholdCurrentStatic(GetTop, Position), $ControlWidth, 20
					TOOLTIP			~Adjusts the Noise Reduction Strength or Threshold~
					TYPENAME		~SLIDER~ 
					UNITS			1

			Define: ZeroStaticOne Using DDWinCtrlDef AsSymbol ZeroStaticOne
			Fields: POSITION		NRThresholdCurrentStatic(GetRight,Position) + 35, NRThresholdCurrentStatic(GetTop,Position), 15, 20
					TEXT			~0%~
					RIGHTJUSTIFIED	FALSE
					TYPENAME		StaticText

			Define: HundredStaticOne Using DDWinCtrlDef AsSymbol HundredStaticOne
			Fields: POSITION		ThresholdSlider(GetRight, Position) + 5, ThresholdSlider(GetTop, Position), 30,20
					TEXT			~100%~
					RIGHTJUSTIFIED	FALSE
					TYPENAME		StaticText

// NOTE: Do like so in order to swap:
//	dlg(ShowControls, TRUE, RadiusStatic, RadiusSlider);
//	dlg(ShowControls, FALSE, ThresholdStatic, ThresholdSlider);

			Define: RadiusStatic Using DDWinCtrlDef AsSymbol RadiusStatic
			Fields: POSITION		ThresholdStatic(GetLeft, Position), ZeroStaticOne(GetBottom, Position) + 5, 100, 20
					TEXT			~Radius:~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText

			Define: NRRadiusCurrentStatic Using DDWinCtrlDef AsSymbol NRRadiusCurrentStatic
			Fields: POSITION		RadiusStatic(GetRight,Position) + 15, RadiusStatic(GetTop,Position), 15, 20
					DACTIONSTEXT	ACTIONS ( Save Update(RadiusSlider)  )
					GENCONFIELD		NRRadius
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					TOOLTIP			~Radius~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText

			Define: RadiusSlider Using DDWinCtrlDef AsSymbol RadiusSlider
			Fields: GENCONFIELD		NRRadius
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save Exec("OnNRRadiusChanged()") Update(NRRadiusCurrentStatic))
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		ThresholdSlider(GetLeft, Position), NRRadiusCurrentStatic(GetTop, Position), $ControlWidth, 20 
					TOOLTIP			~Adjusts the Noise Reduction Radius~
					TYPENAME		~SLIDER~ 
					UNITS			1

			Define: ZeroStaticTwo Using DDWinCtrlDef AsSymbol ZeroStaticTwo
			Fields: POSITION		ZeroStaticOne(GetLeft,Position), NRRadiusCurrentStatic(GetTop,Position), 15,20
					TEXT			~0%~
					RIGHTJUSTIFIED	FALSE
					TYPENAME		StaticText

			Define: HundredStaticTwo Using DDWinCtrlDef AsSymbol HundredStaticTwo
			Fields: POSITION		RadiusSlider(GetRight, Position) + 5, RadiusSlider(GetTop, Position), 30,20
					TEXT			~100%~
					RIGHTJUSTIFIED	FALSE
					TYPENAME		StaticText

			Define: NoiseReductionGroupBox Using DDWinCtrlDef
			Fields:	TypeName		GroupBox
					Position		<GroupBoxLeft>, $hGap*3+37, <GroupBoxWidth>, <GroupBoxHeight> + 45
					Text			~Noise Reduction~;

		return (HundredStaticTwo(GetBottom, Position) + 5);
}

/***************************************************************************************************/
NUMERIC SharpenButtons(tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight,&xstart,&ystart,ControlWidth)
{
			Define: SharpenDisabledStatic Using DDWinCtrlDef AsSymbol SharpenDisabledStatic
			Fields: POSITION		$xstart + $hGap+13, $ystart + $vGap*2, 400, 70 
					TEXT			~Raw camera file sharpening is disabled. In order to enable it, see the checkbox on the Output tab. DP2 will only sharpen your converted Raw camera files at output time.~
					RIGHTJUSTIFIED	FALSE
					TYPENAME		StaticText

			Define: SharpenAmountText Using DDWinCtrlDef AsSymbol SharpenAmountText
			Fields: POSITION		$xstart + $hGap + 17, $ystart + $vGap*2, 40, 20
					TEXT			~Amount:~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: SharpenAmountCurrentText Using DDWinCtrlDef AsSymbol SharpenAmountCurrentText
			Fields: POSITION		SharpenAmountText(GetRight, Position) + 20, SharpenAmountText(GetTop, Position), 20, 20
					GenConName		THIS
					GenConField		AppSharpenAmount
					IACTIONSTEXT	ACTIONS ( Get )
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: SharpenAmountMinText Using DDWinCtrlDef AsSymbol SharpenAmountMinText
			Fields: POSITION		SharpenAmountCurrentText(GetRight, Position) + 45, SharpenAmountCurrentText(GetTop, Position), 15, 20
					GenConName		THIS
					GenConField		AppSharpAmountMin
					IACTIONSTEXT	ACTIONS ( Get )
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: AppSharpenAmountSlider Using DDWinCtrlDef AsSymbol AppSharpenAmountSlider
			Fields: GENCONFIELD		AppSharpenAmount
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Exec("OnAppSharpenAmountChanged()") Update(SharpenAmountCurrentText))
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		SharpenAmountMinText(GetRight, Position) + 5, SharpenAmountMinText(GetTop, Position), 270, 20
					TOOLTIP			~Adjusts the Sharpening Amount~
					TYPENAME		~SLIDER~ 
					UNITS			1
					ISHIDDEN		T

			Define: SharpenAmountMaxText Using DDWinCtrlDef AsSymbol SharpenAmountMaxText
			Fields: POSITION		AppSharpenAmountSlider(GetRight, Position) + 3, AppSharpenAmountSlider(GetTop, Position), 20, 20
					GenConName		THIS
					GenConField		AppSharpAmountMax
					IACTIONSTEXT	ACTIONS ( Get )
					TYPENAME		StaticText
					ISHIDDEN		T

///// RADIUS

			Define: SharpenRadiusText Using DDWinCtrlDef AsSymbol SharpenRadiusText
			Fields: POSITION		SharpenAmountText(GetLeft, Position), SharpenAmountText(GetBottom, Position) + 5, 40, 20
					TEXT			~Radius:~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: SharpenRadiusCurrentText Using DDWinCtrlDef AsSymbol SharpenRadiusCurrentText
			Fields: POSITION		SharpenRadiusText(GetRight, Position) + 20, SharpenRadiusText(GetTop, Position), 20, 20
					GenConName		THIS
					GenConField		AppSharpenRadius
					IACTIONSTEXT	ACTIONS ( Get )
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T
					DECIMALPLACES	1

			Define: SharpenRadiusMinText Using DDWinCtrlDef AsSymbol SharpenRadiusMinText
			Fields: POSITION		SharpenRadiusCurrentText(GetRight, Position) + 45, SharpenRadiusCurrentText(GetTop, Position), 15, 20
					GenConName		THIS
					GenConField		AppSharpRadiusMin
					IACTIONSTEXT	ACTIONS ( Get )
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: AppSharpenRadiusSlider Using DDWinCtrlDef AsSymbol AppSharpenRadiusSlider
			Fields: GENCONFIELD		AppSharpenRadius
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Exec("OnAppSharpenRadiusChanged()") Update(SharpenRadiusCurrentText))
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		SharpenRadiusMinText(GetRight, Position) + 5, SharpenRadiusMinText(GetTop, Position), 270, 20
					TOOLTIP			~Adjusts the Sharpening Radius~
					TYPENAME		~SLIDER~ 
					UNITS			.1
					Mask			~###.#~
					ISHIDDEN		T

			Define: SharpenRadiusMaxText Using DDWinCtrlDef AsSymbol SharpenRadiusMaxText
			Fields: POSITION		AppSharpenRadiusSlider(GetRight, Position) + 3, AppSharpenRadiusSlider(GetTop, Position), 20, 20
					GenConName		THIS
					GenConField		AppSharpRadiusMax
					IACTIONSTEXT	ACTIONS ( Get )
					TYPENAME		StaticText
					ISHIDDEN		T

////////// THRESHOLD

			Define: SharpenThresholdText Using DDWinCtrlDef AsSymbol SharpenThresholdText
			Fields: POSITION		SharpenAmountText(GetLeft, Position) - 10, SharpenRadiusText(GetBottom, Position) + 5, 50, 20
					TEXT			~Threshold:~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: SharpenThresholdCurrentText Using DDWinCtrlDef AsSymbol SharpenThresholdCurrentText
			Fields: POSITION		SharpenThresholdText(GetRight, Position) + 20, SharpenThresholdText(GetTop, Position), 20, 20
					GenConName		THIS
					GenConField		AppSharpenThreshold
					IACTIONSTEXT	ACTIONS ( Get )
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: SharpenThresholdMinText Using DDWinCtrlDef AsSymbol SharpenThresholdMinText
			Fields: POSITION		SharpenThresholdCurrentText(GetRight, Position) + 45, SharpenThresholdCurrentText(GetTop, Position), 15, 20
					GenConName		THIS
					GenConField		AppSharpThresholdMin
					IACTIONSTEXT	ACTIONS ( Get )
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: AppSharpenThresholdSlider Using DDWinCtrlDef AsSymbol AppSharpenThresholdSlider
			Fields: GENCONFIELD		AppSharpenThreshold
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Exec("OnAppSharpenThresholdChanged()") Update(SharpenThresholdCurrentText))
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		SharpenThresholdMinText(GetRight, Position) + 5, SharpenThresholdMinText(GetTop, Position), 270, 20
					TOOLTIP			~Adjusts the Sharpening Threshold~
					TYPENAME		~SLIDER~ 
					UNITS			1
					ISHIDDEN		T

			Define: SharpenThresholdMaxText Using DDWinCtrlDef AsSymbol SharpenThresholdMaxText
			Fields: POSITION		AppSharpenThresholdSlider(GetRight, Position) + 3, AppSharpenThresholdSlider(GetTop, Position), 20, 20
					GenConName		THIS
					GenConField		AppSharpThresholdMax
					IACTIONSTEXT	ACTIONS ( Get )
					TYPENAME		StaticText
					ISHIDDEN		T

			Define: SharpenGroupBox Using DDWinCtrlDef AsSymbol SharpenGroupBox
			Fields:	TypeName		GroupBox
					Position		<GroupBoxLeft>, $ystart,  <GroupBoxWidth>, <GroupBoxHeight> + 50
					Text			~Sharpening~;

		Return AppSharpenThresholdSlider(GetBottom,Position);
}

/***************************************************************************************************/
NUMERIC DefineOutputTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	Define: Tab<tab> Using DDWinCtrlDef
			Fields: Text	~Output~
			TypeName		Tab
			Tooltip			Translate(~Setup Output File Type~)
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "DC_OutputFileType.htm" )	

		Contains: INLISTORDER
		{
			Define: FileTypeStaticText Using DDWinCtrlDef AsSymbol FileTypeStaticText 
					Fields: TypeName        StaticText
							Text            ~File Type~
							RightJustified	TRUE
							Position        <LeftX> + 8, $hGap*4 + 16, 85, 20

			Define: FileTypeComboBox Using DDWinCtrlDef AsSymbol FileTypeComboBox 
					Fields: TypeName		SComboBox 
							Position		FileTypeStaticText(GetRight,Position) + $hGap, FileTypeStaticText(Gettop,Position),100 ,20*8 
							IActionsText    ~[GetList(CameraOutputFileTypes) Get]~
							DActionsText	~[Save Exec("OnFileTypeChange(FALSE)")]~
							OActionsText    ~[Save]~
							GenConName       THIS
							GenConField      ~SaveFileType~
							Tooltip          ~Select a file type~

			Define: ExtensionPrompt Using DDWinCtrlDef AsSymbol ExtensionPrompt 
					Fields: TypeName		StaticText
							Text			~Extension~
							RightJustified	TRUE
							Position		FileTypeStaticText(GetLeft,Position),FileTypeStaticText(GetBottom,Position) + $vGap, 85,20
 		
			Define: ExtensionField Using DDWinCtrlDef AsSymbol ExtensionField 
					Fields: TypeName		MaskedEditText  
							POSITION		FileTypeComboBox(GetLeft,Position),ExtensionPrompt(Gettop,Position),100 ,20 
							DACTIONSTEXT	~[Save]~
							IACTIONSTEXT    ~[Get]~
							OACTIONSTEXT    ~[Save]~
							GENCONNAME       THIS
							GENCONFIELD      ~FileExtension~
							MASK			~%%%%%%~
							PROMPTCHAR		~ ~		
							TOOLTIP			~Extension to concatenate to the file name (ex.  .jpg  .tif)~;
		
			Define: JPEGQualityPrompt Using DDWinCtrlDef AsSymbol JPEGQualityPrompt
					Fields:	TYPENAME		StaticText
							POSITION		FileTypeComboBox(GetRight,Position) + $hGap + 10,FileTypeComboBox(GetTop,Position) + 3 ,70,20
							TEXT			~JPEG Quality~

			Define: JPEGQualityField Using DDWinCtrlDef AsSymbol JPEGQualityField
					Fields:	DACTIONSTEXT	ACTIONS ( Save Update(JPEGQualitySlider) "Exec(AuditField(JPEGQualityField,0,100,100, JPEGQuality);)" )
							GENCONFIELD		~JPEGQuality~
							GENCONNAME		THIS
							IACTIONSTEXT	ACTIONS ( Get )
							OACTIONSTEXT	ACTIONS ( Save )
							POSITION		JPEGQualityPrompt(GetRight,Position),FileTypeComboBox(GetTop,Position),30,20
							TEXT			~~
							TOOLTIP			~Adjust the quality of the JPEG output file~
							TYPENAME		MaskedEditText
							Mask			~###~
							PromptChar		~ ~ 
							IsTabStop		T;

			Define: JPEGQualityMinStatic Using DDWinCtrlDef AsSymbol JPEGQualityMinStatic
					Fields: POSITION		JPEGQualityField(GetRight,Position) + 8, JPEGQualityField(GetTop,Position) + 3, 10,20
							TEXT			~0~
							RIGHTJUSTIFIED	TRUE
							TYPENAME		StaticText;

			Define: JPEGQualitySlider Using DDWinCtrlDef AsSymbol JPEGQualitySlider
					Fields:	DACTIONSTEXT	ACTIONS ( Save Update(JPEGQualityField) )
							GENCONFIELD		~JPEGQuality~
							GENCONNAME		THIS
							IACTIONSTEXT	ACTIONS ( Get )
							OACTIONSTEXT	ACTIONS ( Save )
							POSITION		JPEGQualityMinStatic(GetRight,Position) + 2,JPEGQualityField(GetTop,Position),80, 20
							TOOLTIP			~Adjust the quality of the JPEG output file~
							TYPENAME		~SLIDER~ 
							UNITS			1;

			Define: JPEGQualityMaxStatic Using DDWinCtrlDef AsSymbol JPEGQualityMaxStatic
					Fields: POSITION		JPEGQualitySlider(GetRight,Position), JPEGQualitySlider(GetTop,Position) + 3, 20,20
							TEXT			~100~
							LEFTJUSTIFIED	TRUE
							TYPENAME		StaticText;


			Define: EnableRawFileSharpeningCheckBox Using DDWinCtrlDef AsSymbol EnableRawFileSharpeningCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	ExtensionPrompt(GetLeft, Position), ExtensionField(GetBottom,Position) + 3, 15, 15
					GENCONFIELD ~EnableRawFileSharpening~
					GENCONNAME	THIS
					TEXT		~~
					DActionsText ~[ Save "Exec(OnEnableRawFileSharpeningChanged())" ]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
 					TOOLTIP		~Enable Raw Camera File Sharpening. Images will be sharpened on conversion to 8-bits as well as at output.~;

			Define: EnableRawFileSharpeningStatic Using DDWinCtrlDef AsSymbol EnableRawFileSharpeningStatic
			Fields: TYPENAME		StaticText
					DActionsText	~[ Save "Exec(OnEnableRawFileSharpeningText())" ]~
					POSITION		EnableRawFileSharpeningCheckBox(GetRight,Position) + 4, EnableRawFileSharpeningCheckBox(GetTop, Position) + 1, 400, 27
					TEXT			~Enable Raw Camera File Sharpening. Images will be sharpened on conversion to 8-bits as well as at output.~
					TOOLTIP			~Enable Raw Camera File Sharpening. Images will be sharpened on conversion to 8-bits as well as at output.~;

			Define: OverrideDeltaSharpeningCheckBox Using DDWinCtrlDef AsSymbol OverrideDeltaSharpeningCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	EnableRawFileSharpeningCheckBox(GetLeft, Position), EnableRawFileSharpeningCheckBox(GetBottom,Position) + 15, 260, 20
					GENCONFIELD ~OverrideDeltaSharpening~
					GENCONNAME	THIS
					TEXT		~Override the current Delta Sharpening setting with: ~
					DActionsText ~[ Save "Exec(OnOverrideDeltaSharpeningChanged())" ]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
					TOOLTIP		~Allows you to specify a delta sharpening amount to be associated with the 8-bit output file.~

			Define: DeltaSharpeningField Using DDWinCtrlDef AsSymbol DeltaSharpeningField 
			Fields: TypeName		MaskedEditText  
					POSITION		OverrideDeltaSharpeningCheckBox(GetRight,Position), OverrideDeltaSharpeningCheckBox(GetTop,Position), 50,20 
					DACTIONSTEXT	ACTIONS ( Save "Exec(AuditField(DeltaSharpeningField, -300, 300, 0, DeltaSharpeningValue);)" )
					IACTIONSTEXT    ~[Get]~
					OACTIONSTEXT    ~[Save]~
					GENCONNAME		THIS
					GENCONFIELD		~DeltaSharpeningValue~
					MASK			~#####~
					AllowedChars	~-~
					PROMPTCHAR		~ ~
					TOOLTIP			~Specify a delta sharpening amount to be associated with the 8-bit output file. This value will overwrite any existing delta sharpening value. Range is -300 to +300.~;

			// OUTPUT PROFILE SELECTION
			Define: UseWorkingSpaceRadioButton Using DDWinCtrlDef AsSymbol UseWorkingSpaceRadioButton
			Fields:	POSITION		OverrideDeltaSharpeningCheckBox(GetLeft,Position) + 20, OverrideDeltaSharpeningCheckBox(GetBottom,Position) + $hGap + 7, 250, 20
					TOOLTIP			~Choose if you would like to use DP2's current Working Space Profile as the output profile for conversion of the raw camera file to an 8-bit image. If no Working Space Profile is configured, then SRGB will be used.~
					TYPENAME		~RadioButton~ 
					TEXT			~Use DP2's current Working Space Profile~
					RADIOTRUEVALUE	~1~
					GENCONNAME		THIS
					GENCONFIELD		~UseWorkingspaceProfile~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( UncheckButton(UseDifferentProfileRadioButton) CheckButton(UseWorkingSpaceRadioButton) "Exec(OnOutputProfileChanged())")
					OACTIONSTEXT	ACTIONS ( Save )

			Define: UseDifferentProfileRadioButton Using DDWinCtrlDef AsSymbol UseDifferentProfileRadioButton
			Fields:	POSITION		UseWorkingSpaceRadioButton(GetLeft,Position), UseWorkingSpaceRadioButton(GetBottom,Position), 130, 20
					TOOLTIP			~Choose if you would like to specify a different Working Space Profile to use as the output profile for conversion of the raw camera file to an 8-bit image~
					TYPENAME		~RadioButton~ 
					TEXT			~Use Alternate Profile:~
					RADIOTRUEVALUE	~0~
					GENCONNAME		THIS
					GENCONFIELD		~UseWorkingspaceProfile~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( UncheckButton(UseWorkingSpaceRadioButton) CheckButton(UseDifferentProfileRadioButton) "Exec(OnOutputProfileChanged())")
					OACTIONSTEXT	ACTIONS ( Save )

			Define: ProfileComboBox Using DDWinCtrlDef AsSymbol ProfileComboBox
			Fields:	TypeName		SComboBox
					Position		UseDifferentProfileRadioButton(GetRight,Position), UseDifferentProfileRadioButton(GetTop,Position), <EditTextWidth>,200
					DActionsText	ACTIONS ( Save )
					GenConName		THIS
					GenConField		AlternateOutputProfile
					IsTabStop		1
					DropDownActionsText ACTION CALL ( RefreshProfilesComboBox() )
					Tooltip			~Choose the profile to use as the output profile for conversion of the raw camera file to an 8-bit image~;

			Define: OutputProfileGroupBox Using DDWinCtrlDef
			Fields:	TypeName	GroupBox
					Position	<GroupBoxLeft>, OverrideDeltaSharpeningCheckBox(GetBottom, Position),  <GroupBoxWidth>, 65
					Text		~Output Profile Selection~

			// SETUPS
			Define: LoadDCSetupsButton Using DDWinCtrlDef AsSymbol LoadDCSetupsButton 
				Fields: TypeName		Button
						Text			~Load Setup~
						DActionsText	ACTION EXEC ( OnLoadSetupButton(TRUE) )
						Tooltip			~Load the settings stored in the currently selected setup.~
						Position		<LeftX> + 8, UseDifferentProfileRadioButton(GetBottom, Position) + $hGap + 10, 75, <SmallButtonHeight>

			Define: DCSetupsComboBox Using DDWinCtrlDef AsSymbol DCSetupsComboBox 
				Fields: TypeName        ComboBox  
						Position		LoadDCSetupsButton(GetRight,Position) + $hGap, LoadDCSetupsButton(GetTop,Position),<EditTextWidth>,<ComboBoxHeight>
						DropDownActionsText	ACTION EXEC ( UpdateSetupsList(DCSetup, DCSetupsComboBox) )
						DActionsText	ACTIONS ( Save )
						OActionsText	ACTIONS ( Save )
						GenConName		THIS
						GenConField		~DCSetup~
						Mask			~<$[DATABASE FieldTypes].ScanSetupName[Mask]>~
						PromptChar		~<$[DATABASE FieldTypes].ScanSetupName[PromptChar]>~
						AllowedChars	~<$[DATABASE FieldTypes].ScanSetupName[AllowedChars]>~
						DisallowedChars ~<$[DATABASE FieldTypes].ScanSetupName[DisallowedChars]>~
						Tooltip			~Choose a setup to load here. The setup will be loaded when you press the 'Load Setup' button. Type in a name to create a new setup.~

			Define: EditSetups_Button Using DDWinCtrlDef AsSymbol EditSetups_Button 
				Fields:	TypeName		Button
						Text			Translate( ~?~ )
						Position		DCSetupsComboBox(GetRight,Position)+$hGap,DCSetupsComboBox(GetTop,Position), <SmallButtonWidth>, <SmallButtonHeight>
						DActionsText	ACTION EXEC  ( OnEditSetups() ) 
						Tooltip			Translate( ~View Setups~ );

			Define: SaveSetup_Button Using DDWinCtrlDef AsSymbol SaveSetup_Button 
				Fields:	TypeName		Button
						Text			Translate( ~Save~ )
						Position		EditSetups_Button(GetRight,Position) + $hGap,EditSetups_Button(GetTop,Position), <ButtonWidth>,<SmallButtonHeight>
						DActionsText	ACTION EXEC ( OnSaveDCSetup() ) 
						Tooltip			Translate( ~Save the current settings in the selected setup.~ );


//			yStart = LoadDCSetupsButton(GetBottom, Position);
//			xStart = <LeftX>;
//			SharpenButtons(<++tab>,x,y,hGap,vGap,TabWidth,TabHeight,xStart,yStart,200 );
		}

	return TRUE;
}

/***************************************************************************************************/
NUMERIC DefineDCQueueOptionsTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	Define: Tab<tab> Using DDWinCtrlDef
			Fields: Text	~Queue Options~
			TypeName		Tab
			Tooltip			Translate(~Specify Background Queue Processing Options~)
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "DC_QueueOptions.htm" )

		Contains: INLISTORDER
		{
			/**** Auto Queue on Import Images Checkbox ****/
			Define: AutoQueueOnImportCheckBox Using DDWinCtrlDef AsSymbol AutoQueueOnImportCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	<LeftX> + 12, 50, 15, 15
					GENCONFIELD ~AutoQueueOnImport~
					GENCONNAME	THIS
					TEXT		~~
					DActionsText ~[ Save "Exec(OnAutoQueueImportChanged())" ]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
 					TOOLTIP		~Automatically queue Kodak raw camera files for conversion when importing through Import Images.~;

			Define: QueueOnImportStatic Using DDWinCtrlDef AsSymbol QueueOnImportStatic
			Fields: TYPENAME		StaticText
					DActionsText	~[ Save "Exec(OnAutoQueueImportText())" ]~
					POSITION		AutoQueueOnImportCheckBox(GetRight,Position) + 4, AutoQueueOnImportCheckBox(GetTop, Position) + 1, 400, 27
					TEXT			~Automatically queue Kodak raw camera files for conversion when importing through Import Images.~
					TOOLTIP			~Automatically queue Kodak raw camera files for conversion when importing through Import Images.~;

			Define: QueueOnImportSetupStatic Using DDWinCtrlDef AsSymbol QueueOnImportSetupStatic
			Fields: TYPENAME		StaticText
					POSITION		QueueOnImportStatic(GetLeft,Position), QueueOnImportStatic(GetBottom, Position) + 3, 90, 20
					TEXT			~Setup to use:~
					TOOLTIP			~Specify the setup to use when automatically queueing images for processing.~

			Define: ImportSetupsComboBox Using DDWinCtrlDef AsSymbol ImportSetupsComboBox
				Fields: TypeName        SComboBox  
						Position		AutoQueueOnImportCheckBox(GetRight,Position) + 90, AutoQueueOnImportCheckBox(GetBottom,Position) + $hGap,<EditTextWidth>,<ComboBoxHeight>
						DropDownActionsText	ACTION EXEC ( UpdateSetupsList(ImportSetup, ImportSetupsComboBox) )
						DActionsText	ACTIONS ( Save "Exec(OnImportSetupsComboChanged())")
						OActionsText	ACTIONS ( Save )
						GenConName		THIS
						GenConField		~ImportSetup~
						Mask			~<$[DATABASE FieldTypes].ScanSetupName[Mask]>~
						PromptChar		~<$[DATABASE FieldTypes].ScanSetupName[PromptChar]>~
						AllowedChars	~<$[DATABASE FieldTypes].ScanSetupName[AllowedChars]>~
						DisallowedChars ~<$[DATABASE FieldTypes].ScanSetupName[DisallowedChars]>~
						TOOLTIP			~Specify the setup to use when automatically queueing images for processing.~

			Define: EditImportSetups_Button Using DDWinCtrlDef AsSymbol EditImportSetups_Button 
				Fields:	TypeName		Button
						Text			Translate( ~?~ )
						Position		ImportSetupsComboBox(GetRight,Position)+$vGap, ImportSetupsComboBox(GetTop,Position), <SmallButtonWidth>, <SmallButtonHeight>
						DActionsText	ACTION EXEC  ( OnEditSetups() ) 
						Tooltip			Translate( ~View Setups~ );

			/**** Auto Queue on Cmds Import Checkbox ***/
 			Define: AutoQueueOnCmdsCheckBox Using DDWinCtrlDef AsSymbol AutoQueueOnCmdsCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	AutoQueueOnImportCheckBox(GetLeft, Position), ImportSetupsComboBox(GetTop, Position) + 28, 15, 15
					GENCONFIELD ~AutoQueueOnCmds~
					GENCONNAME	THIS
					DActionsText ~[Save "Exec(OnAutoQueueCmdsChanged())"]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
					TEXT		~~
					TOOLTIP		~Automatically queue Kodak raw camera files for conversion when imported through a commands script.~

			Define: QueueOnCmdsStatic Using DDWinCtrlDef AsSymbol QueueOnCmdsStatic
			Fields: TYPENAME		StaticText
					DActionsText	~[ Save "Exec(OnAutoQueueCmdsText())" ]~
					POSITION		AutoQueueOnCmdsCheckBox(GetRight,Position) + 4, AutoQueueOnCmdsCheckBox(GetTop, Position) + 1, 400, 27
					TEXT			~Automatically queue Kodak raw camera files for conversion when imported through a commands script.~
					TOOLTIP			~Automatically queue Kodak raw camera files for conversion when imported through a commands script.~

			Define: QueueOnCommandsSetupStatic Using DDWinCtrlDef AsSymbol QueueOnCommandsSetupStatic
			Fields: TYPENAME		StaticText
					POSITION		QueueOnCmdsStatic(GetLeft,Position), QueueOnCmdsStatic(GetBottom, Position) + 3, 90, 20
					TEXT			~Setup to use:~
					TOOLTIP			~Specify the setup to use when automatically queueing images for processing.~

			Define: CommandsSetupsComboBox Using DDWinCtrlDef AsSymbol CommandsSetupsComboBox
				Fields: TypeName        SComboBox
						Position		AutoQueueOnCmdsCheckBox(GetRight,Position) + 90, AutoQueueOnCmdsCheckBox(GetBottom,Position) + $hGap,<EditTextWidth>,<ComboBoxHeight>
						DropDownActionsText	ACTION EXEC ( UpdateSetupsList(CommandsSetup, CommandsSetupsComboBox) )
						DActionsText	ACTIONS ( Save "Exec(OnCommandsSetupsComboChanged())")
						OActionsText	ACTIONS ( Save )
						GenConName		THIS
						GenConField		~CommandsSetup~
						Mask			~<$[DATABASE FieldTypes].ScanSetupName[Mask]>~
						PromptChar		~<$[DATABASE FieldTypes].ScanSetupName[PromptChar]>~
						AllowedChars	~<$[DATABASE FieldTypes].ScanSetupName[AllowedChars]>~
						DisallowedChars ~<$[DATABASE FieldTypes].ScanSetupName[DisallowedChars]>~
						TOOLTIP			~Specify the setup to use when automatically queueing images for processing.~

			Define: EditCommandsSetups_Button Using DDWinCtrlDef AsSymbol EditCommandsSetups_Button 
				Fields:	TypeName		Button
						Text			Translate( ~?~ )
						Position		CommandsSetupsComboBox(GetRight,Position)+$vGap, CommandsSetupsComboBox(GetTop,Position), <SmallButtonWidth>, <SmallButtonHeight>
						DActionsText	ACTION EXEC  ( OnEditSetups() ) 
						Tooltip			Translate( ~View Setups~ );


			/**** Auto Start Background Queue ***/
			Define: BKQueueAutoStartCheckBox Using DDWinCtrlDef AsSymbol BKQueueAutoStartCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	AutoQueueOnCmdsCheckBox(GetLeft, Position), CommandsSetupsComboBox(GetTop, Position) + 28, 15, 15
					GENCONFIELD ~AutoStartBackgroundQueue~
					GENCONNAME	THIS
					DActionsText ~[Save "Exec(OnAutoStartChanged())"]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
					TEXT		~~
					TOOLTIP		~Automatically start the background queue processor when starting DP2.~

			Define: BackgroundQueueAutoStartStatic Using DDWinCtrlDef AsSymbol BackgroundQueueAutoStartStatic
			Fields: POSITION		BKQueueAutoStartCheckBox(GetRight,Position) + 4, BKQueueAutoStartCheckBox(GetTop, Position) + 1, 400, 14
					DActionsText	~[ Save "Exec(OnBkgrndQueueAutoStartText())" ]~
					TEXT			~Automatically start the background queue processor when starting DP2.~
					TOOLTIP			~Automatically start the background queue processor when starting DP2.~
					TYPENAME		StaticText

			/**** Timer Interval Slider & Activation Button ****/
			Define: TimerIntervalStatic Using DDWinCtrlDef AsSymbol TimerIntervalStatic
			Fields: POSITION		BKQueueAutoStartCheckBox(GetLeft,Position), BKQueueAutoStartCheckBox(GetBottom,Position) + 15, 70, 20
					TEXT			~Timer Interval:~
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					TYPENAME		StaticText
					TOOLTIP			~Specify the timer interval used by the background processing queue.~

			Define: TimerIntervalField Using DDWinCtrlDef AsSymbol TimerIntervalField
			Fields: POSITION		TimerIntervalStatic(GetRight,Position), BKQueueAutoStartCheckBox(GetBottom,Position) + 15, 20, 20
					GENCONFIELD		~QueueTimerInterval~
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					TYPENAME		StaticText
					TOOLTIP			~Specify the timer interval used by the background processing queue.~

			Define: TimerUnitsStatic Using DDWinCtrlDef AsSymbol TimerUnitsStatic
			Fields: POSITION		TimerIntervalField(GetRight,Position), BKQueueAutoStartCheckBox(GetBottom,Position) + 15, 43, 20
					TEXT			~Seconds~
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					TYPENAME		StaticText
								
			Define: BackgroundQueueTimerSlider Using DDWinCtrlDef AsSymbol BackgroundQueueTimerSlider
			Fields: DACTIONSTEXT    ACTIONS ( Save Update(TimerIntervalField) "Exec(OnBackgroundQueueTimerChanged())" )
					GENCONFIELD		~QueueTimerInterval~
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		TimerUnitsStatic(GetRight,Position), BKQueueAutoStartCheckBox(GetBottom,Position) + 15, 200, 20
					TOOLTIP			~Specify the timer interval used by the background processing queue.~
					TYPENAME		~SLIDER~
					UNITS			1;

			Define: ApplyTimerValueButton Using DDWinCtrlDef AsSymbol ApplyTimerValueButton
			Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ApplyTimerValue())" )
					POSITION		BackgroundQueueTimerSlider(GetRight,Position) + 8, BackgroundQueueTimerSlider(GetTop, Position), 85, <SmallButtonHeight>
					TOOLTIP			~Apply the new background queue timer interval.~
					TYPENAME		~Button~
					TEXT			~Save and Apply~

			Define: BackgroundQueueGroupBox Using DDWinCtrlDef
			Fields:	TypeName	GroupBox
					Position	<GroupBoxLeft>, $hGap*3,  <GroupBoxWidth>, 190
					Text		~Background Processing Queue Controls~
	}

	return TRUE;
}

/***************************************************************************************************/
NUMERIC DefineDCOptionsTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	Define: Tab<tab> Using DDWinCtrlDef
			Fields: Text	~General Options~
			TypeName		Tab
			Tooltip			Translate(~Specify Kodak DCR Import Options~)
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "DC_GeneralOptions.htm" )

		Contains: INLISTORDER
		{
			/**** Load Image Description Controls ****/
			Define: LoadImageDescriptionCheckBox Using DDWinCtrlDef AsSymbol LoadImageDescriptionCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	<LeftX> + 12, 50, 15, 15
					GENCONFIELD ~LoadImageDescription~
					GENCONNAME	THIS
					TEXT		~~
					DActionsText ~[ Save "Exec(OnLoadImageDescriptionChanged())" ]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
 					TOOLTIP		~Automatically load the Image Description field from the raw camera metadata into the selected database field when processing.~;

			Define: LoadImageDescriptionStatic Using DDWinCtrlDef AsSymbol LoadImageDescriptionStatic
			Fields: TYPENAME		StaticText
					DActionsText	~[ Save "Exec(OnLoadImageDescriptionText())" ]~
					POSITION		LoadImageDescriptionCheckBox(GetRight,Position) + 4, LoadImageDescriptionCheckBox(GetTop, Position) + 1, 400, 27
					TEXT			~Automatically load the Image Description field from the raw camera metadata into the selected database field when processing.~
					TOOLTIP			~Automatically load the Image Description field from the raw camera metadata into the selected database field when processing.~;

			Define: LoadImageDescriptionSetupStatic Using DDWinCtrlDef AsSymbol LoadImageDescriptionSetupStatic
			Fields: TYPENAME		StaticText
					POSITION		LoadImageDescriptionStatic(GetLeft,Position), LoadImageDescriptionStatic(GetBottom, Position) + 11, 90, 20
					TEXT			~Images table field:~
					TOOLTIP			~Specifies the field in the Images table into which the Image Description information should be loaded.~

			Define: ImageDescriptionComboBox Using DDWinCtrlDef AsSymbol ImageDescriptionComboBox
			Fields: TypeName        SComboBox  
					Position		LoadImageDescriptionCheckBox(GetRight,Position) + 100, LoadImageDescriptionCheckBox(GetBottom,Position) + 20,100,<ComboBoxHeight>
					IActionsText    ~[GetList(ImageDescriptionOutputFields) Get]~
					DActionsText	~[Save Exec("OnImageDescriptionComboChanged()")]~
					OActionsText    ~[Save]~
					GenConName		THIS
					GenConField		~ImageDescriptionField~
					TOOLTIP			~Specifies the field in the Images table into which the Image Description information should be loaded.~

			/*** High Level Logging Checkbox ***/
			Define: HighLevelLoggingCheckBox Using DDWinCtrlDef AsSymbol HighLevelLoggingCheckBox
			Fields:	TYPENAME	Checkbox
					POSITION	LoadImageDescriptionCheckBox(GetLeft, Position), ImageDescriptionComboBox(GetTop, Position) + 30, 200, 15
					GENCONFIELD ~HighLevelLogging~
					GENCONNAME	THIS
					TEXT		~High Level Logging~
					DActionsText ~[ Save "Exec(OnHighLevelLoggingChanged())" ]~
					IActionsText ~[Get]~
					OActionsText ~[Save]~
 					TOOLTIP		~Turn on high level logging in order to help diagnose problems.~;

			/**** Preview Size Controls ****/
			Define: VariableResolutionRadioButton Using DDWinCtrlDef AsSymbol VariableResolutionRadioButton
			Fields:	POSITION		HighLevelLoggingCheckBox(GetLeft,Position) + 10, HighLevelLoggingCheckBox(GetBottom,Position) + 35, 120, 20
					TOOLTIP			~Select preview image size using the slider. A smaller preview size will render more quickly, but will be of lesser quality.~
					TYPENAME		~RadioButton~ 
					TEXT			~Variable Size: ~
					RADIOTRUEVALUE	~0~
					GENCONNAME		THIS
					GENCONFIELD		~Resolution~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( UncheckButton(UseHighestResolutionRadioButton) CheckButton(VariableResolutionRadioButton) DialogTimer(0 500))
					OACTIONSTEXT	ACTIONS ( Save )

			Define: PreviewSizeField Using DDWinCtrlDef AsSymbol PreviewSizeField
			Fields: POSITION		VariableResolutionRadioButton(GetRight, Position) + 10, VariableResolutionRadioButton(GetTop, Position)+2, 30, 20
					GENCONFIELD		~PreviewImageSize~
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					TYPENAME		StaticText
		
			Define: PreviewSizeSlider Using DDWinCtrlDef AsSymbol PreviewSizeSlider
			Fields: DACTIONSTEXT    ACTIONS ( Save Update(PreviewSizeField) DialogTimer(0 500))
					GENCONFIELD		~PreviewImageSize~
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		PreviewSizeField(GetRight, Position), PreviewSizeField(GetTop, Position), 200, 20
					TOOLTIP			~Select the preview image size~
					TYPENAME		~SLIDER~
					UNITS			20;

			Define: UseHighestResolutionRadioButton Using DDWinCtrlDef AsSymbol UseHighestResolutionRadioButton
			Fields:	POSITION		VariableResolutionRadioButton(GetLeft,Position), VariableResolutionRadioButton(GetBottom,Position), 170, 20
					TOOLTIP			~Use the highest resolution image available. This option will take significantly more time to process, but will result in a very high quality preview image.~
					TYPENAME		~RadioButton~ 
					TEXT			~Use Highest Resolution Image~
					RADIOTRUEVALUE	~1~
					GENCONNAME		THIS
					GENCONFIELD		~Resolution~
					IACTIONSTEXT    ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( UncheckButton(VariableResolutionRadioButton)  CheckButton(UseHighestResolutionRadioButton) DialogTimer(0 500))
					OACTIONSTEXT	ACTIONS ( Save )

			Define: PreviewResolutionGroupBox Using DDWinCtrlDef
			Fields:	TypeName		GroupBox
					POSITION		<GroupBoxLeft>, HighLevelLoggingCheckBox(GetBottom,Position) + 15,  <GroupBoxWidth>, <GroupBoxHeight> + 20
					Text			~Preview Image Size~;
		}

	return TRUE;
}

/***************************************************************************************************/
NUMERIC ColorControl( Prompt,Type,x,CurrentY,hGap,MinValue,MaxValue )
{
	Increment = 1;

	Define: <Type>Prompt Using DDWinCtrlDef AsSymbol <Type>Prompt
		Fields:	POSITION		$x, $CurrentY+3, 50, $StaticTextHeight
				TEXT			~<Prompt>~
				RightJustified	TRUE
				TYPENAME		StaticText

	Define: <Type>Field Using DDWinCtrlDef AsSymbol <Type>Field
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(AuditField(<Type>Field,-999,999,0,<Type>); On<Type>SliderChanged();)" Update(<Type>Slider))
				GENCONFIELD		~<Type>~
				GENCONNAME		THIS
				IACTIONSTEXT	ACTIONS ( Get )
				OACTIONSTEXT	ACTIONS ( Save )
				POSITION		(<Type>Prompt(GetRight,Position) + $hGap), $CurrentY, 30, $EditTextHeight
				TEXT			~~
				TOOLTIP			~Apply <Type> adjustment to the selected image(s) white point.~
				TYPENAME		MaskedEditText
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~ ;

	Define: <Type>Slider Using DDWinCtrlDef AsSymbol <Type>Slider
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(On<Type>SliderChanged())" Update(<Type>Field) )
				GENCONFIELD		~<Type>~
				GENCONNAME		THIS
				IACTIONSTEXT	ACTIONS ( Get )
				OACTIONSTEXT	ACTIONS ( Save )
				POSITION		<Type>Field(GetRight, Position), $CurrentY 130 $EditTextHeight
				TOOLTIP			~Apply <Type> adjustment to the selected image(s) white point.~
				TYPENAME		~SLIDER~ 
				UNITS			1 ;

	Define: <Type>MinusButton Using DDWinCtrlDef AsSymbol <Type>MinusButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeColor(<Type>,~-<Increment>~,<MinValue>,<MaxValue>))" Update(<Type>Slider) "Exec(On<Type>ButtonPressChanged())")
				POSITION		<Type>Slider(GetRight,Position)+$hGap * 2, $CurrentY, <SmallButtonWidth>, <SmallButtonHeight>
				TOOLTIP			~Decrease by 1~
				TYPENAME		~Button~ 
				TEXT			~-~;

	Define: <Type>ZeroButton Using DDWinCtrlDef AsSymbol <Type>ZeroButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeColor(<Type>,0,<MinValue>,<MaxValue>))" Update(<Type>Slider) "Exec(On<Type>ButtonPressChanged())")
				POSITION		<Type>MinusButton(GetRight,Position) + $hGap, $CurrentY, <SmallButtonWidth>, <SmallButtonHeight>
				TOOLTIP			~Reset to 0~
				TYPENAME		~Button~ 
				TEXT			~0~

	Define: <Type>PlusButton Using DDWinCtrlDef AsSymbol <Type>PlusButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeColor(<Type>,~<Increment>~,<MinValue>,<MaxValue>))" Update(<Type>Slider) "Exec(On<Type>ButtonPressChanged())")
				POSITION		<Type>ZeroButton(GetRight,Position)+$hGap, $CurrentY, <SmallButtonWidth>, <SmallButtonHeight>
				TOOLTIP			~Increase by 1~
				TYPENAME		~Button~ 
				TEXT			~+~;

	CurrentY = $CurrentY + 20;

	return $CurrentY;
}


/***************************************************************************************************/
VOID DefineDialogControls(&ystart, &TabWidth)
{
		tempGap = $vGap - 8;

		Define: DigitalOrdersStatic Using DDWinCtrlDef AsSymbol DigitalOrdersStatic
		Fields: POSITION		<LeftX>, $ystart + 5, 85, 20
				TEXT			~Orders to Process~
				RIGHTJUSTIFIED	TRUE
				TYPENAME		StaticText

		Define: DigitalOrders Using DDWinCtrlDef AsSymbol DigitalOrders
		Fields:	POSITION		DigitalOrdersStatic(GetLeft,Position), DigitalOrdersStatic(GetBottom,Position), ($DialogWidth / 2 - 20) - 100 , 200
				GENCONNAME		THIS
				GENCONFIELD		~Directory~
				ALLOWMULTIPLESELECTION	FALSE
				IACTIONSTEXT	ACTIONS ( Get )
				DACTIONSTEXT	ACTIONS ( Save "Exec(UpdateImagesList())")
				OACTIONSTEXT	ACTIONS ( Save )
				SORTED			TRUE
				NoDuplicates	TRUE
				ToolTip			Translate( ~Select the order to work with~ )
				TYPENAME		ListBox
				KEYBOARDACTIONSTEXT	 ACTION EXEC ( OnKeyDown() )

		Define: DigitalOrderImagesStatic Using DDWinCtrlDef AsSymbol DigitalOrderImagesStatic
		Fields: POSITION		DigitalOrders(GetRight,Position) + $hGap - 5, DigitalOrdersStatic(GetTop,Position), 155, 20
				TEXT			~Unprocessed Order Images~
				RIGHTJUSTIFIED	FALSE
				TYPENAME		StaticText


		Define: DigitalOrderImages Using DDWinCtrlDef AsSymbol DigitalOrderImages
		Fields:	POSITION		DigitalOrders(GetRight,Position) + $hGap - 5, DigitalOrderImagesStatic(GetBottom,Position),($DialogWidth / 2 - 20) + 110, 200
				GENCONNAME		THIS
				GENCONFIELD		~OrderImages~
				ALLOWMULTIPLESELECTION	TRUE

HorizontalScrollPixels  1000     // Sets the width, in pixels, to 1000, by which a list box can be scrolled horizontally. 
			          // If the size of the list box is smaller than this value, the horizontal scroll bar will 
			         // horizontally scroll items in the list box. If the list box is as large or larger than this value, 
                                                         // the horizontal scroll bar is hidden. 
				RIGHTJUSTIFIED	TRUE
				IACTIONSTEXT	ACTIONS ( Get )
				DACTIONSTEXT	ACTIONS ( Save 	"Exec(LoadImageAttributes();)")
				OACTIONSTEXT	ACTIONS ( Save )
				DOUBLECLICKACTIONSTEXT	ACTION EXEC ( PreviewImageNonQueueing() )
				NoDuplicates	TRUE
				ToolTip			Translate( ~Images associated with the highlighted order~ )
				TYPENAME		ListBox
				KEYBOARDACTIONSTEXT	 ACTION EXEC ( OnKeyDown() )

		Define: RefreshListsButton Using DDWinCtrlDef AsSymbol RefreshListsButton
		Fields:	TYPENAME		Button
				TEXT			~&Refresh Lists~
				DACTIONSTEXT	ACTION EXEC ( RefreshLists() )
				TOOLTIP			~Refresh the Orders and Order Images lists~
				POSITION		DigitalOrders(GetLeft,Position), DigitalOrders(GetBottom,Position)-8, DigitalOrders(GetWidth,Position),  <ButtonHeight> + 10;
			
		Define: OpenSelectedOrderButton Using DDWinCtrlDef AsSymbol OpenSelectedOrderButton
		Fields:	TYPENAME		Button
				TEXT			~&View Images~
				TOOLTIP			~Open the Order Images view for the selected order~
				DACTIONSTEXT	ACTION EXEC ( OpenOrderImages() )
				POSITION		RefreshListsButton(GetLeft,Position), RefreshListsButton(GetBottom,Position) + $tempGap, RefreshListsButton(GetWidth,Position),  <ButtonHeight> + 10;
	
		Define: ImportImagesButton Using DDWinCtrlDef AsSymbol ImportImagesButton
		Fields:	TYPENAME		Button
				TEXT			~Import Images~
				TOOLTIP			~Bring up the Import Images dialog for the selected Order~
				DACTIONSTEXT	ACTION EXEC ( OpenImportImages() )
				POSITION		OpenSelectedOrderButton(GetLeft,Position), OpenSelectedOrderButton(GetBottom,Position) + $tempGap, OpenSelectedOrderButton(GetWidth,Position),  <ButtonHeight> + 10;

		
		Define: PreviewButton Using DDWinCtrlDef AsSymbol PreviewButton
		Fields:	TYPENAME		Button
				TEXT			~&Preview~
				TOOLTIP			~Display previews for each selected image.~
				DACTIONSTEXT	ACTION EXEC ( PreviewImageNonQueueing() )
				POSITION		DigitalOrderImages(GetLeft,Position), RefreshListsButton(GetTop,Position), <ButtonWidth>+10,  <ButtonHeight> + 10;

		Define: ProcessNowButton Using DDWinCtrlDef AsSymbol ProcessNowButton
		Fields:	TYPENAME		Button
				TEXT			~Process Now~
				TOOLTIP			~Process selected image(s) to 8 bit rgb image files~
				DACTIONSTEXT	ACTION EXEC ( ProcessImageNow() )
				POSITION		PreviewButton(GetRight,Position) + $ButtonGap, PreviewButton(GetTop,Position) , <ButtonWidth>+10,  <ButtonHeight> + 10;
	
		Define: QueueButton Using DDWinCtrlDef AsSymbol QueueButton
		Fields:	TYPENAME		Button
				TEXT			~Queue For Later~
				TOOLTIP			~Queue the selected image(s) for background processing to 8 bit rgb image files~
				DACTIONSTEXT	ACTION EXEC ( QueueImage() )
				POSITION		ProcessNowButton(GetRight,Position) + $ButtonGap, ProcessNowButton(GetTop,Position), <ButtonWidth>+12,  <ButtonHeight> + 10;

		Define: OpenBackgroundQueueButton Using DDWinCtrlDef AsSymbol OpenBackgroundQueueButton
		Fields:	TYPENAME		Button
				TEXT			~View Queue~
				TOOLTIP			~Open the Background Queue Processor view.~
				DACTIONSTEXT	ACTION EXEC ( OpenBackgroundQueue() )
				POSITION		QueueButton(GetRight,Position) + $ButtonGap, QueueButton(GetTop,Position), <ButtonWidth>-5,  <ButtonHeight> + 10;

		Define: CancelProcessingButton Using DDWinCtrlDef AsSymbol CancelProcessingButton
		Fields:	TYPENAME		Button
				TEXT			~Cancel Preview or Process Now~
				TOOLTIP			~Cancel current preview or process now activity.~
				DACTIONSTEXT	ACTION EXEC ( CancelProcessing() )
				POSITION		PreviewButton(GetLeft,Position), PreviewButton(GetBottom,Position) + $tempGap, <ButtonWidth>+100,  <ButtonHeight> + 10;

		Define: ChangeDestinationButton Using DDWinCtrlDef AsSymbol ChangeDestinationButton
		Fields:	TYPENAME		Button
				TEXT			~Change Destination Folder~
				TOOLTIP			~Change the destination folder for the output 8-bit image~
				DACTIONSTEXT	ACTION EXEC ( ChooseNewDestinationFolder() )
				POSITION		CancelProcessingButton(GetRight, Position)+$ButtonGap, CancelProcessingButton(GetTop,Position), <ButtonWidth>+87,  <ButtonHeight> + 10;

		Define: RevertButton Using DDWinCtrlDef AsSymbol RevertButton
		Fields:	TYPENAME		Button
				TEXT			~Revert Settings~
				DACTIONSTEXT	ACTION EXEC ( RevertSettings() )
				TOOLTIP			~Revert to the original camera file settings~
				POSITION		ProcessNowButton(GetLeft,Position) , ImportImagesButton(GetTop,Position), <ButtonWidth> + 10,  <ButtonHeight> + 10;

   		Define: HelpButton Using DDWinCtrlDef AsSymbol HelpButton
		Fields:	TYPENAME		Button
				TEXT			~Help~
				TOOLTIP			~Display Help on this dialog~
				DACTIONSTEXT	ACTION SHOWHELPPAGE ( KPISHelpFile "DC_Import.htm" )
				POSITION		RevertButton(GetRight,Position) + $ButtonGap + 20, RevertButton(GetTop,Position),68,  <ButtonHeight> + 10;

  		Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton
		Fields:	TYPENAME		Button
				TEXT			~Close~
				TOOLTIP			~Close the Kodak DCR Import dialog~
				DACTIONSTEXT	ACTION EXEC ( CloseDialog(); )
				POSITION		HelpButton(GetRight,Position) + $ButtonGap, HelpButton(GetTop,Position), 69,  <ButtonHeight> + 10;

}


/***************************************************************************************************/
/***************************************************************************************************/
/***																							 ***/
/***									GUI HANDLERS											 ***/
/***																							 ***/
/***************************************************************************************************/
/***************************************************************************************************/

/***********************************/
/***      FOR THE COLOR TAB      ***/
/***********************************/

/***************************************************************************************************/
VOID OnLightingChanged()
{
	dlg(GetInput);

	// Set Lighting
	lightSetting = ~<$con.dlgData[Lighting]>~;

	if ( ~<lightSetting>~ == ~0~ )
	{
		SQLCommand = ~UPDATE DCImageProperties SET BaseIlluminantID = 'Daylight'~;
		Illuminant = ~KVTPICPROCDaylightIllum~;
	}
	else if ( ~<lightSetting>~ == ~1~ )
	{
		SQLCommand = ~UPDATE DCImageProperties SET BaseIlluminantID = 'Tungsten'~;
		Illuminant = ~KVTPICPROCTungstenIllum~;
	} 
	else if ( ~<lightSetting>~ == ~2~ )
	{
		SQLCommand = ~UPDATE DCImageProperties SET BaseIlluminantID = 'Flash'~;
		Illuminant = ~KVTPICPROCFlashIllum~;
	}
	else
	{
		SQLCommand = ~UPDATE DCImageProperties SET BaseIlluminantID = 'Fluorescent'~;
		Illuminant = ~KVTPICPROCFluorescentIllum~;
	};

	ParametersChangedWithValidation(~<SQLCommand>~, KVTPICPROCBaseIlluminantID, ~<Illuminant>~, ~SET~);
}

/***************************************************************************************************/
VOID UpdateLookProfileList(GenConName, ComboBoxName)
{
	dlg( GetInput );

	SelectedLookProfile = ~<$con.DlgData[<GenConName>]>~;

	Query = ~Select Name From Profiles WHERE Type = 'Look' Order By Name~;

	if ( !PGenConList( LookProfileList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		LookProfileList( GetErrorDescription,0,theErr );
		Warning( Translate( ~Failed to query the DigitalCameraSetups table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	LookProfileList( MakeStringList, ~<GenConName>~, Name);

	dlg( SetControlFromStringList, ~<ComboBoxName>~, ~<GenConName>~, ~Selection~ );

	if (~<SelectedLookProfile>~ != ~~)
	{
		dlg(SelectString, ~<ComboBoxName>~, ~<SelectedLookProfile>~);
	}
}

/***************************************************************************************************/
VOID OnLookChanged()
{
	dlg(GetInput);

	// LOOK Profile
	currentLook = ~<$con.Dlgdata[Look]>~;

	if (!SimilarStr(~<currentLook>~, ~<Use Embedded>~))
	{
		if (!AuditLookProfiles(~<currentLook>~))
		{
			// Bail out, since we don't want to change the look profile if it's invalid for one of the selections
			dlg(SelectString, LookProfilesComboBox, ~<LastLook>~);
			MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
			
			return;
		}

		MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
	}

	LastLook = ~<currentLook>~;
	
	// Set the Look Profile
	SQLCommand = ~UPDATE DCImageProperties SET LookProfPathID = '<currentLook>'~;

	ParametersChanged(~<SQLCommand>~);
}

/***************************************************************************************************/
NUMERIC AuditLookProfiles(CurrentLookProfile)
{
	LookProductSupported = ~FALSE~;
	LookPortraitSupported = ~FALSE~;
	LookProductRedSupported = ~FALSE~;
	LookPortraitRedSupported = ~FALSE~;

	if (SimilarStr(~<CurrentLookProfile>~, ~Product~) ||
		SimilarStr(~<CurrentLookProfile>~, ~Product Reduced~) ||
		SimilarStr(~<CurrentLookProfile>~, ~Portrait~) ||
		SimilarStr(~<CurrentLookProfile>~, ~Portrait Reduced~) )
	{
		// Have to iterate through all images selected in the list.
		dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

		Index = 0;

		while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
		{
			if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~<ImagePath>~))
			{
				return FALSE;
			}

			if (MyCamera(GetAttributeValue, MyCamera(KVTPICPROCPicTypeID), PictureTypeID))
			{
				if (<PictureTypeID> == MyCamera(KVTPICPROC_DCSFile))
				{
					MyCamera(GetSupportedDCSLookAttributeValueInfo, LookProductSupported, LookPortraitSupported, 
							LookProductRedSupported, LookPortraitRedSupported);

					if ( SimilarStr(~<CurrentLookProfile>~, ~Product~) )
					{
						if (!<LookProductSupported>)
						{
							MessageBox(~Product Look not supported by: <ImagePath>~);
							return FALSE;
						}
					}
					if ( SimilarStr(~<CurrentLookProfile>~, ~Product Reduced~) )
					{
						if (!<LookProductRedSupported>)
						{
							MessageBox(~Product Reduced Look not supported by: <ImagePath>~);
							return FALSE;
						}
					}
					if ( SimilarStr(~<CurrentLookProfile>~, ~Portrait~) )
					{
						if (!<LookPortraitSupported>)
						{
							MessageBox(~Portrait Look not supported by: <ImagePath>~);
							return FALSE;
						}
					}
					if ( SimilarStr(~<CurrentLookProfile>~, ~Portrait Reduced~) )
					{
						if (!<LookPortraitRedSupported>)
						{
							MessageBox(~Portrait Reduced Look not supported by: <ImagePath>~);
							return FALSE;
						}
					}
				}
			}
		}
	} else if (!SimilarStr(~<CurrentLookProfile>~, ~Product~) &&
				!SimilarStr(~<CurrentLookProfile>~, ~Product Reduced~) &&
				!SimilarStr(~<CurrentLookProfile>~, ~Portrait~) &&
				!SimilarStr(~<CurrentLookProfile>~, ~Portrait Reduced~) )
	{
		Index = 0;
		while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
		{
			if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~<ImagePath>~))
			{
				return FALSE;
			}

			if (MyCamera(GetAttributeValue, MyCamera(KVTPICPROCPicTypeID), PictureTypeID))
			{
				if (<PictureTypeID> == MyCamera(KVTPICPROC_DCSFile))
				{
					MessageBox(~The selected profile is not valid for <ImagePath>~);
					return FALSE;
				}
			}
		}
	}

	return TRUE;
}


/***************************************************************************************************/
VOID OnBalanceChanged()
{
	dlg(GetInput);

	balanceSetting = ~<$con.dlgData[Balance]>~;

	if ( ~<balanceSetting>~ == ~3~ )
	{
		SQLCommand = ~UPDATE DCImageProperties SET BalanceTypeID = 'Auto'~;

		Balance = KVTPICPROCAutoWhiteBalanceRGBTripletID;

	}
	else if ( ~<balanceSetting>~ == ~2~ )
	{
		SQLCommand = ~UPDATE DCImageProperties SET BalanceTypeID = 'Custom'~;

		Balance = KVTPICPROCCustomWhiteBalanceRGBTripletID;
	}
	else if ( ~<balanceSetting>~ == ~1~ )
	{
		// NOTE: Can only change to Click if the info table has click values
		// OR if the original file settings were click...
		SQLCommand = ~UPDATE DCImageProperties SET BalanceTypeID = 'Click'~;

		Balance = KVTPICPROCClickWhiteBalanceRGBTripletID;
	}
	else if ( ~<balanceSetting>~ == ~0~ )
	{
		SQLCommand = ~UPDATE DCImageProperties SET BalanceTypeID = 'Preset'~;

		Balance = KVTPICPROCDaylightWhiteBalanceRGBTripletID;
	} else
	{
		// This is probably not necessary since it should never happen
		SQLCommand = ~UPDATE DCImageProperties SET BalanceTypeID = ' '~;
	}

	ParametersChangedWithValidation(~<SQLCommand>~, ~<Balance>~, nullparam, ~NONE~);

	LastBalanceType = <balanceSetting>;
}

/***************************************************************************************************/
VOID SaveClickBalanceValues( )
{
	RedClickValue = ~<$con.dlgData[ClickBalanceRed]>~;
	GreenClickValue = ~<$con.dlgData[ClickBalanceGreen]>~;
	BlueClickValue = ~<$con.dlgData[ClickBalanceBlue]>~;

	SQLCommand = ~UPDATE DCImageProperties SET ClickBalanceRed = '<RedClickValue>', ClickBalanceGreen = '<GreenClickValue>', ClickBalanceBlue = '<BlueClickValue>', BalanceTypeID = 'Click'~;

	ParametersChanged(~<SQLCommand>~);
}

/***************************************************************************************************/
VOID OnPreviewAllClickChanged()
{
	dlg(GetInput);

	SetWorkStationSettings( ~DigitalCamera~, ~PreviewAllClickBalances~, ~<$con.dlgData[PreviewAllClickBalances]>~, TRUE );
}

/***************************************************************************************************/
VOID OnRedButtonPressChanged( )
{
	dlg(GetInput);

	RedSliderValue = ~<$con.dlgData[Red]>~;

	SQLCommand = ~UPDATE DCImageProperties SET WhiteBalanceRed = '<RedSliderValue>'~;

	ParametersChanged(~<SQLCommand>~);

	NewRedSetting = ~<RedSliderValue>~;
}

/***************************************************************************************************/
VOID OnRedSliderChanged( )
{
	dlg(GetInput);
		
// NOTE: THE FOLLOWING IF STATEMENT CAUSES A PROBLEM WHEN PRESSING THE '0' BUTTON WITH
// MULTIPLE IMAGES SELECTED
// SINCE THE FIRST CLAUSE IS TRUE, WE DON'T SAVE ANYTHING, EVEN THOUGH ONE OF THE IMAGES
// NEEDS THE CHANGE. THIS AFFECTS ANY OF THE BUTTONS IF THE BUTTON PRESS DOESN'T RESULT IN
// A CHANGE FOR THE CURRENT SELECTION, BUT WOULD HAVE FOR ONE OR MORE OF THE OTHER IMAGES
// SELECTED...

	// If we're either just opening the dialog (NewRedSetting == ~~) or the DACTIONSTEXT
	// got called because code was changing the control, then we just return.
	if ( (~<NewRedSetting>~ == ~<$con.dlgData[Red]>~) || (~<NewRedSetting>~ == ~~) )
	{
		return;
	}

	RedSliderValue = ~<$con.dlgData[Red]>~;

	SQLCommand = ~UPDATE DCImageProperties SET WhiteBalanceRed = '<RedSliderValue>'~;

	ParametersChanged(~<SQLCommand>~);

	NewRedSetting = ~<RedSliderValue>~;
}

/***************************************************************************************************/
VOID OnGreenSliderChanged( )
{
	dlg(GetInput);
	
	// If we're either just opening the dialog (NewGreenSetting == ~~) or the DACTIONSTEXT
	// got called because code was changing the control, then we just return.
	if ( (~<NewGreenSetting>~ == ~<$con.dlgData[Green]>~) || (~<NewGreenSetting>~ == ~~) )
	{
		return;
	}

	GreenSliderValue = ~<$con.dlgData[Green]>~;

	SQLCommand = ~UPDATE DCImageProperties SET WhiteBalanceGreen = '<GreenSliderValue>'~;

	ParametersChanged(~<SQLCommand>~);

	NewGreenSetting = ~<GreenSliderValue>~;
}

/***************************************************************************************************/
VOID OnGreenButtonPressChanged( )
{
	dlg(GetInput);

	GreenSliderValue = ~<$con.dlgData[Green]>~;

	SQLCommand = ~UPDATE DCImageProperties SET WhiteBalanceGreen = '<GreenSliderValue>'~;

	ParametersChanged(~<SQLCommand>~);

	NewGreenSetting = ~<GreenSliderValue>~;
}

/***************************************************************************************************/
VOID OnBlueSliderChanged( )
{
	dlg(GetInput);
	
	// If we're either just opening the dialog (NewBlueSetting == ~~) or the DACTIONSTEXT
	// got called because code was changing the control, then we just return.
	if ( (~<NewBlueSetting>~ == ~<$con.dlgData[Blue]>~) || (~<NewBlueSetting>~ == ~~) )
	{
		return;
	}

	BlueSliderValue = ~<$con.dlgData[Blue]>~;

	SQLCommand = ~UPDATE DCImageProperties SET WhiteBalanceBlue = '<BlueSliderValue>'~;

	ParametersChanged(~<SQLCommand>~);

	NewBlueSetting = ~<BlueSliderValue>~;
}

/***************************************************************************************************/
VOID OnBlueButtonPressChanged( )
{
	dlg(GetInput);

	BlueSliderValue = ~<$con.dlgData[Blue]>~;

	SQLCommand = ~UPDATE DCImageProperties SET WhiteBalanceBlue = '<BlueSliderValue>'~;

	ParametersChanged(~<SQLCommand>~);

	NewBlueSetting = ~<BlueSliderValue>~;
}

/***************************************************************************************************/
VOID ChangeColor( Type,Amount,MinValue,MaxValue )
{
	sum = (<amount> == 0) ? 0 : dlgData( GetNumeric,<Type> ) + <amount>;

	sum = Pin( <sum>,<MinValue>,<MaxValue> );

	dlg( SetString,~<sum>~,<Type> );
}


/**********************************************/
/***      FOR THE IMAGE ADJUSTMENT TAB      ***/
/**********************************************/

VOID OnExposureChanged( )
{
	dlg(GetInput);

	ExposureGainID = ~<$con.dlgData[Exposure]>~;
	SQLCommand = ~UPDATE DCImageProperties SET ExposureGainID = '<ExposureGainID>'~;

	ParametersChangedWithValidation(~<SQLCommand>~, KVTPICPROCExposureGainID, ~<ExposureGainID>~, ~SET~);
}

/***************************************************************************************************/
VOID ChangeExposure( amount, adjust )
{
	if ( <adjust> )
	{
		sum = dlgData( GetNumeric,Exposure ) + <amount>;
	}
	else
	{
		sum = <amount>;
	}

	lowVal = ~<$con.dlgData[ExposureMin]>~;
	highVal = ~<$con.dlgData[ExposureMax]>~;

	sum = Pin( <sum>, <lowVal>, <highVal> );

	dlg( SetStrings,Exposure,~<sum>~ );
}

/*************************************/
/***      FOR THE FILTERS TAB      ***/
/*************************************/

/***************************************************************************************************/
VOID OnNoiseReductionChanged( )
{
	dlg(GetInput);
	
	NoiseReductionType = ~<$con.dlgData[NRType]>~;

	// If it's the same as it was, then do nothing
	if (~<NewNoiseReduction>~ == ~<NoiseReductionType>~)
	{
		return;
	}

	NewNoiseReduction = ~<NoiseReductionType>~;

// threshold/strength slider
// Basic = always disabled
// advanced with moire = always enabled
// Advanced = disabled when radius=FALSE, else enabled

	dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo,ZeroStaticOne, HundredStaticOne);
	dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic );

	// Enable/Disable the Strength/Threshold slider as appropriate
	if ( SimilarStr(~<NoiseReductionType>~, ~Expert~) )
	{
		// we must disable the threshold slider.  The image will render correctly
		// only if the threshold slider is not moved.  See problem 17073.
		dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
	}
	else if ( SimilarStr(~<NoiseReductionType>~, ~Basic With Radius~) )
	{
		dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
		dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
	}
	else if ( SimilarStr(~<NoiseReductionType>~, ~Advanced with Moire Reduction~) )
	{
		dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
		dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
	}
	else if ( SimilarStr(~<NoiseReductionType>~, ~Advanced~) && (<NRRadiusSupported> || <NRStrengthThresholdSupported>) )
	{
		dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
		dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
	}


/*
NOTE: NoiseFilterTypeID is only 6 characters

	Type #		Gencon Field:		List String:					Database Storage:
		1		NROff				Off								None
		2		NRBasic				Basic							Sigma
		3		NRChroma			Advanced						Chroma
		4		NRMoire				Advanced with Moire Reduction	Moire
		5		NRChromaRadius		Advanced						ChrRad
		6		NRMoireRadius		Advanced with Moire Reduction	MoiRad
		7		NRExpert			Expert							Expert
		8		NRBasicRadius		Basic with Radius				BasRad
*/

	// Now commit the change to the database
	NoiseSetting = ~<$con.dlgData[NRType]>~;
	FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;
	FilterRadiusID = ~<$con.DlgData[NRRadius]>~;

	NewNoiseReduction = ~<$con.dlgData[NRType]>~;

	NRParametersChangedWithValidation(~<NoiseSetting>~, ~<FilterStrengthID>~, ~<FilterRadiusID>~);
}

/***************************************************************************************************/
VOID OnNRStrengthThresholdChanged( )
{
	dlg(GetInput);

	FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;

	NoiseReductionType = ~<$con.dlgData[NRType]>~;
	FilterRadiusID = ~<$con.DlgData[NRRadius]>~;

	NRParametersChangedWithValidation(~<NoiseReductionType>~, ~<FilterStrengthID>~, ~<FilterRadiusID>~);
}

/***************************************************************************************************/
VOID OnNRRadiusChanged( )
{
	dlg(GetInput);

	FilterRadiusID = ~<$con.DlgData[NRRadius]>~;

	NoiseReductionType = ~<$con.dlgData[NRType]>~;
	FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;

	NRParametersChangedWithValidation(~<NoiseReductionType>~, ~<FilterStrengthID>~, ~<FilterRadiusID>~);
}


/***************************************************************************************************/
VOID OnAppSharpenAmountChanged( )
{
	dlg(GetInput);

	AppSharpenAmountID = ~<$con.dlgData[AppSharpenAmount]>~;
	SQLCommand = ~UPDATE DCImageProperties SET SharpenAmountID = '<AppSharpenAmountID>'~;

	// If the Sharpening Amount goes to zero, then Radius and Threshold should be disabled.
	if (<AppSharpenAmountID> == 0)
	{
		dlg(EnableControls, FALSE, AppSharpenRadiusSlider);
		dlg(EnableControls, FALSE, SharpenRadiusText, SharpenRadiusMinText, SharpenRadiusMaxText, SharpenRadiusCurrentText);

		dlg(EnableControls, FALSE, AppSharpenThresholdSlider);
		dlg(EnableControls, FALSE, SharpenThresholdText, SharpenThresholdMinText, SharpenThresholdMaxText, SharpenThresholdCurrentText);
	} else
	{
		// Otherwise make sure that they're all ON.
		EnableSharpeningControls(TRUE);
	}

	ParametersChangedWithValidation(~<SQLCommand>~, KVTPICPROCSharpenAmountID, ~<AppSharpenAmountID>~, ~SET~);
}

/***************************************************************************************************/
VOID OnAppSharpenRadiusChanged( )
{
	dlg(GetInput);

	AppSharpenRadiusID = ~<$con.dlgData[AppSharpenRadius]>~;
	SQLCommand = ~UPDATE DCImageProperties SET SharpenRadiusID = '<AppSharpenRadiusID>'~;

	// If the Sharpening Radius goes to zero, then Amount and Threshold should be disabled.
	if (<AppSharpenRadiusID> == 0)
	{
		dlg(EnableControls, FALSE, AppSharpenAmountSlider, AppSharpenThresholdSlider);
		dlg(EnableControls, FALSE, SharpenAmountText, SharpenAmountMinText, SharpenAmountMaxText, SharpenAmountCurrentText);

		dlg(EnableControls, FALSE, AppSharpenThresholdSlider);
		dlg(EnableControls, FALSE, SharpenThresholdText, SharpenThresholdMinText, SharpenThresholdMaxText, SharpenThresholdCurrentText);
	} else
	{
		// Otherwise make sure that they're all ON.
		EnableSharpeningControls(TRUE);
	}

	ParametersChangedWithValidation(~<SQLCommand>~, KVTPICPROCSharpenRadiusID, ~<AppSharpenRadiusID>~, ~SET~);
}


/***************************************************************************************************/
VOID OnAppSharpenThresholdChanged( )
{
	dlg(GetInput);

	AppSharpenThresholdID = ~<$con.dlgData[AppSharpenThreshold]>~;
	SQLCommand = ~UPDATE DCImageProperties SET SharpenThresholdID = '<AppSharpenThresholdID>'~;

	ParametersChangedWithValidation(~<SQLCommand>~, KVTPICPROCSharpenThresholdID, ~<AppSharpenThresholdID>~, ~SET~);
}

/***************************************************************************************************/
VOID OnEnableRawFileSharpeningChanged( )
{
	dlg(GetInput);

	value = ~<$con.DlgData[EnableRawFileSharpening]>~;

	if (Numeric(~<value>~))
	{
		// Enable all of the slider stuff
		HideSharpeningControls(FALSE);

		LoadImageAttributes();
	} else
	{
		// Disable all of the slider stuff
		HideSharpeningControls(TRUE);
	}
}

/***************************************************************************************************/
VOID OnEnableRawFileSharpeningText()
{
	dlg(GetInput);

	value = ~<$con.dlgData[EnableRawFileSharpening]>~;
	value = !<value>;

	dlg( SetCheck, <value>, EnableRawFileSharpeningCheckBox);

	if (Numeric(~<value>~))
	{
		// Enable all of the slider stuff
		HideSharpeningControls(FALSE);

		LoadImageAttributes();
	} else
	{
		// Disable all of the slider stuff
		HideSharpeningControls(TRUE);
	}
}

/***************************************************************************************************/
VOID HideSharpeningControls(bControlsEnabled)
{
	dlg(HideControls, <bControlsEnabled>, AppSharpenAmountSlider);
	dlg(HideControls, <bControlsEnabled>, SharpenAmountText, SharpenAmountMinText, SharpenAmountMaxText, SharpenAmountCurrentText);

	dlg(HideControls, <bControlsEnabled>, AppSharpenRadiusSlider);
	dlg(HideControls, <bControlsEnabled>, SharpenRadiusText, SharpenRadiusMinText, SharpenRadiusMaxText, SharpenRadiusCurrentText);

	dlg(HideControls, <bControlsEnabled>, AppSharpenThresholdSlider);
	dlg(HideControls, <bControlsEnabled>, SharpenThresholdText, SharpenThresholdMinText, SharpenThresholdMaxText, SharpenThresholdCurrentText);

	dlg(HideControls, !<bControlsEnabled>, SharpenDisabledStatic);
}

/***************************************************************************************************/
VOID EnableSharpeningControls(bControlsEnabled)
{
	dlg(EnableControls, <bControlsEnabled>, SharpenGroupBox);

	dlg(EnableControls, <bControlsEnabled>, AppSharpenAmountSlider, AppSharpenThresholdSlider);
	dlg(EnableControls, <bControlsEnabled>, SharpenAmountText, SharpenAmountMinText, SharpenAmountMaxText, SharpenAmountCurrentText);

	dlg(EnableControls, <bControlsEnabled>, AppSharpenRadiusSlider);
	dlg(EnableControls, <bControlsEnabled>, SharpenRadiusText, SharpenRadiusMinText, SharpenRadiusMaxText, SharpenRadiusCurrentText);

	dlg(EnableControls, <bControlsEnabled>, AppSharpenThresholdSlider);
	dlg(EnableControls, <bControlsEnabled>, SharpenThresholdText, SharpenThresholdMinText, SharpenThresholdMaxText, SharpenThresholdCurrentText);
}


/**********************************************/
/***      FOR THE OUTPUT FILE TYPE TAB      ***/
/**********************************************/

/***************************************************************************************************/
VOID OnFileTypeChange(LoadingSettings)
{
	dlg( GetInput );

	JPEGEnabled = SimilarStr( ~<$con.dlgData[SaveFileType]>~, JPEG );
	TIFFEnabled = SimilarStr( ~<$con.dlgData[SaveFileType]>~, TIFF );

	dlg( EnableControls, <JPEGEnabled>, JPEGQualitySlider, JPEGQualityField, JPEGQualityPrompt, JPEGQualityMinStatic, JPEGQualityMaxStatic);

	if ( !<LoadingSettings> )
	{
		TheFileExtension = ~~;

		if (<TIFFEnabled>) { TheFileExtension = ~.tif~; }
		if (<JPEGEnabled>) { TheFileExtension = ~.jpg~; }

		// This will trigger the changed handler for File Extension
		dlg(SetStrings, FileExtension, ~<TheFileExtension>~);
	}
}

/***************************************************************************************************/
VOID OnOverrideDeltaSharpeningChanged( )
{
	dlg(GetInput);

	if ( Numeric(~<$con.dlgData[OverrideDeltaSharpening]>~) )
	{
		dlg(EnableControls, TRUE, DeltaSharpeningField);
	} else
	{
		dlg(EnableControls, FALSE, DeltaSharpeningField);
	}

}

/***************************************************************************************************/
VOID LoadProfilesComboBox( )
{
	Query = ~Select * From Profiles Where Type = 'WorkingSpace' OR Type = 'Output' And Path IS NOT NULL Order By Type,Name~;

	if ( !PGenConList( ProfilesList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ProfilesList( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) ); 
	}

	ProfilesList( MakeStringList,ScannerProfiles,Name );

	dlg( SetControlFromStringList,ProfileComboBox,ScannerProfiles,~NoSelection~ );
}

/***************************************************************************************************/
NUMERIC RefreshProfilesComboBox( )
{
	LoadProfilesComboBox();

	return dlg( SelectString,ProfileComboBox,~<$con.dlgData[AlternateOutputProfile]>~ );
}

/***************************************************************************************************/
VOID OnOutputProfileChanged( )
{
	dlg(GetInput);

	if (Numeric(~<$con.dlgData[UseWorkingspaceProfile]>~))
	{
		dlg(EnableControls, FALSE, ProfileComboBox);
	} else
	{
		dlg(EnableControls, TRUE, ProfileComboBox);
		LoadProfilesComboBox();
	}
}

/***************************************************************************************************/
VOID UpdateSetupsList(GenConName, ComboBoxName)
{
	SelectedSetup = ~<$con.DlgData[<GenConName>]>~;

	Query = ~Select Setup From DigitalCameraSetups Order By Setup~;

	if ( !PGenConList( SetupsList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		SetupsList( GetErrorDescription,0,theErr );
		Warning( Translate( ~Failed to query the DigitalCameraSetups table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	SetupsList( MakeStringList, ~<GenConName>~, Setup);

	dlg( SetControlFromStringList, ~<ComboBoxName>~, ~<GenConName>~, ~Selection~ );

	if (~<SelectedSetup>~ != ~~)
	{
		dlg(SelectString, ~<ComboBoxName>~, ~<SelectedSetup>~);
	}
}

/***************************************************************************************************/
NUMERIC OnSaveDCSetup()
{
	dlg( GetInput );

	SetupName = ~<$con.DlgData[DCSetup]>~;

	if ( ~<SetupName>~ == ~~ )
	{
		return Warning( Translate( ~No setup name specified~ ) );
	}

	Extension = ~<$con.DlgData[FileExtension]>~;
	if (~<Extension>~ == ~~)
	{
		return Warning( Translate( ~No file extension was specified~ ) );
	}

	Key = ~Setup = '<SetupName>'~;

	Query = ~Select * From DigitalCameraSetups Where <Key>~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Query Failed: <Query>. <theErr>~ ) );
	}

	if ( !List( GetFirst,Item ) )
	{
		if ( MessageBox( Translate(~Create a new setup called <$con.DlgData[DCSetup]>?~),YESNO ) != YES )
		{
			return FALSE;
		}

		if ( !List( AddNew,Item ) )
		{
			List( GetErrorDescription,0,theErr );
			return Warning( Translate( ~AddNew for DigitalCameraSetups Failed:. <theErr>~ ) );
		}

		Item( Set, Setup, ~<$con.DlgData[DCSetup]>~ );
	}
	else
	{
		if ( MessageBox( Translate(~Update the existing setup called <$con.DlgData[DCSetup]>?~),YESNO ) != YES )
		{
			return FALSE;
		}
	}

	if ( !Item( UpdateFrom, DlgData ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		return Warning( Translate( ~Could not update DigitalCameraSetups record where <Key>. <theErr>~ ) );
	}

	if ( !List( Update ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		return Warning( Translate( ~Could not update DigitalCameraSetups record where <Key>. <theErr>~ ) );
	}

	return TRUE;
}

/***************************************************************************************************/
NUMERIC OnLoadSetupButton( DisplayWarning )
{
	dlg( GetInput );

	SetupName = ~<$con.dlgData[DCSetup]>~;

	if ( IsNull( ~<SetupName>~ ) )
	{
		if ( !<DisplayWarning> )
		{
			return FALSE;
		}

		return Warning(Translate(~You must select a setup to load~));
	}

	Key = ~Setup = '<SetupName>'~;

	Query = ~Select * from DigitalCameraSetups Where <Key>~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Query Failed: <Query>. <theErr>~ ) );
	}

	if ( !List( GetFirst, Setup ) )
	{
		return Warning( Translate( ~Could not find a setup named <SetupName>~ ) );
	}

	if ( !Setup( UpdateIn,dlgData ) )
	{
		return Warning( Translate( ~Failed to update the dialog from <SetupName>~ ) );
	}

	value = ~<$con.dlgData[EnableRawFileSharpening]>~;

	if (Numeric(~<value>~))
	{
		// Enable all of the slider stuff
		HideSharpeningControls(FALSE);
		dlg( Update );
		
		LoadImageAttributes();
	} else
	{
		// Disable all of the slider stuff
		HideSharpeningControls(TRUE);
	}

	JPEGEnabled = SimilarStr( ~<$con.dlgData[SaveFileType]>~, JPEG );
	dlg( EnableControls, <JPEGEnabled>, JPEGQualitySlider, JPEGQualityField, JPEGQualityPrompt, JPEGQualityMinStatic, JPEGQualityMaxStatic);

	if (Numeric(~<$con.dlgData[OverrideDeltaSharpening]>~))
	{
		dlg(EnableControls, TRUE, DeltaSharpeningField);
	} else
	{
		dlg(EnableControls, FALSE, DeltaSharpeningField);
	}

	if (Numeric(~<$con.dlgData[UseWorkingspaceProfile]>~))
	{
		dlg(EnableControls, FALSE, ProfileComboBox);
	} else
	{
		dlg(EnableControls, TRUE, ProfileComboBox);
	}

	LoadProfilesComboBox();

	OutputProfileName = ~<$con.dlgData[AlternateOutputProfile]>~;
	if (!IsNULL(~<OutputProfileName>~))
	{
		dlg(SetStrings, OutputProfileName, ~<OutputProfileName>~);
	}

	dlg( Update );

	return TRUE;
}

/***************************************************************************************************/
// This is the function that gets called when you press the '?' button.
VOID OnEditSetups()
{
	Actions = ACTION Doc ( DigitalCameraSetupDoc OpenOnce DigitalCameraSetupDoc "Init(~Digital Camera Setups~);" );

	PerformActions( Actions );
}


/*******************************************/
/***      FOR THE QUEUE OPTIONS TAB      ***/
/*******************************************/


/***************************************************************************************************/
VOID OnImportSetupsComboChanged( )
{
	dlg(GetInput);

	SetWorkStationSettings( ~DigitalCamera~, ~AutoImportSetup~, ~<$con.dlgData[ImportSetup]>~, TRUE );
}

/***************************************************************************************************/
VOID OnCommandsSetupsComboChanged( )
{
	dlg(GetInput);

	SetSystemSettings( ~DigitalCamera~, ~AutoCommandsSetup~, ~<$con.dlgData[CommandsSetup]>~, TRUE );
}

/***************************************************************************************************/
VOID OnAutoQueueImportChanged( )
{
	dlg(GetInput);

	SetWorkStationSettings( ~DigitalCamera~, ~AutoQueueOnImport~, ~<$con.dlgData[AutoQueueOnImport]>~, TRUE );

	Enabled = ~<$con.dlgData[AutoQueueOnImport]>~;
	dlg(EnableControls, <Enabled>, ImportSetupsComboBox, QueueOnImportSetupStatic);
}

/***************************************************************************************************/
VOID OnAutoQueueImportText()
{
	dlg(GetInput);

	value = ~<$con.dlgData[AutoQueueOnImport]>~;
	value = !<value>;

	dlg( SetCheck, <value>, AutoQueueOnImportCheckBox);
	dlg(EnableControls, <value>, ImportSetupsComboBox, QueueOnImportSetupStatic);

	SetWorkStationSettings( ~DigitalCamera~, ~AutoQueueOnImport~, <value>, TRUE);
}

/***************************************************************************************************/
VOID OnAutoQueueCmdsChanged( )
{
	SetSystemSettings( ~DigitalCamera~, ~AutoQueueOnCmds~, ~<$con.dlgData[AutoQueueOnCmds]>~, TRUE );

	Enabled = ~<$con.dlgData[AutoQueueOnCmds]>~;
	dlg(EnableControls, <Enabled>, CommandsSetupsComboBox, QueueOnCommandsSetupStatic);
}

/***************************************************************************************************/
VOID OnAutoQueueCmdsText()
{
	dlg(GetInput);

	value = ~<$con.dlgData[AutoQueueOnCmds]>~;
	value = !<value>;

	dlg( SetCheck, <value>, AutoQueueOnCmdsCheckBox);
	dlg(EnableControls, <value>, CommandsSetupsComboBox, QueueOnCommandsSetupStatic);

	SetSystemSettings( ~DigitalCamera~, ~AutoQueueOnCmds~, <value>, TRUE);
}

/***************************************************************************************************/
VOID OnAutoStartChanged()
{
	SetWorkStationSettings( ~DigitalCamera~, ~AutoStartBackgroundQueue~, ~<$con.dlgData[AutoStartBackgroundQueue]>~, TRUE );
}

/***************************************************************************************************/
VOID OnBkgrndQueueAutoStartText()
{
	dlg(GetInput);

	value = ~<$con.dlgData[AutoStartBackgroundQueue]>~;
	value = !<value>;

	dlg( SetCheck, <value>, BKQueueAutoStartCheckBox);

	SetWorkStationSettings( ~DigitalCamera~, ~AutoStartBackgroundQueue~, <value>, TRUE);
}

/***************************************************************************************************/
VOID OnBackgroundQueueTimerChanged()
{
	dlg(GetInput);

	if (Numeric(~<$con.dlgData[QueueTimerInterval]>~) == Numeric(~<OriginalTimerIntervalValue>~))
	{
		dlg(EnableControls, FALSE, ApplyTimerValueButton);
	} else
	{
		dlg(EnableControls, TRUE, ApplyTimerValueButton);
	}
}

/***************************************************************************************************/
VOID ApplyTimerValue()
{
	SetWorkStationSettings( ~DigitalCamera~, ~QueueTimerInterval~, ~<$con.dlgData[QueueTimerInterval]>~, TRUE );

	DigitalCameraOrderProcessor(SetQueueTimer, Numeric(~<$con.dlgData[QueueTimerInterval]>~) * 1000);
	
	OriginalTimerIntervalValue = Numeric(~<QueueTimerInterval>~);

	dlg(EnableControls, FALSE, ApplyTimerValueButton);
}


/*********************************************/
/***      FOR THE GENERAL OPTIONS TAB      ***/
/*********************************************/

/***************************************************************************************************/
VOID OnImageDescriptionComboChanged( )
{
	dlg(GetInput);

	SetSystemSettings(~DigitalCamera~, ~ImageDescriptionField~, ~<$con.dlgData[ImageDescriptionField]>~, TRUE);
}

/***************************************************************************************************/
VOID OnLoadImageDescriptionChanged( )
{
	dlg(GetInput);

	Enabled = ~<$con.dlgData[LoadImageDescription]>~;
	SetSystemSettings( ~DigitalCamera~, ~LoadImageDescription~, ~<Enabled>~, TRUE );
	SetSystemSettings(~DigitalCamera~, ~ImageDescriptionField~, ~<$con.dlgData[ImageDescriptionField]>~, TRUE);

	dlg(EnableControls, <Enabled>, ImageDescriptionComboBox, LoadImageDescriptionSetupStatic);
}

/***************************************************************************************************/
VOID OnLoadImageDescriptionText()
{
	dlg(GetInput);

	value = ~<$con.dlgData[LoadImageDescription]>~;
	value = !<value>;

	dlg(SetCheck, <value>, LoadImageDescriptionCheckBox);
	dlg(EnableControls, <value>, ImageDescriptionComboBox, LoadImageDescriptionSetupStatic);

	SetSystemSettings(~DigitalCamera~, ~ImageDescriptionField~, ~<$con.dlgData[ImageDescriptionField]>~, TRUE);
	SetSystemSettings( ~DigitalCamera~, ~LoadImageDescription~, <value>, TRUE);
}

/***************************************************************************************************/
VOID OnHighLevelLoggingChanged()
{
	// In order to eliminate the lag time between the setting of this parameter,
	// and when the thread checks the status, we'll just let the thread handle
	// it directly.
	MyCamera(SetLoggingLevel, ~<$con.dlgData[HighLevelLogging]>~);
}



Timer0_Action = ~OnPreviewSizeChanged()~;	// WHERE TO GO WHEN TIMER0 TRIPS

/***************************************************************************************************/
VOID OnPreviewSizeChanged()
{
	dlg(GetInput);

// 0 == variable
// 1 == use highest

	KillTimer( 0 );

	if (Numeric(~<$con.dlgData[Resolution]>~))
	{
		dlg(EnableControls, FALSE, PreviewSizeSlider, PreviewSizeField, PreviewSizeStatic);
		SetUserSettings(~DCPreviewOptions~, ~HighestResolution~, TRUE, TRUE);
	} else
	{
		dlg(EnableControls, TRUE, PreviewSizeSlider, PreviewSizeField, PreviewSizeStatic);
		SetUserSettings(~DCPreviewOptions~, ~HighestResolution~, FALSE, TRUE);
	}

	SetUserSettings(~DCPreviewOptions~, ~MaxPreviewDimension~, ~<$con.dlgData[PreviewImageSize]>~, TRUE);
}


/***************************************************************************************************/
/***************************************************************************************************/
/***																							 ***/
/***								REAL FUNCTIONS BEGIN HERE									 ***/
/***																							 ***/
/***************************************************************************************************/
/***************************************************************************************************/

/***************************************************************************************************/
VOID LoadWorkstationSettings( )
{
	dlg(EnableControls, FALSE, ApplyTimerValueButton);
	
	if ( GetWorkStationSettings( ~DigitalCamera~,~AutoQueueOnImport~, AutoQueueOnImport, Enabled ) )
	{
		if ( Numeric( ~<AutoQueueOnImport>~ ) )
		{
			dlg(SetCheck, TRUE, AutoQueueOnImportCheckBox);
			dlg(EnableControls, TRUE, ImportSetupsComboBox, QueueOnImportSetupStatic);
		} else
		{
			dlg(SetCheck, FALSE, AutoQueueOnImportCheckBox);
			dlg(EnableControls, FALSE, ImportSetupsComboBox, QueueOnImportSetupStatic);
		}
	} else
	{
		dlg(SetCheck, FALSE, AutoQueueOnImportCheckBox);
		dlg(EnableControls, FALSE, ImportSetupsComboBox, QueueOnImportSetupStatic);
	}

	if ( GetWorkStationSettings( ~DigitalCamera~,~AutoImportSetup~, AutoImportSetup, Enabled ) )
	{
		UpdateSetupsList(ImportSetup, ImportSetupsComboBox);
		dlg( SetStrings, ImportSetup, ~<AutoImportSetup>~);
	}

	if ( GetSystemSettings( ~DigitalCamera~,~AutoQueueOnCmds~, AutoQueueOnCmds, Enabled ) )
	{
		if ( Numeric( ~<AutoQueueOnCmds>~ ) )
		{
			dlg(SetCheck, TRUE, AutoQueueOnCmdsCheckBox);
			dlg(EnableControls, TRUE, CommandsSetupsComboBox, QueueOnCommandsSetupStatic);
		} else
		{
			dlg(SetCheck, FALSE, AutoQueueOnCmdsCheckBox);
			dlg(EnableControls, FALSE, CommandsSetupsComboBox, QueueOnCommandsSetupStatic);
		}
	} else
	{
		dlg(SetCheck, FALSE, AutoQueueOnCmdsCheckBox);
		dlg(EnableControls, FALSE, CommandsSetupsComboBox, QueueOnCommandsSetupStatic);
	}

	if ( GetSystemSettings( ~DigitalCamera~,~AutoCommandsSetup~, AutoCommandsSetup, Enabled ) )
	{
		UpdateSetupsList(CommandsSetup, CommandsSetupsComboBox);
		dlg( SetStrings, CommandsSetup, ~<AutoCommandsSetup>~);
	}

	if ( GetWorkStationSettings( ~DigitalCamera~,~AutoStartBackgroundQueue~, AutoStartBackgroundQueue, Enabled ) )
	{
		if ( Numeric( ~<AutoStartBackgroundQueue>~ ) )
		{
			dlg(SetCheck, TRUE, BKQueueAutoStartCheckBox);
		} else
		{
			dlg(SetCheck, FALSE, BKQueueAutoStartCheckBox);
		}
	} else
	{
		dlg(SetCheck, FALSE, BKQueueAutoStartCheckBox);
	}

	if ( GetWorkStationSettings( ~DigitalCamera~,~QueueTimerInterval~, QueueTimerInterval, Enabled ) )
	{
		if ( Numeric( ~<QueueTimerInterval>~ ) )
		{
			dlg(SetString, ~<QueueTimerInterval>~, QueueTimerInterval, 0 );
			OriginalTimerIntervalValue = <QueueTimerInterval>;
			Global(OriginalTimerIntervalValue);
		} else
		{
			dlg(SetString, ~<QueueTimerInterval>~, 10, 0 );
		}
	} else
	{
		dlg(SetString, ~<QueueTimerInterval>~, 10, 0 );
	}

	if (GenCon( LocalDCOptionsGC,GetFrom,DCOptionsGC,~[GENCONS]~ ))
	{
		bUseHighLevelLogging = 0;
		LocalDCOptionsGC( GetValue, ~HighLevelDCLogging~, bUseHighLevelLogging);
		dlg(SetCheck, <bUseHighLevelLogging>, HighLevelLoggingCheckBox);
	}

	if ( GetSystemSettings(~DigitalCamera~, ~LoadImageDescription~, LoadImageDescription, Enabled) )
	{
		if ( Numeric( ~<LoadImageDescription>~ ) )
		{
			dlg(SetCheck, TRUE, LoadImageDescriptionCheckBox);
			dlg(EnableControls, TRUE, ImageDescriptionComboBox, LoadImageDescriptionSetupStatic);
		} else
		{
			dlg(SetCheck, FALSE, LoadImageDescriptionCheckBox);
			dlg(EnableControls, FALSE, ImageDescriptionComboBox, LoadImageDescriptionSetupStatic);
		}
	} else
	{
		dlg(SetCheck, FALSE, LoadImageDescriptionCheckBox);
		dlg(EnableControls, FALSE, ImageDescriptionComboBox, LoadImageDescriptionSetupStatic);
	}

	if ( GetSystemSettings( ~DigitalCamera~,~ImageDescriptionField~, ImageDescriptionField, Enabled ) )
	{
		dlg( SetStrings, ImageDescriptionField, ~<ImageDescriptionField>~);
	}

	if (GetUserSettings(~DCPreviewOptions~, ~HighestResolution~, bUseHighestResolution, Enabled))
	{
		if (<bUseHighestResolution>)
		{
			dlg(EnableControls, FALSE, PreviewSizeSlider, PreviewSizeField, PreviewSizeStatic);
			dlg( SetStrings, Resolution, ~1~);
		} else
		{
			dlg(EnableControls, TRUE, PreviewSizeSlider, PreviewSizeField, PreviewSizeStatic);
			dlg( SetStrings, Resolution, ~0~);
		}
	} else
	{
		dlg(EnableControls, TRUE, PreviewSizeSlider, PreviewSizeField, PreviewSizeStatic);
		dlg( SetStrings, Resolution, ~0~);
	}

	if (GetUserSettings(~DCPreviewOptions~, ~MaxPreviewDimension~, PreviewImageSize, Enabled))
	{
		dlg(SetStrings, PreviewImageSize, ~<PreviewImageSize>~);
	} else
	{
		dlg(SetStrings, ~<$con.dlgData[PreviewImageSize]>~, ~660~);
	}

	if ( GetWorkStationSettings( ~DigitalCamera~,~PreviewAllClickBalances~, PreviewAllClickBalances, Enabled ) )
	{
		if ( Numeric( ~<PreviewAllClickBalances>~ ) )
		{
			dlg(SetCheck, TRUE, PreviewAllClickBalancesCheckBox);
		} else
		{
			dlg(SetCheck, FALSE, PreviewAllClickBalancesCheckBox);
		}
	} else
	{
		dlg(SetCheck, FALSE, PreviewAllClickBalancesCheckBox);
	}

}

/***************************************************************************************************/
// NOTE: This function won't work for situations where you have a minvalue of, say, 10, since when you
// enter '100', it chokes on the '1' that you entered first...
VOID AuditField( FieldName,LowValue,HighValue,DefaultValue, Stringname )
{
	dlg(GetInput);

	dlg( GetControlValue,~<FieldName>~,Value );

	if ( ~<Value>~ == ~-~ )
	{
		if ( <LowValue> < 0 )
		{
			return;
		}
		else
		{
			dlg(SetStrings, ~<Stringname>~, ~<LowValue>~);

			MessageBox(~Value must be greater than or equal to <LowValue>~ );
						
			// Now set the focus back to that control
			if (~<FieldName>~ != ~~)
			{
				dlg( SetControlFocus, ~<FieldName>~ );
			}

			return;
		}
	}

	if ( Numeric(~<Value>~) < <LowValue> )
	{
		dlg(SetStrings, ~<Stringname>~, ~<LowValue>~);
		MessageBox(~Value must be greater than or equal to <LowValue>~ );
		
		// Now set the focus back to that control
		if (~<FieldName>~ != ~~)
		{
			dlg( SetControlFocus, ~<FieldName>~ );
		}
	}
	else if ( Numeric(~<Value>~) > <HighValue> )
	{
		dlg(SetStrings, ~<Stringname>~, ~<HighValue>~);

		MessageBox(~Value must be less than or equal to <HighValue>~ );

		// Now set the focus back to that control
		if (~<FieldName>~ != ~~)
		{
			dlg( SetControlFocus, ~<FieldName>~ );
		}
	}
}

/***************************************************************************************************/
NUMERIC ChooseDestinationFolder(&OutputFolder, StartingDirectory)
{
	Title = Translate( ~Choose a destination for processed Kodak Raw Camera Images~ );
	FileFilter = ~All Files|*.*||~;

	if ( FileDialog( Title,~<title>~,PATH,Path,DefaultFile,~Choose an output folder~, DefaultDirectory, ~<StartingDirectory>~, FILTER,~<FileFilter>~, OPEN, NOREADONLYRETURN) )
	{
		OutputFolder = ~<$Str.$Path.Path>~;

 		// Make sure that the path is a UNC Path.
		OutputFolder = MakePath( Type,UNC,~<OutputFolder>~);

		if ( !Files( IsUNC,~<OutputFolder>~ ) && NetworkOperation() )
		{
			Msg = Translate( UIMessages,UnsharedFolder,~<OutputFolder>~ );

			if ( MessageBox( ~<Msg>~,YESNO ) != YES )
			{ 
				return FALSE;
			} else
			{
				// Recursively call this function until they say "No", or they choose a UNC path.
				return ChooseDestinationFolder(OutputFolder, ~<StartingDirectory>~);
			}
		}

		return TRUE;
	}

	return FALSE;
}


/***************************************************************************************************/
VOID ChooseNewDestinationFolder(&OutputFolder)
{
	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

	if (dlg(ListBox, DigitalOrderImages, GetSelectedItem, ImagePath))
	{
		FileName = ~<$Str.$ImagePath.FileName>~;

		if (!GetRollAndFrameForFile(LocalDBConnect, ~<ImagePath>~, Roll, Frame))
		{
			MessageBox( ~There was an error getting the Roll or Frame for the image: <ImagePath>.~ );
			return;
		}

		if (IsNULL(~<OrderID>~) || IsNULL(~<Roll>~) || IsNULL(~<Frame>~) )
		{
			return;
		}

		Query = ~Select OutputPath From RawImages Where OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>'~;
		if (LocalDBConnect(RecordCountFor, ~<Query>~))
		{
			if (!PGenConList(List,Connection,LocalDBConnect,Cursor,Forward,Query,~<Query>~) )
			{
				List(GetErrorDescription, 0, theErr);
				Warning(~Error querying shared database:<theErr>~);
			}

			List(GetFirst, OutputPathRecord);
		}

		StartingDirectory = ~<$pcon.OutputPathRecord[OutputPath]>~;

		if ( ChooseDestinationFolder(OutputFolder, ~<StartingDirectory>~) )
		{
			if (~<OutputFolder>~ != ~~)
			{
				SQLCommand = ~Update RawImages Set OutputPath='<OutputFolder>'~;

				ParametersChanged(~<SQLCommand>~);
			}

			return;
		}

		return;
	} else
	{
		dlg( SetStatus, 0, ~~);
		StatusMessage = ~~;
		Warning(~You must select an order and/or image(s).~);
		return;
	}
}

/***************************************************************************************************/
VOID CancelProcessing()
{
	MyCamera(StopQueue);

	dlg(EnableControls, FALSE, CancelProcessingButton);

	// If they decide to cancel processing, then we need to disable these two buttons.
	// Otherwise the combination of cleaning out the queue while simultaneously adding
	// things to the queue breaks things. This is a much less complicated solution to the
	// problem, as opposed to managing the flags more aggressively so you can keep track
	// of what should be added and what should be removed from the queue.
	dlg(EnableControls, FALSE, PreviewButton);
	dlg(EnableControls, FALSE, ProcessNowButton);

	if (MyCamera(WaitToClose))
	{
		dlg(SetStatus, 0, ~Processing will stop when the current image is finished...~ );
		StatusMessage = ~~;
	}
}

/***************************************************************************************************/
VOID RightClickIn()
{
	if ( dlg( GetControlWithFocus, CtrlName ) )
	{
		if (SimilarStr(~<CtrlName>~, ~DigitalOrders~))
		{
			Class(OrdersListMenu, Extends, BaseMenu);

			OrdersListMenu(New, theMenu);

			theMenu.DisplayInView(dlg);
		}
		
		return;
	}

	return;
}

/***************************************************************************************************/
VOID OrdersListMenu::AddMenuItems( &View )	// OVERRIDE FROM BASEMENU TO ADD MENU ITEMS
{
	OrderID = ~<$con.DlgData[Directory]>~;

	if ( ~<OrderID>~ == ~~ )
	{
		MessageBox(~No Order was selected~);
		return;
	}

	Query = ~Select * From Images Where OrderID In ('<OrderID>') Order By OrderID,Roll,Frame~;

	WhichDoc = ImagesDoc;

	Actions = ACTION Doc ( ~OrderImages~ OpenOnce <WhichDoc> "Init( ~<OrderID>~, 1,~<Query>~,0 );" );

	AddMenuItem(TRUE, FALSE, Translate(~Open Order Images~), Actions);
}

/***************************************************************************************************/
VOID OpenOrderImages( )
{
	OrderID = ~<$con.DlgData[Directory]>~;

	if ( ~<OrderID>~ == ~~ )
	{
		MessageBox(~No Order was selected~);
		return;
	}

	Query = ~Select * From Images Where OrderID In ('<OrderID>') Order By OrderID,Roll,Frame~;

	WhichDoc = ImagesDoc;

	Actions = ACTION Doc ( ~OrderImages~ OpenOnce <WhichDoc> "Init( ~<OrderID>~, 1,~<Query>~,0 );" );

	PerformActions( Actions );
}

/***************************************************************************************************/
VOID OpenBackgroundQueue()
{
	action = ACTION Doc ( DigitalCameraOrderProcessor OpenOnce DigitalCameraQueueDoc "ConsoleInit();" );

	PerformActions( action );
}

/***************************************************************************************************/
VOID UpdateImagesList( )
{
	GetImagesFromSelectedOrder();

	dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);

	LoadImageAttributes();
}

/***************************************************************************************************/
// This function simply answers the question as to whether or not a record already exists in the
// DCImageProperties table.
NUMERIC PropertyRecordExists(&dBase, OrderID, Roll, Frame)
{
	if (IsNULL(~<OrderID>~) || IsNULL(~<Roll>~) || IsNULL(~<Frame>~) )
	{
		return FALSE;
	}

	Query = ~Select OrderID From DCImageProperties Where OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>'~;

	count = dBase(RecordCountFor, ~<Query>~);

	if (!<count>)
	{
		return FALSE;
	} else
	{
		return TRUE;
	}
}

/***************************************************************************************************/
NUMERIC ValidateParameter(ImagePath, ParameterName, ParameterValue, GetOrSetOrNone)
{
	if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~<ImagePath>~))
	{
		MessageBox( ~There was an error setting the source image path id! DP2 will be unable to retrieve settings for <ImagePath>.~ );
		return FALSE;
	}

	TranslatedParameterName = MyCamera(~<ParameterName>~);

	bReturn = MyCamera(CapabilitySupported, ~<TranslatedParameterName>~);

	if (~<bReturn>~ == ~1~)
	{
		if (~<GetOrSetOrNone>~ == ~GET~)
		{
			bReturn = MyCamera(GetAttributeValue, MyCamera(~<ParameterName>~), junk);
		} else if (~<GetOrSetOrNone>~ == ~SET~)
		{
			if (!IsNumeric(~<ParameterValue>~))
			{
				// Translate the parameter value
				TranslatedParameterValue = MyCamera(~<ParameterValue>~);
			} else
			{
				TranslatedParameterValue = ~<ParameterValue>~;
			}

			// If we get 0 back, but the original value was really 0, then use that.
			if ( (~<TranslatedParameterValue>~ == ~0~) && (~<ParameterValue>~ == ~0~) )
			{
				bReturn = MyCamera(SetAttributeValue, ~<TranslatedParameterName>~, ~<TranslatedParameterValue>~);
			} else if (~<TranslatedParameterValue>~ == ~0~)
			{
				// Use the real parameter value, since it must be a data point.
				bReturn = MyCamera(SetAttributeValue, ~<TranslatedParameterName>~, ~<ParameterValue>~);
			} else
			{
				// Otherwise we use the transated value, since it must be meaningful.
				bReturn = MyCamera(SetAttributeValue, ~<TranslatedParameterName>~, ~<TranslatedParameterValue>~);
			}
		}
	}

	// Release our handle to the picture
	MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);

	return (~<bReturn>~ == ~1~);
}


/***************************************************************************************************/
VOID NRParametersChangedWithValidation(NoiseSetting, NoiseFilterStrength, NoiseFilterRadius)
{
	// Have to iterate through all images selected in the list.
	dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	Index = 0;
	InvalidIndex = 0;
	InvalidFilename = ~~;

	while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
	{
		FileName = ~<$Str.$ImagePath.FileName>~;

		if ( (~<NoiseSetting>~ == ~Advanced~) || (~<NoiseSetting>~ == ~Advanced with Moire Reduction~) )
		{
			if (ValidateParameter(~<ImagePath>~, ~KVTPICPROCNoiseFilterModeID~, ~KVTPICPROCNoiseFilterModeMoireWithRadius~, ~SET~))
			{
				bSupportsRadius = TRUE;
			} else
			{
				bSupportsRadius = FALSE;
			}

			if ( (~<noiseSetting>~ == ~Advanced~) && !<bSupportsRadius>)
			{
				SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'Chroma'~;
				NoiseMode = KVTPICPROCNoiseFilterModeChroma;
			}
			else if ( (~<noiseSetting>~ == ~Advanced with Moire Reduction~) && !<bSupportsRadius>)
			{
				// SAVE THRESHOLD ALSO
				FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;
				SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'Moire', NoiseFilterStrengthID = '<FilterStrengthID>'~;
				NoiseMode = KVTPICPROCNoiseFilterModeMoire;
			}
			else if ((~<noiseSetting>~ == ~Advanced~) && <bSupportsRadius>)
			{
				// SAVE THRESHOLD && RADIUS ALSO
				FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;
				FilterRadiusID = ~<$con.DlgData[NRRadius]>~;
				SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'ChrRad', NoiseFilterStrengthID = '<FilterStrengthID>', NoiseFilterRadiusID = '<FilterRadiusID>'~;
				NoiseMode = KVTPICPROCNoiseFilterModeChromaWithRadius;
			}
			else if (( ~<noiseSetting>~ == ~Advanced with Moire Reduction~ ) && <bSupportsRadius>)
			{
				// SAVE THRESHOLD && RADIUS ALSO
				FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;
				FilterRadiusID = ~<$con.DlgData[NRRadius]>~;
				SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'MoiRad', NoiseFilterStrengthID = '<FilterStrengthID>', NoiseFilterRadiusID = '<FilterRadiusID>'~;
				NoiseMode = KVTPICPROCNoiseFilterModeMoireWithRadius;
			}

		} 
		else if ( ~<NoiseSetting>~ == ~Expert~ )
		{
			if (ValidateParameter(~<ImagePath>~, ~KVTPICPROCNoiseFilterModeID~, ~KVTPICPROCNoiseFilterModeExpert~, ~SET~))
			{
				bSupportsRadius = FALSE;
			} else
			{
				bSupportsRadius = FALSE;
			}
			if (!<bSupportsRadius>)
			{
				// SAVE THRESHOLD && RADIUS ALSO
				FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;
				FilterRadiusID = ~<$con.DlgData[NRRadius]>~;
				SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'Expert', NoiseFilterStrengthID = '<FilterStrengthID>', NoiseFilterRadiusID = '<FilterRadiusID>'~;
				NoiseMode = KVTPICPROCNoiseFilterModeExpert;
			}
		}
		
		else if ( ~<NoiseSetting>~ == ~Basic with Radius~ )
		{
			if (ValidateParameter(~<ImagePath>~, ~KVTPICPROCNoiseFilterModeID~, ~KVTPICPROCNoiseFilterModeBasicWithRadius~, ~SET~))
			{
				bSupportsRadius = TRUE;
			} else
			{
				bSupportsRadius = FALSE;
			}
			if (<bSupportsRadius>)
			{
				// SAVE THRESHOLD && RADIUS ALSO
				FilterStrengthID = ~<$con.DlgData[NRStrengthThreshold]>~;
				FilterRadiusID = ~<$con.DlgData[NRRadius]>~;
				SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'BasRad', NoiseFilterStrengthID = '<FilterStrengthID>', NoiseFilterRadiusID = '<FilterRadiusID>'~;
				NoiseMode = KVTPICPROCNoiseFilterModeBasicWithRadius;
			};
		}
		else if ( ~<NoiseSetting>~ == ~Off~ )
		{
			SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'None'~;
			NoiseMode = KVTPICPROCNoiseFilterModeOff;
		}
		else if ( ~<NoiseSetting>~ == ~Basic~ )
		{
			SQLCommand = ~UPDATE DCImageProperties SET NoiseFilterTypeID = 'Sigma'~;
			NoiseMode = KVTPICPROCNoiseFilterModeBasic;
		}

		// Validation goes here
		if ( ValidateParameter(~<ImagePath>~, ~KVTPICPROCNoiseFilterModeID~, ~<NoiseMode>~, ~SET~) )
		{
			// Parameter change goes here
			if (!GetRollAndFrameForFile(LocalDBConnect, ~<ImagePath>~, Roll, Frame))
			{
				MessageBox( ~There was an error getting the Roll or Frame for the image: <ImagePath>.~ );
				return;
			}

			if (!PropertyRecordExists(LocalDBConnect, ~<OrderID>~, ~<Roll>~, ~<Frame>~))
			{
				CreatePropertiesRecord(LocalDBConnect, ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<SQLCommand>~);
			}

			dlg(GetInput);

			if (IsNULL(~<OrderID>~) || IsNULL(~<Roll>~) || IsNULL(~<Frame>~) )
			{
				return;
			}

			SQLCommand = ~<SQLCommand>~ + ~ WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>')~;

			if (!LocalDBConnect(Cmd, ~<SQLCommand>~))
			{
				LocalDBConnect(GetErrorDescription, theErr);
				Warning( Translate(~Database update failed <SQLCommand>. <theErr>~));
				return;
			}
		} else
		{
			<InvalidIndex++>;
			InvalidFilename = ~<FileName>~;
		}
	}

	if (<InvalidIndex> == 1)
	{
		MessageBox(~Unable to apply the new process parameter to <InvalidFilename>. The change can be applied only to those files which support the given setting.~);
	} else if (<InvalidIndex> > 1)
	{
		MessageBox(~Not all the images could have the new process parameters applied to them. The change can be applied only to those files which support the given setting.~);
	}

	LocalDBConnect(RefreshCache);
	LocalDBConnect(Close);
}



/***************************************************************************************************/
VOID ParametersChangedWithValidation(SQLStatementStart, ParameterName, ParameterValue, GetOrSetOrNone)
{
	// Have to iterate through all images selected in the list.
	dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	Index = 0;

	InvalidIndex = 0;
	InvalidFilename = ~~;

	while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
	{
		FileName = ~<$Str.$ImagePath.FileName>~;

		// Validation goes here
		if ( ValidateParameter(~<ImagePath>~, ~<ParameterName>~, ~<ParameterValue>~, ~<GetOrSetOrNone>~) )
		{
			// Parameter change goes here
			if (!GetRollAndFrameForFile(LocalDBConnect, ~<ImagePath>~, Roll, Frame))
			{
				MessageBox( ~There was an error getting the Roll or Frame for the image: <ImagePath>.~ );
				return;
			}

			if (!PropertyRecordExists(LocalDBConnect, ~<OrderID>~, ~<Roll>~, ~<Frame>~))
			{
				CreatePropertiesRecord(LocalDBConnect, ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<SQLStatementStart>~);
			}

			dlg(GetInput);

			if (IsNULL(~<OrderID>~) || IsNULL(~<Roll>~) || IsNULL(~<Frame>~) )
			{
				return;
			}

			SQLCommand = ~<SQLStatementStart>~ + ~ WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>')~;

			if (!LocalDBConnect(Cmd, ~<SQLCommand>~))
			{
				LocalDBConnect(GetErrorDescription, theErr);
				return Warning( Translate(~Database update failed <SQLCommand>. <theErr>~));
			}
		} else
		{
			<InvalidIndex++>;
			InvalidFilename = ~<FileName>~;
		}
	}

	if (<InvalidIndex> == 1)
	{
		MessageBox(~Unable to apply the new process parameter to <InvalidFilename>. The change can be applied only to those files which support the given setting.~);
	} else if (<InvalidIndex> > 1)
	{
		MessageBox(~Not all the images could have the new process parameters applied to them. The change can be applied only to those files which support the given setting.~);
	}

	LocalDBConnect(RefreshCache);

	LocalDBConnect(Close);
}



/***************************************************************************************************/
VOID ParametersChanged(SQLStatementStart)
{
	// Have to iterate through all images selected in the list.
	dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	LocalDBConnect(BeginTransaction);

	Index = 0;
	while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
	{
		FileName = ~<$Str.$ImagePath.FileName>~;

		if (!GetRollAndFrameForFile(LocalDBConnect, ~<ImagePath>~, Roll, Frame))
		{
			MessageBox( ~There was an error getting the Roll or Frame for the image: <ImagePath>.~ );
			LocalDBConnect(RollBackTransaction);
			return;
		}

		if (!PropertyRecordExists(LocalDBConnect, ~<OrderID>~, ~<Roll>~, ~<Frame>~))
		{
			// DO NOT want to do this if we're doing a DELETE!!!
			if (~<SQLStatementStart>~ != ~DELETE FROM DCImageProperties~)
			{
				CreatePropertiesRecord(LocalDBConnect, ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<SQLStatementStart>~);
			}
		}

		dlg(GetInput);

		if (IsNULL(~<OrderID>~) || IsNULL(~<Roll>~) || IsNULL(~<Frame>~) )
		{
			LocalDBConnect(RollBackTransaction);
			return;
		}

		SQLCommand = ~<SQLStatementStart>~ + ~ WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>')~;

		if (!LocalDBConnect(Cmd, ~<SQLCommand>~))
		{
			LocalDBConnect(GetErrorDescription, theErr);
			LocalDBConnect(RollBackTransaction);
			Warning( Translate(~Database update failed <SQLCommand>. <theErr>~));
			return;
		}
	}

//	LocalDBConnect(RefreshCache);
	LocalDBConnect(CommitTransaction);

	LocalDBConnect(Close);
}

/***************************************************************************************************/
// This function creates a record consisting basically of just the primary key of OrderID, Roll & Frame
// The caller will be responsible for setting the appropriate data fields with an UPDATE SQL statement.
NUMERIC CreatePropertiesRecord(&dBase, OrderID, Roll, Frame, SQLStatementStart)
{
	Parameters = ~OrderID, Roll, Frame, ClickBalanceRed, ClickBalanceGreen, ClickBalanceBlue, ExposureGainID~;

	Values = ~'<OrderID>','<Roll>','<Frame>', -1, -1, -1, -20~;

	SQLCommand = ~Insert Into DCImageProperties(<Parameters>) Values(<Values>)~;

	if (!dBase(Cmd, ~<SQLCommand>~))
	{
		// If it failed, that might be because of lazy writes, and we really just want to do an update.
		if (PropertyRecordExists(dBase, ~<OrderID>~, ~<Roll>~, ~<Frame>~))
		{
			// If exists, which is why the insert failed. So do an update instead.
			SQLCommand = ~<SQLStatementStart>~ + ~ WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>')~;

			if (!dBase(Cmd, ~<SQLCommand>~))
			{
				dBase(GetErrorDescription, theErr);
				return Warning( Translate(~Database update failed <SQLCommand>. <theErr>~));
			}
		} else
		{
			// The record does not exist, so the update failed for some other reason, so it's
			// OK to error out.
			dBase(GetErrorDescription, theErr);
			return Warning( Translate(~Database update failed <SQLCommand>. <theErr>~));
		}
	}

	dBase(RefreshCache);

	return TRUE;
}

/***************************************************************************************************/
VOID RevertSettings( )
{
	// Delete the DCImageProperties record for the selected image(s)
	SQLCommand = ~DELETE FROM DCImageProperties~;

	ParametersChanged(~<SQLCommand>~);

	LoadImageAttributes(TRUE);
}

/***************************************************************************************************/
VOID CloseDialog()
{
	if (MyCamera(WaitToClose))
	{
		Warning( ~Sorry, we can not close the dialog yet since there are images being processed!~ );
		dlg( SetDlgHandleActionsFlag, TRUE );
		return;
	}

	dlg( End );

	Exit();
}

/***************************************************************************************************/
VOID OpenImportImages()
{
	// Initialize with the name of the currently selected order, if there is one.
	Actions = ACTION Doc ( ImportImagesDoc OpenOnce ImportImagesDoc "Init(~<$con.DlgData[Directory]>~, ~1~);" );

	PerformActions( Actions );
}

/***************************************************************************************************/
VOID ReOpen(  )
{
	dlg(SetWindowOrder, Top, SetFocus);
}

/********************************************************************************************/
VOID OnClickBalance( Path,x,y,x2,y2 )
{
	//////////////////////////////////////////////////////////////////////////////////////////////////////////
	// Setup the input file
	dlg(ListBox, DigitalOrderImages, GetSelectedItem, Item);

	if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~<Path>~))
	{
		MessageBox( ~There was an error setting the source image path id!~ );
		return;
	}

	if (!MyCamera(CapabilitySupported, MyCamera(KVTPICPROCClickWhiteBalanceRGBTripletID)))
	{
		// If we can't do a click balance, then maybe the image the user clicked on wasn't a
		// digital camera image, or maybe it was, but got processed (NOTE: You can't just check the
		// extension for.DCR, because the file may have been a legacy camera image with a .tif extension!)
		// In any case, if this failed, then we'll see if the image has a corresponding image in
		// the RawImages table. If not, then we bail. Otherwise we try again with that image.

		if (!ADO(dBase, Connect))
		{
			dbase( GetErrorDescription, theErr);
			Warning( Translate( ~OnClickBalance: Could not connect to the database. <theErr>~ ) );
			return;
		}

		if (!IsNULL(~<Path>~))
		{
			Query = ~SELECT OrderID, Roll, Frame FROM Images WHERE Path = '<Path>'~;

			if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
			{ 
				List( GetErrorDescription,0,theErr );
				Warning( Translate( ~Failed to query the Images table.\n\n<Query>\n\n<theErr>~ ) ); 
				return;
			}

			if ( List( GetFirst,ImageRecord ) )
			{
				OrderID = ~<$pcon.ImageRecord[OrderID]>~;
				Roll = ~<$pcon.ImageRecord[Roll]>~;
				Frame = ~<$pcon.ImageRecord[Frame]>~;
			} else
			{
				// The image doesn't have an entry in the Images table, so we're out of luck!
				MessageBox(~Click balance can not be performed on non-Kodak Raw Images. Please try another image!~ );
				MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
				return;
			}
		} else
		{
			return;
		}

		if (IsNULL(~<OrderID>~) || IsNULL(~<Roll>~) || IsNULL(~<Frame>~) )
		{
			return;
		}

		ForgetLocal(List);

		Query = ~SELECT Path FROM RawImages WHERE OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>' AND ImageType = 0~;

		if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
		{ 
			List( GetErrorDescription,0,theErr );
			Warning( Translate( ~Failed to query the Images table.\n\n<Query>\n\n<theErr>~ ) ); 
			return;
		}

		if ( List( GetFirst,ImageRecord2) )
		{
			Path = ~<$pcon.ImageRecord2[Path]>~;
		} else
		{
			// The image doesn't have an entry in the RawImages table, so we're definitely out of luck!
			MessageBox(~Click balance can not be performed on non-Kodak Raw Images. Please try another image!~ );
			MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
			return;
		}

		// Set the path to the Raw Image file
		if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~<Path>~))
		{
			MessageBox( ~There was an error setting the source image path id!~ );
			return;
		}

		// Try again. If it fails, then we can't do anything!
		if (!MyCamera(CapabilitySupported, MyCamera(KVTPICPROCClickWhiteBalanceRGBTripletID)))
		{
			MessageBox(~Click balance can not be performed on non-Kodak Raw Images. Please try another image!~ );
			MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
			return;
		}
	}

// Perform a scaling operation so that we can figure out what the high-res coordinate
// equivalent is.

	if (!MyCamera(GetAttributeValue, MyCamera(KVTPICPROCHiResWidthID), nWidth))
	{
		MessageBox( ~There was an error getting the image width!~ );
	}

	if (!MyCamera(GetAttributeValue, MyCamera(KVTPICPROCHiResHeightID), nHeight))
	{
		MessageBox( ~There was an error getting the image height!~ );
	}

	ActualX = <nWidth> * (<x> / <x2>);
	ActualY = <nHeight> * (<y> / <y2>);

	dlg( SetStrings, CenterPtRow, ~<ActualY>~);
	dlg( SetStrings, CenterPtCol, ~<ActualX>~);

	if (!MyCamera(DoClickBalance, DlgData))
	{
		MessageBox( ~Sorry, but the image might be saturated at that point. Please try to click balance in a different spot.~ );
		MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
		return;
	} else
	{
		SaveClickBalanceValues();
	}

	// Set the balance type to "Click"
	dlg(SetCheck, FALSE, BalanceAuto, BalancePreset, BalanceCustom);
	
	dlg(EnableControls, TRUE, BalanceClick);
	dlg(SetCheck, TRUE, BalanceClick);

	MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);

	if (Numeric(~<$con.dlgData[PreviewAllClickBalances]>~))
	{
		PreviewImageNonQueueing();
	}
}

/***************************************************************************************************/
VOID RefreshLists()
{
	dlg(GetInput);

	// Remember the previously selected order so we can hilight it again later
	SelectedOrder = ~~;
	dlg( ListBox, DigitalOrders, GetSelectedItem, SelectedOrder);

	// Remember the previously selected image so we can hilight it again later
	SelectedImage = ~~;
	dlg( ListBox, DigitalOrderImages, GetSelectedItem, SelectedImage);

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	GetOrdersFromDatabase(LocalDBConnect);

	if ( ~<SelectedOrder>~ == ~~)
	{
		dlg( ListBox, DigitalOrders, Select, 0);
		
		GetImagesFromSelectedOrder();

		dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);

	} else
	{
		Index = dlg( ListBox, DigitalOrders, SelectString, -1, ~<SelectedOrder>~);
		if ( ~<Index>~ == ~-1~)
		{
			dlg( ListBox, DigitalOrders, Select, 0);
		}

		GetImagesFromSelectedOrder();

		if (~<SelectedImage>~ == ~~)
		{
			dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);
		} else
		{
			// TODO: SelectString doesn't work for multi-select list boxes (this is an MFC limitation). 
			// Eventually add a FindString function which preforms this action as desired.
			dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);

//			Index = dlg( ListBox, DigitalOrderImages, SelectString, -1, ~<SelectedImage>~);
//			if ( ~<Index>~ == ~-1~)
//			{
//				dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);
//			}
		}
	}

	LoadImageAttributes();
}

/***************************************************************************************************/
NUMERIC GetOrdersFromDatabase(&dBase)
{
	dlg(GetInput);

	// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
	if (!PGenConList(List,Connection,dBase,Query,~Select * From Orders Where CameraFileConversionStatus = 1~) )
	{
		List(GetErrorDescription,0,theErr);
		Warning(~Error querying shared database:<theErr>~);
	}

	List(MakeStringList, aList, ID);
	
	dlg(SetControlFromStringList, DigitalOrders, aList);

	return TRUE;
}

/***************************************************************************************************/
NUMERIC CheckOrderExists(&connection)
{
	Query = ~SELECT * FROM Orders WHERE ID = '<$con.DlgData[Directory]>'~;

	count = connection(RecordCountFor, ~<Query>~);

	if ( ~<count>~ == ~0~ )
	{
		Messagebox(~It seems that Order '<$con.DlgData[Directory]>' was deleted, so it will be removed from the Orders list.~);
		return FALSE;
	} else
	{
		return TRUE;
	}
}

/***************************************************************************************************/
NUMERIC GetImagesFromSelectedOrder()
{
	dlg(GetInput);

	// Get the currently selected order ID from the GUI
	OrderID = ~<$con.DlgData[Directory]>~;

	// There are no more orders in the list, so get out of here!
	if (~<OrderID>~ == ~~)
	{
		PGenConList(List);
		List(MakeStringList, ImagesList, junk);
		dlg(SetControlFromStringList, DigitalOrderImages, ImagesList);
		return FALSE;
	}

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	// If the order has been removed, then we tell the user and refresh the lists.
	if (!CheckOrderExists(LocalDBConnect))
	{
		GetOrdersFromDatabase(LocalDBConnect);

		dlg( ListBox, DigitalOrders, Select, 0);
		GetImagesFromSelectedOrder();
	}

	// If there are no images in the order, then we should really mark the order CameraFileConversionStatus 
	// as "Complete" so that it will drop off of our list. Then we should refresh the lists.

	OrderID = ~<$con.DlgData[Directory]>~;
	Query = ~Select BatchID From DCQueue Where OrderID = '<OrderID>'~;
	QueueCount = LocalDBConnect(RecordCountFor, ~<Query>~);

	// If there's images from this order still in the queue, then we want to mark it 
	// In Progress. Otherwise we mark it Complete.
	if (<QueueCount> > 0)
	{
		// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
		CheckOrderCompleted(LocalDBConnect, 2);		// The order conversion is still in progress
	} else
	{
		// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
		if (CheckOrderCompleted(LocalDBConnect, 3))		// The order conversion is now complete
		{
			// If it returned true, then we know that we should select the first order again.
			// Selecting an order will recursively call this function, but once we're out of orders
			// we should roll out of the recursion OK.

			Messagebox(~All images in Order '<OrderID>' have been processed or queued. Its Camera File Conversion status will be changed it will be taken out of the Orders to Process list.~);
			dlg( ListBox, DigitalOrders, Select, 0);
			GetImagesFromSelectedOrder();
		}
	}

	ForgetLocal(List);

	if (!PGenConList(List,Connection,LocalDBConnect,Query,~Select * From RawImages Where OrderID = '<$con.DlgData[Directory]>' AND Processed <> 1 AND ImageType = 0 AND Path IS NOT NULL ORDER BY Path~) )
	{
		List(GetErrorDescription,0,theErr);
		Warning(~Error querying shared database:<theErr>~);
	}

	List(MakeStringList, ImagesList, Path);

	dlg(SetControlFromStringList, DigitalOrderImages, ImagesList);

	return TRUE;
}

/***************************************************************************************************/
// Given an input file name, get the attributes and set the controls
// as appropriate
VOID LoadImageAttributes(bOverrideDBChanges)
{
	bChangesWereMade = FALSE;

	dlg(GetInput);

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	//////////////////////////////////////////////////////////
	// See if any changes were made to the image attributes //
	//////////////////////////////////////////////////////////
	dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

	if (dlg(ListBox, DigitalOrderImages, GetSelectedItem, ImagePath))
	{
		// First make sure that the file at ImagePath exists...

		FileNotFoundMessage = ~The selected file could not be found.~;
		if (!Files(FileExists, ~<ImagePath>~))
		{
			StatusMessage = ~<FileNotFoundMessage>~;
			dlg( SetStatus, 0, ~<StatusMessage>~);

			// Disable everything here!
			EnableControlsBool(FALSE);

			return;
		} else
		{
			if (~<StatusMessage>~ == ~<FileNotFoundMessage>~)
			{
				dlg(SetStatus, 0, ~~);
				StatusMessage = ~~;
			}
		}

		FileName = ~<$Str.$ImagePath.FileName>~;

		if (!GetRollAndFrameForFile(LocalDBConnect, ~<ImagePath>~, Roll, Frame))
		{
			MessageBox( ~There was an error getting the Roll or Frame for the image: <ImagePath>.~ );
			return;
		}

		if (IsNULL(~<OrderID>~) || IsNULL(~<Roll>~) || IsNULL(~<Frame>~) )
		{
			return;
		}

		// If we're overriding the database changes, that means that we probable just chose to
		// revert the file's settings. We ignore the database because sometimes this reload of image
		// attributes comes before the database is finished with removing the entry. Thus, it appears
		// to the user that nothing happened. We can ignore the database here since the calling function
		// has told us to do so.
		if (Numeric(~<bOverrideDBChanges>~))
		{
			bChangesWereMade = FALSE;
		} else
		{
			Query = ~Select * From DCImageProperties Where OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>'~;
			if (LocalDBConnect(RecordCountFor, ~<Query>~))
			{
				bChangesWereMade = TRUE;

				if (!PGenConList(List,Connection,LocalDBConnect,Cursor,Forward,Query,~Select * From DCImageProperties Where OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>'~) )
				{
					List(GetErrorDescription, 0, theErr);
					Warning(~Error querying shared database:<theErr>~);
				}

				List(GetFirst, ImagePropertiesRecord);
			}			
		}
	} else
	{
		// Disable everything here!
		EnableControlsBool(FALSE);

		return;
	}

	/////////////////
	// RGB SLIDERS //
	/////////////////
	if (<bChangesWereMade>)
	{
		RedValue = ~<$pcon.ImagePropertiesRecord[WhiteBalanceRed]>~;

		if (~<RedValue>~ == ~~)
		{
			if (~<NewRedSetting>~ != ~0~)
			{
				NewRedSetting = ~0~;
				dlg( SetStrings, Red, ~0~);
			}
		} else
		{
			NewRedSetting = ~<RedValue>~;
			dlg( SetStrings, Red, ~<RedValue>~);
		}

		GreenValue = ~<$pcon.ImagePropertiesRecord[WhiteBalanceGreen]>~;
		if (~<GreenValue>~ == ~~)
		{
			if (~<NewGreenSetting>~ != ~0~)
			{
				NewGreenSetting = ~0~;
				dlg( SetStrings, Green, ~0~);
			}
		} else
		{
			NewGreenSetting = ~<GreenValue>~;
			dlg( SetStrings, Green, ~<GreenValue>~);
		}

		BlueValue = ~<$pcon.ImagePropertiesRecord[WhiteBalanceBlue]>~;
		if (~<BlueValue>~ == ~~)
		{
			if (~<NewBlueSetting>~ != ~0~)
			{
				NewBlueSetting = ~0~;
				dlg( SetStrings, Blue, ~0~);
			}
		} else
		{
			NewBlueSetting = ~<BlueValue>~;
			dlg( SetStrings, Blue, ~<BlueValue>~);
		}
	} else
	{
		if (~<NewRedSetting>~ != ~0~)
		{
			NewRedSetting = ~0~;
			dlg( SetStrings, Red, ~0~);
		}

		if (~<NewGreenSetting>~ != ~0~)
		{
			NewGreenSetting = ~0~;
			dlg( SetStrings, Green, ~0~);
		}
		
		if (~<NewBlueSetting>~ != ~0~)
		{
			NewBlueSetting = ~0~;
			dlg( SetStrings, Blue, ~0~);
		}
	}

	//////////////////////////
	// SETUP THE INPUT FILE //
	//////////////////////////
	if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~<ImagePath>~))
	{
		MessageBox( ~There was an error setting the source image path id! DP2 will be unable to retrieve settings for <ImagePath>.~ );
		EnableControlsBool(FALSE);
		return;
	}

	///////////////////
	// LOOK PROFILE  //
	///////////////////
	if (MyCamera(GetAttributeValue, MyCamera(KVTPICPROCPicTypeID), PictureTypeID))
	{
		if ( (<PictureTypeID> == MyCamera(KVTPICPROC_DCRFile)) || (<PictureTypeID> == MyCamera(KVTPICPROC_DCSFile)) )
		{
			dlg(EnableControls, TRUE, LookGroupBox, LookProfilesComboBox);
			if (<bChangesWereMade>)
			{	
				look = ~<$pcon.ImagePropertiesRecord[LookProfPathID]>~;
				if (~<look>~ == ~~)
				{
					LookProfileID = ~<Use Embedded>~;
					// do nothing, since LookProfileID is already loaded with the value from the file header.
				} else
				{
					LookProfileID = ~<look>~;
				}
			} else
			{
				LookProfileID = ~<Use Embedded>~;
			}

			dlg(SelectString, LookProfilesComboBox, ~<LookProfileID>~);

			LastLook = ~<LookProfileID>~;
		} else
		{
			// Not a DCR image, so disable look profiles
			dlg(EnableControls, FALSE, LookGroupBox, LookProfilesComboBox);
		}
	}
	
	//////////////////////
	// LIGHTING SETTING //
	//////////////////////
	if (!MyCamera(CapabilitySupported, MyCamera(KVTPICPROCBaseIlluminantID)))
	{
		// Turn off all of the illuminant controls if the file doesn't support base illuminants.
		dlg(EnableControls, FALSE, LightingGroupBox);
		dlg(EnableControls, FALSE, DaylightButton, FluorescentButton, TungstenButton, FlashButton);
		dlg(SetCheck, FALSE, DaylightButton, TungstenButton, FluorescentButton, FlashButton);
	} else
	{
		MyCamera(GetAttributeValue, MyCamera(KVTPICPROCBaseIlluminantID), BaseIlluminantID);

		// If changes were made, then override the info we just got from the file header
		if (<bChangesWereMade>)
		{
			IlluminantName = ~<$pcon.ImagePropertiesRecord[BaseIlluminantID]>~;
			if (~<IlluminantName>~ == ~Daylight~)
			{
				dlg( SetStrings, Lighting, ~0~);
			} else if (~<IlluminantName>~ == ~Tungsten~)
			{
				dlg( SetStrings, Lighting, ~1~);
			} else if (~<IlluminantName>~ == ~Fluorescent~)
			{
				dlg( SetStrings, Lighting, ~3~);
			} else if (~<IlluminantName>~ == ~Flash~)
			{
				dlg( SetStrings, Lighting, ~2~);
			} else
			{
				// None of those worked, so either they didn't have it set or the data
				// from the database was bad. Either way, just use the value from the
				// file's metadata instead.
				if (<BaseIlluminantID> == MyCamera(KVTPICPROCDaylightIllum))
				{
					dlg( SetStrings, Lighting, ~0~);
				} else if (<BaseIlluminantID> == MyCamera(KVTPICPROCTungstenIllum))
				{
					dlg( SetStrings, Lighting, ~1~);
				} else if (<BaseIlluminantID> == MyCamera(KVTPICPROCFlashIllum))
				{
					dlg( SetStrings, Lighting, ~2~);
				} else if (<BaseIlluminantID> == MyCamera(KVTPICPROCFluorescentIllum))
				{
					dlg( SetStrings, Lighting, ~3~);
				}
			}
		} else
		{
			if (<BaseIlluminantID> == MyCamera(KVTPICPROCDaylightIllum))
			{
				dlg( SetStrings, Lighting, ~0~);
			} else if (<BaseIlluminantID> == MyCamera(KVTPICPROCTungstenIllum))
			{
				dlg( SetStrings, Lighting, ~1~);
			} else if (<BaseIlluminantID> == MyCamera(KVTPICPROCFlashIllum))
			{
				dlg( SetStrings, Lighting, ~2~);
			} else if (<BaseIlluminantID> == MyCamera(KVTPICPROCFluorescentIllum))
			{
				dlg( SetStrings, Lighting, ~3~);
			} else
			{
				MessageBox(~There was no illuminant set up in the file. Defaulting to Daylight.~);
				dlg( SetStrings, Lighting, ~0~);
			}
		}

		dlg(EnableControls, TRUE, DaylightButton, FluorescentButton, TungstenButton, FlashButton);

		if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCDaylightWhiteBalanceRGBTripletID)) != TRUE )
		{
			dlg(EnableControls, FALSE, DaylightButton);
		}
		
		if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCTungstenWhiteBalanceRGBTripletID)) != TRUE )
		{
			dlg(EnableControls, FALSE, TungstenButton);
		}

		if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCFlashWhiteBalanceRGBTripletID)) != TRUE )
		{
			dlg(EnableControls, FALSE, FlashButton);
		}

		if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCFluorescentWhiteBalanceRGBTripletID)) != TRUE )
		{
			dlg(EnableControls, FALSE, FluorescentButton);
		}
		
		dlg(EnableControls, TRUE, LightingGroupBox);	
	}

	//////////////
	// EXPOSURE //
	//////////////
	if (!MyCamera(GetExposureAttributeValueInfo, tempMax, tempMin, ExposureGain))
	{
		// Turn off the exposure controls if Exposure Compensation is not supported
		dlg(EnableControls, FALSE, ExposurePrompt, ExposureGroupBox, ExposureMinStatic, ExposureSlider);
		dlg(EnableControls, FALSE, ExposureMaxStatic, ExposureMinusButton, ExposurePlusButton, ExposureZeroButton);
		dlg(EnableControls, FALSE, ExposureField);
	}
	else
	{
		dlgData(SetAttrInfo, Exposure, LowValue, ~<tempMin>~); 
		dlgData(SetAttrInfo, Exposure, HighValue, ~<tempMax>~);

		dlg( SetStrings, ExposureMax, ~<tempMax>~ );
		dlg( SetStrings, ExposureMin, ~<tempMin>~ );

		if (<bChangesWereMade>)
		{
			// If the exposure was changed, then use that. Otherwise still use the file's setting.
			if ( (~<$pcon.ImagePropertiesRecord[ExposureGainID]>~ == ~~) || (~<$pcon.ImagePropertiesRecord[ExposureGainID]>~ == ~-20~) )
			{
				dlg( SetStrings, Exposure, ~<ExposureGain>~ );
			} else
			{
				// Set the exposure based on the previous setting
				dlg( SetStrings, Exposure, ~<$pcon.ImagePropertiesRecord[ExposureGainID]>~);
			}
		} else
		{	
			// Set the exposure based on the file's settings
			dlg( SetStrings, Exposure, ~<ExposureGain>~ );
		}

		dlg(EnableControls, TRUE, ExposurePrompt, ExposureGroupBox, ExposureMinStatic, ExposureSlider, ExposureMaxStatic);
		dlg(EnableControls, TRUE, ExposureMinusButton, ExposurePlusButton, ExposureZeroButton, ExposureField);
	}

	////////////////
	// SHARPENING //
	////////////////

	// Only do this if SDK sharpening is enabled!
	AppSharpeningEnabled = ~<$con.DlgData[EnableRawFileSharpening]>~;

	if (Numeric(~<AppSharpeningEnabled>~))
	{
		// NOTE: Always have to call GetAppSharpeningAttributeValueInfoInGencon, since that'll get your
		// max and min values for the sliders. Always set up the other stuff AFTER this is called.
		if (!MyCamera(GetAppSharpeningAttributeValueInfoInGencon, DlgData))
		{
			// There was an error, so all sharpening controls are disabled
			EnableSharpeningControls(FALSE);
		} else
		{
			// Setup the Radius slider and text fields
			dlgData(SetAttrInfo, AppSharpenRadius, LowValue, ~<$con.dlgData[AppSharpRadiusMin]>~); 
			dlgData(SetAttrInfo, AppSharpenRadius, HighValue, ~<$con.dlgData[AppSharpRadiusMax]>~);

			// Setup the Threshold slider and text fields
			dlgData(SetAttrInfo, AppSharpenThreshold, LowValue, ~<$con.dlgData[AppSharpThresholdMin]>~); 
			dlgData(SetAttrInfo, AppSharpenThreshold, HighValue, ~<$con.dlgData[AppSharpThresholdMax]>~);

			// Setup the Amount slider and text fields
			dlgData(SetAttrInfo, AppSharpenAmount, LowValue, ~<$con.dlgData[AppSharpAmountMin]>~); 
			dlgData(SetAttrInfo, AppSharpenAmount, HighValue, ~<$con.dlgData[AppSharpAmountMax]>~);

			if (<bChangesWereMade>)
			{
				// If the Amount was changed, then use that. Otherwise still use the file's setting.
				if ( (~<$pcon.ImagePropertiesRecord[SharpenAmountID]>~ != ~~) && (~<$pcon.ImagePropertiesRecord[SharpenAmountID]>~ != ~-1~) )
				{
					dlg( SetStrings, AppSharpenAmount, ~<$pcon.ImagePropertiesRecord[SharpenAmountID]>~ );
				}

				// If the Radius was changed, then use that. Otherwise still use the file's setting.
				if ( (~<$pcon.ImagePropertiesRecord[SharpenRadiusID]>~ != ~~) && (~<$pcon.ImagePropertiesRecord[SharpenRadiusID]>~ != ~-1~) )
				{
					dlg( SetStrings, AppSharpenRadius, ~<$pcon.ImagePropertiesRecord[SharpenRadiusID]>~ );
				}

				// If the Threshold was changed, then use that. Otherwise still use the file's setting.
				if ( (~<$pcon.ImagePropertiesRecord[SharpenThresholdID]>~ != ~~) && (~<$pcon.ImagePropertiesRecord[SharpenThresholdID]>~ != ~-1~) )
				{
					dlg( SetStrings, AppSharpenThreshold, ~<$pcon.ImagePropertiesRecord[SharpenThresholdID]>~ );
				}
			}

			dlg(Update);

			// Sanity check on the status of the various sliders, depending on their values
			AppSharpenRadiusID = ~<$con.dlgData[AppSharpenRadius]>~;
			AppSharpenAmountID = ~<$con.dlgData[AppSharpenAmount]>~;

//			EnableSharpeningControls(TRUE);		// Don't do this... It causes the controls to flicker whenever
												// the file selection is changed.
			if (<AppSharpenAmountID> == 0)
			{
				// If the Sharpening Amount goes to zero, then Radius and Threshold should be disabled.
				dlg(EnableControls, FALSE, AppSharpenRadiusSlider);
				dlg(EnableControls, FALSE, SharpenRadiusText, SharpenRadiusMinText, SharpenRadiusMaxText, SharpenRadiusCurrentText);

				dlg(EnableControls, FALSE, AppSharpenThresholdSlider);
				dlg(EnableControls, FALSE, SharpenThresholdText, SharpenThresholdMinText, SharpenThresholdMaxText, SharpenThresholdCurrentText);

				// ...and by the way... make sure the Amount slider is ON!!
				dlg(EnableControls, TRUE, AppSharpenAmountSlider, AppSharpenThresholdSlider);
				dlg(EnableControls, TRUE, SharpenAmountText, SharpenAmountMinText, SharpenAmountMaxText, SharpenAmountCurrentText);

			} else if (<AppSharpenRadiusID> == 0)
			{
				// If the Sharpening Radius goes to zero, then Amount and Threshold should be disabled.
				dlg(EnableControls, FALSE, AppSharpenAmountSlider, AppSharpenThresholdSlider);
				dlg(EnableControls, FALSE, SharpenAmountText, SharpenAmountMinText, SharpenAmountMaxText, SharpenAmountCurrentText);

				dlg(EnableControls, FALSE, AppSharpenThresholdSlider);
				dlg(EnableControls, FALSE, SharpenThresholdText, SharpenThresholdMinText, SharpenThresholdMaxText, SharpenThresholdCurrentText);

				// ...and by the way... make sure the Radius slider is ON!!
				dlg(EnableControls, TRUE, AppSharpenRadiusSlider);
				dlg(EnableControls, TRUE, SharpenRadiusText, SharpenRadiusMinText, SharpenRadiusMaxText, SharpenRadiusCurrentText);

			} else
			{
				// Otherwise make sure that they're all ON.
				EnableSharpeningControls(TRUE);
			}
		}
	
	} else
	{
		EnableSharpeningControls(TRUE);
	}

	/////////////////////
	// NOISE REDUCTION //
	/////////////////////
/*
	Type #		Gencon Field:		List String:					Database Storage:
		1		NROff				Off								None
		2		NRBasic				Basic							Sigma
		3		NRChroma			Advanced						Chroma
		4		NRMoire				Advanced with Moire Reduction	Moire
		5		NRChromaRadius		Advanced						ChrRad
		6		NRMoireRadius		Advanced with Moire Reduction	MoiRad
		7		NRExpert			Expert							Expert
		8		NRBasicRadius		Basic with Radius				BasRad
*/
	SetupNoiseReductionList();

	// Check the database value
	NoiseReductionType = ~<$pcon.ImagePropertiesRecord[NoiseFilterTypeID]>~;

	// NOTE - This depends on all 3 of the Noise Reduction settings being
	// saved anytime any one of the 3 are changed.
	if (<bChangesWereMade> && !(~<NoiseReductionType>~ == ~~))
	{
		// Set the noise filter level based on the stored setting
		NoiseReductionType = ~<$pcon.ImagePropertiesRecord[NoiseFilterTypeID]>~;

		if (~<NoiseReductionType>~ == ~None~)
		{
			NRTypeString = ~Off~;
			dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		} else if (~<NoiseReductionType>~ == ~Sigma~)
		{
			NRTypeString = ~Basic~;
			dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		} else if (~<NoiseReductionType>~ == ~Chroma~)
		{
			NRTypeString = ~Advanced~;
			dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		} else if (~<NoiseReductionType>~ == ~Moire~)
		{
			NRTypeString = ~Advanced with Moire Reduction~;
			NRStrengthThreshold = ~<$pcon.ImagePropertiesRecord[NoiseFilterStrengthID]>~;

			dlg(SetStrings, NRStrengthThreshold, ~<NRStrengthThreshold>~);
			dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);

			dlg(SetStrings, NRRadius, ~0~);		// Zero the radius slider, since it's not supported!
		} else if (~<NoiseReductionType>~ == ~ChrRad~)
		{
			NRTypeString = ~Advanced~;
			NRStrengthThreshold = ~<$pcon.ImagePropertiesRecord[NoiseFilterStrengthID]>~;
			NRRadius = ~<$pcon.ImagePropertiesRecord[NoiseFilterRadiusID]>~;

			dlg(SetStrings, NRStrengthThreshold, ~<NRStrengthThreshold>~, NRRadius, ~<NRRadius>~);
			dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		} else if (~<NoiseReductionType>~ == ~MoiRad~)
		{
			NRTypeString = ~Advanced with Moire Reduction~;
			NRStrengthThreshold = ~<$pcon.ImagePropertiesRecord[NoiseFilterStrengthID]>~;
			NRRadius = ~<$pcon.ImagePropertiesRecord[NoiseFilterRadiusID]>~;

			dlg(SetStrings, NRStrengthThreshold, ~<NRStrengthThreshold>~, NRRadius, ~<NRRadius>~);
			dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		} else if (~<NoiseReductionType>~ == ~Expert~)
		{
			NRTypeString = ~Expert~;
			NRStrengthThreshold = ~<$pcon.ImagePropertiesRecord[NoiseFilterStrengthID]>~;
			NRRadius = ~<$pcon.ImagePropertiesRecord[NoiseFilterRadiusID]>~;

			// we must disable the threshold slider.  The image will render correctly
			// only if the threshold slider is not moved.  See problem 17073.
			dlg(SetStrings, NRStrengthThreshold, ~<NRStrengthThreshold>~, NRRadius, ~<NRRadius>~);
			dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		}else if (~<NoiseReductionType>~ == ~BasRad~)
		{
			NRTypeString = ~Basic with Radius~;
			NRStrengthThreshold = ~<$pcon.ImagePropertiesRecord[NoiseFilterStrengthID]>~;
			NRRadius = ~<$pcon.ImagePropertiesRecord[NoiseFilterRadiusID]>~;

			dlg(SetStrings, NRStrengthThreshold, ~<NRStrengthThreshold>~, NRRadius, ~<NRRadius>~);
			dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
			dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		}else
		{
			Log(Session, ~ERROR: An unrecognized noise reduction type '<NoiseReductionType>' was retrieved from the database for file <ImagePath>.~);
		}

		dlg(SelectString, NoiseReductionComboBox, ~<NRTypeString>~);
	} else
	{
		// Use the values from the file
		if (MyCamera(GetCurrentNoiseReductionValues, NoiseReductionType, NoiseReductionStrength, NoiseReductionRadius))
		{
			// Select the NoiseReductionType in the list
			if (~<NoiseReductionType>~ == ~1~)
			{
				NRTypeString = ~Off~;
				dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else if (~<NoiseReductionType>~ == ~2~)
			{
				NRTypeString = ~Basic~;

				dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else if (~<NoiseReductionType>~ == ~3~)
			{
				NRTypeString = ~Advanced~;
				dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else if (~<NoiseReductionType>~ == ~4~)
			{
				NRTypeString = ~Advanced with Moire Reduction~;
				dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else if (~<NoiseReductionType>~ == ~5~)
			{
				NRTypeString = ~Advanced~;
				dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else if (~<NoiseReductionType>~ == ~6~)
			{
				NRTypeString = ~Advanced with Moire Reduction~;
				dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else if (~<NoiseReductionType>~ == ~7~)
			{
				NRTypeString = ~Expert~;
				// we must disable the threshold slider.  The image will render correctly
				// only if the threshold slider is not moved.  See problem 17073.
				dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else if (~<NoiseReductionType>~ == ~8~)
			{
				NRTypeString = ~Basic with Radius~;
				dlg(EnableControls, TRUE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
				dlg(EnableControls, TRUE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
			} else			
			{
				Log(Session, ~ERROR: An unrecognized noise reduction type '<NoiseReductionType>' was retrieved from the file <ImagePath>.~);
			}

			dlg(SelectString, NoiseReductionComboBox, ~<NRTypeString>~);

			// Scale the values by 100
			NoiseReductionStrength = <NoiseReductionStrength> * 100;
			NoiseReductionRadius = <NoiseReductionRadius> * 100;
			dlg( SetStrings, NRStrengthThreshold, ~<NoiseReductionStrength>~ );
			dlg( SetStrings, NRRadius, ~<NoiseReductionRadius>~ );
		} else
		{
			Log(Session, ~ERROR: There was an error getting the current noise reduction settings for file <ImagePath>.~);
		}
	}

	NewNoiseReduction = ~<NRTypeString>~;

	///////////////////
	// BALANCE TYPES //
	///////////////////
	// Auto
	if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCAutoWhiteBalanceRGBTripletID)) != TRUE )
	{
		dlg(EnableControls, FALSE, BalanceAuto);
		dlg(SetCheck, FALSE, BalanceAuto);

		SetRGBSliderControls(FALSE);
		
		balanceSupported = FALSE;
	}
	else
	{
		dlg(EnableControls, TRUE, BalanceAuto);

		balanceSupported = TRUE;
	}

	// Custom //
	if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCCustomWhiteBalanceRGBTripletID)) != TRUE )
	{
		dlg(EnableControls, FALSE, BalanceCustom);
		dlg(SetCheck, FALSE, BalanceCustom);
		
		if ( !<balanceSupported> )
		{
			SetRGBSliderControls(FALSE);

			balanceSupported = FALSE;
		}
	}
	else
	{
		dlg(EnableControls, TRUE, BalanceCustom);

		balanceSupported = TRUE;
	}

	// Preset //
	if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCDaylightWhiteBalanceRGBTripletID)) != TRUE )
	{
		dlg(EnableControls, FALSE, BalancePreset);
		dlg(EnableControls, FALSE, BalanceGroupBox);
		
		dlg(SetCheck, FALSE, BalancePreset);

		if ( !<balanceSupported> )
		{
			SetRGBSliderControls(FALSE);
			balanceSupported = FALSE;
		}
	}
	else
	{
		dlg(EnableControls, TRUE, BalancePreset);
		dlg(EnableControls, TRUE, BalanceGroupBox);

		balanceSupported = TRUE;
	}

	// Click //
	if ( MyCamera(CapabilitySupported, MyCamera(KVTPICPROCClickWhiteBalanceRGBTripletID)) != TRUE )
	{
		dlg(EnableControls, FALSE, BalanceClick);
		dlg(SetCheck, FALSE, BalanceClick);

		dlg( SetStrings, CenterPtRow, 0);
		dlg( SetStrings, CenterPtCol, 0);

		clickBalanceSupported = FALSE;

		if ( !<balanceSupported> )
		{
			SetRGBSliderControls(FALSE);

			balanceSupported = FALSE;
		}
	}
	else
	{
		dlg(EnableControls, FALSE, BalanceClick);

		clickBalanceSupported = TRUE;

		balanceSupported = TRUE;
	}

	// Set the appropriate button for balance
	if ( <balanceSupported> )
	{
		// If changes were made, then override the info we just got from the file header
		
		// Figure out whether or not the Click Balance button should be enabled or disabled
		OriginalBalance = MyCamera(GetActiveBalance, DlgData);

		if (<bChangesWereMade>)
		{
			BalanceSetting = ~<$pcon.ImagePropertiesRecord[BalanceTypeID]>~;

			if ( ~<BalanceSetting>~ == ~Auto~ )
			{
				dlg(SetStrings, Balance, ~3~);
			}
			else if ( ~<BalanceSetting>~ == ~Custom~ )
			{
				dlg(SetStrings, Balance, ~2~);
			}
			else if ( ~<BalanceSetting>~ == ~Click~ )
			{
				dlg(SetStrings, Balance, ~1~);
				dlg(EnableControls, TRUE, BalanceClick);
			}
			else if ( ~<BalanceSetting>~ == ~Preset~ )
			{
				dlg(SetStrings, Balance, ~0~);
			} else
			{
				// If we fall through, then set the balance based on the file settings.
				ActiveBalance = ~<OriginalBalance>~; // MyCamera(GetActiveBalance, DlgData);

				if (~<ActiveBalance>~ != ~-1~)
				{
					dlg(SetStrings, Balance, <ActiveBalance>);
				}
			}
		} else
		{
			// Set the balance based on the file settings.
			ActiveBalance = ~<OriginalBalance>~; // MyCamera(GetActiveBalance, DlgData);

			if (~<ActiveBalance>~ != ~-1~)
			{
				dlg(SetStrings, Balance, <ActiveBalance>);
			}
		}

		// If the file hasn't been click balanced (no data in the DB for it) and the original
		// balance wasn't click, then disable the button. Otherwise the button is enabled.
		if ( (	(~<$pcon.ImagePropertiesRecord[ClickBalanceRed]>~ == ~-1~) ||
				(~<$pcon.ImagePropertiesRecord[ClickBalanceGreen]>~ == ~-1~) ||
				(~<$pcon.ImagePropertiesRecord[ClickBalanceBlue]>~ == ~-1~) ||
				(!<bChangesWereMade>) ) &&
				(~<OriginalBalance>~ != ~1~) )
		{
			dlg(EnableControls, FALSE, BalanceClick);
		} else
		{
			dlg(EnableControls, TRUE, BalanceClick);
		}
	}

	if (<balanceSupported>)
	{
		SetRGBSliderControls(TRUE);
	}

	MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
}


VOID SetupNoiseReductionList( )
{
	MyCamera(GetNoiseModes, NoiseReductionData);

	NRRadiusSupported = FALSE;
	NRStrengthThresholdSupported = FALSE;

	StringList(NRList, New);

	NoiseReductionData(GetValue, NROff, NoiseOff);

	NothingSupported = TRUE;

	if (~<NoiseOff>~ == ~1~)
	{
		StringList(	NRList, InListOrder, AddStrings, ~Off~);
		NothingSupported = FALSE;
	}

	NoiseReductionData(GetValue, NRBasic, Basic);
	if (~<Basic>~ == ~1~)
	{
		StringList(	NRList, InListOrder, AddStrings, ~Basic~);
		NothingSupported = FALSE;
	}

	NoiseReductionData(GetValue, NRChroma, Chroma);
	if (~<Chroma>~ == ~1~)
	{
		StringList(	NRList, InListOrder, AddStrings, ~Advanced~);
		NothingSupported = FALSE;
	}

	NoiseReductionData(GetValue, NRMoire, Moire);
	if (~<Moire>~ == ~1~)
	{
		StringList(	NRList, InListOrder, AddStrings, ~Advanced with Moire Reduction~);
		NRStrengthThresholdSupported = TRUE;
		NothingSupported = FALSE;
	}

	NoiseReductionData(GetValue, NRChromaRadius, ChromaRadius);
	if (~<ChromaRadius>~ == ~1~)
	{
		// Delete it in case it was already there. Don't want the string in the list twice!
		StringList(	NRList, DeleteStringByContents, ~Advanced~);

		StringList(	NRList, InListOrder, AddStrings, ~Advanced~);
		NRRadiusSupported = TRUE;
		NRStrengthThresholdSupported = TRUE;
		NothingSupported = FALSE;
	}

	NoiseReductionData(GetValue, NRMoireRadius, MoireRadius);
	if (~<MoireRadius>~ == ~1~)
	{
		// Delete it in case it was already there. Don't want the string in the list twice!
		StringList(	NRList, DeleteStringByContents, ~Advanced with Moire Reduction~);

		StringList(	NRList, InListOrder, AddStrings, ~Advanced with Moire Reduction~);
		NRRadiusSupported = TRUE;
		NRStrengthThresholdSupported = TRUE;
		NothingSupported = FALSE;
	}

	NoiseReductionData(GetValue, NRExpert, Expert);
	if (~<Expert>~ == ~1~)
	{
		// Delete it in case it was already there. Don't want the string in the list twice!
		StringList(	NRList, DeleteStringByContents, ~Expert~);

		StringList(	NRList, InListOrder, AddStrings, ~Expert~);
		NRRadiusSupported = FALSE;
		NRStrengthThresholdSupported = TRUE;
		NothingSupported = FALSE;
	}
	NoiseReductionData(GetValue, NRBasicRadius, BasicRadius);
	if (~<BasicRadius>~ == ~1~)
	{
		// Delete it in case it was already there. Don't want the string in the list twice!
		StringList(	NRList, DeleteStringByContents, ~Basic with Radius~);

		StringList(	NRList, InListOrder, AddStrings, ~Basic with Radius~);
		NRRadiusSupported = TRUE;
		NRStrengthThresholdSupported = TRUE;
		NothingSupported = FALSE;
	}
	if (<NothingSupported>)
	{
		dlg(EnableControls, FALSE, ThresholdStatic, ThresholdSlider, NRThresholdCurrentStatic, ZeroStaticOne, HundredStaticOne);
		dlg(EnableControls, FALSE, RadiusStatic, RadiusSlider, NRRadiusCurrentStatic, ZeroStaticTwo, HundredStaticTwo);
		dlg(EnableControls, FALSE, NoiseReductionGroupBox, NoiseReductionComboBox);
	} else
	{
		dlg(EnableControls, TRUE, NoiseReductionGroupBox, NoiseReductionComboBox);
	}

	dlg(SetControlFromStringList, NoiseReductionComboBox, NRList);
}


/***************************************************************************************************/
VOID SetRGBSliderControls(bControlsEnabled)
{
	dlg(EnableControls, <bControlsEnabled>, RGBGroupBox);
	dlg(EnableControls, <bControlsEnabled>, RedPrompt);
	dlg(EnableControls, <bControlsEnabled>, GreenPrompt);
	dlg(EnableControls, <bControlsEnabled>, BluePrompt);
	dlg(EnableControls, <bControlsEnabled>, RedSlider);
	dlg(EnableControls, <bControlsEnabled>, GreenSlider);
	dlg(EnableControls, <bControlsEnabled>, BlueSlider);
	dlg(EnableControls, <bControlsEnabled>, RedField);
	dlg(EnableControls, <bControlsEnabled>, GreenField);
	dlg(EnableControls, <bControlsEnabled>, BlueField);
	dlg(EnableControls, <bControlsEnabled>, RedPlusButton);
	dlg(EnableControls, <bControlsEnabled>, RedMinusButton);
	dlg(EnableControls, <bControlsEnabled>, RedZeroButton);
	dlg(EnableControls, <bControlsEnabled>, GreenPlusButton);
	dlg(EnableControls, <bControlsEnabled>, GreenMinusButton);
	dlg(EnableControls, <bControlsEnabled>, GreenZeroButton);
	dlg(EnableControls, <bControlsEnabled>, BluePlusButton);
	dlg(EnableControls, <bControlsEnabled>, BlueMinusButton);
	dlg(EnableControls, <bControlsEnabled>, BlueZeroButton);
}

/***************************************************************************************************/
VOID EnableControlsBool(bControlsEnabled)
{
	dlg(EnableControls, <bControlsEnabled>, LookGroupBox);
	dlg(EnableControls, <bControlsEnabled>, LookProfilesComboBox);
	
	dlg(EnableControls, <bControlsEnabled>, LightingGroupBox);
	dlg(EnableControls, <bControlsEnabled>, DaylightButton);
	dlg(EnableControls, <bControlsEnabled>, FluorescentButton);
	dlg(EnableControls, <bControlsEnabled>, TungstenButton);
	dlg(EnableControls, <bControlsEnabled>, FlashButton);

	dlg(EnableControls, <bControlsEnabled>, ExposureGroupBox);
	dlg(EnableControls, <bControlsEnabled>, ExposurePrompt);
	dlg(EnableControls, <bControlsEnabled>, ExposureMinStatic);
	dlg(EnableControls, <bControlsEnabled>, ExposureSlider);
	dlg(EnableControls, <bControlsEnabled>, ExposureMaxStatic);
	dlg(EnableControls, <bControlsEnabled>, ExposureMinusButton);
	dlg(EnableControls, <bControlsEnabled>, ExposurePlusButton);
	dlg(EnableControls, <bControlsEnabled>, ExposureZeroButton);
	dlg(EnableControls, <bControlsEnabled>, ExposureField);
	
	dlg(EnableControls, <bControlsEnabled>, NoiseReductionGroupBox);
	dlg(EnableControls, <bControlsEnabled>, NoiseReductionComboBox);
	dlg(EnableControls, <bControlsEnabled>, ThresholdStatic);
	dlg(EnableControls, <bControlsEnabled>, NRThresholdCurrentStatic);
	dlg(EnableControls, <bControlsEnabled>, ThresholdSlider);
	dlg(EnableControls, <bControlsEnabled>, ZeroStaticOne);
	dlg(EnableControls, <bControlsEnabled>, HundredStaticOne);
	dlg(EnableControls, <bControlsEnabled>, RadiusStatic);
	dlg(EnableControls, <bControlsEnabled>, NRRadiusCurrentStatic);
	dlg(EnableControls, <bControlsEnabled>, RadiusSlider);
	dlg(EnableControls, <bControlsEnabled>, ZeroStaticTwo);
	dlg(EnableControls, <bControlsEnabled>, HundredStaticTwo);

	EnableSharpeningControls(<bControlsEnabled>);

	SetRGBSliderControls(<bControlsEnabled>);

	dlg(EnableControls, <bControlsEnabled>, BalanceGroupBox);
	dlg(EnableControls, <bControlsEnabled>, BalanceAuto);
	dlg(EnableControls, <bControlsEnabled>, BalanceCustom);
	dlg(EnableControls, <bControlsEnabled>, BalancePreset);
	dlg(EnableControls, <bControlsEnabled>, BalanceClick);
}

/***************************************************************************************************/
NUMERIC GetRollAndFrameForFile(&dBase, ImagePath, &Roll, &Frame)
{
	Query = ~SELECT Roll, Frame FROM RawImages WHERE Path = '<ImagePath>' AND ImageType = 0~;

	if (!PGenConList(List, Connection, dBase, Cursor, Forward, QUERY, ~<Query>~))
	{
		List(GetErrorDescription, 0, theErr);
		return Warning( Translate( ~Failed to query the RawImages table.\n\n<Query>\n\n<theErr>~ ) );
	}

	if ( !List(GetFirst, RawImagesRecord) )
	{
		return FALSE;
	}

	Roll = ~<$pcon.RawImagesRecord[Roll]>~;
	Frame = ~<$pcon.RawImagesRecord[Frame]>~;

	return TRUE;
}

/***************************************************************************************************/
NUMERIC CheckOrderCompleted(&connection, NewOrderStatus)
{
	Query = ~SELECT * FROM RawImages WHERE OrderID = '<$con.DlgData[Directory]>' AND Processed <> 1 AND Path IS NOT NULL AND ImageType = 0~;

	count = connection(RecordCountFor, ~<Query>~);

	if ( ~<count>~ == ~0~ )
	{
		// There were no more unprocessed images, so set the order CameraFileConversionStatus to whatever 
		// the caller specified 
		// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
		if ( !connection(Cmd, ~UPDATE Orders SET CameraFileConversionStatus = <NewOrderStatus> WHERE ID = '<$con.DlgData[Directory]>'~) )
		{
			connection(GetErrorDescription, theErr);

			return Warning( ~Error Updating the order status: <theErr>~ );
		}

		connection(RefreshCache);

		// Now refresh the Orders list
		GetOrdersFromDatabase(connection);

		// Since there is no order or images selected, then disable the GUI.
		EnableControlsBool(FALSE);
		
		dlg( ListBox, DigitalOrders, Select, 0);
		
		GetImagesFromSelectedOrder();

		dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);

		LoadImageAttributes();

		return TRUE;
	} else
	{
		return FALSE;
	}

}


/***************************************************************************************************/
// This function rips through the Orders list and, for each order found, will check if it has
// any images which need to be processed. If it does not, then the status is set to "Proof".
// This helps to eliminate orders which are autoqueued when coming in through the commands
// processor. Als helps eliminate orders where all of the raw files were reassigned to a different
// order.
NUMERIC CheckAllOrdersCompleted(&connection)
{
	// must loop through all orders in the list to check them all.
	Index = 0;

	if (dlg(ListBox, DigitalOrders, GetCount) <= 0)
	{
		return TRUE;
	}

	while ( dlg(ListBox, DigitalOrders, GetNthItem, <Index++>, OrderID) > 0 )
	{
		Query = ~SELECT * FROM RawImages WHERE OrderID = '<OrderID>' AND Processed <> 1 AND Path IS NOT NULL AND ImageType = 0~;

		count = connection(RecordCountFor, ~<Query>~);

		if ( ~<count>~ == ~0~ )
		{
			// Now check if there's anything in the queue...
			Query = ~SELECT * FROM DCQueue WHERE OrderID = '<OrderID>'~;

			count = connection(RecordCountFor, ~<Query>~);

			// ... if there's also nothing in DCQueue, then it's really complete.
			if ( ~<count>~ == ~0~ )
			{
				// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
				if ( !connection(Cmd, ~UPDATE Orders SET CameraFileConversionStatus = 3 WHERE ID = '<OrderID>'~) )
				{
					connection(GetErrorDescription, theErr);

					Warning( ~Error Updating the order status: <theErr>~ );
					return;
				}
			} else	// ... otherwise it's really In Progress!
			{
				// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
				if ( !connection(Cmd, ~UPDATE Orders SET CameraFileConversionStatus = 2 WHERE ID = '<OrderID>'~) )
				{
					connection(GetErrorDescription, theErr);

					Warning( ~Error Updating the order status: <theErr>~ );
					return;
				}
			}
		}
	}

	// Now refresh the Orders list
	GetOrdersFromDatabase(connection);

	return TRUE;
}


/***************************************************************************************************/
VOID ThreadProcessingComplete()
{
	dlg( SetStatus, 0, ~Processing Image(s) Complete~ );
	StatusMessage = ~~;

	dlg(EnableControls, TRUE, PreviewButton);
	dlg(EnableControls, TRUE, ProcessNowButton);
	dlg(EnableControls, TRUE, CancelButton);

	dlg(EnableControls, FALSE, CancelProcessingButton);
}

/***************************************************************************************************/
VOID ProcessingPreview(Filename)
{
	Message = ~Processing Preview Image...~ + ~<$Str.$Filename.FileName>~;
	dlg( SetStatus, 0, ~<Message>~);
	StatusMessage = ~~;
}

/***************************************************************************************************/
VOID ProcessingToFile(Filename)
{
	Message = ~Processing to file...~ + ~<$Str.$Filename.FileName>~;
	dlg( SetStatus, 0, ~<Message>~);
	StatusMessage = ~~;
}

/***************************************************************************************************/
VOID RenderSuccessNotify(FileName)
{
	dlg( SetStatus, 0, ~Ready to Process~);
	StatusMessage = ~~;

	ImageData(SetValues, ImageBuffer, QueueItemData(GetNumeric, ImageBuffer) );
	ImageData(SetValues, ImageWidth, QueueItemData(GetNumeric, ImageBufferWidth) );
	ImageData(SetValues, ImageHeight, QueueItemData(GetNumeric, ImageBufferHeight) );
	ImageData(SetValues, ImageDepth, QueueItemData(GetNumeric, ImageBufferDepth) );
	QueueItemData(GetValue, ImageBufferLayout, Layout);
	ImageData(SetValues, ImageLayout, ~<Layout>~);

	Document( Doc );

	QueueItemData(GetValue, RenderedPathName, Path);

	while (GenCon(Window, GetWindowByIndex, <Index++>))
	{
		if (!Window(GetNext, aView))
			continue;

		aView(Get, ViewType, ViewType);

		if ( ~<ViewType>~ == ImageView || ~<ViewType>~ == ImageEditView )
		{
			aView(GetDocumentPath, DocumentPath);

			if ( SimilarStr(~<DocumentPath>~, ~<Path>~) && Doc(FindByPath, ~<Path>~) )
			{
				Window(SetWindowOrder, Top);

				Doc( ReplaceImage, ~<Path>~, NULL, ImageData);
				return;
			}
		}
	}

	LastImageDocument = ~0~;

	// If we got here, the window was not found, so open a new one
	LastImageDocument = Open( Image, ~<Path>~, NULL, ImageData );

	if ((~<LastImageDocument>~ != ~0~) || (~<LastImageDocument>~ != ~~))
	{
		PostMessageToDocumentWindow(~<LastImageDocument>~, 32814, 0, 0);	// Disable cropping
	}
}

/***************************************************************************************************/
VOID RenderFailureNotify(Filename)
{
	dlg( SetStatus, 0, ~Ready to Process~ );
	StatusMessage = ~~;

	dlg(EnableControls, TRUE, PreviewButton);
	dlg(EnableControls, TRUE, ProcessNowButton);
	dlg(EnableControls, TRUE, CancelButton);

	MessageBox(~There was an error while rendering image <Filename>. Please see the log file for more information.~);
}

/***************************************************************************************************/
NUMERIC QueueImage()
{
	numEntries = dlg( ListBox, DigitalOrderImages,GetSelectedCount);
	count = dlg( ListBox, DigitalOrderImages, GetCount);

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	WaitCursor(Begin);

	if (<numEntries> == 0)
	{
		WaitCursor(End);

		dlg( SetStatus, 0, ~~);
		StatusMessage = ~~;
		Warning(~You must select an order and/or image(s).~);
		return FALSE;
	} else
	{
		if (!QueueForLater(LocalDBConnect))
		{
			WaitCursor(End);
			return FALSE;
		}
	}

	if (~<numEntries>~ == ~<count>~)
	{
		// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
		CheckOrderCompleted(LocalDBConnect, 2);		// The conversion is in progress now
	}

	WaitCursor(End);
	return TRUE;
	
	return TRUE;
}

/***************************************************************************************************/
NUMERIC ProcessImageNow()
{
	if ( (dlg( ListBox, DigitalOrders, GetSelectedCount) == 0) ||
			(dlg( ListBox, DigitalOrderImages, GetSelectedCount) == 0) )
	{
		dlg( SetStatus, 0, ~~);
		StatusMessage = ~~;
		Warning(~You must select an order and/or image(s).~);
		return FALSE;
	}

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	PreviewImageSize = 0;		// Make it a full-sized image.
	fileExtension = ~<$con.DlgData[FileExtension]>~;

	if ( SimilarStr( ~<$con.dlgData[SaveFileType]>~, TIFF ) )
	{
		OutputTypeID = ~TIFF~;
	}
	else
	{
		OutputTypeID = ~JPEG~;
		JPEGQuality = ~<$con.DlgData[JPEGQuality]>~;
	}
	
	Index = 0;

	// Release our handle to a file!
	if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~))
	{
	//	Warning( ~There was an error reading image!~ );
	}

	bLoadImageAttributes = FALSE;

	if (GetSystemSettings( ~DigitalCamera~, ~LoadImageDescription~, LoadImageDescription, Enabled ) )
	{
		if ( Numeric(~<LoadImageDescription>~) )
		{
			bLoadImageAttributes = TRUE;

			if (!GetSystemSettings( ~DigitalCamera~, ~ImageDescriptionField~, ImageDescriptionField, Enabled ) )
			{
				// If this fails, then we're not gonna do it, because we won't know where to put the information!
				bLoadImageAttributes = FALSE;

				Log(Session, ~Unable to determine the Image Description destination field, so we won't retrieve the Image Description at this time.~);
			} else
			{
				Query = ~Select <ImageDescriptionField> From Images~;	// WILL BE A QUERY THAT RETURNS NO RECORDS
				TruncationLength = -1;

				if ( PGenConList( List,Connection,LocalDBConnect,Cursor,Forward,SetMaxRecords,1,SetCacheSize,1,QUERY,~<Query>~ ) )
				{
					Index = -1;
					Tab = Chr(9);

					while ( List( FieldInfo,<++Index>,Name,FieldName,Length,FieldLength,Type,FieldType ) )
					{
						FieldName = FormatString( ~<FieldName>~,~%-31s~ );
						FieldName = String( TrimLeftRight,~<FieldName>~ );
						if ( SimilarStr(~<FieldName>~, ~<ImageDescriptionField>~) )
						{
							TruncationLength = <FieldLength>;
						}
					}
				}

				if (<TruncationLength> == -1)
				{
					// The field we got was invalid! So, forget about loading the descriptions!
					LoadImageDescription = FALSE;
					bLoadImageAttributes = FALSE;

					Log(Session, ~An invalid Image Description destination field was specified.~);
				}
			}
		}
	}
	
	Index = 0;

	WorkingSpaceProfName = GetWorkingSpaceProfile();

	EnableRawFileSharpening = ~<$con.DlgData[EnableRawFileSharpening]>~;
	OverrideDeltaSharpening = ~<$con.DlgData[OverrideDeltaSharpening]>~;
	DeltaSharpeningValue = ~<$con.DlgData[DeltaSharpeningValue]>~;

	while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
	{
		FileName = ~<$Str.$ImagePath.FileName>~;

		if (!GetRollAndFrameForFile(LocalDBConnect, ~<ImagePath>~, Roll, Frame))
		{
			return FALSE;
		}

		ImageName = ~<ImagePath>~;
		
		// Have to get the OutputFolderPath from the 'Path' field in the RawImages table.
		Query = ~SELECT OutputPath, LowResImagePath FROM RawImages WHERE OrderID = '<$con.DlgData[Directory]>' AND Roll = '<Roll>' AND Frame = '<Frame>' AND ImageType = 0~;

		ForgetLocal(List);

		if (!PGenConList(List, Connection, LocalDBConnect, Cursor, Forward, QUERY, ~<Query>~))
		{
			List(GetErrorDescription, 0, theErr);
			return Warning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) );
		}

		if ( !List(GetFirst, ProfileRecord) )
		{
			MessageBox(~Unable to process the image to a file. There may be a data error.~);
			Log(Session, ~Unable to process the image to a file. Failed to get data for query: \n<Query>~);
			return FALSE;
		}

		OutputFolderPath = ~<$pcon.ProfileRecord[OutputPath]>~;

		OutputFileName = ~~;
		LowResFileName = ~~;

		// If an image has been processed already and someone sets its status back to Unprocessed
		// by hand, then there's a possibility that the Path field will be the name of an output file,
		// rather than an output folder. This will hopefully detect that happening and adjust accordingly.
		if (~<OutputFolderPath>~ == ~~)
		{
			MessageBox(~The image '<ImageName>' has no output folder specified. Please fill in the Path field as appropriate and try again.~);
			return FALSE;
		} else if (Files(DirectoryExists, ~<OutputFolderPath>~))
		{
			OutputFileName = ~<OutputFolderPath>\<$Str.$ImageName.FileName.WithoutExt><fileExtension>~;
		} else if (~<$Str.$OutputFolderPath.ext>~ != ~~)
		{
			if (Files(DirectoryExists, ~<$Str.$OutputFolderPath.Path>~))
			{
				OutputFileName = ~<$Str.$OutputFolderPath.Path>\<$Str.$ImageName.FileName.WithoutExt><fileExtension>~;
			} else
			{
				// We do not have a valid folder to put the output image, so error out of here.
				MessageBox(~Sorry, but the output folder '<$Str.$OutputFolderPath.Path>' is not a valid destination. Please fill in the Path field as appropriate and try again.~);
				return FALSE;
			}
		} else
		{
			if (Files(DirectoryExists, ~<OutputFolderPath>~))
			{
				OutputFileName = ~<OutputFolderPath>\<$Str.$ImageName.FileName.WithoutExt><fileExtension>~;
			} else
			{
				// We do not have a valid folder to put the output image, so error out of here.
				MessageBox(~Sorry, but the output folder '<OutputFolderPath>' is not a valid destination. Please fill in the Path field as appropriate and try again.~);
				return FALSE;
			}
		}

		// Now time for a sanity check!! If the input file name == output file name, as could happen
		// if we didn't specify a different output folder for TIFF or JPEG images, then we should
		// stop processing right now!
		if (~<$Str.$OutputFileName.upper>~ == ~<$Str.$ImageName.upper>~)
		{
			MessageBox(~The input file name is the same as the output file name. Please change the Path field for this image in the Images table and try again.~);
			return FALSE;
		}

		// Tell everyone to let go of the image. This is only necessary in the case where the image
		// was processed before and the "Path" field is already filled in with the name of the image.
		// If that happens, then views like Order Images will keep the file from processing because
		// they are displaying the thumbnail.
		if ( ~<OutputFileName>~ != ~~ )
		{
			if ( !BroadcastMessageToAllViews( CanReleaseImage, ~<OutputFileName>~ ) )
				{ return Warning( Translate( ~Could not close\n\n<OutputFileName>\n\nbecause it is still open in a job or layout.~ ) ); }

			if ( !BroadcastMessageToAllViews( ReleaseImage, ~<OutputFileName>~ ) )		
				{ return Warning( Translate( ~Could not close\n\n<OutputFileName>\n\nbecause it is still open in a job or layout.~ ) ); }
		}

		// If the output file already exists and can not be removed, notify the user about this and
		// don't queue the file.
		if ( Files( FileExists,~<OutputFileName>~ ) )
		{
			if ( !Files( Delete, ~<OutputFileName>~ ) )
			{
				return Warning( Translate( ~Output file <OutputFileName> already exists and can not be deleted! Please delete the file and try converting it again.~ ) );
			}
		}

		LowResFileName = ~<$pcon.ProfileRecord[LowResImagePath]>~;

		InputProfilePath = GetInputProfile(~<ImageName>~, ~<Roll>~, ~<Frame>~);

		// Load the necessary information into the GenCon
		QueueItemData( SetValues, SrcPicPathID, ~<ImagePath>~ );
		QueueItemData( SetValues, OrderID, ~<$con.DlgData[Directory]>~ );
		QueueItemData( SetValues, Roll, ~<Roll>~ );
		QueueItemData( SetValues, Frame, ~<Frame>~ );
		QueueItemData( SetValues, MaxOutputDimension, ~0~ );

		QueueItemData( SetValues, OutputType, ~<OutputTypeID>~ );
		QueueItemData( SetValues, JPEGQuality, ~<JPEGQuality>~ );
		
		QueueItemData( SetValues, OutputPathName, ~<OutputFileName>~ );
		QueueItemData( SetValues, LowResPathName, ~<LowResFileName>~ );
		QueueItemData( SetValues, WorkingSpaceProfileName, ~<WorkingSpaceProfName>~ );
		QueueItemData( SetValues, InputProfilePath, ~<InputProfPathID>~ );

		QueueItemData( SetValues, LoadImageAttributes, ~<bLoadImageAttributes>~ );
		QueueItemData( SetValues, ImageDescriptionField, ~<ImageDescriptionField>~ );
		QueueItemData( SetValues, TruncationLength, ~<TruncationLength>~ );

		QueueItemData( SetValues, EnableRawFileSharpening, ~<EnableRawFileSharpening>~ );
		QueueItemData( SetValues, OverrideDeltaSharpening, ~<OverrideDeltaSharpening>~ );
		QueueItemData( SetValues, DeltaSharpeningValue, ~<DeltaSharpeningValue>~ );
		
		// Update the path and turn off Unprocessed flag.
		if ( !LocalDBConnect( Cmd,~UPDATE RawImages SET Processed = 1 WHERE OrderID = '<$con.DlgData[Directory]>' AND Roll = '<Roll>' AND Frame = '<Frame>' AND ImageType = 0~ ) )
		{
			LocalDBConnect( GetErrorDescription,theErr );
			Warning( ~Error Updating the shared database: <theErr>~ );
			Exit();

			OnErrorRollback(LocalDBConnect, ~<OrderID>~, ~<Roll>~, ~<Frame>~);
		}

		if ( !MyCamera(CookImagesAsynchNonQueueing, ~DlgData~, ~QueueItemData~) )
		{
			MessageBox( ~There was an error in CookImagesAsynch~);
		}
	}

	ForgetLocal(List);

	// Update the Unprocessed Images list
	if (!PGenConList(ListB,Connection,LocalDBConnect,Query,~Select * From RawImages Where OrderID = '<$con.DlgData[Directory]>' AND Processed <> 1 AND ImageType = 0~) )
	{
		ListB(GetErrorDescription,0,theErr);
		Warning(~Error querying shared database:<theErr>~);
	}

	ListB(MakeStringList, ImagesList, Path);

	dlg(SetControlFromStringList, DigitalOrderImages, ImagesList);

	dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);	// Select the first image by default

	LocalDBConnect(RefreshCache);
	
	dlg(EnableControls, FALSE, CancelButton);

	dlg(EnableControls, TRUE, CancelProcessingButton);

	OrderID = ~<$con.DlgData[Directory]>~;
	Query = ~Select BatchID From DCQueue Where OrderID = '<OrderID>'~;
	QueueCount = LocalDBConnect(RecordCountFor, ~<Query>~);

	// If there's images from this order still in the queue, then we want to mark it 
	// In Progress. Otherwise we mark it Complete.
	if (<QueueCount> > 0)
	{
		// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
		CheckOrderCompleted(LocalDBConnect, 2);		// The order conversion is still in progress
	} else
	{
		// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
		CheckOrderCompleted(LocalDBConnect, 3);		// The order conversion is now complete
	}

	LocalDBConnect(Close);

	return TRUE;
}


/***************************************************************************************************/
VOID PreviewImageNonQueueing()
{
	if (!MyCamera(WaitToClose))
	{
		dlg( SetStatus, 0, ~Previewing Image(s)...~);
		StatusMessage = ~~;
	}

	dlg(GetInput);

	if ( (dlg( ListBox, DigitalOrders, GetSelectedCount) == 0) ||
			(dlg( ListBox, DigitalOrderImages, GetSelectedCount) == 0) )
	{
		dlg( SetStatus, 0, ~~);
		StatusMessage = ~~;
		Warning(~You must select an order and/or image(s).~);
		return;
	}

	// Prepare the global ImageData object for the returned image.
	ImageData(SetValues, ImageBuffer, 0);
	ImageData(SetValues, ImageWidth, 0);
	ImageData(SetValues, ImageHeight, 0);
	ImageData(SetValues, ImageDepth, 0);
	ImageData(SetValues, ImageLayout, ~~);

	Index = 0;

	WorkingSpaceProfName = GetWorkingSpaceProfile();

	EnableRawFileSharpening = ~<$con.DlgData[EnableRawFileSharpening]>~;
	OverrideDeltaSharpening = ~<$con.DlgData[OverrideDeltaSharpening]>~;
	DeltaSharpeningValue = ~<$con.DlgData[DeltaSharpeningValue]>~;

	dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

	if (!ADO(LocalDBConnect, Connect))
	{
		LocalDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	UseHighest = ~<$con.dlgData[Resolution]>~;

	if (<UseHighest> == 1)
	{
		PreviewSize = 0;
	} else
	{
		PreviewSize = ~<$con.dlgData[PreviewImageSize]>~;
	}

	MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);

	while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
	{
		QueueItemData( SetValues, SrcPicPathID, ~<ImagePath>~ );

		QueueItemData( SetValues, MaxOutputDimension, ~<PreviewSize>~ );

		QueueItemData( SetValues, OutputType, ~MEMORY~ );

		QueueItemData( SetValues, WorkingSpaceProfileName, ~<WorkingSpaceProfName>~ );

		if (!GetRollAndFrameForFile(LocalDBConnect, ~<ImagePath>~, Roll, Frame))
		{
			Warning( ~ERROR: Unable to retrieve Roll and Frame for file <ImagePath>.~ );
			Log(Session, ~ERROR: Unable to retrieve Roll and Frame for file <ImagePath>.~);
			return;
		}

		QueueItemData( SetValues, OrderID, ~<OrderID>~ );
		QueueItemData( SetValues, Roll, ~<Roll>~ );
		QueueItemData( SetValues, Frame, ~<Frame>~ );

		QueueItemData( SetValues, EnableRawFileSharpening, ~<EnableRawFileSharpening>~ );
		QueueItemData( SetValues, OverrideDeltaSharpening, ~<OverrideDeltaSharpening>~ );
		QueueItemData( SetValues, DeltaSharpeningValue, ~<DeltaSharpeningValue>~ );

		if ( !MyCamera(CookImagesAsynchNonQueueing, ~DlgData~, ~QueueItemData~) )
		{
			MessageBox( ~There was an error in CookImagesAsynch~);
		}
	}

	dlg(EnableControls, FALSE, CancelButton);

	dlg(EnableControls, TRUE, CancelProcessingButton);

	return;
}

/***************************************************************************************************/
NUMERIC QueueForLater(&dBase)
{
	dlg(GetInput);

	dlg(ListBox, DigitalOrders, GetSelectedItem, OrderID);

	// If going from file settings, use the image file's setting to clue us in to the look profile to use.
	// So... set nothing here. We'll worry about it in the thread!

	JPEGQuality = 100;

	PreviewImageSize = 0;		// Make it a full-sized image.

 	fileExtension = ~<$con.DlgData[FileExtension]>~;

	if ( SimilarStr( ~<$con.dlgData[SaveFileType]>~, TIFF ) )
	{
		OutputTypeID = ~TIFF~;
	}
	else
	{
		OutputTypeID = ~JPEG~;
		JPEGQuality = ~<$con.DlgData[JPEGQuality]>~;
	}
	
	Index = 0;

	// Release our handle to a file!
	if (!MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~))
	{
	//	Warning( ~There was an error reading image!~ );
	}

	BatchID = UniqueBatchID();

	bLoadImageAttributes = FALSE;

	if (GetSystemSettings( ~DigitalCamera~, ~LoadImageDescription~, LoadImageDescription, Enabled ) )
	{
		if ( Numeric(~<LoadImageDescription>~) )
		{
			bLoadImageAttributes = TRUE;

			if (!GetSystemSettings( ~DigitalCamera~, ~ImageDescriptionField~, ImageDescriptionField, Enabled ) )
			{
				// If this fails, then we're not gonna do it, because we won't know where to put the information!
				bLoadImageAttributes = FALSE;

				Log(Session, ~Unable to determine the Image Description destination field, so we won't retrieve the Image Description at this time.~);
			} else
			{
				Query = ~Select <ImageDescriptionField> From Images~;	// WILL BE A QUERY THAT RETURNS NO RECORDS
				TruncationLength = -1;

				if ( PGenConList( List,Connection,dBase,Cursor,Forward,SetMaxRecords,1,SetCacheSize,1,QUERY,~<Query>~ ) )
				{
					Index = -1;
					Tab = Chr(9);

					while ( List( FieldInfo,<++Index>,Name,FieldName,Length,FieldLength,Type,FieldType ) )
					{
						FieldName = FormatString( ~<FieldName>~,~%-31s~ );
						FieldName = String( TrimLeftRight,~<FieldName>~ );
						if ( SimilarStr(~<FieldName>~, ~<ImageDescriptionField>~) )
						{
							TruncationLength = <FieldLength>;
						}
					}
				}

				if (<TruncationLength> == -1)
				{
					// The field we got was invalid! So, forget about loading the descriptions!
					LoadImageDescription = FALSE;
					bLoadImageAttributes = FALSE;

					Log(Session, ~An invalid Image Description destination field was specified.~);
				}
			}
		}
	}
	
	Index = 0;

	while ( dlg(ListBox, DigitalOrderImages, GetNthSelectedItem, <Index++>, ImagePath) > 0 )
	{
		FileName = ~<$Str.$ImagePath.FileName>~;

		if (!GetRollAndFrameForFile(dBase, ~<ImagePath>~, Roll, Frame))
		{
			return FALSE;
		}

		ImageName = ~<ImagePath>~;
		
		// If we've been asked, we need to extract the Image Description from each file as we queue 
		// it to be processed

		if (<bLoadImageAttributes>)
		{
			ImageDescription = ~~;

			if (MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~<ImageName>~))
			{
				if (MyCamera(CapabilitySupported, MyCamera(KVTPICPROCImageDescStringID)))
				{
					if (!MyCamera(GetAttributeValue, MyCamera(KVTPICPROCImageDescStringID), ImageDescription))
					{
						MessageBox( ~There was an error getting the Image Description!~ );
					}

					substr(~<ImageDescription>~, 0, <TruncationLength>, ImageDescription);
				}
			}

			MyCamera(SetAttributeValue, MyCamera(KVTPICPROCSrcPicPathID), ~c:\~);
		}

		// Have to get the OutputFolderPath from the 'Path' field in the RawImages table.
		Query = ~SELECT OutputPath, LowResImagePath FROM RawImages WHERE OrderID = '<$con.DlgData[Directory]>' AND Roll = '<Roll>' AND Frame = '<Frame>' AND ImageType = 0~;

		ForgetLocal(List);

		if (!PGenConList(List, Connection, dBase, Cursor, Forward, QUERY, ~<Query>~))
		{
			List(GetErrorDescription, 0, theErr);
			return Warning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) );
		}

		if ( !List(GetFirst, ProfileRecord) )
		{
			MessageBox(~Unable to process the image to a file. There may be a data error.~);
			Log(Session, ~Unable to process the image to a file. Failed to get data for query: \n<Query>~);
			return FALSE;
		}

		OutputFolderPath = ~<$pcon.ProfileRecord[OutputPath]>~;

		// If an image has been processed already and someone sets its status back to Unprocessed
		// by hand, then there's a possibility that the Path field will be the name of an output file,
		// rather than an output folder. This will hopefully detect that happening and adjust accordingly.
		if (~<OutputFolderPath>~ == ~~)
		{
			MessageBox(~The image '<ImageName>' has no output folder specified. Please fill in the Path field as appropriate and try again.~);
			return FALSE;
		} else if (Files(DirectoryExists, ~<OutputFolderPath>~))
		{
			OutputFileName = ~<OutputFolderPath>\<$Str.$ImageName.FileName.WithoutExt><fileExtension>~;
		} else if (~<$Str.$OutputFolderPath.ext>~ != ~~)
		{
			if (Files(DirectoryExists, ~<$Str.$OutputFolderPath.Path>~))
			{
				OutputFileName = ~<$Str.$OutputFolderPath.Path>\<$Str.$ImageName.FileName.WithoutExt><fileExtension>~;
			} else
			{
				// We do not have a valid folder to put the output image, so error out of here.
				MessageBox(~Sorry, but the output folder '<$Str.$OutputFolderPath.Path>' is not a valid destination. Please fill in the Path field as appropriate and try again.~);
				return FALSE;
			}
		} else
		{
			if (Files(DirectoryExists, ~<OutputFolderPath>~))
			{
				OutputFileName = ~<OutputFolderPath>\<$Str.$ImageName.FileName.WithoutExt><fileExtension>~;
			} else
			{
				// We do not have a valid folder to put the output image, so error out of here.
				MessageBox(~Sorry, but the output folder '<OutputFolderPath>' is not a valid destination. Please fill in the Path field as appropriate and try again.~);
				return FALSE;
			}
		}

		// Now time for a sanity check!! If the input file name == output file name, as could happen
		// if we didn't specify a different output folder for TIFF or JPEG images, then we should
		// stop processing right now!
		if (~<$Str.$OutputFileName.upper>~ == ~<$Str.$ImageName.upper>~)
		{
			MessageBox(~The input file name is the same as the output file name. Please change the Path field for this image in the Images table and try again.~);
			return FALSE;
		}

		// Tell everyone to let go of the image. This is only necessary in the case where the image
		// was processed before and the "Path" field is already filled in with the name of the image.
		// If that happens, then views like Order Images will keep the file from processing because
		// they are displaying the thumbnail.
		if ( ~<OutputFileName>~ != ~~ )
		{
			if ( !BroadcastMessageToAllViews( CanReleaseImage, ~<OutputFileName>~ ) )
				{ return Warning( Translate( ~Could not close\n\n<OutputFileName>\n\nbecause it is still open in a job or layout.~ ) ); }

			if ( !BroadcastMessageToAllViews( ReleaseImage, ~<OutputFileName>~ ) )		
				{ return Warning( Translate( ~Could not close\n\n<OutputFileName>\n\nbecause it is still open in a job or layout.~ ) ); }
		}

		// If the output file already exists and can not be removed, notify the user about this and
		// don't queue the file.
		if ( Files( FileExists,~<OutputFileName>~ ) )
		{
			if ( !Files( Delete, ~<OutputFileName>~ ) )
			{
				return Warning( Translate( ~Output file <OutputFileName> already exists and can not be deleted! Please delete the file and try converting it again.~ ) );
			}
		}

		LowResFileName = ~<$pcon.ProfileRecord[LowResImagePath]>~;

		InputProfilePath = GetInputProfile(~<ImageName>~, ~<Roll>~, ~<Frame>~);

		WorkingSpaceProfName = GetWorkingSpaceProfile();

		Computer = ~<$App.ComputerName>~;

		EnableRawFileSharpening = ~<$con.DlgData[EnableRawFileSharpening]>~;
		OverrideDeltaSharpening = ~<$con.DlgData[OverrideDeltaSharpening]>~;
		DeltaSharpeningValue = ~<$con.DlgData[DeltaSharpeningValue]>~;

		// Remove any old queued requests before inserting the new one, just so that we don't conflict on the
		// primary key and cause an error.
		SQLDelete = ~DELETE FROM DCQueue WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>' AND Computer='<Computer>')~;
		dBase(Cmd, ~<SQLDelete>~);	// OK if this fails

		Parameters = ~OrderID, Roll, Frame, BatchID, OutputTypeID, JPEGQualityID, MaxOutputDimensionID, SrcPicPathID, OutputPicPathID, LowResPicPathID, ~;
		Parameters = ~<Parameters>~ + ~Priority, Computer, InputProfPathID, WorkingSpaceProfName, EnableRawFileSharpening, OverrideDeltaSharpening, DeltaSharpeningValue~;

		Values = ~'<OrderID>', '<Roll>', '<Frame>', '<BatchID>', '<OutputTypeID>', <JPEGQuality>, <PreviewImageSize>,'<ImageName>','<OutputFileName>','<LowResFileName>',~;
		Values = ~<Values>~ + ~'QUEUE_FOR_LATER','<Computer>','<InputProfilePath>','<WorkingSpaceProfName>', <EnableRawFileSharpening>, <OverrideDeltaSharpening>, <DeltaSharpeningValue>~;

		SQLCommand = ~Insert Into DCQueue(<Parameters>) Values(<Values>)~;

		if (!dBase(Cmd, ~<SQLCommand>~))
		{
			dbase(GetErrorDescription, theErr);
			return Warning( Translate(~Database update failed <SQLCommand>. <theErr>~));
		}

		// Update the path and turn off Unprocessed flag.
		if ( !dBase( Cmd,~UPDATE RawImages SET Processed = 1 WHERE OrderID = '<$con.DlgData[Directory]>' AND Roll = '<Roll>' AND Frame = '<Frame>' AND ImageType = 0~ ) )
		{
			dBase( GetErrorDescription,theErr );
			Warning( ~Error Updating the shared database: <theErr>~ );
			Exit();

			OnErrorRollback(dBase, ~<OrderID>~, ~<Roll>~, ~<Frame>~);
		}

		UpdateQuery = ~~;

		if (<bLoadImageAttributes>)
		{
			UpdateQuery = ~UPDATE Images SET Reconverting=1, <ImageDescriptionField> = '<ImageDescription>', Path = '' WHERE OrderID = '<$con.DlgData[Directory]>' AND Roll = '<Roll>' AND Frame = '<Frame>'~;
		} 
		else
		{
			UpdateQuery = ~UPDATE Images SET Reconverting=1, Path = '' WHERE OrderID = '<$con.DlgData[Directory]>' AND Roll = '<Roll>' AND Frame = '<Frame>'~;
		}

		if (~<UpdateQuery>~ != ~~)
		{
			if ( !dBase( Cmd, ~<UpdateQuery>~ ) )
			{
				dBase( GetErrorDescription,theErr );
				Warning( ~Error Updating the shared database: <theErr>~ );
				Exit();

				OnErrorRollback(dBase, ~<OrderID>~, ~<Roll>~, ~<Frame>~);
			}
		}
	}

	if (!PGenConList(ListB,Connection,dBase,Query,~Select * From RawImages Where OrderID = '<$con.DlgData[Directory]>' AND Processed <> 1 AND ImageType = 0~) )
	{
		ListB(GetErrorDescription,0,theErr);
		Warning(~Error querying shared database:<theErr>~);
	}

	ListB(MakeStringList, ImagesList, Path);

	dlg(SetControlFromStringList, DigitalOrderImages, ImagesList);

	dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);	// Select the first image by default

	dBase(RefreshCache);

	return TRUE;
}

/********************************************************************************************/
STR GetInputProfile(ImageName, Roll, Frame)
{
	if (!ADO(dBase, Connect))
	{
		dbase( GetErrorDescription, theErr);
		return Warning( Translate( ~Could not connect to the database. <theErr>~ ) );
	}

	// If a profile is specified in ICCProfile, then we use that one as the Input Profile
	Query = ~SELECT ICCProfile FROM RawImages WHERE OrderID = '<$con.DlgData[Directory]>' AND Roll = '<Roll>' AND Frame = '<Frame>' AND ImageType = 0~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Failed to query the Images table.\n\n<Query>\n\n<theErr>~ ) ); 
	}

	InputProfilePath = ~~;

	if ( List( GetFirst,ProfileRecord ) )
	{
		InputProfilePath = ~<$pcon.ProfileRecord[ICCProfile]>~;
	}

	return ~<InputProfilePath>~;
}

/********************************************************************************************/
STR GetWorkingSpaceProfile( void )
{
	if (!ADO(dBase, Connect))
	{
		dbase( GetErrorDescription, theErr);
		return Warning( Translate( ~Could not connect to the database. <theErr>~ ) );
	}

	// If the control is set to "Use DP2's current working space", then we load it.
	// Otherwise, we need to see what they chose in the OutputProfileName field.
	// If that fails, then we default to srgb.
	if (Numeric(~<$con.dlgData[UseWorkingspaceProfile]>~))
	{
		// Use the current DP2 working space profile if it's set
		Query = ~SELECT WorkingSpaceProfile FROM ViewProfiles WHERE ComputerName = '<$app.ComputerName>' AND UserName = '<$app.UserName>'~;

		if (!dBase(GetValuesFor, ~<Query>~, WorkingSpaceProfile) )
		{
//			Warning(~Unable to set the working space profile!~ );
//			Exit();

			Log(Session, ~Unable to ID DP2's Working Space Profile. Instead using 'SRGB'~);
			WorkingSpaceProfileName = ~~;
		} else
		{
			WorkingSpaceProfileName = ~<WorkingSpaceProfile>~;
		}
	} else
	{
		WorkingSpaceProfileName = ~<$con.dlgData[AlternateOutputProfile]>~;

		if (GenCon( LocalDCOptionsGC,GetFrom,DCOptionsGC,~[GENCONS]~ ))
		{
			bUseHighLevelLogging = 0;
			LocalDCOptionsGC( GetValue, ~HighLevelDCLogging~, bUseHighLevelLogging);
		}

		if (<bUseHighLevelLogging>)
		{
			Log(Session, ~Overriding DP2's Working Space Profile. Instead using '<WorkingSpaceProfileName>'~);
		}
	}

	// If no one had a default working space profile setting, then we use SRGB 
	// for processing.
	if ( (~<WorkingSpaceProfileName>~ == ~None~) || (~<WorkingSpaceProfileName>~ == ~~) )
	{
		WorkingSpaceProfileName = ~srgb~;
	}

	return ~<WorkingSpaceProfileName>~;
}

/********************************************************************************************/
VOID OnErrorRollback(&dBase, OrderID, Roll, Frame)
{
	////////////////////////////////////////////////////////////
	// Remove the record from the DCQueue table, if it's there.
	SQLDelete = ~DELETE FROM DCQueue WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>')~;
	dBase(Cmd, ~<SQLDelete>~);	// OK if this fails

	////////////////////////////////////////////////////////////
	// Set the Image's status back to Unprocessed and clear the ICCProfile field. Also clear the Path
	Query = ~SELECT Path FROM RawImages WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>' AND ImageType = 0)~;
	if (!PGenConList(List, Connect, Cursor, Forward, QUERY, ~<Query>~))
	{
		List(GetErrorDescription, 0, theErr);
		return Warning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) );
	}

	if ( !List(GetFirst, ProfileRecord) )
	{
		return FALSE;
	}

	CurrentPath = ~<$pcon.ProfileRecord[Path]>~;

	Path = $Str.$CurrentPath.Path;

	dBase( Cmd,~UPDATE RawImages SET Processed = 0 WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>' AND ImageType = 0)~ );
	dBase( Cmd,~UPDATE Images SET Path = '', ICCProfile = '', Reprocess = 1, Reconverting = 1 WHERE (OrderID='<OrderID>' AND Roll='<Roll>' AND Frame='<Frame>')~ );


	////////////////////////////////////////////////////////////
	// Make sure that the Order's status has not been changed to "Complete"
	// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
	if ( !dBase(Cmd, ~UPDATE Orders SET CameraFileConversionStatus = 1 WHERE ID = '<OrderID>'~) )
	{
		dBase(GetErrorDescription, theErr);

		Warning( ~Error Updating the order status: <theErr>~ );
		return;
	}

	dBase(RefreshCache);
}


// OnKeyDown is only executed when a control is not in focus to accept the keystroke.  In this case,
// the dialog accepts the key and calls this routine. PDF 10/6/00
NUMERIC ControlAction( which)
{
	return dlg( TriggerControlActions , <which>, DActionsText );
}

NUMERIC OnKeyDown()
{
	Key = dlg(GetLastKey, Keyname);

	OnSimilarStr( ~<Keyname>~, 
		~p~, ~ControlAction(PreviewButton)~,
		~r~, ~ControlAction(RefreshListsButton)~,
		~v~, ~ControlAction(OpenSelectedOrderButton)~);

	OnSimilarStr( ~<Key>~, 		
		~116~, ~ControlAction(RefreshListsButton)~);

	return TRUE;
}


/********************************************************************************************/
VOID InitMain()
{
	if (!ADO(MainDBConnect, Connect))
	{
		MainDBConnect( GetErrorDescription,theErr );
		Warning( ~Error connecting to the shared database: <theErr>~ );
		Exit();
	}

	EnableControlsBool(FALSE);

	GetOrdersFromDatabase(MainDBConnect);
	CheckAllOrdersCompleted(MainDBConnect);

	MainDBConnect(RefreshCache);
	MainDBConnect(Close);
}


/********************************************************************************************/
//			MAIN
/********************************************************************************************/

DefineDialog();
GenDlg( dlg,Definition,DigitalCameraDlgDefinition,Data,DlgData,Document,$Doc.This,New,Temporary );

InitMain();

if (DigitalCamera(MyCamera, CreatePictureProcessor) == MyCamera(DC_OBJECT_ALREADY_EXISTS))
{
	MessageBox( ~There was an error on creation!!~ );
}

// Select the first order by default
dlg( ListBox, DigitalOrders, Select, 0);

GetImagesFromSelectedOrder();

LoadWorkstationSettings();

UpdateLookProfileList(Look, LookProfilesComboBox);

dlg( ListBox, DigitalOrderImages, SetSel, 0, 1);

LastLook = ~Use Embedded~;
Global(LastLook);

LoadImageAttributes();

JPEGEnabled = SimilarStr( ~<$con.dlgData[SaveFileType]>~, JPEG );
dlg( EnableControls, <JPEGEnabled>, JPEGQualitySlider, JPEGQualityField, JPEGQualityPrompt, JPEGQualityMinStatic, JPEGQualityMaxStatic);

dlg(EnableControls, FALSE, CancelProcessingButton);
dlg(EnableControls, FALSE, ProfileComboBox);
dlg(EnableControls, FALSE, DeltaSharpeningField);

/********************************************************************************************/
PreviewCount = 0;
Path = ~~;

