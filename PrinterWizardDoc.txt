IncludeClass( BaseWizard );

Class( Wiz,Extends,BaseWizard );

//---------------------------------------------MAIN MENU---------------------------------------------------

// Initial menu allowing choice of functions to perform
enum( Main,0,Menu_0 );

// Main menu of choices shown on the first dialog
enum( Menu,0,Menu,prn_1,PrinterBalance,ChangePrinterQueue,DeletePrinter,Ignore,que,QueueBalance,DeleteQueue );

//---------------------------------------------PRINTERS----------------------------------------------------

// Streams to handle the creation of new printers of a particular model (Don't forget to handle translations)
enum( prn,0,Menu,Models );

// Windows Printers
enum( prnNTPrinter,0,Menu,Name,OutputPath,NetworkAddress,RollToRoll,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );

// Generic Disk Printer
enum( prnDisk,0,Menu,Name,OutputPath,ICCProfile,Backprint,OrderPunch,RunAttended,PaperSize,Scripts,PrintScripts,RollToRoll,PrintersQueue,AutoStart,PrinterSave );

// Kodak LED Printers
enum( prnKodakLED,0,Menu,Name,OutputPath,Device,RollToRoll,ICCProfile,Gamma,CalibrationLut,LogFile,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );
enum( prnKodakRP50,0,Menu,Name,OutputPath,Device,RollToRoll,ICCProfile,Gamma,CalibrationLut,LogFile,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );

// Kodak Printers based on the Agfa printer
enum( prnKodakRR30,0,Menu,Name,OutputPath,ICCProfile,Gamma,CalibrationLut,LogFile,RunAttended,PaperSize,Scripts,PrintScripts,ResponseScripts,PrintersQueue,AutoStart,PrinterSave );
enum( prnKodakRP30,0,Menu,Name,OutputPath,ICCProfile,Gamma,CalibrationLut,LogFile,RunAttended,PaperSize,Scripts,PrintScripts,ResponseScripts,PrintersQueue,AutoStart,PrinterSave );
enum( prnKodakSRP30,0,Menu,Name,OutputPath,ICCProfile,Gamma,CalibrationLut,LogFile,RunAttended,PaperSize,Scripts,PrintScripts,ResponseScripts,PrintersQueue,AutoStart,PrinterSave );

// Kodak CRT Printers
enum( prnKodakCRT,0,Menu,Name,OutputPath,Device,ICCProfile,Gamma,PaperPack,CalibrationLut,LogFile,Backprint,OrderPunch,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );
enum( prnKPDM,0,Menu,Name,OutputPath,Device,ICCProfile,Gamma,PaperPack,CalibrationLut,LogFile,Backprint,OrderPunch,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );
enum( prnKPDMII,0,Menu,Name,OutputPath,Device,ICCProfile,Gamma,PaperPack,CalibrationLut,LogFile,Backprint,OrderPunch,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );
enum( prnKodakLFCRT,0,Menu,Name,OutputPath,Device,ICCProfile,Gamma,PaperPack,CalibrationLut,LogFile,Backprint,OrderPunch,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );

// Unknown model.  Ask all the questions.
enum( prnUnknown,0,Menu,Name,NetworkAddress,Device,RollToRoll,ICCProfile,Gamma,CalibrationLut,LogFile,Backprint,OrderPunch,RunAttended,PaperSize,Scripts,PrintScripts,PrintersQueue,AutoStart,PrinterSave );

// Change the balance offsets for a printer or a queue
enum( PrinterBalance,0,Menu,Models,Name,PrinterBalance,PrinterSave );
enum( QueueBalance,0,Menu,Models,Queues,QueueBalance,QueueSave );

// Change the queue that a printer is watching
enum( ChangePrinterQueue,0,Menu,Models,Name,PrintersQueue,PrinterSave );

//---------------------------------------------QUEUES------------------------------------------------------

// Change Printer Queue Information
enum(  que,0,Menu,Models,QueueSave );
enum( queUnknown,0,Menu,Models,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );

// Windows Printers
enum( queNTPrinter,0,Menu,Models,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave);

// NexPress Printers
enum( queNexPressPrinter,0,Menu,Models,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave);

// Generic Disk Printer
enum( queDisk,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );

// Kodak LED Printers
enum( queKodakLED,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );
enum( queKodakRP50,0,MenuQueues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );

// Kodak Printers based on the Agfa printer
enum( queKodakRR30,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );
enum( queKodakRP30,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );
enum( queKodakSRP30,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );

// Kodak CRT Printers
enum( queKodakCRT,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );
enum( queKPDM,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );
enum( queKPDMII,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );
enum( queKodakLFCRT,0,Menu,Queues,RunAttended,ICCProfile,Gamma,PaperPack,CalibrationLUT,PaperSize,PaperFill,PaperType,PaperOpacity,PaperSurface,PrintScripts,QueueBalance,QueueSave );

//--------------------------------------------------------------------------------------------------------


VOID	Wiz::Wiz()
{
	Dictionary = ~PrinterWizardDoc~;
	Title = Translate(~Printer Setup Wizard~);
	DialogWidth = 750;
	DialogHeight = 500;
	SetStream( ~Main~ );
	HelpFile = ~KPISHelpFile~;
	HelpPage = ~PrinterWizard.htm~;
}


VOID Wiz::DefineMainMenuMessages()		
{ 
	item = -1;
	Translations( AddText,MenuDescription<++item>,~Verbose description of adding or changing a printer~ );
	Translations( AddText,MenuTitle<item>,~Define a new printer or change an existing printer~ );	
	
	Translations( AddText,MenuDescription<++item>,~Verbose description of changing the printer balance~ );
	Translations( AddText,MenuTitle<item>,~Change the printer balance~ );	
	
	Translations( AddText,MenuDescription<++item>,~Verbose description of changing a printer to look at a different queue~ );
	Translations( AddText,MenuTitle<item>,~Change the queue a printer is watching~ );	

	Translations( AddText,MenuDescription<++item>,~Verbose description of deleting a printer~ );
	Translations( AddText,MenuTitle<item>,~Delete a printer~ );	

	Translations( AddText,MenuDescription<++item>,~ ~ );	// Leave a blank line between the printer and the queue functions
	Translations( AddText,MenuTitle<item>,~ ~ );
	
	Translations( AddText,MenuDescription<++item>,~Verbose description of adding or changing a printer queue~ );
	Translations( AddText,MenuTitle<item>,~Define a new printer queue or change an existing queue~ );	
	
	Translations( AddText,MenuDescription<++item>,~Verbose description of changing the queue balance~ );
	Translations( AddText,MenuTitle<item>,~Change the queue balance~ );	

	Translations( AddText,MenuDescription<++item>,~Verbose description of deleting a printer queue~ );
	Translations( AddText,MenuTitle<item>,~Delete a printer queue~ );	

	item = -1;
	TranslationsSpanish( AddText,MenuDescription<++item>,~Spanish Verbose description of adding or changing a printer~ );	
}

VOID Wiz::DefinePrinterModelMessages()		
{ 
	Translations( AddText,DiskPrinter,~Disk~ );	
	Translations( AddText,KodakLED,~Kodak LED~ );	
	Translations( AddText,KodakCRT,~Kodak CRT~ );	
	Translations( AddText,KPDM,~KPDM~ );	
	Translations( AddText,KPDMII,~KPDM II~ );	
	Translations( AddText,KodakLFCRT,~Kodak LFCRT~ );	
	Translations( AddText,NTPrinter,~NT Printer~ );	
}


VOID Wiz::DefineMessages()		
{ 
	BaseWizard::DefineMessages();

	DefineMainMenuMessages();

	DefinePrinterModelMessages();


	Translations( AddText,NameCantBeNull,~You must enter a node name~ );	
	Translations( AddText,InitialPrompt,~Use this Printer Wizard to define new printers or change existing printers in your system.  It is also used to create and alter printer queues.~ );
	
	Translations( AddText,SelectModel,~Select from one of the following printer models~ );

	Translations( AddText,SelectExistingName,~Select the printer you wish to change by selecting from the list below~ );
	Translations( AddText,OrNewName,~Or enter the name of a new printer~ );
	Translations( AddText,SelectNameTooltip,~Select a name for the printer~ );

	Translations( AddText,QueuePrompt,~Which Queue would you like to modify?  Select from the list of existing queues ~);

	Translations( AddText,PrintersQueuePrompt,~Printers watch queues for work.  Which Queue should this printer watch?  Select from the list of existing queues ~);


	Translations( AddText,ComputerNamePrompt,~Select the computer that will control the printer~);
	Translations( AddText,ComputerNameControl,~Computer~);

	Translations( AddText,AutoStartPrompt,~Would you like to automatically start the printer when <$App.Title> starts up?~);
	Translations( AddText,AutoStartControl,~Auto Start The Printer~);

	Translations( AddText,ICCProfilePrompt,~Select an ICC Output Profile from the following list~);
	Translations( AddText,GammaPrompt,~Select a Gamma Lookup Table from the following list~);

	Translations( AddText,DevicePrompt,~Tell me where the printer is on the SCSII bus~);

	Translations( AddText,LogFilePrompt,~Find the log file~);
	Translations( AddText,NetworkAddressPrompt,~Select from the list of printer?~);

	Translations( AddText,PaperFillPrompt,~Would you like to use paper fill?~);

	Translations( AddText,MenuPrompt,~Click on the function you would like to perform.  A description is shown at the bottom.  Press next to perform the selected function.~);
	
	Translations( AddText,PrinterBalancePrompt,~Define the balance offset for printer %1~);
	Translations( AddText,QueueBalancePrompt,~Define the balance offset for printer queue %1~);

	Translations( AddText,PaperSizePrompt,~Define the maximum print size for printer %1~);
	Translations( AddText,PaperWidthPrompt,~Max Paper Width~);
	Translations( AddText,PaperAdvancePrompt,~Max Paper Advance~);

	
	Translations( AddText,BackPrintPrompt,~Does the printer have a back printer?~);
	Translations( AddText,BackPrintControl,~Back Printer~);

	Translations( AddText,OrderPunchPrompt,~Can the printer punch an Order Punch?~);
	Translations( AddText,OrderPunchControl,~Order Punch~);

	Translations( AddText,OutputPathDescription,~Specify the format and the path to the output file~);

	Translations( AddText,FileTypePrompt,~File Type~);

	Translations( AddText,OutputPathPrompt,~Formulate the path to the output file~ );
	Translations( AddText,OutputPathTooltip,~Formulate the path to the output file~ );
	Translations( AddText,OutputPathBrowse,~Find path to the output file~);

	Translations( AddText,MacrosTitle,~Macros to help formulate an output path~ );

	Translations( AddText,UseOutputMacro,~Copy Macro to the Paste Buffer~ );

	Translations( AddText,QuestionMark,~?~ );

	Translations( AddText,ScriptsDescription,~Specify scripts to execute as rendering starts up and shuts down~ );
	Translations( AddText,PrintScriptsDescription,~Specify scripts to execute during the printing process~ );
	Translations( AddText,ResponseScriptsDescription,~Specify scripts to execute for communicating with the printer~ );

	Translations( AddText,StartUpScriptPrompt,~Script to execute when the render engine starts~ );
	Translations( AddText,ScriptBrowseToolTip,~Browse to the script~ );
	Translations( AddText,ScriptFieldToolTip,~Enter the path to the script~ );

	Translations( AddText,StartUpScriptPrompt,~Script to execute when the render engine starts~ );
	Translations( AddText,HFExePathPrompt,~Script to execute for HFExePath~ );
	Translations( AddText,StartPrintingPrompt,~Script to execute before the rendering of a print~ );
	Translations( AddText,OnPrintCompletePrompt,~Script to execute when a print is complete~ );
	Translations( AddText,OnOrderCompletePrompt,~Script to execute an entire order has been printed~ );
	Translations( AddText,ControlFolderPrompt,~Folder that contains the control scripts for the printer~ );
	Translations( AddText,ResponseScriptPrompt,~Path to the script that interprets responses from the printer~ );
	Translations( AddText,ResponseFolderPrompt,~Folder that contains responses from the printer~ );
	Translations( AddText,ShutDownScriptPrompt,~Script to execute when the render engine shuts down~ );


	Translations( AddText,PaperTypePrompt,~Select the paper type for the queue~ );
	Translations( AddText,PaperSurfacePrompt,~Select the paper surface for the queue~ );
	Translations( AddText,PaperOpacityPrompt,~Select the paper opacity~ );

	Translations( AddText,PaperPackPrompt,~Select the paper pack for the printer~ );
	Translations( AddText,PaperPackBrowse,~Find the paper pack~ );

	Translations( AddText,CalibrationLutPrompt,~Select the calibration lut for the printer~ );
	Translations( AddText,CalibrationLutBrowse,~Find the calibration lut~ );

	Translations( AddText,RollToRollPrompt,~Is your printer roll to roll?~ );
	Translations( AddText,RollToRollBoxPrompt,~Roll to Roll?~ );

	Translations( AddText,RunAttendedPrompt,~Would you like to be notified when there is a rendering problem?~ );
	Translations( AddText,RunAttendedBoxPrompt,~Run Attended?~ );

	Translations( AddText,PrinterSaveDescription,~Press save to remember your changes for this printer~ );
	Translations( AddText,QueueSaveDescription,~Press save to remember your changes for this printer queue~ );

	Translations( AddText,QueueDoesNotExist,~The printer queue %1 does not exist.  Would you like to create it?~ );


	// OUTPUTPATH MACROS

	StringList( MacroNameTranslations,New,Private );
		MacroNameTranslations( AddString,~Order~ );
		MacroNameTranslations( AddString,~OrderItem ID~ );
		MacroNameTranslations( AddString,~Order Sequence~ );
		MacroNameTranslations( AddString,~OrderItem Sequence~ );
		MacroNameTranslations( AddString,~OrderItem Quantity~ );
		MacroNameTranslations( AddString,~Job Quantity~ );
		MacroNameTranslations( AddString,~Total Quantity~ );
		MacroNameTranslations( AddString,~BatchID~ );
		MacroNameTranslations( AddString,~Product Code~ );
		MacroNameTranslations( AddString,~Page Number~ );
		MacroNameTranslations( AddString,~Width of the background~ );
		MacroNameTranslations( AddString,~Height of the background~ );
		MacroNameTranslations( AddString,~BatchID OrderID OrderItemID Page~ );

	StringList( MacroToolTipTranslations,New,Private );
		MacroToolTipTranslations( AddString,~Expands to the Order ID of the OrderItem being printed.  Usage: [O]~ );
		MacroToolTipTranslations( AddString,~Expands to the OrderItem ID~ );
		MacroToolTipTranslations( AddString,~Expands to the Order Sequence~ );
		MacroToolTipTranslations( AddString,~Expands to the OrderItem Sequence~ );	
		MacroToolTipTranslations( AddString,~Expands to the OrderItem Quantity~ );
		MacroToolTipTranslations( AddString,~Expands to the Job Quantity~ );
		MacroToolTipTranslations( AddString,~Expands to the Total Quantity which is the OrderItem Quantity times the Job Quantity~ );
		MacroToolTipTranslations( AddString,~Expands to the BatchID~ );
		MacroToolTipTranslations( AddString,~Expands to the Product Code~ );
		MacroToolTipTranslations( AddString,~Expands to the Page Number. Each page of the batch is an incrementing number starting with 1.~ );
		MacroToolTipTranslations( AddString,~Expands to the Width of the background in inches~ );
		MacroToolTipTranslations( AddString,~Expands to the Height of the background in inches~ );
		MacroToolTipTranslations( AddString,~Expands to the BatchID OrderID OrderItemID Page~ );

	StringList( MacroText,New,Private );
		MacroText( AddString,~[O]~ );		// OrderID
		MacroText( AddString,~[I]~ );		// OrderItem ID	
		MacroText( AddString,~[UUU]~ );		// Order Sequence	
		MacroText( AddString,~[SSS]~ );		// OrderItem Sequence	
		MacroText( AddString,~[QQQ]~ );		// OrderItem Quantity			(Zero Filled)
		MacroText( AddString,~[JJJ]~ );		// Job Quantity					(Zero Filled)
		MacroText( AddString,~[###]~ );		// Total Quantity				(Zero Filled)
		MacroText( AddString,~[B]~ );		// BatchID
		MacroText( AddString,~[P]~ );		// Product Code	
		MacroText( AddString,~[G]~ );		// Page Number	
		MacroText( AddString,~[WWW]~ );		// Width of the background		(Zero Filled)
		MacroText( AddString,~[HHH]~ );		// Height of the background		(Zero Filled)
		MacroText( AddString,~[-]~ );		// BatchID OrderID OrderItemID Page
}


VOID	Wiz::DefineDictionary()
{
	Dictionary: ~<Dictionary>~ 
		Fields: Name Function			type text	// All
		Fields: Name FunctionDescription type text	

		Fields: Name PrinterModel		type text	// Printer and QueueDefinition
		Fields: Name PrinterName		type text	// Printer
		Fields: Name QueueName			type text	// Printer and QueueDefinition
		Fields: Name RunAttended		type long	// Printer
		Fields: Name ForeignDevice		type long	// Printer Used for AutoStart
		Fields: Name RollToRoll			type long	// Printer

		// Printer Balance Fields
		Fields:	Name Brt				type long	// Printer and QueueDefinition		
		Fields:	Name Red				type long	// Printer and QueueDefinition	
		Fields:	Name Grn				type long	// Printer and QueueDefinition	
		Fields:	Name Blu				type long	// Printer and QueueDefinition	
		Fields:	Name Con				type long	// Printer and QueueDefinition	
		Fields:	Name Gam				type double	// Printer and QueueDefinition		
		Fields:	Name Sat				type long	// Printer and QueueDefinition	

		// Location Fields
		Fields: Name Domain				type text	// Not stored in the database.  Used in the UI
		Fields: Name ComputerName		type text	// Printer	
		Fields: Name ProgramPath		type text	// Printer

		// Printer Capability Fields
		Fields: Name MaxPaperWidth		type double	// Printer
		Fields: Name MaxPaperAdvance	type double	// Printer
		Fields: Name BackPrinter		type long	// Printer
		Fields: Name OrderPunch			type long	// Printer

		// Color Management Fields
		Fields: Name ICCProfile			type text	// QueueDefinition	
		Fields: Name Gamma				type text	// QueueDefinition	
		Fields: Name PaperPack			type text	// QueueDefinition	
		Fields: Name CalibrationLUT		type text	// QueueDefinition	

		// Paper Fields
		Fields: Name PaperType			type text	// QueueDefinition
		Fields: Name PaperSurface		type text	// QueueDefinition
		Fields: Name PaperOpacity		type text	// QueueDefinition
	
		Fields: Name PackageCut			type long	// QueueDefinition
		Fields: Name PaperWidth			type double	// QueueDefinition
		Fields: Name PaperAdvance		type double	// QueueDefinition
		Fields: Name Resolution			type double	// QueueDefinition

		// Paper Fill Fields
		Fields: Name PaperFill			type long	// Queue
		Fields: Name BreakOnNewImage	type long	// Queue	
		Fields: Name SpillOverType		type long	// Queue
		Fields: Name SpillOverAmt		type double	// Queue
		Fields: Name SpillOverUOM		type text	// Not in any table.  Just used on the UI
		
		// Output Fields
		Fields: Name OutputFileType		type long	// Printer
		Fields: Name OutputPath			type text	// Printer
		Fields: Name OutputMacroName	type text	// Not in any table.  Just used on the UI
		Fields: Name OutputMacroCall	type text	// Not in any table.  Just used on the UI
		Fields: Name OutputMacroDef		type text	// Not in any table.  Just used on the UI

		// Scripting Hooks
		Fields: Name StartUpScript		type text	// Printer
		Fields: Name HFExePath			type text	// Printer
		Fields: Name StartPrinting		type text	// Printer and QueueDefinition
		Fields: Name OnPrintComplete	type text	// Printer and QueueDefinition
		Fields: Name OnOrderComplete	type text	// Printer and QueueDefinition
		Fields: Name ControlFolder		type text	// Printer and QueueDefinition
		Fields: Name ResponseScript		type text	// Printer
		Fields: Name ResponseFolder		type text	// Printer
		Fields: Name ShutDownScript		type text	// Printer		
		
		// Physical Device Addresses
		Fields:	Name SCSIHostAdapter		type long	// Printer	
		Fields:	Name SCSIHostBus			type long	// Printer
		Fields:	Name SCSIID					type long	// Printer
		Fields:	Name SCSILUN				type long	// Printer
		Fields:	Name PrinterBuffers			type long	// Printer
		Fields: Name LogFile				type text	// Printer Mode's log file
		Fields: Name NetworkAddress			type text	// Printer

		// Various Overrides
		Fields: Name UseOverrides			type long	// QueueDefinition	
		Fields: Name QualityOR				type double	// QueueDefinition
		Fields:	Name DeltaRotation			type long	// QueueDefinition	
		Fields:	Name DeltaSharpen			type long	// QueueDefinition
		Fields:	Name PaperSurfaceOR			type text	// QueueDefinition
		Fields:	Name PaperWidthOR			type double	// QueueDefinition
		Fields: Name PrinterResizeOR		type long	// QueueDefinition
		Fields:	Name ResolutionOR			type long	// QueueDefinition

		// Proposed additions for Job Queue Mgmt
		Fields:	Name AvgProductLength		type double	// QueueDefinition
		Fields:	Name AvgPrintSpeed			type long	// QueueDefinition


}

VOID	Wiz::Disk_Initialize()				// Set dialog data to the defaults for the device
{
	DlgData( SetValues,ForeignDevice,TRUE );
}

VOID	Wiz::NTPrinter_Initialize()			// Set dialog data to the defaults for the device
{
}

VOID	Wiz::KodakLED_Initialize()			// Set dialog data to the defaults for the device
{
}

VOID	Wiz::KodakRP50_Initialize()			// Set dialog data to the defaults for the device
{
	KodakLED_Initialize();					// Same device as the LED printer
}

VOID	Wiz::KodakRR30_Initialize()			// Set dialog data to the defaults for the device
{
	DlgData( SetValues,RollToRoll,TRUE );
}

VOID	Wiz::KodakRP30_Initialize()			// Set dialog data to the defaults for the device
{
}

VOID	Wiz::KodakSRP30_Initialize()		// Set dialog data to the defaults for the device
{
}

VOID	Wiz::KodakCRT_Initialize()			// Set dialog data to the defaults for the device
{
}

VOID	Wiz::KPDM_Initialize()				// Set dialog data to the defaults for the device
{
}

VOID	Wiz::KPDMII_Initialize()			// Set dialog data to the defaults for the device
{
}

VOID	Wiz::KodakLFCRT_Initialize()		// Set dialog data to the defaults for the device
{
}

//----------------------------------------------------------------------------------

VOID	Wiz::DefineControls()			// Initial Screen
{
	DefineControl(Welcome,StaticText);
		Fields:	POSITION			<PromptPosition>
				FontWeight			600
				TEXT				Translate( Translations,InitialPrompt )

	DefineNextButton(TRUE);	
}

VOID	Wiz::DefinePrompt( ThePrompt )	// Initial Prompt on each Screen
{
	DefineControl(Prompt,StaticText);
		Fields:	POSITION			<PromptPosition>
				FONTWEIGHT			600
				TEXTCOLORRED		50 TEXTCOLORGREEN 50 TEXTCOLORBLUE 150
				TEXT				~<ThePrompt>~;

	PassBack(Prompt);
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_Menu()			// Controls to select the function you wish to perform
{ 
	DefinePrompt( Translate(Translations,MenuPrompt) );

	DefineControl(FunctionListBox,ListBox,Field,Function);
		Fields:	POSITION			<FirstControlPosition>,<DialogWidth>-$hGap*3,250
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnFunctionSelection() )
				FONTSIZE			18
				FONTWEIGHT			600
				TOOLTIP				Translate( Translations,MenuPrompt );

	DefineControl(DescriptionBox,StaticText,Field,FunctionDescription);
			Fields:	POSITION			$hgap,FunctionListBox(GetBottom,Position),<DialogWidth>-$hGap*3,130;

	DefineNextButton();
		Fields:	TypeName	DefaultButton;
}


VOID	Wiz::OnFunctionSelection()
{ 
	Selection = dlg( ListBox,FunctionListBox,GetSelectedIndex );

	SelectionString = ~MenuDescription<Selection>~;

	dlg( EnableControls,!IsNULLOrWhite( Translate(Translations,~<SelectionString>~) ),NextButton);

	dlg( SetStrings,FunctionDescription,Translate( Translations,~<SelectionString>~ ) );
}


VOID Wiz::AttributesFor_Menu()	{ fCurrentTitle = ~<Title>~; }		


NUMERIC Wiz::OnNext_Menu()		
{ 
	Selection = dlg( ListBox,FunctionListBox,GetSelectedIndex );

	SelectionString = ~MenuTitle<Selection>~;

	fCurrentTitle = Translate(Translations,~<SelectionString>~);

	ReturnOnSuccess( IsNULLOrWhite( Translate(Translations,~<SelectionString>~) ) );

	ReturnOnSuccess( ChangeStreams(~<Menu<++Selection>>~) );	// Switching streams?

	if ( Defined( ~<Menu<Selection>>1~ ) )
	{
		SetStream( ~<Menu<Selection>>~ );
		SetCurrentPage(1);
		return TRUE;
	}

	return Warning( ~That function has not been defined yet~ );
}

VOID	Wiz::Refresh_Menu()
{ 
	dlg( ListBox,FunctionListBox,ResetContent );

	item = -1;

	while ( Translations(GetByName,MenuTitle<++item>,container) )
	{
		dlg( ListBox,FunctionListBox,AddString,Translate(Translations,MenuTitle<item>) );
	}

	dlg( ListBox,FunctionListBox,Select,0 );
	dlg( SetControlFocus,FunctionListBox );

	OnFunctionSelection();
}

//----------------------------------------------------------------------------------
VOID	Wiz::Controls_Models()			// Controls to select from a list of Models
{ 
	DefinePrompt( Translate(Translations,SelectModel) );

	DefineControl(ModelListBox,ListBox,Field,PrinterModel);
		Fields:	POSITION			<FirstControlPosition>,200,250
				TOOLTIP				Translate( Translations,SelectModel )
				SORTED				TRUE;

	DefineNextPreviousButtons(TRUE);
}

VOID Wiz::ResetDialogValues()
{
	Function = ~<$con.DlgData[Function]>~;
	PrinterModel = ~<$con.DlgData[PrinterModel]>~;

	DlgData( Reset );	// Clears everything to NULL

	DlgData( SetValues,Function,~<Function>~,PrinterModel,~<PrinterModel>~ );
}

NUMERIC Wiz::OnNext_Models()
{ 
	ReturnOnFailure( AuditForNull(PrinterModel,Translate(~You must select a printer model before you can proceed~) ) );

	ResetDialogValues();

	InitializationMethod = ~<$con.DlgData[PrinterModel].NoSpaces>_Initialize~;

	if ( MethodDefined( ~<InitializationMethod>~ ) )
	{
		<InitializationMethod>();
	}
	
	if ( Defined( ~<fStream><$con.DlgData[PrinterModel].NoSpaces>0~ ) )
	{
		SetStream( ~<fStream><$con.DlgData[PrinterModel].NoSpaces>~ );
		SetCurrentPage(1);
	}
	else
	{
		ShowNextPage();
	}

	return TRUE;
}

VOID	Wiz::Refresh_Models()		{ RefreshPrinterModels(); }		// Load the Models List Box

VOID  Wiz::RefreshPrinterModels()
{
	dlg( ListBox,ModelListBox,ResetContent );

	Query = ~Select Model From PrinterModels~;

	if ( PGenConList( List,Connect,Cursor,Static,Query,~<Query>~ ) )
	{
		dlg( ListBox,ModelListBox,AddStringsFromPGenConList,List,Model );
	}

	dlg( ListBox,ModelListBox,Select,0 );

	if ( !IsNull(~<$con.DlgData[PrinterModel]>~) )	
	{ 
		dlg( ListBox,ModelListBox,SelectString,0,~<$con.DlgData[PrinterModel]>~ );
	}

	dlg( SetControlFocus,ModelListBox );
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_Name()			// Controls to select a Printer Name
{ 
	DefinePrompt( Translate(Translations,SelectExistingName) );

	DefineControl(NameListBox,ListBox,Field,PrinterName);
		Fields:	POSITION			<FirstControlPosition>,200,250
				DACTIONSTEXT		ACTIONS ( Update(PrinterNameField) )
				TOOLTIP				Translate( Translations,SelectExistingName )
				SORTED				TRUE;

	DefineControl(PrinterNamePrompt,StaticText);
		Fields:	POSITION			NameListBox(GetLeft,Position),NameListBox(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( Translations,OrNewName );

	DefineControl(PrinterNameField,MaskedEditText,FieldMask,PrinterName,Field,PrinterName);
		Fields:	POSITION			PrinterNamePrompt(GetLeft,Position),PrinterNamePrompt(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>
				TOOLTIP				Translate( Translations,SelectNameTooltip );

	DefineNextPreviousButtons();	
} 

NUMERIC Wiz::OnNext_Name()			
{ 
	ReturnOnFailure( AuditForNull(PrinterName,Translate(~You must select a printer name before you can proceed~) ) );

	if ( PGenconList( List,Connect,GetExistingRecordFor,~Select * From Printers Where PrinterName = '<$con.DlgData[PrinterName]>'~,Record ) )
	{
		if ( !Record( UpdateIn,DlgData ) )
		{
			return Warning( Translate( ~Failed to update the dialog for Printer <$con.DlgData[PrinterName]>~ ) );
		}
	}

	return ShowNextPage();
}


VOID	Wiz::Refresh_Name()			{ RefreshPrinterNames(); }	// Refresh the Printer Names List Box

VOID	Wiz::RefreshPrinterNames()
{
	dlg( ListBox,NameListBox,ResetContent );

	Query = ~Select PrinterName From Printers Where PrinterModel = '<$con.DlgData[PrinterModel]>'~;

	if ( PGenConList( List,Connect,Cursor,Static,Query,~<Query>~ ) )
	{
		dlg( ListBox,NameListBox,AddStringsFromPGenConList,List,PrinterName );
	}

	dlg( ListBox,NameListBox,Select,0 );

	if ( !IsNull(~<$con.DlgData[PrinterName]>~) )	
	{ 
		dlg( ListBox,NameListBox,SelectString,0,~<$con.DlgData[PrinterName]>~ );
	}

	dlg( SetControlFocus,NameListBox );

	dlg( TriggerControlActions,NameListBox,DActionsText );
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_Queues()		// Queues
{ 
	DefinePrompt( Translate( Translations,QueuePrompt ) );

	DefineControl(QueueListBox,ListBox,Field,QueueName);
		Fields:	POSITION			<FirstControlPosition>,<DialogWidth>-$hGap*3,250
				DACTIONSTEXT		ACTIONS ( Update(QueueNameField) )
				TOOLTIP				Translate( ~Select the queue you wish to change by selecting from the list below~ )
				SORTED				TRUE;

	DefineControl(QueueNamePrompt,StaticText);
		Fields:	POSITION			QueueListBox(GetLeft,Position),QueueListBox(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( ~Or enter the name of a new queue below~ );

	DefineControl(QueueNameField,MaskedEditText,FieldMask,QueueName,Field,QueueName);
		Fields:	POSITION			QueueNamePrompt(GetLeft,Position),QueueNamePrompt(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3,<ButtonHeight>
				TOOLTIP				Translate( ~Select the name of a queue for the printer~ );

	DefineNextPreviousButtons();	
} 

NUMERIC	Wiz::OnNext_Queues()
{
	ReturnOnFailure( AuditForNull(QueueName,Translate(~You must select a queue name before you can proceed~) ) );

	// Do we need to define the queue here? 

	return ShowNextPage();
}

VOID	Wiz::Refresh_Queues()		{ RefreshQueueNames(); }

VOID	Wiz::RefreshQueueNames()
{
	dlg( ListBox,QueueListBox,ResetContent );

	Query = ~Select QueueName From QueueDefinition Where PrinterModel = '<$con.DlgData[PrinterModel]>'~;

	if ( PGenConList( List,Connect,Cursor,Static,Query,~<Query>~ ) )
	{
		dlg( ListBox,QueueListBox,AddStringsFromPGenConList,List,QueueName );
	}

	if ( !IsNull(~<$con.DlgData[QueueName]>~) )	
	{ 
		dlg( ListBox,QueueListBox,SelectString,0,~<$con.DlgData[QueueName]>~ );
	}

	dlg( SetControlFocus,QueueNameField );
}


//----------------------------------------------------------------------------------

VOID	Wiz::Controls_PrintersQueue()		// Queue that a printer should watch
{ 
	DefinePrompt( Translate( Translations,PrintersQueuePrompt ) );

	DefineControl(QueueListBox,ListBox,Field,QueueName);
		Fields:	POSITION			<FirstControlPosition>,<DialogWidth>-$hGap*3,250
				DACTIONSTEXT		ACTIONS ( Update(QueueNameField) )
				TOOLTIP				Translate( ~Select the queue you wish to change by selecting from the list below~ )
				SORTED				TRUE;

	DefineControl(QueueNamePrompt,StaticText);
		Fields:	POSITION			QueueListBox(GetLeft,Position),QueueListBox(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( ~Or enter the name of a new queue below~ );

	DefineControl(QueueNameField,MaskedEditText,FieldMask,QueueName,Field,QueueName);
		Fields:	POSITION			QueueNamePrompt(GetLeft,Position),QueueNamePrompt(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3,<ButtonHeight>
				TOOLTIP				Translate( ~Enter the name of the queue you wish to create or change~ );

	DefineNextPreviousButtons();	
} 

NUMERIC	Wiz::OnNext_PrintersQueue()
{
	ReturnOnFailure( AuditForNull(QueueName,Translate(~You must select a queue name before you can proceed~) ) );

	// Do we need to define the queue here? 

	return ShowNextPage();
}

VOID	Wiz::Refresh_PrintersQueue()		{ RefreshQueueNames(); }


//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_AutoStart()		// AutoStart Check Box
{ 
	DefinePrompt( Translate( Translations,AutoStartPrompt ) );

	DefineControl(ComputerNameListBox,ListBox,Field,ComputerName);
		Fields:	POSITION			<FirstControlPosition>,<DialogWidth>-$hGap*3,150
				DACTIONSTEXT		ACTIONS ( Update(ComputerNameField) )
				SORTED				TRUE;

	DefineControl(ComputerNamePrompt,StaticText);
		Fields:	POSITION			ComputerNameListBox(GetLeft,Position),ComputerNameListBox(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( ~Or enter the computer name here~ );

	DefineControl(ComputerNameField,MaskedEditText,FieldNask,ComputerName,Field,ComputerName);
		Fields:	POSITION			ComputerNamePrompt(GetLeft,Position),ComputerNamePrompt(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3,<ButtonHeight>
				TOOLTIP				Translate( ~Select the computer that will control the printer~ );

	DefineControl(AutoStartDescription,StaticText);
		Fields:	POSITION			ComputerNameField(GetLeft,Position),ComputerNameField(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( Translations,AutoStartControl )

	DefineControl(AutoStartBox,CheckBox,Field,ForeignDevice);
		Fields:	POSITION			AutoStartDescription(GetLeft,Position),AutoStartDescription(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( Translations,AutoStartControl )
			
	DefineNextPreviousButtons();	
} 

NUMERIC	Wiz::OnNext_AutoStart()		
{
	ReturnOnFailure( AuditForNull(ComputerName,Translate(~You must select a workstation before you can proceed~) ) );

	return ShowNextPage();
}

VOID	Wiz::Refresh_AutoStart()		
{
	if ( !MemberDefined( fServerList ) )
	{
		WaitCursor( Begin );

		dlg( SetStatus,0,~Searching for workstations~ );

		if ( !MakeServersList( fServerList,Type,Workstation,Type,Workstation,Domain,~<$con.DlgData[Domain]>~ ) )
		{
			dlg( SetStatus,0,~Search failed~ );
			WaitCursor( End );
			return FALSE;
		}

		dlg( SetStatus,0,~~ );

		Private( fServerList );
		WaitCursor( End );
	}

	dlg( ListBox,ComputerNameListBox,ResetContent );
	dlg( ListBox,ComputerNameListBox,AddStringsFromStringList,fServerList );
	if ( !IsNull(~<$con.DlgData[ComputerName]>~) )
	{
		dlg( ListBox,ComputerNameListBox,SelectString,0,~<$con.DlgData[ComputerName]>~ );
	}

	dlg( SetControlFocus,AutoStartBox );
}

//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_BackPrint()		// BackPrint Check Box
{ 
	DefinePrompt( Translate( Translations,BackPrintPrompt ) );

	DefineControl(BackPrintBox,CheckBox,Field,BackPrinter);
		Fields:	POSITION			<FirstControlPosition>,150,<ButtonHeight>
				TEXT				Translate( Translations,BackPrintControl );

	DefineNextPreviousButtons();	
} 

//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_OrderPunch()		// OrderPunch Check Box
{ 
	DefinePrompt( Translate( Translations,OrderPunchPrompt ) );

	DefineControl(OrderPunchBox,CheckBox,Field,OrderPunch);
		Fields:	POSITION			<FirstControlPosition>,150,<ButtonHeight>
				TEXT				Translate( Translations,OrderPunchControl );

	DefineNextPreviousButtons();	
} 

//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_RollToRoll()		// Is it a Roll to Roll device
{ 
	DefinePrompt( Translate( Translations,RollToRollPrompt ) );

	DefineControl(RollToRollBox,CheckBox,Field,RollToRoll);
		Fields:	POSITION			<FirstControlPosition>,150,<ButtonHeight>
				TEXT				Translate( Translations,RollToRollBoxPrompt );

	DefineNextPreviousButtons();	
} 


//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_RunAttended()		// Popup dialogs when there is a problem rendering?
{ 
	DefinePrompt( Translate( Translations,RunAttendedPrompt ) );

	DefineControl(RunAttendedBox,CheckBox,Field,RunAttended);
		Fields:	POSITION			<FirstControlPosition>,150,<ButtonHeight>
				TEXT				Translate( Translations,RunAttendedBoxPrompt );

	DefineNextPreviousButtons();	
} 

//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_PrinterBalance()		// Balance Offsets for the Printer
{ 
	ChangeBalance( Translate( Translations,PrinterBalancePrompt,~<$Con.DlgData[PrinterName]>~ ) );
}

VOID	Wiz::Controls_QueueBalance()		// Balance Offsets for the Printer Queue
{ 
	ChangeBalance( Translate( Translations,QueueBalancePrompt,~<$Con.DlgData[QueueName]>~ ) );
}

VOID	Wiz::ChangeBalance( Prompt )		// Balance Offsets for the Printer or the Queue
{ 
	DefinePrompt( ~<Prompt>~ );

	DefineControl(PrinterBrtPrompt,StaticText);
		Fields:	POSITION			<FirstControlPosition>,120.<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Brightness~ );

	DefineControl(PrinterBrtField,MaskedEditText,FieldMask,ColorOffset,Field,Brt);
		Fields:	POSITION			PrinterBrtPrompt(GetRight,Position)+$hGap,PrinterBrtPrompt(GetTop,Position),50,<ButtonHeight>
				TOOLTIP				Translate( ~Select a balance offset for Brightness~ );

	DefineControl(PrinterRedPrompt,StaticText);
		Fields:	POSITION			PrinterBrtPrompt(GetLeft,Position),PrinterBrtPrompt(GetBottom,Position)+$vGap,PrinterBrtPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Red~ );

	DefineControl(PrinterRedField,MaskedEditText,FieldMask,ColorOffset,Field,Red);
		Fields:	POSITION			PrinterRedPrompt(GetRight,Position)+$hGap,PrinterRedPrompt(GetTop,Position),PrinterBrtField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select a balance offset for Red~ );
	
	DefineControl(PrinterGrnPrompt,StaticText);
		Fields:	POSITION			PrinterRedPrompt(GetLeft,Position),PrinterRedPrompt(GetBottom,Position)+$vGap,PrinterBrtPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Green~ );

	DefineControl(PrinterGrnField,MaskedEditText,FieldMask,ColorOffset,Field,Grn);
		Fields:	POSITION			PrinterRedPrompt(GetRight,Position)+$hGap,PrinterGrnPrompt(GetTop,Position),PrinterBrtField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select a balance offset for Green~ );

	DefineControl(PrinterBluPrompt,StaticText);
		Fields:	POSITION			PrinterGrnPrompt(GetLeft,Position),PrinterGrnPrompt(GetBottom,Position)+$vGap,PrinterBrtPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Blue~ );

	DefineControl(PrinterBluField,MaskedEditText,FieldMask,ColorOffset,Field,Blu);
		Fields:	POSITION			PrinterBluPrompt(GetRight,Position)+$hGap,PrinterBluPrompt(GetTop,Position),PrinterBrtField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select a balance offset for Blue~ );

	DefineControl(PrinterGamPrompt,StaticText);
		Fields:	POSITION			PrinterBluPrompt(GetLeft,Position),PrinterBluPrompt(GetBottom,Position)+$vGap,PrinterBrtPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Gamma~ );

	DefineControl(PrinterGamField,MaskedEditText,FieldMask,Gamma,Field,Gam);
		Fields:	POSITION			PrinterGamPrompt(GetRight,Position)+$hGap,PrinterGamPrompt(GetTop,Position),PrinterBrtField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select a balance offset for Gamma~ );

	DefineControl(PrinterSatPrompt,StaticText);
		Fields:	POSITION			PrinterGamPrompt(GetLeft,Position),PrinterGamPrompt(GetBottom,Position)+$vGap,PrinterBrtPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Saturation~ );

	DefineControl(PrinterSatField,MaskedEditText,FieldMask,Saturation,Field,Sat);
		Fields:	POSITION			PrinterSatPrompt(GetRight,Position)+$hGap,PrinterSatPrompt(GetTop,Position),PrinterBrtField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select a balance offset for Saturation~ );

	DefineNextPreviousButtons();	
} 
	
//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_Device()		// Physical device addressing information
{ 
	DefinePrompt( Translate( Translations,DevicePrompt ) );

	DefineControl(SCSIHostAdapterPrompt,StaticText);
		Fields:	POSITION			<FirstControlPosition>,120,<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~SCSIHostAdapter~ );

	DefineControl(SCSIHostAdapterField,MaskedEditText,FieldMask,SCSIAddress,Field,SCSIHostAdapter);
		Fields:	POSITION			SCSIHostAdapterPrompt(GetRight,Position)+$hGap,SCSIHostAdapterPrompt(GetTop,Position),50,<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TOOLTIP				Translate( ~Select the SCSIHostAdapter for the printer~ );

	DefineControl(SCSIHostBusPrompt,StaticText);
		Fields:	POSITION			SCSIHostAdapterPrompt(GetLeft,Position),SCSIHostAdapterPrompt(GetBottom,Position)+$vGap,SCSIHostAdapterPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~SCSI Host Bus~ );

	DefineControl(SCSIHostBusField,MaskedEditText,FieldMask,SCSIAddress,Field,SCSIHostBus);
		Fields:	POSITION			SCSIHostBusPrompt(GetRight,Position)+$hGap,SCSIHostBusPrompt(GetTop,Position),SCSIHostAdapterField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select the SCSI Host Bus for the printer~ );
		
	DefineControl(SCSIIDPrompt,StaticText);
		Fields:	POSITION			SCSIHostBusPrompt(GetLeft,Position),SCSIHostBusPrompt(GetBottom,Position)+$vGap,SCSIHostAdapterPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~SCSI ID~ );

	DefineControl(SCSIIDField,MaskedEditText,FieldMask,SCSIAddress,Field,SCSIID);
		Fields:	POSITION			SCSIIDPrompt(GetRight,Position)+$hGap,SCSIIDPrompt(GetTop,Position),SCSIHostAdapterField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select the SCSI ID for the printer~ );

	DefineControl(SCSILUNPrompt,StaticText);
		Fields:	POSITION			SCSIIDPrompt(GetLeft,Position),SCSIIDPrompt(GetBottom,Position)+$vGap,SCSIHostAdapterPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~SCSI LUN~ );

	DefineControl(SCSILUNField,MaskedEditText,FieldMask,SCSIAddress,Field,SCSILUN);
		Fields:	POSITION			SCSILUNPrompt(GetRight,Position)+$hGap,SCSILUNPrompt(GetTop,Position),SCSIHostAdapterField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select the SCSI LUN for the printer~ );

	DefineControl(PrinterBuffersPrompt,StaticText);
		Fields:	POSITION			SCSILUNPrompt(GetLeft,Position),SCSILUNPrompt(GetBottom,Position)+$vGap,SCSIHostAdapterPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Printer Buffers~ );

	DefineControl(PrinterBuffersField,MaskedEditText,FieldMask,SCSIAddress,Field,PrinterBuffers);
		Fields:	POSITION			PrinterBuffersPrompt(GetRight,Position)+$hGap,PrinterBuffersPrompt(GetTop,Position),SCSIHostAdapterField(GetWidth,Position),<ButtonHeight>
				TOOLTIP				Translate( ~Select # of buffers for the printer~ );

	DefineNextPreviousButtons();	
} 

//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_NetworkAddress()		// Physical device addressing information for network devices
{ 
	DefinePrompt( Translate( Translations,NetworkAddressPrompt ) );

	DefineControl(NetworkAddressPrompt,StaticText);
		Fields:	POSITION			<FirstControlPosition>,90.<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( ~Network Printer~ );

	DefineControl(NetworkAddressListBox,ListBox,Field,NetworkAddress);
		Fields:	POSITION			NetworkAddressPrompt(GetLeft,Position),NetworkAddressPrompt(Getbottom,Position),300,<ButtonHeight>*10
				//DACTIONSTEXT		ACTIONS ( Update(ComputerNameField) )
				//SORTED				TRUE;
				TOOLTIP				Translate( ~Select the NetworkAddress for the printer~ );

	DefineNextPreviousButtons();	
}

VOID	Wiz::Refresh_NetworkAddress()
{
	WinPrinter( Printer,New );

	Printer( GetPrinterNameList,ListOfPrinters );

	dlg( ListBox,NetworkAddressListBox,ResetContent );
	dlg( ListBox,NetworkAddressListBox,AddStringsFromStringList,ListOfPrinters );

	if ( !IsNull(~<$con.DlgData[NetworkAddress]>~) )
	{
		dlg( ListBox,NetworkAddressListBox,SelectString,0,~<$con.DlgData[NetworkAddress]>~ );
	}

	dlg( SetControlFocus,NetworkAddressListBox );
}

//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_PaperSize()		// Print size limits
{ 
	DefinePrompt( Translate( Translations,PaperSizePrompt,~<$con.DlgData[PrinterName]>~ ) );

	DefineControl(PaperWidthPrompt,StaticText);
		Fields:	POSITION			<FirstControlPosition>,120.<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( Translations,PaperWidthPrompt );
	DefineControl(PaperWidthField,MaskedEditText,FieldMask,PaperWidth,Field,MaxPaperWidth);
		Fields:	POSITION			PaperWidthPrompt(GetRight,Position)+$hGap,PaperWidthPrompt(GetTop,Position),100,<ButtonHeight>
				TOOLTIP				Translate( ~Select the maximum width in inches the printer is capabile of printing~ );

	DefineControl(PaperAdvancePrompt,StaticText);
		Fields:	POSITION			PaperWidthPrompt(GetLeft,Position),PaperWidthPrompt(GetBottom,Position)+$vGap,PaperWidthPrompt(GetWidth,Position),<ButtonHeight>
				RIGHTJUSTIFIED		TRUE
				TEXT				Translate( Translations,PaperAdvancePrompt );

	DefineControl(PaperHeightField,MaskedEditText,FieldMask,PaperWidth,Field,MaxPaperAdvance);
		Fields:	POSITION			PaperAdvancePrompt(GetRight,Position)+$hGap,PaperAdvancePrompt(GetTop,Position),100,<ButtonHeight>
				TOOLTIP				Translate( ~Select the maximum advance in inches the printer is capabile of printing~ );

	DefineNextPreviousButtons();	
}

NUMERIC Wiz::OnNext_PaperSize()
{
	ReturnOnFailure( AuditForZero(MaxPaperWidth,Translate(~You must select a maximum printer width before you can proceed~) ) );
	ReturnOnFailure( AuditForZero(MaxPaperAdvance,Translate(~You must select a maximum printer advance before you can proceed~) ) );
	
	return ShowNextPage();
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_LogFile()		// Printer Log File
{ 
	DefinePrompt( Translate( Translations,LogFilePrompt ) );

	DefineControl(LogFileField,MaskedEditText,FieldMask,FilePath,Field,LogFile);
		Fields:	POSITION			<FirstControlPosition>,300,<ButtonHeight>
				TOOLTIP				Translate( ~Find the log file~ );

	DefineControl(LogFileBrowse,Button);
		Fields:	POSITION			LogFileField(GetRight,Position)+$hGap,LogFileField(GetTop,Position),20,<ButtonHeight>
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnLogFileBrowse() )
				TOOLTIP				Translate( ~Find the log file~ )
				TEXT				Translate( ~?~ );

	DefineNextPreviousButtons();	
}

VOID	Wiz::OnLogFileBrowse()	
{
}


//----------------------------------------------------------------------------------

VOID	Wiz::Controls_PaperPack()		// Paper Pack File
{ 
	DefinePrompt( Translate( Translations,PaperPackPrompt ) );

	DefineControl(PaperPackField,MaskedEditText,FieldMask,FilePath,Field,PaperPack);
		Fields:	POSITION			<FirstControlPosition>,300,<ButtonHeight>
				TOOLTIP				Translate( Translations,PaperPackPrompt );

	DefineControl(PaperPackBrowse,Button);
		Fields:	POSITION			PaperPackField(GetRight,Position)+$hGap,PaperPackField(GetTop,Position),20,<ButtonHeight>
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnPaperPackBrowse() )
				TOOLTIP				Translate( Translations,PaperPackBrowse )
				TEXT				Translate( Translations,QuestionMark );

	DefineNextPreviousButtons();	
}

VOID	Wiz::OnPaperPackBrowse()	
{
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_CalibrationLut()		// Calibration Lut File
{ 
	DefinePrompt( Translate( Translations,CalibrationLutPrompt ) );

	DefineControl(CalibrationLutField,MaskedEditText,FieldMask,FilePath,Field,CalibrationLut);
		Fields:	POSITION			<FirstControlPosition>,300,<ButtonHeight>
				TOOLTIP				Translate( Translations,CalibrationLutPrompt );

	DefineControl(CalibrationLutBrowse,Button);
		Fields:	POSITION			CalibrationLutField(GetRight,Position)+$hGap,CalibrationLutField(GetTop,Position),20,<ButtonHeight>
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnCalibrationLutBrowse() )
				TOOLTIP				Translate( Translations,CalibrationLutBrowse )
				TEXT				Translate( Translations,QuestionMark );

	DefineNextPreviousButtons();	
}

VOID	Wiz::OnCalibrationLutBrowse()	
{
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_Scripts()		// Various Script Hooks  excluding printing
{ 
	enum( StartupScripts,1,StartUpScript,HFExePath,ShutDownScript );
	
	DefinePrompt( Translate( Translations,ScriptsDescription ) );

	YPos = Prompt(GetBottom,Position)+$vGap;

	Index = 0;

	while ( Defined( StartupScripts<++Index> ) )
	{
		Section = ~<StartupScripts<Index>>~;

		DefineControl(<Section>Prompt,StaticText);
			Fields:	POSITION			$hGap,$YPos,<DialogWidth>-$hGap*3,<ButtonHeight>
					TEXT				Translate( Translations,~<Section>Prompt~ );

		DefineControl(<Section>Field,MaskedEditText,FieldMask,FilePath,Field,<Section>);
			Fields:	POSITION			<fLastControl>(GetLeft,Position),<fLastControl>(GetBottom,Position)-7,<fLastControl>(GetWidth,Position) - 30,<ButtonHeight>
					TOOLTIP				Translate( Translations,ScriptBrowseToolTip );

		DefineControl(<Section>Browse,Button);
			Fields:	POSITION			<fLastControl>(GetRight,Position)+$hGap,<fLastControl>(GetTop,Position),20,<ButtonHeight>
					DACTIONSTEXT		ACTION EXEC ( <THIS>.OnScriptFileBrowse(<Section>) )
					TOOLTIP				Translate( Translations,ScriptFieldToolTip )
					TEXT				Translate( Translations,~QuestionMark~ );

		YPos += 42;
	}

	DefineNextPreviousButtons();	
}

//----------------------------------------------------------------------------------


VOID	Wiz::Controls_PrintScripts()		// Various Script Hooks during printing
{ 
	enum( StartupScripts,1,StartPrinting,OnPrintComplete,OnOrderComplete,ControlFolder );
	
	DefinePrompt( Translate( Translations,PrintScriptsDescription ) );

	YPos = Prompt(GetBottom,Position)+$vGap;

	Index = 0;

	while ( Defined( StartupScripts<++Index> ) )
	{
		Section = ~<StartupScripts<Index>>~;

		DefineControl(<Section>Prompt,StaticText);
			Fields:	POSITION			$hGap,$YPos,<DialogWidth>-$hGap*3,<ButtonHeight>
					TEXT				Translate( Translations,~<Section>Prompt~ );

		DefineControl(<Section>Field,MaskedEditText,FieldMask,FilePath,Field,<Section>);
			Fields:	POSITION			<fLastControl>(GetLeft,Position),<fLastControl>(GetBottom,Position)-7,<fLastControl>(GetWidth,Position) - 30,<ButtonHeight>
					TOOLTIP				Translate( Translations,ScriptBrowseToolTip );

		DefineControl(<Section>Browse,Button);
			Fields:	POSITION			<fLastControl>(GetRight,Position)+$hGap,<fLastControl>(GetTop,Position),20,<ButtonHeight>
					DACTIONSTEXT		ACTION EXEC ( <THIS>.OnScriptFileBrowse(<Section>) )
					TOOLTIP				Translate( Translations,ScriptFieldToolTip )
					TEXT				Translate( Translations,~QuestionMark~ );

		YPos += 42;
	}

	DefineNextPreviousButtons();	
}

//----------------------------------------------------------------------------------


VOID	Wiz::Controls_ResponseScripts()		// Various Script Hooks during printing
{ 
	enum( StartupScripts,1,ResponseScript,ResponseFolder );
	
	DefinePrompt( Translate( Translations,ResponseScriptsDescription ) );

	YPos = Prompt(GetBottom,Position)+$vGap;

	Index = 0;

	while ( Defined( StartupScripts<++Index> ) )
	{
		Section = ~<StartupScripts<Index>>~;

		DefineControl(<Section>Prompt,StaticText);
			Fields:	POSITION			$hGap,$YPos,<DialogWidth>-$hGap*3,<ButtonHeight>
					TEXT				Translate( Translations,~<Section>Prompt~ );

		DefineControl(<Section>Field,MaskedEditText,FieldMask,FilePath,Field,<Section>);
			Fields:	POSITION			<fLastControl>(GetLeft,Position),<fLastControl>(GetBottom,Position)-7,<fLastControl>(GetWidth,Position) - 30,<ButtonHeight>
					TOOLTIP				Translate( Translations,ScriptBrowseToolTip );

		DefineControl(<Section>Browse,Button);
			Fields:	POSITION			<fLastControl>(GetRight,Position)+$hGap,<fLastControl>(GetTop,Position),20,<ButtonHeight>
					DACTIONSTEXT		ACTION EXEC ( <THIS>.OnScriptFileBrowse(<Section>) )
					TOOLTIP				Translate( Translations,ScriptFieldToolTip )
					TEXT				Translate( Translations,~QuestionMark~ );

		YPos += 42;
	}

	DefineNextPreviousButtons();	
}

VOID	Wiz::OnScriptFileBrowse(Section)	
{
	StartingDirectory = ~<$App.ShareDirectory>\Scripts~;

	if ( FileDialog( Title,Translate(Translations,<Section>),DefaultDirectory,~<StartingDirectory>~,
						DefaultFile,Translate(~In this directory~),Path,Path,Save) )

}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_ICCProfile()			// Controls to select an ICC Profile
{ 
	DefinePrompt( Translate(Translations,ICCProfilePrompt) );

	DefineControl(ICCProfileListBox,ListBox,Field,ICCProfile);
		Fields:	POSITION			<FirstControlPosition>,<DialogWidth>-$hGap*3,250
				DACTIONSTEXT		ACTIONS ( Update(ICCProfileField) );

	DefineControl(ICCProfilePrompt,StaticText);
		Fields:	POSITION			ICCProfileListBox(GetLeft,Position),ICCProfileListBox(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( ~Or leave the following blank if you don't wish to use an ICCProfile~ );

	DefineControl(ICCProfileField,MaskedEditText,FieldMask,ICCProfile,Field,ICCProfile);
		Fields:	POSITION			ICCProfilePrompt(GetLeft,Position),ICCProfilePrompt(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3,<ButtonHeight>
				TOOLTIP				Translate( ~Select an ICC profile~ );

	DefineNextPreviousButtons();	
} 

VOID	Wiz::Refresh_ICCProfile()			{ RefreshICCProfiles(); }	// Refresh the ICCProfiles List Box

VOID	Wiz::RefreshICCProfiles()
{
	dlg( ListBox,ICCProfileListBox,ResetContent );

	Query = ~Select Name From Profiles Where Type = 'Output'~;
	
	if ( !SimilarStr( ~<$con.DlgData[PrinterModel]>~,~Disk~ ) )		// Unless it is disk, show only the profiles for the model
	{
		Query = ~<Query> And Device = '<$con.DlgData[PrinterModel]>'~;
	}

	if ( PGenConList( List,Connect,Cursor,Static,Query,~<Query> Order By Device,Type~ ) )
	{
		dlg( ListBox,ICCProfileListBox,AddStringsFromPGenConList,List,Name );
	}

	if ( !IsNull(~<$con.DlgData[ICCProfile]>~) )	
	{ 
		dlg( ListBox,ICCProfileListBox,SelectString,0,~<$con.DlgData[ICCProfile]>~ );
	}

	dlg( SetControlFocus,ICCProfileListBox );
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_OutputPath()			// Controls to select the output path and filetype for the printer
{ 
	DefinePrompt( Translate(Translations,OutputPathDescription) );

	DefineControl(FileTypePrompt,StaticText);
		Fields:	POSITION			<FirstControlPosition>,90,<ButtonHeight>
				TEXT				Translate(Translations,FileTypePrompt);

	DefineControl(FileTypeListBox,ListBox,Field,OutputFileType);
		Fields:	POSITION			FileTypePrompt(GetLeft,Position),FileTypePrompt(GetBottom,Position),FileTypePrompt(GetWidth,Position).<ButtonHeight>*2
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnFileTypeSelection() )

	DefineControl(OutputPathPrompt,StaticText);
		Fields:	POSITION			FileTypeListBox(GetLeft,Position),FileTypeListBox(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>
				TEXT				Translate(Translations,OutputPathPrompt);

	DefineControl(OutputPathField,MaskedEditText,FieldMask,FilePath,Field,OutputPath);
		Fields:	POSITION			OutputPathPrompt(GetLeft,Position),OutputPathPrompt(GetBottom,Position),<DialogWidth>-$hGap*3 - 30,<ButtonHeight> * 3
				TOOLTIP				Translate(Translations,OutputPathTooltip);

	DefineControl(OutputPathBrowse,Button);
		Fields:	POSITION			OutputPathField(GetRight,Position)+$hGap,OutputPathField(GetTop,Position),20,<ButtonHeight>
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnOutputFileBrowse() )
				TOOLTIP				Translate(Translations,OutputPathTooltip)
				TEXT				Translate(Translations,QuestionMark);

	DefineControl(MacrosTitle,StaticText);
		Fields:	POSITION			OutputPathField(GetLeft,Position),OutputPathField(GetBottom,Position)+$vgap*4,<DialogWidth>-$hGap*3-150,<ButtonHeight>
				TEXT				Translate( Translations,MacrosTitle );

	DefineControl(MacrosListBox,ListBox,Field,OutputMacroName);
		Fields:	POSITION			MacrosTitle(GetLeft,Position),MacrosTitle(GetBottom,Position),<DialogWidth>-$hGap*3.<ButtonHeight>*5
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnOutputMacroSelection() )

	DefineControl(UseMacroButton,Button);
		Fields:	POSITION			MacrosListBox(GetLeft,Position),MacrosListBox(GetBottom,Position)+$vGap,160.<ButtonHeight>
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnUseOutputMacro() )
				TEXT				Translate( Translations,UseOutputMacro );

	DefineControl(MacroCallText,StaticText,Field,OutputMacroCall);
		Fields:	POSITION			UseMacroButton(GetRight,Position)+$hGap,UseMacroButton(GetTop,Position)+2,<DialogWidth>-$hGap*3-150,<ButtonHeight>

	DefineControl(MacrosDefinition,StaticText,Field,OutputMacroDef);
		Fields:	POSITION			UseMacroButton(GetLeft,Position),UseMacroButton(GetBottom,Position)+$vgap,<DialogWidth>-$hGap*3-150,<ButtonHeight>*3				

	DefineNextPreviousButtons();	
} 

NUMERIC	Wiz::OnNext_OutputPath()	{ return ShowNextPage(); }	


VOID	Wiz::OnOutputFileBrowse()	
{
}

VOID	Wiz::Refresh_OutputPath()	
{ 
	if ( StringList( FileTypeListList,New,Is,~<$[DATABASE FieldTypes].SaveFileType[ChoiceList]>~ ) )
	{
		dlg( ListBox,FileTypeListBox,AddStringsFromStringList,FileTypeListList );
		dlg( ListBox,FileTypeListBox,Select,~<$con.DlgData[OutputFileType]>~ );
	}

	dlg( ListBox,MacrosListBox,AddStringsFromStringList,MacroNameTranslations );
}

VOID	Wiz::OnFileTypeSelection()
{
	Selection = dlg( ListBox,FileTypeListBox,GetSelectedIndex );
	DlgData( Set,OutputFileType,<Selection> ); 
}


VOID	Wiz::OnOutputMacroSelection()
{
	Selection = dlg( ListBox,MacrosListBox,GetSelectedIndex );

	if ( MacroToolTipTranslations( GetStringAt,<Selection>,ToolTip ) )
	{
		//PopupMsg( ~<ToolTip>~,50,-150,FromCursor );
		dlg( SetStrings,OutputMacroDef,~<ToolTip>~ );
	}

	if ( MacroText( GetStringAt,<Selection>,TheMacroText ) )
	{
		dlg( SetStrings,OutputMacroCall,~<TheMacroText>~ );
	}
}	

VOID	Wiz::OnUseOutputMacro()
{
	Selection = dlg( ListBox,MacrosListBox,GetSelectedIndex );

	if ( MacroText( GetStringAt,<Selection>,TheMacroText ) )
	{
		CopyToClipboard( ~<TheMacroText>~ );
		//dlg( EditText,OutputPathField,PasteAtCursor );	// Don't know why this doesn't work
	}
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_Gamma()			// Controls to select a Gamma Table
{ 
	DefinePrompt( Translate(Translations,GammaPrompt) );

	DefineControl(GammaListBox,ListBox,Field,Gamma);
		Fields:	POSITION			<FirstControlPosition>,<DialogWidth>-$hGap*3,250
				DACTIONSTEXT		ACTIONS ( Update(GammaField) )
				SORTED				TRUE;

	DefineControl(GammaPrompt,StaticText);
		Fields:	POSITION			GammaListBox(GetLeft,Position),GammaListBox(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3.<ButtonHeight>*2
				TEXT				Translate( ~Or leave the following blank if you don't wish to use a Gamma lookup table~ );

	DefineControl(GammaField,MaskedEditText,FieldMask,FilePath,Field,Gamma);
		Fields:	POSITION			GammaPrompt(GetLeft,Position),GammaPrompt(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3,<ButtonHeight>
				TOOLTIP				Translate( ~Enter the path to the Gamma lookup table or leave blank for none~ );

	DefineNextPreviousButtons();	
} 

VOID	Wiz::Refresh_Gamma()			{ RefreshGammasList(); }	// Refresh the Gammas List Box

VOID	Wiz::RefreshGammasList()
{
	dlg( ListBox,GammaListBox,ResetContent );

	RecursiveSearchForGamma( ~<$App.ShareDirectory>\Tables~,~*.*~,dlg );
	
	if ( !IsNull(~<$con.DlgData[Gamma]>~) )	
	{ 
		dlg( ListBox,GammaListBox,SelectString,0,~<$con.DlgData[Gamma]>~ );
	}
}

NUMERIC Wiz::RecursiveSearchForGamma( path,search,&dlg )
{
    MoreFiles = findfile( aDirectoryEntry,Find,~<path>\<search>~ );

    while ( $Morefiles )
    {
        Morefiles = aDirectoryEntry( Next );

        aDirectoryEntry( Get,Path,aPath );
                
        if ( aDirectoryEntry( Dots ) )
                continue;
                
        if ( aDirectoryEntry( Is,aDirectoryEntry(Directory) ) )
        {       
            RecursiveSearchForGamma( ~<aPath>~,~<search>~,dlg );
            continue;
        }

		if ( SimilarStr( ~<$str.$aPath.ext>~,~Gamma~,~Txt~ ) )
		{
			dlg( ListBox,GammaListBox,AddString,~<aPath>~ );
		}
    }

    return TRUE;
}

//----------------------------------------------------------------------------------	

VOID	Wiz::Controls_PaperFill()		// Paper Fill Choices (An index is stored in the database)
{ 
	DefinePrompt( Translate( Translations,PaperFillPrompt ) );

	DefineControl(PaperFillTypePrompt,StaticText);
		Fields:	POSITION			<FirstControlPosition>,150,<ButtonHeight>
				TEXT				~Type Of Spill Over~
				RIGHTJUSTIFIED		TRUE

	DefineControl(PaperFillListBox,ListBox);
		Fields:	POSITION			PaperFillTypePrompt(GetRight,Position)+$hGap,PaperFillTypePrompt(GetTop,Position),150,<ButtonHeight>*3
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnPaperFillSelection() );

	DefineControl(PaperAdvancePrompt,StaticText);
		Fields:	POSITION			PaperFillTypePrompt(GetLeft,Position),PaperFillListBox(GetBottom,Position)+$vGap,150,<ButtonHeight>*3
				TEXT				~Paper Advance~
				RIGHTJUSTIFIED		TRUE

	DefineControl(PaperAdvanceField,MaskedEditText,FieldMask,PaperAdvance,Field,PaperAdvance);
		Fields:	POSITION			PaperAdvancePrompt(GetRight,Position)+$hGap,PaperAdvancePrompt(GetTop,Position),50,<ButtonHeight>
				TOOLTIP				Translate( ~Enter the desired paper advance~ );

	DefineControl(ImageBreakPrompt,StaticText);
		Fields:	POSITION			PaperAdvancePrompt(GetLeft,Position),PaperAdvanceField(GetBottom,Position)+$vGap,150,<ButtonHeight>
				TEXT				~Image Break~
				RIGHTJUSTIFIED		TRUE

	DefineControl(ImageBreakField,CheckBox,Field,BreakOnNewImage);
		Fields:	POSITION			ImageBreakPrompt(GetRight,Position)+$hGap,ImageBreakPrompt(GetTop,Position),50,<ButtonHeight>
				TOOLTIP				Translate( ~Create a new page for every image?~ );

	DefineControl(SpillOverDescription,StaticText);
		Fields:	POSITION			ImageBreakPrompt(GetLeft,Position),ImageBreakField(GetBottom,Position)+$vGap,<DialogWidth>-$hGap*3,<ButtonHeight>
				TEXT				~Spill Over is the amount of exposure that is larger than the paper.  Etc.~

	DefineControl(SpillOverTypePrompt,StaticText);
		Fields:	POSITION			ImageBreakPrompt(GetLeft,Position),SpillOverDescription(GetBottom,Position)+$vGap,150,<ButtonHeight>
				TEXT				~Type Of Spill Over~
				RIGHTJUSTIFIED		TRUE

	DefineControl(SpillOverListBox,ListBox,Field,SpillOverType);
		Fields:	POSITION			SpillOverTypePrompt(GetRight,Position)+$hGap,SpillOverTypePrompt(GetTop,Position),100,<ButtonHeight>*3
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnSpillOverSelection() );

	DefineControl(SpillOverAmountPrompt,StaticText);
		Fields:	POSITION			ImageBreakPrompt(GetLeft,Position),SpillOverListBox(GetBottom,Position)+$vGap,150,<ButtonHeight>
				TEXT				~Spill Over Amount~
				RIGHTJUSTIFIED		TRUE

	DefineControl(SpillOverAmountField,MaskedEditText,FieldMask,SpillOverAmt,Field,SpillOverAmt);
		Fields:	POSITION			SpillOverAmountPrompt(GetRight,Position)+$hGap,SpillOverAmountPrompt(GetTop,Position)-2,50,<ButtonHeight>
				TOOLTIP				Translate( ~Amount to spill over the edges of the page~ );

	DefineControl(SpillOverUOM,StaticText,Field,SpillOverUOM);
		Fields:	POSITION			SpillOverAmountField(GetRight,Position)+$hGap,SpillOverAmountPrompt(GetTop,Position),45,<ButtonHeight>

	DefineControl(PackageCutPrompt,StaticText);
		Fields:	POSITION			SpillOverAmountPrompt(GetLeft,Position),SpillOverAmountPrompt(GetBottom,Position)+20,150,<ButtonHeight>
				TEXT				~Package Cut~
				RIGHTJUSTIFIED		TRUE

	DefineControl(PackageCutListBox,ListBox);
		Fields:	POSITION			PackageCutPrompt(GetRight,Position)+$hGap,PackageCutPrompt(GetTop,Position),100,<ButtonHeight>*3
				DACTIONSTEXT		ACTION EXEC ( <THIS>.OnPackageCutSelection() );
				

	DefineNextPreviousButtons();	
} 

VOID	Wiz::OnSpillOverSelection()	
{ 
	Selection = dlg( ListBox,SpillOverListBox,GetSelectedIndex );
	DlgData( Set,SpillOverType,<Selection> ); 
	dlg( EnableControls,<Selection>,SpillOverAmountField );
	dlg( SetControlValue,SpillOverUOM,~<$str.$Selection.IndexValue__%_Inches>~ );			
}

VOID	Wiz::OnPaperFillSelection()	
{ 
	Selection = dlg( ListBox,PaperFillListBox,GetSelectedIndex );
	DlgData( Set,PaperFill,<Selection> ); 
	dlg( EnableControls,<Selection>,PaperAdvanceField,ImageBreakField,SpillOverListBox,SpillOverAmountField,PackageCutListBox );
	OnSpillOverSelection();
}

VOID	Wiz::OnPackageCutSelection()	
{ 
	Selection = dlg( ListBox,PackageCutListBox,GetSelectedIndex );
	DlgData( Set,PackageCut,<Selection> ); 
}

VOID	Wiz::Refresh_PaperFill()
{
	if ( StringList( PaperFillList,New,Is,~<$[DATABASE FieldTypes].PaperFill[ChoiceList]>~ ) )
	{
		dlg( ListBox,PaperFillListBox,AddStringsFromStringList,PaperFillList );
		dlg( ListBox,PaperFillListBox,Select,~<$con.DlgData[PaperFill]>~ );
	}

	if ( StringList( SpillOverType,New,Is,~<$[DATABASE FieldTypes].SpillOverType[ChoiceList]>~ ) )
	{
		dlg( ListBox,SpillOverListBox,AddStringsFromStringList,SpillOverType );
		dlg( ListBox,SpillOverListBox,Select,~<$con.DlgData[SpillOverType]>~ );
	}

	if ( StringList( PackageCutList,New,Is,~<$[DATABASE FieldTypes].PackageCut[ChoiceList]>~ ) )
	{
		dlg( ListBox,PackageCutListBox,AddStringsFromStringList,PackageCutList );
		dlg( ListBox,PackageCutListBox,Select,~<$con.DlgData[PackageCut]>~ );
	}


	OnPaperFillSelection();
	OnSpillOverSelection();
}

NUMERIC	Wiz::OnNext_PaperFill()		{ 	return ShowNextPage(); }		

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_PrinterSave()		// Various Script Hooks
{ 	
	DefinePrompt( Translate( Translations,PrinterSaveDescription ) );

	DefineNextPreviousButtons();
		Fields: DACTIONSTEXT		ACTION EXEC ( <THIS>.OnSavePrinter() )
				TEXT				~Save~
				ISENABLED			TRUE
			
}


VOID	Wiz::OnSavePrinter()	
{
	Query = ~Select * from Printers Where PrinterName = '<$con.DlgData[PrinterName]>'~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		Warning( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
		return;
	}

	IsNewRow = List( NumEntries ) == 0;

	Key = ~PrinterName = '<$con.DlgData[PrinterName]>'~;

	if ( !List( UpdateFrom,DlgData,~<Key>~,<IsNewRow> ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		Warning( Translate( ~Could not update Printer record where <Key>. <theErr>~ ) );
		return;
	}

	QueueName = ~<$con.DlgData[QueueName]>~;

	Query = ~Select * from QueueDefinition Where QueueName = '<$con.DlgData[QueueName]>'~;

	List( GetConnection,dbConnection );

	QueueNameExists = dbConnection( RecordCountFor,~<Query>~ );

	if ( !<QueueNameExists> )
	{
		if ( MessageBox( Translate(Translations,QueueDoesNotExist,~<QueueName>~),YESNO ) == YES )
		{ 
			ResetDialogValues();

			DlgData( Set,QueueName,~<QueueName>~ );

			SetStream( ~que<$con.DlgData[PrinterModel]>~ );
			SetCurrentPage(1);
		}
	}
	else
	{
		SetStream( ~Menu~ );
		SetCurrentPage(0);
		Warning( ~Update Complete for the <$con.DlgData[PrinterName]> Printer~ );
	}
}


//----------------------------------------------------------------------------------

VOID	Wiz::Controls_QueueSave()		
{ 	
	DefinePrompt( Translate( Translations,QueueSaveDescription ) );

	DefineNextPreviousButtons();
		Fields: DACTIONSTEXT		ACTION EXEC ( <THIS>.OnSaveQueue() )
				TEXT				~Save~
				ISENABLED			TRUE
			
}


//----------------------------------------------------------------------------------

VOID	Wiz::Controls_PaperType()			// Controls to select a paper type
{ 
	DefinePrompt( Translate(Translations,PaperTypePrompt) );

	DefineControl(PaperTypeListBox,ListBox,Field,PaperType);
		Fields:	POSITION			<FirstControlPosition>,200,250
				TOOLTIP				Translate( Translations,PaperTypePrompt )
				SORTED				TRUE;

	DefineNextPreviousButtons();	
} 

NUMERIC Wiz::OnNext_PaperType()			
{ 
	ReturnOnFailure( AuditForNull(PaperType,Translate(~You must select a paper type before you can proceed~) ) );

	return ShowNextPage();
}


VOID	Wiz::Refresh_PaperType()
{
	if ( StringList( PaperTypeList,New,Is,~<$[DATABASE FieldTypes].PaperType[ChoiceList]>~ ) )
	{
		dlg( ListBox,PaperTypeListBox,AddStringsFromStringList,PaperTypeList );

		if ( !IsNull( ~<$con.DlgData[PaperType]>~ ) )
		{
			dlg( ListBox,PaperTypeListBox,Select,~<$con.DlgData[PaperType]>~ );
		}
	}
}

//----------------------------------------------------------------------------------

VOID	Wiz::Controls_PaperSurface()			// Controls to select a paper type
{ 
	DefinePrompt( Translate(Translations,PaperSurfacePrompt) );

	DefineControl(PaperSurfaceListBox,ListBox,Field,PaperSurface);
		Fields:	POSITION			<FirstControlPosition>,200,250
				TOOLTIP				Translate( Translations,PaperSurfacePrompt )
				SORTED				TRUE;

	DefineNextPreviousButtons();	
} 

NUMERIC Wiz::OnNext_PaperSurface()			
{ 
	ReturnOnFailure( AuditForNull(PaperSurface,Translate(~You must select a paper surface before you can proceed~) ) );

	return ShowNextPage();
}

VOID	Wiz::Refresh_PaperSurface()
{
	if ( StringList( PaperSurfaceList,New,Is,~<$[DATABASE FieldTypes].PaperSurface[ChoiceList]>~ ) )
	{
		dlg( ListBox,PaperSurfaceListBox,AddStringsFromStringList,PaperSurfaceList );

		if ( !IsNull( ~<$con.DlgData[PaperSurface]>~ ) )
		{
			dlg( ListBox,PaperSurfaceListBox,Select,~<$con.DlgData[PaperSurface]>~ );
		}
	}
}


//----------------------------------------------------------------------------------

VOID	Wiz::Controls_PaperOpacity()			// Controls to select a paper opacity
{ 
	DefinePrompt( Translate(Translations,PaperOpacityPrompt) );

	DefineControl(PaperOpacityListBox,ListBox,Field,PaperOpacity);
		Fields:	POSITION			<FirstControlPosition>,200,250
				TOOLTIP				Translate( Translations,PaperOpacityPrompt )
				SORTED				TRUE;

	DefineNextPreviousButtons();	
} 

NUMERIC Wiz::OnNext_PaperOpacity()			
{ 
	ReturnOnFailure( AuditForNull(PaperOpacity,Translate(~You must select a paper opacity before you can proceed~) ) );

	return ShowNextPage();
}

VOID	Wiz::Refresh_PaperOpacity()
{
	if ( StringList( PaperOpacityList,New,Is,~<$[DATABASE FieldTypes].PaperOpacity[ChoiceList]>~ ) )
	{
		dlg( ListBox,PaperOpacityListBox,AddStringsFromStringList,PaperOpacityList );

		if ( !IsNull( ~<$con.DlgData[PaperOpacity]>~ ) )
		{
			dlg( ListBox,PaperOpacityListBox,Select,~<$con.DlgData[PaperOpacity]>~ );
		}
	}
}

//----------------------------------------------------------------------------------

VOID	Wiz::OnSaveQueue()	
{
	Query = ~Select * from QueueDefinition Where QueueName = '<$con.DlgData[QueueName]>'~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		Warning( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
		return;
	}

	IsNewRow = List( NumEntries ) == 0;

	if ( !List( UpdateFrom,DlgData,~QueueName = '<$con.DlgData[QueueName]>'~,<IsNewRow> ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		Warning( Translate( ~Could not update Printer Queue record where <Key>. <theErr>~ ) );
		return;
	}

	Warning( ~Update Complete~ );

	SetStream( ~Menu~ );
	SetCurrentPage(0);
}

//----------------------------------------------------------------------------------

VOID Init()
{
	Wiz( New,obj );

	Global( obj );

	obj.DefineDialog();
}

Init();		// Remove this later and trigger from the Invoking script

