Include: cmds;
Include: FormattingRoutines;
IncludeClass( BaseForm );		// Needed for views
IncludeClass( BaseDialog );		// Needed for dialogs
IncludeClass( BaseWheelman );	// Needed for wheelman support
IncludeClass( BaseMenu );		// Needed for context menu support
IncludeClass( BaseThread );		// Needed for thread support
IncludeClass( BaseImageWnd );	// Needed for image views

Include: ~Utilities2.txt~;
Include: ~MakeImageWritable~;
Include: ~DeleteOrder.txt~;
Include: ~DcSbaDoc.txt~;

//
//Version XXth May 2006  Modified analyser to auto refresh and show images to colour.
//Version 16th May 2006  Added Images to Analyse to view.
//Version 19th May 2006  Added Proofs to Analyser view. Also changed to count images rather than use the count from import.
//Version 26th May 2006  Added Proofs workstation setting to toggle off/on display of proof orders in the analyser window.
//Version 20th June 2006 Added AutoRelease of prints and ability to add conversions table entry.
//Version 6th  July 2006 Updated to autorelease orders from proxies correctly. Popups added where order is a reorder to clarify 
//                       whats happening.
//Version 13th July 2006 Updated to correctly release the new order where its from Proxies. This uses OrderToRelease since you may
//                       be viewing images from an old order. Also added a warning where the images being opened are from an old order.
//Version 2 13th July 2006
//                       Updated to fix the release script to be correct and to only mark adjusting for the reorder.
//Version 17th July 2006 Added Image Index to the analyzer view.
//Version 20th July 2006 Modified to only create release script if not leaving for further analysis.
//Version 21th July 2006 Modified to warn if the release script copies fail.
//Version 25th July 2006 Modified to list Orders On "Hold"
//Version 25th July 2006 Modified to display Order summary when you open an order to colour.
//Version 26th July 2006 Modified to Update the Summary window position, and when its opened.
//                       Made sizing of summary dynamic.     
//                       Added Display of orders and images to colour.
//Version 3rd  Nov  2008 Added LDP Support.
//Version 11th Nov  2008 Added renderpath LDP support
//Version 11th Nov  2008 Remove .aut script creation to be done via order complete script.
//Version 14th Nov  2008 Corrected to only release LDP orders.
//Version 3rd  Apr  2009 Added Pending Approval and auto preview support for order Proofing.
//Version 18th Dec  2012 Added MediaClip Support.

AnalyzerVersion = ~Version 18th Dec 2012~;

ShowButtonsForDebug = FALSE;
QtyToColour = 0;
OrderQty    = 0;
ReleaseScript = FALSE;
 
xAmountAnalyzer = 350;
xAmountLightTable = 350;

if ( !Defined(DP2) )
{
	DP2 = TRUE;
}

// Declare analyzer class
Class( Analyzer, Extends, BaseForm,
		Member, LargeTextHeight,	Numeric,	40,
		Member, LargeTextHeight,	Numeric,	24,
		Member, ColorButtonWidth,	Numeric,	60,
		Member, ListBoxWidth,		Numeric,	90,
		Member, ImageWidth,			Numeric,	90,
		Member, ImageHeight,		Numeric,	100,
		Member, TextHeight,			Numeric,	30,
		Member, WheelManMode,		Numeric,	0,
		Member, ColorWidth,			Numeric,	90,
		Member, LabelWidth,			Numeric,	40,
		Member, ColorHeight,		Numeric,	47,
		Member, ColorFont,			Str,		~Arial~,
		Member, ColorFontSize,		Numeric,	48,
		Member, FontSize,			Numeric,	20,
		Member, BackRed,			Numeric,	128,
		Member, BackGreen,			Numeric,	128,
		Member, BackBlue,			Numeric,	128,
		Member, ToolbarH,			Numeric,	30,
		Member, ToolbarW,			Numeric,	30,
		Member, ToolbarGap,			Numeric,	8,
		Member, ToolbarRed,			Numeric,	GetSysColor( ~3DFACE~, Red ),
		Member, ToolbarGreen,		Numeric,	GetSysColor( ~3DFACE~, Green ),
		Member, ToolbarBlue,		Numeric,	GetSysColor( ~3DFACE~, Blue ),
		Member, LastImagePath,		Str,		~~,
		Member, TimerMils,			Numeric,	10,
		Member, CorrRange,			Numeric,	300,
		Member, AltCorrRange,		Numeric,	100,
		Member, GammaRange,			Numeric,	2.0,
		Member, fSeq,				Numeric,	0
 );

// Declare open order dialog class
Class( OpenDialog, Extends, BaseDialog,
		Member, ManualOrderID,		Str,		~~,
		Member, IsSelectingOrder,	Numeric,	0,
		Member, SortColumn,			Numeric,	0 );

// Declare store corrections dialog
Class( StoreDialog, Extends, BaseDialog );

// Declare recall corrections dialog
Class( RecallDialog, Extends, BaseDialog );

// Declare apply corrections to all dialog
Class( ApplyAllDialog, Extends, BaseDialog,
		Member, ApplyType,			Numeric,	0 );

// Declare apply average corrections to all dialog
Class( FinishDialog, Extends, BaseDialog,
		Member, FinishType,		Numeric,	0,
		Member, OrderStatus,	Str,		~~,
		Member, ShutDownAppFlag,Numeric,	0 );

// Declare recall reference dialog
Class( RecallRefDialog, Extends, BaseDialog,
		Member, PreviewTheImage,	Numeric,	0 );

// Declare options dialog
Class( OptionsDialog, Extends, BaseDialog,
		Member, RenderOption,		Numeric,	0,
		Member, TextCheck,			Numeric,	0,
		Member, HoldCorrectionMode,	Numeric,	0,
		Member, AllowResetOfNoPrint, Numeric,	0,
		Member, PreserveCheck,		Numeric,	0,
		Member, ShowOnlyImagesToAdjust, Numeric,	0,
		Member, DeleteCheck,		Numeric,	0,
		Member, FileOption,			Numeric,	0,
		Member, SaveFileType,		Numeric,	0,
		Member, ProfileOption,		Numeric,	0,
		Member, MinThumbSize,		Numeric,	32,
		Member, DefaultThumbSize,	Numeric,	500,
		Member, MaxThumbSize,		Numeric,	1000,
		Member, RenderProfile,		Str,		~~,
		Member, AutoBalPreference,	Str,		~~,
		Member, AutoBalFirst,		Numeric,	0,
		Member, EnableCropping,		Numeric,	0 );

// Declare thumbnail add thread
Class( ThumbThread, Extends, BaseThread );

// Declare light table class
Class( LightTable, Extends, BaseImageWnd,
		Member, WheelManMode,		Numeric,	0,
		Member, ColorWidth,			Numeric,	90,
		Member, LabelWidth,			Numeric,	40,
		Member, ColorHeight,		Numeric,	47,
		Member, ColorFont,			Str,		~Arial~,
		Member, ColorFontSize,		Numeric,	48,
		Member, FontSize,			Numeric,	20,
		Member, BackRed,			Numeric,	128,
		Member, BackGreen,			Numeric,	128,
		Member, BackBlue,			Numeric,	128,
		Member, ToolbarH,			Numeric,	30,
		Member, ToolbarW,			Numeric,	30,
		Member, ToolbarGap,			Numeric,	8,
		Member, ToolbarRed,			Numeric,	GetSysColor( ~3DFACE~, Red ),
		Member, ToolbarGreen,		Numeric,	GetSysColor( ~3DFACE~, Green ),
		Member, ToolbarBlue,		Numeric,	GetSysColor( ~3DFACE~, Blue ),
		Member, TimerMils,			Numeric,	25,
		Member, ThumbIncrement,		Numeric,	5,
		Member, CorrRange,			Numeric,	300,
		Member, AltCorrRange,		Numeric,	100,
		Member, GammaRange,			Numeric,	2.0 );


/*******************************************************************************
 *******************************************************************************
 ********************************* Light Table *********************************
 *******************************************************************************
 *******************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID LightTable::LightTable()	// Constructor
{
	fMaximized = <DP2> ? FALSE : TRUE;
	fTitle = ~Digital Analyzer~;

//	Define: ImageEditData Using DDImageEdit Private
//		Fields:	orgD			64
//				orgGamma		1.0	;	// all other fields default to 0 or NULL
}

VOID LightTable::CategoryDefinition()	// Define the thumbnail view
{
	Fields:
			BackgroundColor				~<BackRed> <BackGreen> <BackBlue>~
			FrameBackgroundColor		~<BackRed> <BackGreen> <BackBlue>~
			FrameShadowColor			~<BackRed> <BackGreen> <BackBlue>~
			FrameHighlightColor			~<BackRed> <BackGreen> <BackBlue>~
			TextBackgroundColor			~<BackRed> <BackGreen> <BackBlue>~
			HeightPercentOfMainframe	35
			FontWeight					600
			DoubleClickActionsText		ACTION EXEC ( ChangeView( 0 ) )
			HActionsText				ACTION SHOWHELPPAGE( KPDAWHelpFile "Identifying_the_Screen_Features.htm" )
}

VOID LightTable::ThumbnailDefinition()
{
	MACROSOFF

	Fields:		Info2					~<$con.Image[OrderID]>\<$con.Image[Roll]>\<$con.Image[Frame]>~
	//Fields:		Info2					~<$con.Image[Brt]>\<$con.Image[Red]>\<$con.Image[Grn]>\<$con.Image[Blu]>~

	MACROSON
}

VOID LightTable::AddControls()		// Add controls to the upper view
{
	AddPromptControls();
	AddToolbar();
	AddColorControls();
}

VOID LightTable::ViewDefinition()
{
	Fields:		BackgroundColor				~<BackRed> <BackGreen> <BackBlue>~
				WindowPosChangedActionText	ACTION EXEC ( <This>.ResizeToFitScreen() )	// <DP2>
				HActionsText				ACTION SHOWHELPPAGE( KPDAWHelpFile "Identifying_the_Screen_Features.htm" )
}

VOID LightTable::ResizeToFitScreen()	// <DP2>
{
	if ( <DP2> )
	{
		ImageWindow( GetWindowPosition,WindowLeft,WindowTop,WindowRight,WindowBottom );

		View( ControlRect,ReferenceImage,GetPosition,x,y,w,l );
		Left = <WindowRight> - <w> - <hGap>;
		View( ControlRect,ReferenceImage,SetPosition,<Left>,<y>,<w>,<l> );

		View( ControlRect,RefreshButton,GetPosition,x,y,w,l );
		Left = <Left> - 100;
		View( ControlRect,RefreshButton,SetPosition,<Left>,<y>,<w>,<l> );

		View( RefreshView );
	}
}

NUMERIC LightTable::UpdateImages( Field,Value,DontAsk )
{
	ImageWindow( GetViewOfWindow, ImagesThumbNailCategory, View );

	if ( !Defined( View ) )
		{ return FALSE; }

	if ( !View( GetSelected,SelectedImages ) )
		{ return Warning( ~There are no Images selected~ ); }

	Count = SelectedImages( ChildCount );

	if ( <Count> == 0 )
		{ return Warning( ~There are no images selected~ ); }

	if ( !DefinedAndNotNull(DontAsk) )
	{
		if ( MessageBox( ~Are you sure you want to update the <count> selected images? ~,YESNO ) == NO )
			{ return TRUE; }
	}

	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate(~Could not connect to the database. <theErr>~) );
	}

	if ( IsNull( ~<Value>~ ) )	{ Value = ~NULL~; }

	while ( SelectedImages( GetNext,Image ) )
	{
		okToUpdate = TRUE;
		Image( GetThumbNailInfo,ThumbNail );
		if ( Defined( ThumbNail ) )
		{
			ThumbNail( Get,IsDeleted,IsRejected );
			if ( !<ExtAllowResetOfNoPrint> && <IsRejected> && !<Value> )
			{
				okToUpdate = FALSE;
			}
		}

		if ( <okToUpdate> )
		{
			Key = STR ( OrderID = '<$con.Image[OrderID]>' AND Roll = '<$con.Image[Roll]>' AND Frame = '<$con.Image[Frame]>' );

			Cmd = ~Update Images Set <Field>=<Value> Where <Key>~;

			if ( !dBase( CMD,~<Cmd>~ ) )
			{
				dBase( GetErrorDescription,theErr );
				Warning( ~Update Failed.  <Cmd>.  <theErr>~ );
				break;
			}
		}

		if ( Defined( ThumbNail ) )
		{
			if ( ~<Field>~ == ~Rejected~ && <okToUpdate> )
			{
				ThumbNail( Set,IsDeleted,~<Value>~ );
				View( RedrawThumbNail,ThumbNail,FALSE );
			}
			else if ( ~<Field>~ == ~Path~ )
			{
				if ( ~<Value>~ == ~NULL~ )
				{
					ThumbNail( Set,Path,~<Value>~ == ~NULL~ ? ~~ : ~<Value>~ );
					View( RedrawThumbNail,ThumbNail,TRUE );	
				}
			}
		}
	}

	return TRUE;
}

NUMERIC LightTable::UpdateRejectedFlag( TheOrderID,TheRoll,TheFrame,NoPrint )
{
	if ( !Defined( ImageWindow ) )
	{
		return FALSE;
	}

	ImageWindow( GetViewOfWindow, ImagesThumbNailCategory, View );
	if ( !Defined( View ) )
	{ 
		return FALSE;
	}

	if ( View( FindI,Key,~OrderID = '<TheOrderID>' AND Roll = '<TheRoll>' AND Frame = '<TheFrame>'~,Where,TheImage ) )
	{
		View( SetDeleted, TheImage, <NoPrint> );
	}

	return TRUE;
}

VOID LightTable::WindowDefinition()
{
	if ( DefinedAndNotNull( LeftRight ) )
	{
		Fields:		AllowSplitterResize			T	
					Position					0 0 100 100
					IsMaximized					<DP2> ? F : T
					SplitterRows				1
					SplitterColumns				~2 14 76~
					HActionsText				ACTION SHOWHELPPAGE( KPDAWHelpFile "Identifying_the_Screen_Features.htm" )
	}
	else
	{
		Fields:		AllowSplitterResize			T		
					Position					0 0 100 100
					IsMaximized					<DP2> ? F : T
					SplitterRows				~2 31 69~
					SplitterColumns				1
					HActionsText				ACTION SHOWHELPPAGE( KPDAWHelpFile "Identifying_the_Screen_Features.htm" )
	}
}

VOID LightTable::LeftClickInImageView()
{
	DoLeftClickInImageView( ~~, ~~ );
}


VOID LightTable::DoLeftClickInImageView( InitRoll, InitFrame )
{
	PreviousImageSel = ~<LastImageSel>~;
	LastImageSel = ~~;
	ImagePath = ~~;
	NoRevert = FALSE;

	if ( !SimilarStr( ~<InitRoll>~, ~~ ) && !SimilarStr( ~<InitFrame>~, ~~ ) )
	{
		ImageWindow( GetViewOfWindow, ImagesThumbNailCategory, View );

		if ( Defined( View ) )
		{
			if ( View( FindI,Key,~OrderID = '<OrderID>' AND Roll = '<InitRoll>' AND Frame = '<InitFrame>'~,Where,TheImage ) )
			{
				// Deselect all images first.
				View( SetSelected, TheImage, FALSE, TRUE );

				// Now select the image.
				View( SetSelected, TheImage, TRUE, FALSE, TRUE );
			}
		}
	}

	StringList( NewImageList,New );
	
	if ( ThumbView( GetSelected, ImageList ) )	// GetAll gets all records
	{
		while ( ImageList( GetNext,Image ) )
		{
			if ( ThumbView( IsImageLastSelected, Image ) )
			{
				ImagePath = ~<$con.Image[Path]>~;

				if ( ~<ImagePath>~ == ~<LastImageSel>~ )
				{
					NoRevert = TRUE;
				}

				LastImageSel = ~<ImagePath>~;

				Roll = ~<$con.Image[Roll]>~;
				Frame = ~<$con.Image[Frame]>~;
			}

			NewImageList( AddString, ~<$con.Image[Path]>~ );
		}
	}

	if ( !<NoRevert> )
	{
		RevertSelected( ~<InitRoll>~, ~<InitFrame>~, ~<PreviousImageSel>~ );
		InitCorrections();
//		if ( !<ExtKeepCorrection> )
//		{
//			ImageEditData( SetValues, cDensity, 0, cRed, 0, cGreen, 0, cBlue, 0, cContrast, 0, cSaturation, 0, cRotateFromDisk, 0 );
//		}
	}

	StringList( CurImageList,New );
	Global( CurImageList );
	More = NewImageList( GetFirst, ImageName );
	while ( <More> )
	{
		CurImageList( AddString, ~<ImageName>~ );

		More = NewImageList( GetNext, ImageName );
	}	

	if ( (ImagePath != ~~) && ImageCorrections(GetCurrentCorrections, ~<ImagePath>~, Corrections ) )
	{
		gOldDensity = Corrections( GetNumeric, orgDensity );
		gOldRed = Corrections( GetNumeric, orgRed );
		gOldGreen = Corrections( GetNumeric, orgGreen );
		gOldBlue = Corrections( GetNumeric, orgBlue );
		gOldContrast = Corrections( GetNumeric, orgContrast );
		gOldSaturation = Corrections( GetNumeric, orgSaturation );
		gOldGamma = Corrections( GetNumeric, orgGamma );
		gOldRotation = Corrections( GetNumeric, orgRotateFromDisk );
		if ( <ExtAutoBalFirst> )
		{
			OnAutoBalance(FALSE);	
		}
		else if ( <ExtKeepCorrection> )
		{
			ImageEditData( UpdateCorrections, ~<ImagePath>~ );
		}

		UpdateColorValues(TRUE);
	}
	else
	{
		gOldDensity = 0;
		gOldRed = 0;
		gOldGreen = 0;
		gOldBlue = 0;
		gOldContrast = 0;
		gOldSaturation = 0;
		gOldGamma = 0.0;
		gOldRotation = 0;

		UpdateColorValues(FALSE);
	}
}

VOID LightTable::RightClickInImageView()
{
	DoLeftClickInImageView( ~~, ~~ );

	RightClickMenu();
}

VOID LightTable::RightClickMenu()
{
	LightTableMenu( New, theMenu );

	theMenu.DisplayInView( ThumbView );
}

NUMERIC LightTable::OnKeyDown()
{
	if ( !ImageWindow( GetActiveViewOfWindow, View ) )	{ return FALSE; }
		
	key = View( GetLastKey, KeyString );
	KeyString = Upper( ~<KeyString>~ );

	return OnKey( ~<Key>~, ~<KeyString>~, View );
}

NUMERIC LightTable::OnKey( Key, KeyString, &View )	
{
	shiftState = KeyState( Shift );
	altState   = KeyState( Alt );

	if ( !DefinedAndNotNull( LastOrderID ) )
	{
		OnSimilarStr( ~<KeyString>~, 
			~<pMode>~,		~<This>.ToggleWheelman()~,
			~<pViewMode>~,	~ChangeView( 0 )~,
			~<pRecallRef>~,	~<This>.RecallReference()~,
			~<pOpen>~,		~OpenAnOrder()~ );
		return TRUE;
	}

	if ( Defined( ArrowKeyPressed ) )
	{
		ForgetGlobal( ArrowKeyPressed );
		DoLeftClickInImageView( ~~, ~~ );
		return TRUE;
	}

	if ( IsNavigationalKey( ~<Key>~,~<KeyString>~ ) )
	{ 
		NavigationalKey(~<Key>~, ~<KeyString>~, &View );
		DoLeftClickInImageView( ~~, ~~ );
		return TRUE;
	}	// Arrow keys,Home,End,PageUp&Dn

	if ( IsTab( ~<Key>~,~<KeyString>~ ) )				{ return HandleTab( View ); }	// Tab and Control Tab

	if ( IsRefreshKey( ~<Key>~,~<KeyString>~ ) )		{ return RefreshKey( View ); }	// F5

	KeyString = Upper( ~<KeyString>~ );
	OnSimilarStr( ~<KeyString>~, 
		~<pNum0>~,		~SaveChangeFactor( 0 )~,
		~<pNum1>~,		~SaveChangeFactor( 1 )~,
		~<pNum2>~,		~SaveChangeFactor( 2 )~,
		~<pNum3>~,		~SaveChangeFactor( 3 )~,
		~<pNum4>~,		~SaveChangeFactor( 4 )~,
		~<pNum5>~,		~SaveChangeFactor( 5 )~,
		~<pNum6>~,		~SaveChangeFactor( 6 )~,
		~<pNum7>~,		~SaveChangeFactor( 7 )~,
		~<pNum8>~,		~SaveChangeFactor( 8 )~,
		~<pNum9>~,		~SaveChangeFactor( 9 )~,
		~<pNum0_2>~,	~SaveChangeFactor( 0 )~,
		~<pNum1_2>~,	~SaveChangeFactor( 1 )~,
		~<pNum2_2>~,	~SaveChangeFactor( 2 )~,
		~<pNum3_2>~,	~SaveChangeFactor( 3 )~,
		~<pNum4_2>~,	~SaveChangeFactor( 4 )~,
		~<pNum5_2>~,	~SaveChangeFactor( 5 )~,
		~<pNum6_2>~,	~SaveChangeFactor( 6 )~,
		~<pNum7_2>~,	~SaveChangeFactor( 7 )~,
		~<pNum8_2>~,	~SaveChangeFactor( 8 )~,
		~<pNum9_2>~,	~SaveChangeFactor( 9 )~,
		~<pDensity>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( 1 ) )~,
		~<pDensity2>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( -1 ) )~,
		~<pThumbUp>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( 1 ) )~,
		~<pThumbDown>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( -1 ) )~,
		~<pRed>~,		~<This>.OnRedButton( <This>.GetChangeAmount( 1 ) )~,
		~<pRed2>~,		~<This>.OnRedButton( <This>.GetChangeAmount( -1 ) )~,
		~<pGreen>~,		~<This>.OnGreenButton( <This>.GetChangeAmount( 1 ) )~,
		~<pGreen2>~,	~<This>.OnGreenButton( <This>.GetChangeAmount( -1 ) )~,
		~<pBlue>~,		~<This>.OnBlueButton( <This>.GetChangeAmount( 1 ) )~,
		~<pBlue2>~,		~<This>.OnBlueButton( <This>.GetChangeAmount( -1 ) )~,
		~<pPrint>~,		~<This>.AcceptImageEdits( 0 )~,
		~<pNoPrint>~,	~<This>.AcceptImageEdits( 1 )~,
		~<pNext>~,		~<This>.OnNextButton()~,
		~<pPrev>~,		~<This>.OnPrevButton()~,
		~<pNext2>~,		~<This>.OnNextButton()~,
		~<pPrev2>~,		~<This>.OnPrevButton()~,
		~<pMode>~,		~<This>.ToggleWheelman()~,
		~<pViewMode>~,	~ChangeView( 0 )~,
		~<pMakeRef>~,	~<This>.MakeReference()~,
		~<pRecallRef>~,	~<This>.RecallReference()~,
		~<pRotate90>~,	~<This>.RotateImages( 90 )~,
		~<pRotate180>~,	~<This>.RotateImages( 180 )~,
		~<pRotate270>~,	~<This>.RotateImages( 270 )~,
		~<pStore>~,		~<This>.StoreCorrection()~,
		~<pRecall>~,	~<This>.RecallCorrection()~,
		~<pRecallLast>~,~ApplyLastCorrection()~,
		~<pApplyAll>~,	~<This>.StartApplyToAll()~ );

	OnSimilarStr( ~<KeyString>~, 
		~<pOpen>~,		~OpenAnOrder()~,
		~<pReset>~,		~<This>.ResetSelectedCorrections()~,
		~<pViewChanges>~,~ViewChanges()~,
		~<pAutoBal>~,	~<This>.SetAutoBalMode(0, <shiftState>, <altState>, FALSE); <THIS>.OnAutoBalance(TRUE)~ );

	Return TRUE;
}

VOID LightTable::DefineView(Name)
{
	UseView( ~<Name>~ );

	Define: View<Name> Using DDViewDef AsSymbol View<Name> Private
		Fields:	ViewType				~FormView~
				HActionsText			ACTION SHOWHELPPAGE( KPDAWHelpFile "Identifying_the_Screen_Features.htm" )
				CloseActionsText		ACTION Call ( <THIS>.OnCloseWindow() )
//				IActionsText			ACTION EXEC ( <This>.EnableViews() );

		if ( <THIS>( HasMethod,~ViewDefinition<Name>~ ) ) { ViewDefinition<Name>(); }
					
		Contains:
		{
			if ( <THIS>( HasMethod,~AddControls<Name>~ ) ) { AddControls<Name>(); }	
		}

	PopView();
}

VOID LightTable::OnCloseWindow()
{
	// DPT 02/12/04
	// I commented out the following lines because they would cause the image window to be closed prematurely
	// when an image had been changed and the user cancels the End of Order Analysis dialog.  This would result
	// in a script error.  Without this code the windows get closed properly anyway in all cases.
	//if ( DefinedAndNotNull( ExitAnalyzerProgram ) || <DP2> )
	//{
	//	ImageWindow( ForceCloseWindow );
	//}
}

VOID LightTable::CloseWindow()
{
	SetWorkstationSettings( ~Analyzer~, ~DefaultAutoBalLevel~, <ExtSbaLevel>, TRUE );

	if ( Defined( DImageSba ) )
	{
		ForgetGlobal( DImageSba );
	}

	if ( Defined(ImageWindow) )
	{
		ImageWindow( ForceCloseWindow );
	}
}


/**********************************************
 *************** Color controls ***************
 **********************************************/

VOID LightTable::AddColorControls()
{
	if ( DefinedAndNotNull( LeftRight ) )
	{
		Define: DensityLabel Using DDWinCtrlDef AsSymbol DensityLabel Private
			Fields:	Typename		StaticText
					Position		20, 245, <LabelWidth>, <ColorHeight>
					TextColorRed	0,			TextColorGreen 0,			TextColorBlue 0
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Density correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~D~;
	}
	else
	{
		Define: DensityLabel Using DDWinCtrlDef AsSymbol DensityLabel Private
			Fields:	Typename		StaticText
					Position		20, 45, <LabelWidth>, <ColorHeight>
					TextColorRed	0,			TextColorGreen 0,			TextColorBlue 0
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Density correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~D~;
	}

	Define: DensityText Using DDWinCtrlDef AsSymbol DensityText Private
		Fields:	TypeName		StaticText
				Position		DensityLabel(GetRight, Position), DensityLabel(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Density correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: RedLabel Using DDWinCtrlDef AsSymbol RedLabel Private
		Fields:	Typename		StaticText
				Position		DensityLabel(GetLeft, Position), DensityLabel(GetBottom, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Red correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~R~

	Define: RedText Using DDWinCtrlDef AsSymbol RedText Private
		Fields:	TypeName		StaticText
				Position		DensityText(GetLeft, Position), DensityText(GetBottom, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Red correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: GreenLabel Using DDWinCtrlDef AsSymbol GreenLabel Private
		Fields:	Typename		StaticText
				Position		DensityLabel(GetLeft, Position), RedLabel(GetBottom, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 255,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Green correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~G~

	Define: GreenText Using DDWinCtrlDef AsSymbol GreenText Private
		Fields:	TypeName		StaticText
				Position		DensityText(GetLeft, Position), RedText(GetBottom, Position),
								<ColorWidth>, <ColorHeight>,
				TextColorRed	0,			TextColorGreen 255,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Green correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: BlueLabel Using DDWinCtrlDef AsSymbol BlueLabel Private
		Fields:	Typename		StaticText
				Position		DensityLabel(GetLeft, Position), GreenLabel(GetBottom, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Blue correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~B~

	Define: BlueText Using DDWinCtrlDef AsSymbol BlueText Private
		Fields:	TypeName		StaticText
				Position		DensityText(GetLeft, Position), GreenText(GetBottom, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Blue correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: ColorGroupBox Using DDWinCtrlDef AsSymbol ColorGroupBox Private
		Fields:	TypeName		GroupBox
				Position		DensityLabel(GetLeft, Position) - 10,
								DensityText(GetTop, Position) - 10,
								DensityText(GetRight, Position) - DensityLabel(GetLeft, Position) + 20,
								BlueText(GetBottom, Position) - DensityText(GetTop, Position) + 15
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>;

	if ( DefinedAndNotNull( LeftRight ) )
	{
		Define: ContrastLabel Using DDWinCtrlDef AsSymbol ContrastLabel Private
			Fields:	Typename		StaticText
					Position		DensityLabel(GetLeft, Position), BlueLabel(GetBottom, Position) + $vGap * 4,
									<LabelWidth>, <ColorHeight>
					TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Contrast correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~C~;

		Define: GammaLabel Using DDWinCtrlDef AsSymbol GammaLabel Private
			Fields:	Typename		StaticText
					Position		ContrastLabel(GetLeft, Position), ContrastLabel(GetBottom, Position), // + <ColorHeight>,
									<LabelWidth>, <ColorHeight>
					TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Gamma correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~G~;

		Define: SaturationLabel Using DDWinCtrlDef AsSymbol SaturationLabel Private
			Fields:	Typename		StaticText
					Position		ContrastLabel(GetLeft, Position), GammaLabel(GetBottom, Position), // + <ColorHeight>,
									<LabelWidth>, <ColorHeight>
					TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Saturation correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~S~;
	}
	else
	{
		Define: ContrastLabel Using DDWinCtrlDef AsSymbol ContrastLabel Private
			Fields:	Typename		StaticText
					Position		DensityText(GetRight, Position) + $vGap*4, DensityLabel(GetTop, Position),
									<LabelWidth>, <ColorHeight>
					TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Contrast correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~C~;

		Define: GammaLabel Using DDWinCtrlDef AsSymbol GammaLabel Private
			Fields:	Typename		StaticText
					Position		ContrastLabel(GetLeft, Position), RedLabel(GetTop, Position),
									<LabelWidth>, <ColorHeight>
					TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Gamma correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~G~;

		Define: SaturationLabel Using DDWinCtrlDef AsSymbol SaturationLabel Private
			Fields:	Typename		StaticText
					Position		ContrastLabel(GetLeft, Position), GreenLabel(GetTop, Position),
									<LabelWidth>, <ColorHeight>
					TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
					BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip			~Saturation correction for current image~
					Font			~<ColorFont>~
					FontSize		<ColorFontSize>
					Text			~S~;
	}

	Define: ContrastText Using DDWinCtrlDef AsSymbol ContrastText Private
		Fields:	TypeName		StaticText
				Position		ContrastLabel(GetRight, Position), ContrastLabel(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Contrast correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: GammaText Using DDWinCtrlDef AsSymbol GammaText Private
		Fields:	TypeName		StaticText
				Position		GammaLabel(GetRight, Position), GammaLabel(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Gamma correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: SaturationText Using DDWinCtrlDef AsSymbol SaturationText Private
		Fields:	TypeName		StaticText
				Position		SaturationLabel(GetRight, Position), SaturationLabel(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Saturation correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: StepIndicator Using DDWinCtrlDef AsSymbol StepIndicator Private
		Fields:	TypeName		StaticText
				Position		SaturationText(GetRight, Position) - 20, SaturationText(GetBottom, Position) + ($vGap * 2),
								20, 15
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Change size indicator~
				Text			~+5~
				RightJustified	TRUE
				IsHidden		T

	Define: ColorGroupBox2 Using DDWinCtrlDef AsSymbol ColorGroupBox2 Private
		Fields:	TypeName		GroupBox
				Position		ContrastLabel(GetLeft, Position) - 10,
								ContrastText(GetTop, Position) - 10,
								ContrastText(GetRight, Position) - ContrastLabel(GetLeft, Position) + 20,
								SaturationText(GetBottom, Position) - ContrastText(GetTop, Position) + 15
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				IsHidden		T
}

VOID LightTable::SetNewColor()
{
	View( SetControlColor, DensityLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, RedLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, GreenLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, BlueLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, ContrastLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, SaturationLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, GammaLabel, BGColor, 144, 144, 144 );
	
	View( SetControlColor, DensityText, BGColor, 144, 144, 144 );
	View( SetControlColor, RedText, BGColor, 144, 144, 144 );
	View( SetControlColor, GreenText, BGColor, 144, 144, 144 );
	View( SetControlColor, BlueText, BGColor, 144, 144, 144 );
	View( SetControlColor, ContrastText, BGColor, 144, 144, 144 );
	View( SetControlColor, SaturationText, BGColor, 144, 144, 144 );
	View( SetControlColor, GammaText, BGColor, 144, 144, 144 );

	View( SetControlTitle, StepIndicator, ~+<WheelChange>~);
	View( ShowControls, TRUE, StepIndicator );
}

VOID LightTable::SetOldColor()
{
	View( SetControlColor, DensityLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, RedLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GreenLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, BlueLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, ContrastLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, SaturationLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GammaLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );

	View( SetControlColor, DensityText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, RedText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GreenText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, BlueText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, ContrastText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, SaturationText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GammaText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );

	View( ShowControls, FALSE, StepIndicator );
}


/************************************************
 *************** Toolbar controls ***************
 ************************************************/

VOID LightTable::AddToolbar()
{
	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton
			Fields:		TypeName				Button
						Position				<ToolbarGap>, 4, <ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWOpen.tif~
						DActionsText			ACTION EXEC ( OpenAnOrder() )
						ToolTip					~Open an order~
						IsTabStop				F;
	
		Define: Seperator0 Using DDWinCtrlDef AsSymbol Seperator0
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: Seperator1 Using DDWinCtrlDef AsSymbol Seperator1
			Fields:		TypeName				StaticText
						Position				OpenButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: PrevButton Using DDWinCtrlDef AsSymbol PrevButton
			Fields:		TypeName				Button
						Position				OpenButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWPrev.tif~
						DActionsText			ACTION EXEC ( <This>.OnPrevButton() )
						ToolTip					~Previous image~
						IsTabStop				F;

	Define: NextButton Using DDWinCtrlDef AsSymbol NextButton
			Fields:		TypeName				Button
						Position				PrevButton(GetRight, Position) , OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWNext.tif~
						DActionsText			ACTION EXEC ( <This>.OnNextButton() )
						ToolTip					~Next image~
						IsTabStop				F;

		Define: Seperator2 Using DDWinCtrlDef AsSymbol Seperator2
			Fields:		TypeName				StaticText
						Position				NextButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: DensityUpButton Using DDWinCtrlDef AsSymbol DensityUpButton
			Fields:		TypeName				Button
						Position				NextButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWDensityU.tif~
						DActionsText			ACTION EXEC ( <This>.OnDensityButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add density/contrast~
						IsTabStop				F;

	Define: RedUpButton Using DDWinCtrlDef AsSymbol RedUpButton
			Fields:		TypeName				Button
						Position				DensityUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRedU.tif~
						DActionsText			ACTION EXEC ( <This>.OnRedButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add red/gamma~
						IsTabStop				F;

	Define: GreenUpButton Using DDWinCtrlDef AsSymbol GreenUpButton
			Fields:		TypeName				Button
						Position				RedUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWGreenU.tif~
						DActionsText			ACTION EXEC ( <This>.OnGreenButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add green/saturation~
						IsTabStop				F;

	Define: BlueUpButton Using DDWinCtrlDef AsSymbol BlueUpButton
			Fields:		TypeName				Button
						Position				GreenUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWBlueU.tif~
						DActionsText			ACTION EXEC ( <This>.OnBlueButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add blue~
						IsTabStop				F;

		Define: Seperator3 Using DDWinCtrlDef AsSymbol Seperator3
			Fields:		TypeName				StaticText
						Position				BlueUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: DensityDownButton Using DDWinCtrlDef AsSymbol DensityDownButton
			Fields:		TypeName				Button
						Position				BlueUpButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWDensityD.tif~
						DActionsText			ACTION EXEC ( <This>.OnDensityButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract density/contrast~
						IsTabStop				F;

	Define: RedDownButton Using DDWinCtrlDef AsSymbol RedDownButton
			Fields:		TypeName				Button
						Position				DensityDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRedD.tif~
						DActionsText			ACTION EXEC ( <This>.OnRedButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract red/gamma~
						IsTabStop				F;

	Define: GreenDownButton Using DDWinCtrlDef AsSymbol GreenDownButton
			Fields:		TypeName				Button
						Position				RedDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWGreenD.tif~
						DActionsText			ACTION EXEC ( <This>.OnGreenButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract green/saturation~
						IsTabStop				F;

	Define: BlueDownButton Using DDWinCtrlDef AsSymbol BlueDownButton
			Fields:		TypeName				Button
						Position				GreenDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWBlueD.tif~
						DActionsText			ACTION EXEC ( <This>.OnBlueButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract blue~
						IsTabStop				F;

		Define: Seperator4 Using DDWinCtrlDef AsSymbol Seperator4
			Fields:		TypeName				StaticText
						Position				BlueDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: StoreButton Using DDWinCtrlDef AsSymbol StoreButton
			Fields:		TypeName				Button
						Position				BlueDownButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWStore.tif~
						DActionsText			ACTION EXEC ( <This>.StoreCorrection() )
						ToolTip					~Store current corrections~
						IsTabStop				F;

	Define: RecallButton Using DDWinCtrlDef AsSymbol RecallButton
			Fields:		TypeName				Button
						Position				StoreButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRecall.tif~
						DActionsText			ACTION EXEC ( <This>.RecallCorrection() )
						ToolTip					~Recall corrections~
						IsTabStop				F;

	Define: RecallLastButton Using DDWinCtrlDef AsSymbol RecallLastButton
			Fields:		TypeName				Button
						Position				RecallButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRecallLast.tif~
						DActionsText			ACTION EXEC ( ApplyLastCorrection() )
						ToolTip					~Recall last saved correction~
						IsTabStop				F;

		Define: Seperator5 Using DDWinCtrlDef AsSymbol Seperator5
			Fields:		TypeName				StaticText
						Position				RecallLastButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: RecallRefButton Using DDWinCtrlDef AsSymbol RecallRefButton
			Fields:		TypeName				Button
						Position				RecallLastButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRecallRef.tif~
						DActionsText			ACTION EXEC ( <This>.RecallReference() )
						ToolTip					~Recall reference image~
						IsTabStop				F;

	Define: MakeRefButton Using DDWinCtrlDef AsSymbol MakeRefButton
			Fields:		TypeName				Button
						Position				RecallRefButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWMakeRef.tif~
						DActionsText			ACTION EXEC ( <This>.MakeReference() )
						ToolTip					~Make current image a reference image~
						IsTabStop				F;

		Define: Seperator6 Using DDWinCtrlDef AsSymbol Seperator6
			Fields:		TypeName				StaticText
						Position				MakeRefButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ResetButton Using DDWinCtrlDef AsSymbol ResetButton
			Fields:		TypeName				Button
						Position				MakeRefButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWReset.tif~
						DActionsText			ACTION EXEC ( <This>.ResetSelectedCorrections() )
						ToolTip					~Reset corrections~
						IsTabStop				F;

		Define: Seperator7 Using DDWinCtrlDef AsSymbol Seperator7
			Fields:		TypeName				StaticText
						Position				ResetButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ApplyToAllButton Using DDWinCtrlDef AsSymbol ApplyToAllButton
			Fields:		TypeName				Button
						Position				ResetButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWAll.tif~
						DActionsText			ACTION EXEC ( <This>.StartApplyToAll() )
						ToolTip					~Apply current corrections to all images~
						IsTabStop				F;

		Define: Seperator8 Using DDWinCtrlDef AsSymbol Seperator8
			Fields:		TypeName				StaticText
						Position				ApplyToAllButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: AutoDRGBButton Using DDWinCtrlDef AsSymbol AutoDRGBButton Private
			Fields:		GENCONNAME				THIS
						DACTIONSTEXT			ACTION EXEC ( <THIS>.SetAutoBalMode(0,0,0,TRUE); <THIS>.OnAutoBalance(TRUE)  )
						POSITION				ApplyToAllButton(GetRight,Position) + <ToolbarGap>, OpenButton(GetTop,Position), <ToolbarW> + 7, <ToolbarH>
						TEXT					~DRGB~
						TOOLTIP					~Automatically calculate the DRGB balance~
						TYPENAME				BUTTON;

	Define: AutoDenButton Using DDWinCtrlDef AsSymbol AutoDenButton Private
			Fields:		GENCONNAME				THIS
						DACTIONSTEXT			ACTION EXEC ( <THIS>.SetAutoBalMode(16,0,0,TRUE); <THIS>.OnAutoBalance(TRUE)  )
						POSITION				AutoDRGBButton(GetRight,Position), OpenButton(GetTop,Position), <ToolbarW>, <ToolbarH>
						TEXT					~Den~
						TOOLTIP					~Automatically calculate the Density balance~
						TYPENAME				BUTTON;

	Define: AutoRGBButton Using DDWinCtrlDef AsSymbol AutoRGBButton Private
			Fields:		GENCONNAME				THIS
						DACTIONSTEXT			ACTION EXEC ( <THIS>.SetAutoBalMode(1,0,0,TRUE); <THIS>.OnAutoBalance(TRUE)  )
						POSITION				AutoDenButton(GetRight,Position), OpenButton(GetTop,Position), <ToolbarW>, <ToolbarH>
						TEXT					~RGB~
						TOOLTIP					~Automatically calculate the RGB balance~
						TYPENAME				BUTTON;

		Define: Seperator9 Using DDWinCtrlDef AsSymbol Seperator9
			Fields:		TypeName				StaticText
						Position				AutoRGBButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: FullViewButton Using DDWinCtrlDef AsSymbol FullViewButton
			Fields:		TypeName				Button
						Position				AutoRGBButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWFull.tif~
						DActionsText			ACTION EXEC ( ChangeView( 0 ) )
						ToolTip					~Display full view~
						IsTabStop				F;

	Define: LightTableButton Using DDWinCtrlDef AsSymbol LightTableButton
			Fields:		TypeName				Button
						Position				FullViewButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWLight.tif~
						DActionsText			ACTION EXEC ( <This>.SetToolbarState() )
						ToolTip					~Light table mode~
						IsTabStop				F;

		Define: Seperator10 Using DDWinCtrlDef AsSymbol Seperator10
			Fields:		TypeName				StaticText
						Position				LightTableButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ModeButton Using DDWinCtrlDef AsSymbol ModeButton
			Fields:		TypeName				Button
						Position				LightTableButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWMode.tif~
						DActionsText			ACTION EXEC ( <This>.ToggleWheelman() )
						ToolTip					~Change correction mode~
						IsTabStop				F;

		Define: Seperator11 Using DDWinCtrlDef AsSymbol Seperator11
			Fields:		TypeName				StaticText
						Position				ModeButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: RawButton Using DDWinCtrlDef AsSymbol RawButton
			Fields:		TypeName				Button
						Position				ModeButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRaw.tif~
						DActionsText			ACTION DOC ( DigitalCameraDoc OpenOnce "DigitalCameraDoc" )
						ToolTip					~Launch digital camera conversion tool~
						IsTabStop				F;

	if ( <DP2> )
	{
		Define: Seperator12 Using DDWinCtrlDef AsSymbol Seperator12
			Fields:		TypeName				StaticText
						Position				RawButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: OptionsButton Using DDWinCtrlDef AsSymbol OptionsButton
			Fields:		TypeName				Button
						Position				RawButton(GetRight, Position) + <ToolbarGap>, RawButton(GetTop, Position),
												<ToolbarW>+20, <ToolbarH>
						//ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRaw.tif~
						DActionsText			ACTION EXEC ( EditOptions() )
						ToolTip					~Change the analyzer options~
						Text					~Options~
						IsTabStop				F;

		Define: Seperator13 Using DDWinCtrlDef AsSymbol Seperator13
			Fields:		TypeName				StaticText
						Position				OptionsButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: KeepLastCorrectionsCheckBox Using DDWinCtrlDef AsSymbol KeepLastCorrectionsCheckBox
			Fields:		TypeName				CheckBox
						Position				OptionsButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												120, <ToolbarH>
						DActionsText			ACTION EXEC ( SetKeepLastCorrection() )
						Text					~Keep Last Correction~
						ToolTip					~When checked, retains the correction values when you press Print or No Print~
						IsTabStop				F;
	}
	else
	{
		Define: Seperator12 Using DDWinCtrlDef AsSymbol Seperator12
			Fields:		TypeName				StaticText
						Position				RawButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: KeepLastCorrectionsCheckBox Using DDWinCtrlDef AsSymbol KeepLastCorrectionsCheckBox
			Fields:		TypeName				CheckBox
						Position				RawButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												120, <ToolbarH>
						DActionsText			ACTION EXEC ( SetKeepLastCorrection() )
						Text					~Keep Last Correction~
						ToolTip					~When checked, retains the correction values when you press Print or No Print~
						IsTabStop				F;
	}

//	ScreenWidth = App( thisApp, MainWindow, GetClientWidth ) - 4;
//	ScreenHeight = App( thisApp, MainWindow, GetClientHeight ) - 4;

	Define: Filler1 Using DDWinCtrlDef AsSymbol Filler1 Private
			Fields:		TypeName				StaticText
						Position				KeepLastCorrectionsCheckBox(GetRight, Position), OpenButton(GetTop, Position),
												$ScreenWidth - KeepLastCorrectionsCheckBox(GetRight, Position), <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ToolBarLine1 Using DDWinCtrlDef AsSymbol ToolBarLine1 Private
			Fields:		TypeName				StaticText
						Position				0, 0, $ScreenWidth, 1
						BGColorRed				255, BGColorBlue 255, BGColorGreen 255;

	Define: ToolBarLine2 Using DDWinCtrlDef AsSymbol ToolBarLine2 Private
			Fields:		TypeName				StaticText
						Position				0, 1, $ScreenWidth, 3
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ToolBarLine3 Using DDWinCtrlDef AsSymbol ToolBarLine3 Private
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetBottom, Position), $ScreenWidth, 3
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ToolBarLine4 Using DDWinCtrlDef AsSymbol ToolBarLine4 Private
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetBottom, Position) + 3, $ScreenWidth, 1
						BGColorRed				128, BGColorBlue 128, BGColorGreen 128;

	Define: ToolBarLine5 Using DDWinCtrlDef AsSymbol ToolBarLine5 Private
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetBottom, Position) + 4, $ScreenWidth, 1
						BGColorRed				0, BGColorBlue 0, BGColorGreen 0;

	if ( DefinedAndNotNull( LeftRight) )
	{
		Define: ReferenceImage Using DDWinCtrlDef AsSymbol ReferenceImage Private 
			Fields:		TypeName					StaticText
						Position					0, $ScreenHeight - 255, 176, 220
						Tooltip						Translate( ~Reference Image~ )
						BGColorRed					<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
						RClickDnActionsText			ACTION EXEC ( <This>.RefContextMenu() )
						DoubleClickActionsText		ACTION EXEC ( <This>.RecallReference() );
	}
	else
	{
		Define: ReferenceImage Using DDWinCtrlDef AsSymbol ReferenceImage Private 
			Fields:		TypeName					StaticText
						Position					$ScreenWidth - 250, OpenButton(GetBottom, Position) + 5, 250, 200
						Tooltip						Translate( ~Reference Image~ )
						BGColorRed					<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
						RClickDnActionsText			ACTION EXEC ( <This>.RefContextMenu() )
						DoubleClickActionsText		ACTION EXEC ( <This>.RefContextMenu() );
	}

	Define: RefreshButton Using DDWinCtrlDef AsSymbol RefreshButton Private
			Fields:		TypeName			Button
						Position			ReferenceImage(GetLeft, Position) - 100, ReferenceImage(GetBottom, Position) - 25,
											100, 25
						DActionsText		ACTION EXEC ( <This>.RefreshThumbNailView(); )
						Text				Translate( ~Refresh View~ );
}


/*************************************************
 *************** Mnemonic controls ***************
 *************************************************/

VOID LightTable::AddPromptControls()
{
	AddPromptControl( ~<pNum0>~ );
	AddPromptControl( ~<pNum1>~ );
	AddPromptControl( ~<pNum2>~ );
	AddPromptControl( ~<pNum3>~ );
	AddPromptControl( ~<pNum4>~ );
	AddPromptControl( ~<pNum5>~ );
	AddPromptControl( ~<pNum6>~ );
	AddPromptControl( ~<pNum7>~ );
	AddPromptControl( ~<pNum8>~ );
	AddPromptControl( ~<pNum9>~ );
	AddPromptControl( ~<pNum0_2>~ );
	AddPromptControl( ~<pNum1_2>~ );
	AddPromptControl( ~<pNum2_2>~ );
	AddPromptControl( ~<pNum3_2>~ );
	AddPromptControl( ~<pNum4_2>~ );
	AddPromptControl( ~<pNum5_2>~ );
	AddPromptControl( ~<pNum6_2>~ );
	AddPromptControl( ~<pNum7_2>~ );
	AddPromptControl( ~<pNum8_2>~ );
	AddPromptControl( ~<pNum9_2>~ );
	AddPromptControl( ~<pDensity>~ );
	AddPromptControl( ~<pDensity2>~ );
	AddPromptControl( ~<pThumbUp>~ );
	AddPromptControl( ~<pThumbDown>~ );
	AddPromptControl( ~<pRed>~ );
	AddPromptControl( ~<pRed2>~ );
	AddPromptControl( ~<pGreen>~ );
	AddPromptControl( ~<pGreen2>~ );
	AddPromptControl( ~<pBlue>~ );
	AddPromptControl( ~<pBlue2>~ );
	AddPromptControl( ~<pPrint>~ );
	AddPromptControl( ~<pNoPrint>~ );
	AddPromptControl( ~<pNext>~ );
	AddPromptControl( ~<pPrev>~ );
	AddPromptControl( ~<pNext2>~ );
	AddPromptControl( ~<pPrev2>~ );
	AddPromptControl( ~<pMode>~ );
	AddPromptControl( ~<pViewMode>~ );
	AddPromptControl( ~<pMakeRef>~ );
	AddPromptControl( ~<pRecallRef>~ );
	AddPromptControl( ~<pRotate90>~ );
	AddPromptControl( ~<pRotate180>~ );
	AddPromptControl( ~<pRotate270>~ );
	AddPromptControl( ~<pStore>~ );
	AddPromptControl( ~<pRecall>~ );
	AddPromptControl( ~<pRecallLast>~ );
	AddPromptControl( ~<pApplyAll>~ );
	AddPromptControl( ~<pOpen>~ );
	AddPromptControl( ~<pReset>~ );
	AddPromptControl( ~<pPlus>~ );
	AddPromptControl( ~<pMinus>~ );
	AddPromptControl( ~<pAutoBal>~ );
	AddPromptControl( ~<pViewChanges>~ );
}

VOID LightTable::AddPromptControl( Character )
{
	NewCharacter = ~<Character>~;
	if ( ~<Character>~ == ~<pDensity>~ )
	{
		NewCharacter = ~01~;
	}
	else if ( ~<Character>~ == ~<pDensity2>~ )
	{
		NewCharacter = ~02~;
	}
	else if ( ~<Character>~ == ~<pPrint>~ )
	{
		NewCharacter = ~03~;
	}
	else if ( ~<Character>~ == ~<pNoPrint>~ )
	{
		NewCharacter = ~04~;
	}
	else if ( ~<Character>~ == ~<pNext>~ )
	{
		NewCharacter = ~05~;
	}
	else if ( ~<Character>~ == ~<pPrev>~ )
	{
		NewCharacter = ~06~;
	}
	else if ( ~<Character>~ == ~<pNext2>~ )
	{
		NewCharacter = ~07~;
	}
	else if ( ~<Character>~ == ~<pPrev2>~ )
	{
		NewCharacter = ~08~;
	}
	else if ( ~<Character>~ == ~<pMode>~ )
	{
		NewCharacter = ~09~;
	}
	else if ( ~<Character>~ == ~<pPlus>~ )
	{
		NewCharacter = ~10~;
	}
	else if ( ~<Character>~ == ~<pMinus>~ )
	{
		NewCharacter = ~11~;
	}
	else if ( ~<Character>~ == ~<pViewMode>~ )
	{
		NewCharacter = ~12~;
	}
	else if ( ~<Character>~ == ~<pNum0_2>~ )
	{
		NewCharacter = ~13~;
	}
	else if ( ~<Character>~ == ~<pNum1_2>~ )
	{
		NewCharacter = ~14~;
	}
	else if ( ~<Character>~ == ~<pNum2_2>~ )
	{
		NewCharacter = ~15~;
	}
	else if ( ~<Character>~ == ~<pNum3_2>~ )
	{
		NewCharacter = ~16~;
	}
	else if ( ~<Character>~ == ~<pNum4_2>~ )
	{
		NewCharacter = ~17~;
	}
	else if ( ~<Character>~ == ~<pNum5_2>~ )
	{
		NewCharacter = ~18~;
	}
	else if ( ~<Character>~ == ~<pNum6_2>~ )
	{
		NewCharacter = ~19~;
	}
	else if ( ~<Character>~ == ~<pNum7_2>~ )
	{
		NewCharacter = ~20~;
	}
	else if ( ~<Character>~ == ~<pNum8_2>~ )
	{
		NewCharacter = ~21~;
	}
	else if ( ~<Character>~ == ~<pNum9_2>~ )
	{
		NewCharacter = ~22~;
	}
	else if ( ~<Character>~ == ~<pThumbUp>~ )
	{
		NewCharacter = ~23~;
	}
	else if ( ~<Character>~ == ~<pThumbDown>~ )
	{
		NewCharacter = ~24~;
	}
//	else if ( ~<Character>~ == ~<pAutoBal>~ )
//	{
//		NewCharacter = ~25~;
//	}

	// Special handling for ( and ) because these characters embedded in an action will cause us
	// major problems in parsing the action.
	if ( ~<Character>~ == ~<pNum9_2>~ )
	{
		if ( <ShowButtonsForDebug> ) 
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							Position			<xAmountLightTable>,50,15,25
							DActionsText		ACTION EXEC ( <This>.OnLeftParenButton() )
							Text				Translate( ~&<Character>~ );
		}
		else
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							DActionsText		ACTION EXEC ( <This>.OnLeftParenButton() )
							Text				Translate( ~&<Character>~ );
		}
	}
	else if ( ~<Character>~ == ~<pNum0_2>~ )
	{
		if ( <ShowButtonsForDebug> )
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							Position			<xAmountLightTable>,50,15,25
							DActionsText		ACTION EXEC ( <This>.OnRightParenButton() )
							Text				Translate( ~&<Character>~ );
		}
		else
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							DActionsText		ACTION EXEC ( <This>.OnRightParenButton() )
							Text				Translate( ~&<Character>~ );
		}
	}
	else if ( ~<Character>~ == ~<pAutoBal>~ )
	{
			Define: AutoBalShortcutButton Using DDWinCtrlDef AsSymbol AutoBalShortcutButton 
					Fields: TypeName		Button
							Text			Translate( ~&x~ )
							TOOLTIP			~Auto Balance the image for DRGB (x), Density only (Shift-X) or Color Only (Alt-X).~
							DActionsText	ACTION EXEC ( <THIS>.SetAutoBalMode(0,KeyState( SHIFT ) ? 1 : 0, KeyState( ALT ) ? 1 : 0, FALSE); <THIS>.OnAutoBalance(TRUE) ) ;
	}
	else if ( ~<Character>~ == ~<pViewChanges>~ )
	{
			Define: ViewChangesShortcutButton Using DDWinCtrlDef AsSymbol ViewChangesShortcutButton 
					Fields: TypeName		Button
							Text			Translate( ~&q~ )
							TOOLTIP			~View the image before and after~
							DActionsText	ACTION EXEC ( <This>.OnButton( ~<Character>~ ) ) ;
	}
	else
	{
		if ( <ShowButtonsForDebug> )
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							Position			<xAmountLightTable>,50,15,25
							DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
							Text				Translate( ~&<Character>~ );
		}
		else
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
							Text				Translate( ~&<Character>~ );
		}
	}

	xAmountLightTable = <xAmountLightTable> + 20;

}

VOID LightTable::OnLeftParenButton()
{
	OnButton( ~(~ );
}

VOID LightTable::OnRightParenButton()
{
	OnButton( ~)~ );
}

VOID LightTable::OnButton( Value )	// This function controls all mnemonic buttons
{
	State = KeyState( Shift );
	altState = KeyState( Alt );

	if ( !DefinedAndNotNull( LastOrderID ) )
	{
		OnSimilarStr( ~<Value>~,
			~<pMode>~,		<State> ? ~ChangeView( 0 )~ : ~<This>.ToggleWheelman()~ ,
			~<pViewMode>~, ~ChangeView( 0 )~ ,
			~<pRecallRef>~,	~<This>.RecallReference()~,
			~<pOpen>~,		~OpenAnOrder()~ );
		return;
	}

	OnSimilarStr( ~<Value>~,
		~<pNum0>~,		~SaveChangeFactor( 0 )~,
		~<pNum1>~,		~SaveChangeFactor( 1 )~,
		~<pNum2>~,		~SaveChangeFactor( 2 )~,
		~<pNum3>~,		~SaveChangeFactor( 3 )~,
		~<pNum4>~,		~SaveChangeFactor( 4 )~,
		~<pNum5>~,		~SaveChangeFactor( 5 )~,
		~<pNum6>~,		~SaveChangeFactor( 6 )~,
		~<pNum7>~,		~SaveChangeFactor( 7 )~,
		~<pNum8>~,		~SaveChangeFactor( 8 )~,
		~<pNum9>~,		~SaveChangeFactor( 9 )~,
		~<pNum0_2>~,	~SaveChangeFactor( 0 )~,
		~<pNum1_2>~,	~SaveChangeFactor( 1 )~,
		~<pNum2_2>~,	~SaveChangeFactor( 2 )~,
		~<pNum3_2>~,	~SaveChangeFactor( 3 )~,
		~<pNum4_2>~,	~SaveChangeFactor( 4 )~,
		~<pNum5_2>~,	~SaveChangeFactor( 5 )~,
		~<pNum6_2>~,	~SaveChangeFactor( 6 )~,
		~<pNum7_2>~,	~SaveChangeFactor( 7 )~,
		~<pNum8_2>~,	~SaveChangeFactor( 8 )~,
		~<pNum9_2>~,	~SaveChangeFactor( 9 )~,
		~<pDensity>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( 1 ) )~,
		~<pDensity2>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( -1 ) )~,
		~<pThumbUp>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( 1 ) )~,
		~<pThumbDown>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( -1 ) )~,
		~<pRed>~,		~<This>.OnRedButton( <This>.GetChangeAmount( 1 ) )~,
		~<pRed2>~,		~<This>.OnRedButton( <This>.GetChangeAmount( -1 ) )~,
		~<pGreen>~,		~<This>.OnGreenButton( <This>.GetChangeAmount( 1 ) )~,
		~<pGreen2>~,	~<This>.OnGreenButton( <This>.GetChangeAmount( -1 ) )~,
		~<pBlue>~,		~<This>.OnBlueButton( <This>.GetChangeAmount( 1 ) )~,
		~<pBlue2>~,		~<This>.OnBlueButton( <This>.GetChangeAmount( -1 ) )~,
		~<pPrint>~,		~<This>.AcceptImageEdits( 0 )~,
		~<pNoPrint>~,	~<This>.AcceptImageEdits( 1 )~,
		~<pNext>~,		~<This>.OnNextButton()~,
		~<pPrev>~,		~<This>.OnPrevButton()~,
		~<pNext2>~,		~<This>.OnNextButton()~,
		~<pPrev2>~,		~<This>.OnPrevButton()~,
		~<pMode>~,		<State> ? ~ChangeView( 0 )~ : ~<This>.ToggleWheelman()~ ,
		~<pViewMode>~,	~ChangeView( 0 )~ ,
		~<pMakeRef>~,	~<This>.MakeReference()~,
		~<pRecallRef>~,	~<This>.RecallReference()~,
		~<pRotate90>~,	~<This>.RotateImages( 90 )~,
		~<pRotate180>~,	~<This>.RotateImages( 180 )~,
		~<pRotate270>~,	~<This>.RotateImages( 270 )~,
		~<pStore>~,		~<This>.StoreCorrection()~,
		~<pRecall>~,	~<This>.RecallCorrection()~,
		~<pRecallLast>~,~ApplyLastCorrection()~,
		~<pApplyAll>~,	~<This>.StartApplyToAll()~,
		~<pOpen>~,		~OpenAnOrder()~,
		~<pReset>~,		~<This>.ResetSelectedCorrections()~ );
		
		OnSimilarStr( ~<Value>~,
		~<pPlus>~,		~<This>.ChangeThumbnailSize( TRUE )~,
		~<pMinus>~,		~<This>.ChangeThumbnailSize( FALSE )~,
		~<pAutoBal>~,	~<This>.SetAutoBalMode(0,<State>, <altState>, FALSE); <THIS>.OnAutoBalance(TRUE)~ );
}


/******************************************************
 *************** Menu/toolbar functions ***************
 ******************************************************/


VOID LightTable::StoreCorrection()
{
	View( GetControlTitle, DensityText, Density );
	View( GetControlTitle, RedText, Red );
	View( GetControlTitle, GreenText, Green );
	View( GetControlTitle, BlueText, Blue );
	View( GetControlTitle, ContrastText, Contrast );
	View( GetControlTitle, SaturationText, Saturation );
	View( GetControlTitle, GammaText, Gamma );

	ImageWindow( EnableWindow, FALSE );
	DisableWheelman();

	CurDensity = <Density>;
	Global( CurDensity );

	CurRed = <Red>;
	Global( CurRed );

	CurGreen = <Green>;
	Global( CurGreen );

	CurBlue = <Blue>;
	Global( CurBlue );

	CurContrast = <Contrast>;
	Global( CurContrast );

	CurSaturation = <Saturation>;
	Global( CurSaturation );

	CurGamma = <Gamma>;
	Global( CurGamma);

	AnalyzerView.StoreCorrection();
}

VOID LightTable::RecallCorrection()
{
	RecallCorrections();
}

VOID LightTable::ApplyCorrections( Density, Red, Green, Blue, Contrast, Saturation, Gamma )
{
	if ( ThumbView( GetSelected, SelectedImages ) )
	{
		FirstImage = TRUE;
		while ( SelectedImages( GetNext,Image ) )
		{
			ApplySingleCorrection( <Density>, <Red>, <Green>, <Blue>, <Contrast>, <Saturation>, <Gamma>, ~<$con.Image[Path]>~, <FirstImage> );
			FirstImage = FALSE;
		}
	}
}

VOID LightTable::ApplySingleCorrection( Density, Red, Green, Blue, Contrast, Saturation, Gamma, Path, FirstImage )
{
	Found = FALSE;

	InitCorrections();

	if ( ~<Path>~ != ~~ && ImageCorrections(GetCurrentCorrections, ~<Path>~, Corrections ) )
	{
		NewDensity = <Density> - Corrections( GetNumeric, orgDensity );
		NewRed = <Red> - Corrections( GetNumeric, orgRed );
		NewGreen = <Green> - Corrections( GetNumeric, orgGreen );
		NewBlue = <Blue> - Corrections( GetNumeric, orgBlue );
		NewContrast = <Contrast> - Corrections( GetNumeric, orgContrast );
		NewSaturation = <Saturation> - Corrections( GetNumeric, orgSaturation );
		NewGamma = <Gamma> - Corrections( GetNumeric, orgGamma );

		ImageEditData( SetValue, cDensity, <NewDensity> );
		ImageEditData( SetValue, cRed, <NewRed> );
		ImageEditData( SetValue, cGreen, <NewGreen> );
		ImageEditData( SetValue, cBlue, <NewBlue> );
		ImageEditData( SetValue, cContrast, <NewContrast> );
		ImageEditData( SetValue, cSaturation, <NewSaturation> );
		ImageEditData( SetValue, cGamma, <NewGamma> );

		ImageEditData( UpdateCorrections, ~<Path>~ );
		if ( <FirstImage> )
		{
			UpdateColorValues(TRUE);
		}
	}
}

VOID LightTable::ApplySingleDRGBCorrection( Density, Red, Green, Blue, Path, FirstImage )
{
	Found = FALSE;

	InitCorrections();

	if ( ~<Path>~ != ~~ && ImageCorrections(GetCurrentCorrections, ~<Path>~, Corrections ) )
	{
		NewDensity = <Density> - Corrections( GetNumeric, orgDensity );
		NewRed = <Red> - Corrections( GetNumeric, orgRed );
		NewGreen = <Green> - Corrections( GetNumeric, orgGreen );
		NewBlue = <Blue> - Corrections( GetNumeric, orgBlue );

		ImageEditData( SetValue, cDensity, <NewDensity> );
		ImageEditData( SetValue, cRed, <NewRed> );
		ImageEditData( SetValue, cGreen, <NewGreen> );
		ImageEditData( SetValue, cBlue, <NewBlue> );
		ImageEditData( SetValue, AutoBalanceDone, TRUE );

		ImageEditData( UpdateCorrections, ~<Path>~ );
		if ( <FirstImage> )
		{
			UpdateColorValues(TRUE);
		}
	}
}

VOID LightTable::StartApplyToAll()
{
	if ( KeyState( Shift ) )
	{
		RefreshThumbNailView();
		return;
	}

	if ( ThumbView( GetSelected, SelectedImages ) )
	{
		if ( SelectedImages( ChildCount ) > 0 )
		{
			ImageWindow( EnableWindow, FALSE );
			ForgetGlobal( Wheelman );

			AnalyzerView.StartApplyAll();
		}
		else
		{
			Warning( Translate( ~Please select an image.~ ) );
		}
	}
	else
	{
		Warning( Translate( ~Please select an image.~ ) );
	}
}

VOID LightTable::CheckCorrection( OldValue, &NewValue, ValueRange )
{
	TempValue = 0;
	if ( <OldValue> + <NewValue> > <ValueRange> )
	{
		TempValue = <ValueRange> - <OldValue> - <NewValue>;
	}
	else
	{
		if ( <ValueRange> == <GammaRange> )
		{
			ValueRange = 0.0;
		}

		if ( <OldValue> + <NewValue> < -<ValueRange> )
		{
			TempValue = 0 - <ValueRange> - <OldValue> - <NewValue>;
		}
	}

	NewValue += <TempValue>;
}

VOID LightTable::ApplyAll( Value )
{
	OldImagePath = ~~;
	if ( ThumbView( GetSelected, ImageList ) )
	{
		if ( !ImageList( GetFirst, Image ) )
		{
			return;
		}
		OldImagePath = ~<$con.Image[Path]>~;
	}
	else
	{
		return;
	}

	View( GetControlTitle, DensityText, Density );
	View( GetControlTitle, RedText, Red );
	View( GetControlTitle, GreenText, Green );
	View( GetControlTitle, BlueText, Blue );
	View( GetControlTitle, ContrastText, Contrast );
	View( GetControlTitle, SaturationText, Saturation );
	View( GetControlTitle, GammaText, Gamma );

	InitCorrections();

	if ( ThumbView( GetAll, ImageList ) )
	{
		while ( ImageList( GetNext, Image ) )
		{
			StatusBarText( ~Updating <$con.Image[OrderID]>/<$con.Image[Roll]>/<$con.Image[Frame]>~ );

			if ( ImageCorrections( GetCurrentCorrections, ~<$con.Image[Path]>~, Corrections ) )
			{
				if ( <Value> == 1 )
				{
					NewDensity = MakeNumber( ~<Density>~ );
					CheckCorrection( Corrections( GetNumeric, orgDensity ), NewDensity, <CorrRange> );
					NewRed = MakeNumber( ~<Red>~ );
					CheckCorrection( Corrections( GetNumeric, orgRed ), NewRed, <CorrRange> );
					NewGreen = MakeNumber( ~<Green>~ );
					CheckCorrection( Corrections( GetNumeric, orgGreen ), NewGreen, <CorrRange> );
					NewBlue = MakeNumber( ~<Blue>~ );
					CheckCorrection( Corrections( GetNumeric, orgBlue ), NewBlue, <CorrRange> );
					NewContrast = MakeNumber( ~<Contrast>~ );
					CheckCorrection( Corrections( GetNumeric, orgContrast ), NewContrast, <AltCorrRange> );
					NewSaturation = MakeNumber( ~<Saturation>~ );
					CheckCorrection( Corrections( GetNumeric, orgSaturation ), NewSaturation, <AltCorrRange> );
					NewGamma = MakeNumber( ~<Gamma>~ );
					NewGamma = <NewGamma> - 1.0;
					CheckCorrection( Corrections( GetNumeric, orgGamma ), NewGamma, <GammaRange> );
				}
				else
				{
					NewDensity = 0 - Corrections( GetNumeric, orgDensity ) + <Density>;
					NewRed = 0 - Corrections( GetNumeric, orgRed ) + <Red>;
					NewGreen = 0 - Corrections( GetNumeric, orgGreen ) + <Green>;
					NewBlue = 0 - Corrections( GetNumeric, orgBlue ) + <Blue>;
					NewContrast = 0 - Corrections( GetNumeric, orgContrast ) + <Contrast>;
					NewSaturation = 0 - Corrections( GetNumeric, orgSaturation ) + <Saturation>;
					NewGamma = 0.0 - Corrections( GetNumeric, orgGamma ) + <Gamma>;
				}

				// Set values
				ImageEditData( SetValue, cDensity, <NewDensity> );
				ImageEditData( SetValue, cRed, <NewRed> );
				ImageEditData( SetValue, cGreen, <NewGreen> );
				ImageEditData( SetValue, cBlue, <NewBlue> );
				ImageEditData( SetValue, cContrast, <NewContrast> );
				ImageEditData( SetValue, cSaturation, <NewSaturation> );
				ImageEditData( SetValue, cGamma, <NewGamma> );
				ImageEditData( UpdateCorrections, ~<$con.Image[Path]>~ );
				ImageEditData( SaveCorrections, ~<$con.Image[Path]>~ );

				
				if ( ImageCorrections( GetCurrentCorrections, ~<$con.Image[Path]>~, Corrections ) )
				{
					LogDensity = Corrections( GetNumeric, orgDensity );
					LogRed = Corrections( GetNumeric, orgRed );
					LogGreen = Corrections( GetNumeric, orgGreen );
					LogBlue = Corrections( GetNumeric, orgBlue );
					LogContrast = Corrections( GetNumeric, orgContrast );
					LogSaturation = Corrections( GetNumeric, orgSaturation );
					LogGamma = Corrections( GetNumeric, orgGamma );

					if ( ~<OldImagePath>~ == ~<$con.Image[Path]>~ )
					{
						gOldDensity = <LogDensity>;
						gOldRed = <LogRed>;
						gOldGreen = <LogGreen>;
						gOldBlue = <LogBlue>;
						gOldContrast = <LogContrast>;
						gOldSaturation = <LogSaturation>;
						gOldGamma = <LogGamma>;
					}

					// Log image accept
					Line = ~<$con.Image[OrderID]>,<$con.Image[Roll]>,<$con.Image[Frame]>,<LogDensity>,<LogRed>~;
					Line = ~<Line>,<LogGreen>,<LogBlue>,<LogContrast>,<LogSaturation>,<LogGamma>~;
					Line = ~<Line>,<$con.Image[RotateFromDisk]>,<$con.Image[Rejected]>,<$Date.%Y%m%d%H%M%S>~;
					++TotalImageEdits;
					LogImageEdit( ~<Line>~ );
				}
			}
		}
	}

	StatusBarText( ~Complete~ );
	
	ImageEditData( SetValues, cDensity, 0, cRed, 0, cGreen, 0, cBlue, 0, cContrast, 0, cSaturation, 0, cGamma, 0.0);
	UpdateColorValues(TRUE);
}


VOID LightTable::SetAutoBalMode( level, shiftState, altState, FromButton )
{
	if ( <FromButton> )
	{
		ImageEditData( SetValues,SBALevel,~<level>~ );
	}
	else
	{
		if ( <shiftState> )	// Density
		{
			ImageEditData( SetValues,SBALevel,16 );
		}
		else if ( <altState> ) // RGB
		{
			ImageEditData( SetValues,SBALevel,1 );
		}
		else 		// DRGB
		{
			ImageEditData( SetValues,SBALevel,0 );
		}
	}

	ExtSbaLevel = ImageEditData( GetNumeric, SBALevel );
}


NUMERIC LightTable::OnAutoBalance( FromButton )		// Vectors here when the Auto Bal button is pressed  HOLLY
{
	ReturnOnFailure( ThumbView( GetSelected, SelectedImages ) );

	count = SelectedImages( ChildCount );

	if ( <count> == 0 || <count> > 1 )
	{
		return Warning( Translate(~You should select the one image you wish to auto balance~ ) );
	}

	if ( ~<ExtAutoBalPreference>~ == ~~ )
	{
		msg = ~An Auto Balance Preference file must be selected from the Options.~;
		return Warning( Translate( ~<msg>~ ) );
	}

	WaitCursor( Begin );
	moreImages = SelectedImages( GetNext, Item );

	if ( !<FromButton> )
	{
		Query = ~SELECT AutoBalance From Images Where OrderID = '<$con.Item[OrderID]>' AND Roll = '<$con.Item[Roll]>' AND Frame = '<$con.Item[Frame]>'~;
		ADO( dBase,Connect,GetValuesFor,~<Query>~,AutoBalFlag );
		
		if ( ~<AutoBalFlag>~ != ~1~ )
		{
			return FALSE;
		}
	}

	SbaInit();

	if ( <moreImages> )
	{
		result = FALSE;

		Order = ~<$con.Item[OrderID]>~;
		Roll  = ~<$con.Item[Roll]>~;
		Frame = ~<$con.Item[Frame]>~;
		Path  = ~<$con.Item[Path]>~;
		ICCProfile = ~<$con.Item[ICCProfile]>~;

		thumbnailImage = ~~;
		embeddedProfile = ~~;
		embeddedProfileChecked = FALSE;

		den		= 0;
		red		= 0;
		green	= 0;
		blue	= 0;

		ThumbView( GetThumbnailImage,~<Path>~,thumbnailImage,embeddedProfile );
		embeddedProfileChecked = TRUE;

		result = DImageSba.BalanceImage( thumbnailImage,~<ExtAutoBalPreference>~,<ExtSbaLevel>,
										~<Order>~,~<Roll>~,~<Frame>~,~<Path>~,~<ICCProfile>~,
										~<embeddedProfile>~,~<embeddedProfileChecked>~ );

		if ( <result> )
		{
			DImageSba.GetSbaSliders( den,red,green,blue );
			ApplySingleDRGBCorrection( ~<den>~,~<red>~,~<green>~,~<blue>~,~<Path>~,TRUE );
		}
		moreImages = FALSE;
	}

	WaitCursor( End );

	return TRUE;
}


VOID LightTable::RecallReference()
{
	ImageWindow( EnableWindow, FALSE );
	ForgetGlobal( Wheelman );

	RecallTheReference();
}

NUMERIC LightTable::ShowReferenceImage( RefImage2, RefPath )
{
	ReturnOnSuccess( IsNull( ~<RefPath>~ ) );

	RefImage = ~<RefImage2>~;	// Save the reference image name
	DataView( SetControlImageFilePath, ReferenceImage, ~<RefPath>~ );
	LastRefPath = ~<RefPath>~;

	return TRUE;
}

VOID LightTable::MakeReference()
{
	if ( ThumbView( GetSelected, SelectedImages ) )
	{
		if ( SelectedImages( ChildCount ) == 1 )
		{
			SelectedImages( GetFirst, Image );
			ImagePath = ~<$con.Image[Path]>~;
			FileName = ~<$Str.$ImagePath.Filename.WithoutExt>~;

			AddReference( ~<FileName>~, ~<ImagePath>~ );
		}
		else if (SelectedImages( ChildCount ) == 0 )
		{
			Warning( Translate( ~Please select an image.~ ) );
		}
		else
		{
			Warning( Translate( ~Only one image at a time can be made a reference image.~ ) );
		}
	}
	else
	{
		Warning( Translate( ~Please select an image.~ ) );
	}
}

NUMERIC LightTable::AddThumbnail()
{
	if ( !ThumbView( GetSelected, SelectedImages ) )
	{
		return Warning( ~There were no images selected.~ );
	}

	size = ~<$SystemSettings.Thumbnail[Size]>~;
	compressionQuality = ~<$SystemSettings.Thumbnail[Quality]>~;

	size = IsNULL( ~<size>~ ) ? ~500~ : ~<size>~;
	compressionQuality = IsNULL( ~<compressionQuality>~ ) ? ~100~ : ~<compressionQuality>~;

	Count = SelectedImages( ChildCount );

	if ( MessageBox( Translate(~Are you sure you want to add thumbnail images to the <Count> selected images? ~),YESNO ) == NO )
	{
		return TRUE;
	}

	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate(~Could not connect to the database. <theErr>~) );
	}

	WaitCursor( Begin );

	while ( SelectedImages( GetNext,Image ) )
	{
		BroadcastMessageToAllViews( ReleaseImageChain,~<$con.Image[Path]>~ );
		CloseWindowOfPath( ~<$con.Image[Path]>~ );

		FileType = ~~; Width = Length = PreviewWidth = PreviewLength = 0;

		if ( !IsNull(~<$con.Image[Path]>~) )
		{
			if ( AddThumbNailToImage( ~<$con.Image[Path]>~,<size>,<compressionQuality>,FileType,Width,Length,PreviewWidth,PreviewLength ) > 0 )
			{ 
				Key = STR ( OrderID = '<$con.Image[OrderID]>' AND Roll = '<$con.Image[Roll]>' AND Frame = '<$con.Image[Frame]>' );

				SizeFields	= ~Width=<Width>,PreviewWidth=<PreviewWidth>,Length=<Length>,PreviewLength=<PreviewLength>~;
				InsertCmd	= ~Update Images Set Filetype='<Filetype>',<SizeFields> Where <Key>~;

				if ( !dbase( CMD,~<InsertCmd>~ ) )
				{
					dbase( GetErrorDescription,theErr );
					WaitCursor( End );
					return Warning( Translate( ~Database update failed. <InsertCmd>. <theErr>~ ) );
				}

				if ( Image( GetThumbNailInfo,ThumbNail ) )
				{
					ThumbView( RedrawThumbNail,ThumbNail,TRUE );
				}
			}
			else
			{
				ImageWindow( RefreshWindow,TRUE );
				WaitCursor( End );
				return Warning( Translate( ~Stopping.  Failed to add a thumbnail to <$con.Image[OrderID]>/<$con.Image[Roll]>/<$con.Image[Frame]>\n\n<$con.Image[Path]>~ ) );
			}
		}
	}

	WaitCursor( End );

	ImageWindow( RefreshWindow,TRUE );

	return TRUE;
}


NUMERIC LightTable::SetInputProfileForImages()
{
	if ( !ThumbView( GetSelected,ImagesToSetProfileFor ) )
	{
		return Warning( ~There were no images selected.~ );
	}

	ImagesToSetProfileFor( GetFirst,Image );

	ImageCorrections( GetInputProfileName,~<$con.Image[Path]>~,ProfileName );

	AllTheSame = ImagesToSetProfileFor( HaveSameProfile );

	Query = ~Select Device,Name,Path From Profiles Where (Type = 'Input' OR Type = 'WorkingSpace') Order By Device,Name~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Profiles table: <Query>. <theErr>~ );
	}

	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	Count = 0;

	while ( List( GetNext,Item ) )
	{
		GenCon( Profile<++Count>,New,DDMenuItemDef,SetValues,
				Text,		~&<Count>)  <$pcon.Item[Name]>~,
				IDText,		~ID~,
				IsChecked,	(<AllTheSame> && SimilarStr(~<$pcon.Item[Name]>~,~<ProfileName>~)) ? T : F );

		theAction = ACTION EXEC ( <This>.WantProfile(~<$pcon.Item[Name]>~) );

		Profile<Count>( SetValuesFrom,ActionsText,theAction );

		ListMenu( InsertBack,Profile<Count> );
	}

	GenCon( Profile<++Count>,New,DDMenuItemDef,SetValues,
			Text,		~&<Count>)  Use Embedded Input Profile if Available or Default Input Profile if not Available~,
			IDText,		~ID~,
			IsChecked,	(<AllTheSame> && ~~ == ~<ProfileName>~) ? T : F );

	theAction = ACTION EXEC ( <This>.WantProfile(~~); );

	Profile<Count>( SetValuesFrom,ActionsText,theAction );
		
	ListMenu( InsertBack,Profile<Count> );

	ThumbView( DisplayMenu,ListMenu );

	return TRUE;
}


NUMERIC LightTable::WantProfile( ProfileName)
{
	if ( !ThumbView( GetSelected,ImagesToSetProfileFor ) )
	{
		return Warning( ~There were no images selected~ );
	}

	while ( ImagesToSetProfileFor( GetNext,Image ) )
	{
		SetInputProfile( ~<ProfileName>~,~~,
							~<$con.Image[OrderID]>~,~<$con.Image[Roll]>~,~<$con.Image[Frame]>~,
								~<$con.Image[Path]>~ );
	}

	return TRUE;
}


NUMERIC LightTable::OpenAnImageExternal()
{
	if ( !ThumbView( GetSelected,SelectedImages ) )		
	{
		return Warning( ~There were no images selected~ );
	}

	WaitCursor( Begin );

	while ( SelectedImages( GetNext,Image ) )
	{
		Path = ~<$con.Image[Path]>~;

		if ( !IsNull(~<Path>~) )
		{
			BroadcastMessageToAllViews( ReleaseImageChain,~<Path>~ );
			CloseWindowOfPath( ~<Path>~ );

			if ( !MakeImageWritable( ~<$con.Image[Path]>~ ) )
			{
				WaitCursor( End );
				return FALSE;
			}

			if ( !FindExecutable( ~<$con.Image[Path]>~,Program ) )
			{
				GetLastError( ErrorString,theErr );
				WaitCursor( End );
				return Warning( ~You must go to View/Options/FileTypes of the Windows Explorer to define the program that can open\n\n  <Path>.\n\n<theErr>~ );
			}

			if ( !ShellExecute( Open,~<$con.Image[Path]>~ ) )
			{
				GetLastError( ErrorString,theErr );
				Log( Session,~Could not open <$con.Image[Path]>. <theErr>~ );
			}
		}
	}

	WaitCursor( End );

	return TRUE;
}


NUMERIC LightTable::ShowCrop()
{
	ThumbView( SetShowCropBox,!ThumbView(IsCropBoxShown) );

	return ImageWindow( RefreshWindow );
}


CopiedCropX = CopiedCropY = CopiedCropWidth = CopiedCropLength = 0;
CopiedCropRotation = 0;

NUMERIC LightTable::CopyCrop()	
{
	if ( !ThumbView( GetSelected,SelectedImages ) )		
		{ return Warning( Translate( ~You must select an image to copy.~ ) ); }

	if ( !SelectedImages( GetFirst,Item ) )
	{
		return Warning( Translate( ~You must select an image to copy.~ ) );
	}

	Path = ~<$con.Item[Path]>~;

	if ( ~<Path>~ != ~~ )
	{		
		if ( ImageCorrections( GetCrop,~<Path>~,x,y,w,l,rotation ) )
		{
			CopiedCropX=<x>;	CopiedCropY = <y>;	CopiedCropWidth = <w>;  CopiedCropLength = <l>;
			CopiedCropRotation=<rotation>;
		}
	}

	return TRUE;
}


NUMERIC LightTable::PasteCrop()
{
	if ( <CopiedCropWidth> == 0 || <CopiedCropLength> == 0 )
	{
		return Warning( Translate( ~You must copy a crop first.~ ) );
	}

	if ( !ThumbView( GetSelected,SelectedImages ) )		
		{ return Warning( ~You must select an image to paste a crop to.~ ); }

	ImagesCount = SelectedImages( ChildCount );

	if ( <ImagesCount> <= 0 )
		{ return Warning( ~You must select an image to paste a crop to.~ ); }

	while ( SelectedImages( GetNext,Item ) )
	{
		Path = ~<$con.Item[Path]>~;

		if ( ~<Path>~ != ~~ )
		{		
			ImageCorrections( PasteCrop,~<Path>~,<CopiedCropX>,<CopiedCropY>,<CopiedCropWidth>,<CopiedCropLength>,<CopiedCropRotation> );
		}
	}

	return TRUE;
}


NUMERIC CloseWindowOfPath( Path )
{
	Count = Index = 0;

	app( ThisApp,MessagePump,3 );

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( Window( GETNEXT,aView ) )
		{
			aView( GET,ViewType,ViewType );

			if ( ~<ViewType>~ == ~ImageEditView~ || ~<ViewType>~ == ~PIEEditView~)
			{
				aView( GetDocumentPath,DocumentPath );

				if ( ~<DocumentPath>~ == ~<Path>~ )
				{ 
					Window( CloseWindow );
					ThisApp( MessagePump,3 );
					++Count;
					Index = 0;
				}
			}
		}
	}

	ThisApp( MessagePump,0 );

	return TRUE;
}


/**************************************************
 *************** Wheelman functions ***************
 **************************************************/

VOID LightTable::OnNextButton()
{
//	RevertSelected();
	ArrowKeyPressed = TRUE;
	Global( ArrowKeyPressed );
	ThumbView( PostViewMessage, 0x0100, 39,0 );
	ThumbView( PostViewMessage, 0x0101, 39,0 );
}

VOID LightTable::OnPrevButton()
{
//	RevertSelected();
	ArrowKeyPressed = TRUE;
	Global( ArrowKeyPressed );
	ThumbView( PostViewMessage, 0x0100, 37,0 );
	ThumbView( PostViewMessage, 0x0101, 37,0 );
}

VOID LightTable::AcceptImageEdits( NoPrint )
{
	LastSavedOrderID = ~~;
	LastSavedRoll = ~~;
	LastSavedFrame = ~~;

	NewDensity = 0;
	NewRed		= 0;
	NewGreen	= 0;
	NewBlue		= 0;
	NewContrast = 0;
	NewSaturation = 0;
	NewGamma	= 0;


	if ( ThumbView( GetSelected, SelectedImages ) )
	{
		
		FirstImage = TRUE;

		while ( SelectedImages( GetNext, Image ) )
		{
			// Get total correction
			NewDensity = MakeNumber(~<$con.Image[Brt]>~) + ImageEditData( GetNumeric, cDensity );
			NewRed = MakeNumber(~<$con.Image[Red]>~) + ImageEditData( GetNumeric, cRed );
			NewGreen = MakeNumber(~<$con.Image[Grn]>~) + ImageEditData( GetNumeric, cGreen );
			NewBlue = MakeNumber(~<$con.Image[Blu]>~) + ImageEditData( GetNumeric, cBlue );
			NewContrast = MakeNumber(~<$con.Image[Con]>~) + ImageEditData( GetNumeric, cContrast );
			NewSaturation = MakeNumber(~<$con.Image[Saturation]>~) + ImageEditData( GetNumeric, cSaturation );
			NewGamma = MakeNumber(~<$con.Image[Gamma]>~) + ImageEditData( GetNumeric, cGamma );

			ModifiedFlag = TRUE;
			gCorrectionMade = TRUE;

			if ( <FirstImage> )
			{
				FirstImage = FALSE;

				// Save last correction
				gLastDensity = <NewDensity>;
				gLastRed = <NewRed>;
				gLastGreen = <NewGreen>;
				gLastBlue = <NewBlue>;
				gLastContrast = <NewContrast>;
				gLastSaturation = <NewSaturation>;
				gLastGamma = <NewGamma>;
			}

			// Log image accept
			Line = ~<$con.Image[OrderID]>,<$con.Image[Roll]>,<$con.Image[Frame]>,<NewDensity>,<NewRed>~;
			Line = ~<Line>,<NewGreen>,<NewBlue>,<NewContrast>,<NewSaturation>,<NewGamma>~;
			Line = ~<Line>,<$con.Image[RotateFromDisk]>,<NoPrint>,<$Date.%Y%m%d%H%M%S>~;
			++TotalImageEdits;
			LogImageEdit( ~<Line>~ );

			ImageEditData( SaveCorrections, ~<$con.Image[Path]>~ );

			LastSavedOrderID = ~<$con.Image[OrderID]>~;
			LastSavedRoll = ~<$con.Image[Roll]>~;
			LastSavedFrame = ~<$con.Image[Frame]>~;
		}

		// If the last saved image is the last image in the order then display the end of order dialog box.
		if ( ThumbView( GetAll, ImageList ) )
		{
			if ( ImageList( GetLast, Image2 ) )
			{
				if ( (~<LastSavedOrderID>~ == ~<$con.Image2[OrderID]>~) &&
					 (~<LastSavedRoll>~ == ~<$con.Image2[Roll]>~) &&
					 (~<LastSavedFrame>~ == ~<$con.Image2[Frame]>~) )
				{
					// Reset reject flags
					UpdateImages( Rejected, <NoPrint> , TRUE );
					
					ImageAccepted = TRUE;

					if ( !<ExtHoldCorrectionMode> )
					{
						ResetWheelMode();
					}
					// End order
					EndOrder();
					return;
				}
			}
		}
	}

	// Reset reject flags
	UpdateImages( Rejected, <NoPrint> , TRUE );
	
	ImageAccepted = TRUE;
	OnNextButton();

	if ( !<ExtHoldCorrectionMode> )
	{
		ResetWheelMode();
	}
}

VOID LightTable::ResetWheelMode()
{
	// Set WheelMan mode back to RGB
	if ( <WheelManMode> == 1 )
	{
		ToggleWheelMan();
	}
}

NUMERIC LightTable::EnableWheelman()
{
	Wheelman.CloseInputDevice();

	if ( GetWorkStationSettings( ~Analyzer~, ~WheelmanInputPort~, Port, Enabled ) )
	{
	
		if ( IsNull( ~<Port>~ ) )
		{
			return FALSE;
		}

		if ( MakeNumber( ~<Port>~ ) <= 0 )	{ return FALSE; };

		if ( !Wheelman.OpenInputDevice( <Port> ) )
		{
			// Error is already reported
		}
		else
		{
			if ( Defined( DataView ) )
			{
				DataView( ShowControls, !<WheelManMode>, ColorGroupBox );
				DataView( ShowControls, <WheelManMode>, ColorGroupBox2 );
			}
		}
	}

	return TRUE;
}

VOID NotifyAnalyzerToggleWheelMan()
{
	AnalyzerView.ToggleFromOtherView();
}

VOID LightTable::ToggleWheelman()
{
	WheelManMode = !<WheelManMode>;
	Wheelman.ToggleWheelmanMode();
	DataView( ShowControls, !<WheelManMode>, ColorGroupBox );
	DataView( ShowControls, <WheelManMode>, ColorGroupBox2 );

	NotifyAnalyzerToggleWheelMan();
}

VOID LightTable::ToggleFromOtherView()
{
	WheelManMode = !<WheelManMode>;

	if ( Defined( DataView ) )
	{
		DataView( ShowControls, !<WheelManMode>, ColorGroupBox );
		DataView( ShowControls, <WheelManMode>, ColorGroupBox2 );
	}
}

VOID OnLightTableTimer()
{
	KillTimer( 0 );
	LightTableView.UpdateTheColor();
}

NUMERIC LightTable::GetSingleColor( CurValue, &TempValue, OldValue, ValueRange )
{
	NewValue = <CurValue> + <TempValue>;
	SumValue = <NewValue> + <OldValue>;
	if ( <SumValue> > <ValueRange> )
	{
		NewValue = <ValueRange> - <OldValue>;
	}
	else
	{
		if ( <ValueRange> == <GammaRange> )
		{
			ValueRange = 0.0;
		}

		if ( <SumValue> < -<ValueRange> )
		{
			NewValue = -<ValueRange> - <OldValue>;
		}
	}
	TempValue = 0;

	return <NewValue>;
}

VOID LightTable::UpdateTheColor()
{
	NewDensity = GetSingleColor( ImageEditData(GetNumeric, cDensity), tDensity, <gOldDensity>, <CorrRange> );
	ImageEditData( SetValue, cDensity, <NewDensity> );

	NewRed = GetSingleColor( ImageEditData(GetNumeric, cRed), tRed, <gOldRed>, <CorrRange> );
	ImageEditData( SetValue, cRed, <NewRed> );

	NewGreen = GetSingleColor( ImageEditData(GetNumeric, cGreen), tGreen, <gOldGreen>, <CorrRange> );
	ImageEditData( SetValue, cGreen, <NewGreen> );

	NewBlue = GetSingleColor( ImageEditData(GetNumeric, cBlue), tBlue, <gOldBlue>, <CorrRange> );
	ImageEditData( SetValue, cBlue, <NewBlue> );

	NewContrast = GetSingleColor( ImageEditData(GetNumeric, cContrast), tContrast, <gOldContrast>, <AltCorrRange> );
	ImageEditData( SetValue, cContrast, <NewContrast> );

	NewSaturation = GetSingleColor( ImageEditData(GetNumeric, cSaturation), tSaturation, <gOldSaturation>, <AltCorrRange> );
	ImageEditData( SetValue, cSaturation, <NewSaturation> );

	NewGamma = GetSingleColor( ImageEditData(GetNumeric, cGamma), tGamma, <gOldGamma>, <GammaRange> );
	ImageEditData( SetValue, cGamma, <NewGamma> );

	if ( ThumbView( GetSelected, SelectedImages ) )
	{
		while ( SelectedImages( GetNext,Image ) )
		{
			ImageEditData( UpdateCorrections, ~<$con.Image[Path]>~ );
		}
	}
	
	UpdateColorValues(TRUE);
	InitCorrections();
}

VOID LightTable::UpdateColorValues(ImageIsSelected)
{
	if ( <ImageIsSelected> )
	{
		nDensity = ImageEditData( GetNumeric, cDensity ) + <gOldDensity>;
		nRed = ImageEditData( GetNumeric, cRed ) + <gOldRed>;
		nGreen = ImageEditData( GetNumeric, cGreen ) + <gOldGreen>;
		nBlue = ImageEditData( GetNumeric, cBlue ) + <gOldBlue>;
		nContrast = ImageEditData( GetNumeric, cContrast ) + <gOldContrast>;
		nSaturation = ImageEditData( GetNumeric, cSaturation ) + <gOldSaturation>;
		dGamma = ImageEditData( GetNumeric, cGamma ) + <gOldGamma>;
	}
	else
	{
		nDensity = 0;
		nRed = 0;
		nGreen = 0;
		nBlue = 0;
		nContrast = 0;
		nSaturation = 0;
		dGamma = 1.0;
	}

	if ( !<PreDP2_42> )
	{
		nRed = Truncate( <nRed> );
		nGreen = Truncate( <nGreen> );
		nBlue = Truncate( <nBlue> );
	}

	DataView( SetControlTitle, DensityText,~<nDensity>~ );
	DataView( SetControlTitle, RedText,~<nRed>~ );
	DataView( SetControlTitle, GreenText,~<nGreen>~ );
	DataView( SetControlTitle, BlueText,~<nBlue>~ );
	DataView( SetControlTitle, ContrastText,~<nContrast>~ );
	DataView( SetControlTitle, SaturationText,~<nSaturation>~ );
	DataView( SetControlTitle, GammaText, Format(~<dGamma>~,~%1.2lf~) );

	ShowOpticalDRGB(<ImageIsSelected>);
}

VOID LightTable::InitCorrections()
{
	tDensity = 0;
	tRed = 0;
	tGreen = 0;
	tBlue = 0;
	tContrast = 0;
	tSaturation = 0;
	tGamma = 0;
}

VOID LightTable::RevertSelected( Roll, Frame, PreviousImageSel )
{
	if ( <ExtKeepCorrection> && <ImageAccepted> )
	{
		nDensity = ImageEditData( GetNumeric, cDensity );
		nRed = ImageEditData( GetNumeric, cRed );
		nGreen = ImageEditData( GetNumeric, cGreen );
		nBlue = ImageEditData( GetNumeric, cBlue );
		nContrast = ImageEditData( GetNumeric, cContrast );
		nSaturation = ImageEditData( GetNumeric, cSaturation );
		dGamma = ImageEditData( GetNumeric, cGamma );
	}

	if ( Defined( CurImageList ) )
	{
		//ImageEditData( SetValues,cDensity,0,cRed,0,cGreen,0,cBlue,0,cContrast,0,cSaturation,0,cGamma,0,cRotateFromDisk,0 );

		if ( !<ImageAccepted> )
		{
			More = CurImageList( GetFirst, ImageName );
			while ( <More> )
			{
				if ( SimilarStr( ~<Roll>~, ~~ ) && SimilarStr( ~<Frame>~, ~~ ) )
				{
					if ( SimilarStr( ~<ImageName>~, ~<PreviousImageSel>~ ) )
					{
						ImageEditData( UpdateCorrections, ~<ImageName>~ );
					}
				}

				More = CurImageList( GetNext, ImageName );
			}
		}

		ForgetGlobal( CurImageList );
	}
	// CGCGCG Reset all images for now

/*
	ImageEditData( SetValues,cDensity,0,cRed,0,cGreen,0,cBlue,0,cContrast,0,cSaturation,0,cGamma,0,cRotateFromDisk,0 );

	if ( ThumbView( GetAll, ImageList ) )
	{
		while ( ImageList( GetNext, Image ) )
		{
			ImageEditData( UpdateCorrections, ~<$con.Image[Path]>~ );
		}
	}
*/
	if ( <ExtKeepCorrection> && <ImageAccepted> )
	{
		ImageEditData( SetValues, cDensity, <nDensity>, cRed, <nRed>, cGreen, <nGreen>, cBlue, <nBlue>, cContrast, <nContrast>, cSaturation, <nSaturation>, cRotateFromDisk, 0, cGamma, <dGamma> );
	}
	else
	{
		if ( ImageCorrections( GetCurrentCorrections, ~<LastImageSel>~, Corrections ) )
		{
			cDensity = Corrections( GetNumeric, Density );
			cRed = Corrections( GetNumeric, Red );
			cGreen = Corrections( GetNumeric, Green );
			cBlue = Corrections( GetNumeric, Blue );
			cContrast = Corrections( GetNumeric, Contrast );
			cSaturation = Corrections( GetNumeric, Saturation );
			cRotateFromDisk = Corrections( GetNumeric, RotateFromDisk );
			dGamma = Corrections( GetNumeric, Gamma );
		}

		ImageEditData( SetValues, cDensity, <cDensity>, cRed, <cRed>, cGreen, <cGreen>, cBlue, <cBlue>, cContrast, <cContrast>, cSaturation, <cSaturation>, cRotateFromDisk, <cRotateFromDisk>, cGamma, <dGamma> );
	}

	ImageAccepted = FALSE;
}


NUMERIC LightTable::GetChangeAmount( Amount )
{
	return <Amount> * <WheelChange>;
//	Value = <Amount>;
//	if ( <BigStep> )
//	{
//		Value = <Amount> * 5;
//	}
//	return <Value>;
	//return KeyState( Shift ) ? 5 * <Amount> : <Amount>;
}

VOID LightTable::OnDensityButton( amount )
{
	KillTimer( 0 );

	if ( KeyState( Shift ) )
	{
		if ( <amount> < 0 )
		{
			ChangeThumbNailSize( FALSE );
		}
		else
		{
			ChangeThumbNailSize( TRUE );
		}
		return;
	}

	if ( !ThumbView( GetSelected, ImageList ) )
	{
		return;
	}
	if ( ImageList( ChildCount ) == 0)
	{
		return;
	}

	if ( DefinedAndNotNull( UserChange ) )
	{
		if ( <Amount> < 0 )
		{
			Amount = 0 - MakeNumber( ~<UserChange>~ );
		}
		else
		{
			Amount = MakeNumber( ~<UserChange>~ );
		}
		ResetChangeFactor();
	}

	if (<WheelManMode> > 0)
	{
		tContrast += <amount>;
	}
	else
	{
		tDensity += <amount>;
	}
	SetTimer( 0, <TimerMils>, ~OnLightTableTimer()~ );
}

VOID LightTable::OnRedButton(amount)
{
	KillTimer( 0 );

	if ( !ThumbView( GetSelected, ImageList ) )
	{
		return;
	}
	if ( ImageList( ChildCount ) == 0)
	{
		return;
	}

	if ( DefinedAndNotNull( UserChange ) )
	{
		if ( <Amount> < 0 )
		{
			Amount = 0 - MakeNumber( ~<UserChange>~ );
		}
		else
		{
			Amount = MakeNumber( ~<UserChange>~ );
		}
		ResetChangeFactor();
	}

	if (<WheelManMode> > 0)
	{
		amount = <amount> / 20;
		tGamma += <amount>;
	}
	else
	{
		tRed += <amount>;
		if ( <ExtPreserveCheck> )
		{
			tGreen -= (<amount> / 2);
			tBlue -= (<amount> / 2);
		}
	}
	SetTimer( 0, <TimerMils>, ~OnLightTableTimer()~ );
}

VOID LightTable::OnGreenButton(amount)
{
	KillTimer( 0 );

	if ( !ThumbView( GetSelected, ImageList ) )
	{
		return;
	}
	if ( ImageList( ChildCount ) == 0)
	{
		return;
	}
	
	if ( DefinedAndNotNull( UserChange ) )
	{
		if ( <Amount> < 0 )
		{
			Amount = 0 - MakeNumber( ~<UserChange>~ );
		}
		else
		{
			Amount = MakeNumber( ~<UserChange>~ );
		}
		ResetChangeFactor();
	}

	if (<WheelManMode> > 0)
	{
		tSaturation += <amount>;
	}
	else
	{
		tGreen += <amount>;
		if ( <ExtPreserveCheck> )
		{
			tRed -= (<amount> / 2);
			tBlue -= (<amount> / 2);
		}
	}
	SetTimer( 0, <TimerMils>, ~OnLightTableTimer()~ );
}

VOID LightTable::OnBlueButton(amount)
{
	if (<WheelManMode> == 0)
	{
		KillTimer( 0 );

		if ( !ThumbView( GetSelected, ImageList ) )
		{
			return;
		}
		if ( ImageList( ChildCount ) == 0)
		{
			return;
		}

		if ( DefinedAndNotNull( UserChange ) )
		{
			if ( <Amount> < 0 )
			{
				Amount = 0 - MakeNumber( ~<UserChange>~ );
			}
			else
			{
				Amount = MakeNumber( ~<UserChange>~ );
			}
			ResetChangeFactor();
		}

		tBlue += <amount>;
		if ( <ExtPreserveCheck> )
		{
			tRed -= (<amount> / 2);
			tGreen -= (<amount> / 2);
		}
		SetTimer( 0, <TimerMils>, ~OnLightTableTimer()~ );
	}
}

VOID LightTable::RotateImages(Rotation)
{
	if ( ThumbView( GetSelected, SelectedImages ) )
	{
		if ( SelectedImages( ChildCount ) > 0 )
		{
			NewValue = ImageEditData(GetNumeric, cRotateFromDisk) + <Rotation>;
			while ( <NewValue> + <gOldRotation> > 360 )
			{
				NewValue -= 360;
			}
			ImageEditData( SetValue, cRotateFromDisk, <NewValue> );

			while ( SelectedImages( GetNext, Image ) )
			{
				ImageEditData( UpdateCorrections, ~<$con.Image[Path]>~ );
			}
		}
	}
}

VOID LightTable::CancelCorrections( NewRoll,NewFrame )
{
	// This function cancels all corrections except the current image.
	if ( ThumbView( GetAll, ImageList ) )
	{
		while ( ImageList( GetNext, Image ) )
		{
			ImageRoll = ~<$con.Image[Roll]>~;
			ImageFrame = ~<$con.Image[Frame]>~;

			if ( !SimilarStr( ~<NewRoll>~, ~<ImageRoll>~ ) || !SimilarStr( ~<NewFrame>~, ~<ImageFrame>~ ) )
			{
				ImageEditData( CancelCorrections,~<$con.Image[Path]>~ );
			}
		}
	}
}

VOID LightTable::ResetSelectedCorrections()
{
	if ( ThumbView( GetSelected, SelectedImages ) )
	{
		if ( SelectedImages( ChildCount) > 0 )
		{
			if ( !Numeric(~<$SystemSettings.Analyzer[IgnoreResetPrompt].boolean>~) )
			{
				if ( MessageBox( ~Are you sure you want to reset all color corrections (crop and rotation will not be affected)?  These corrections will be saved in the database.~,YESNO ) != YES )
				{ 
					return; 
				}
			}

			while ( SelectedImages( GetNext,Image ) )
			{
				ImageEditData( ResetCorrections,~<$con.Image[Path]>~, FALSE );
				ImageEditData( RefreshCorrections,~<$con.Image[Path]>~ );
			}

			ImageEditData( SetValue, cDensity, 0 );
			ImageEditData( SetValue, cRed, 0 );
			ImageEditData( SetValue, cGreen, 0 );
			ImageEditData( SetValue, cBlue, 0 );
			ImageEditData( SetValue, cContrast, 0 );
			ImageEditData( SetValue, cSaturation, 0 );
			ImageEditData( SetValue, cGamma, 0.0 );
			ImageEditData( SetValue, AutoBalanceDone, 0 );

			gOldDensity = 0;
			gOldRed = 0;
			gOldGreen = 0;
			gOldBlue = 0;
			gOldContrast = 0;
			gOldSaturation = 0;
			gOldGamma = 1.0;
			gOldRotation = 0;

			UpdateColorValues(TRUE);

			ModifiedFlag = TRUE;
			gCorrectionMade = TRUE;
		}
		else
		{
			Warning( Translate( ~No images selected.~ ) );
		}
	}
}

/*******************************************************
 *************** Miscellaneous functions ***************
 *******************************************************/

VOID LightTable::SaveThumbnailSize()
{
	if ( !<fFirstTime> )
	{
		if ( ImageWindow( Get, ImageFrameSize, CurrentSize ) )
		{
			SetWorkStationSettings( ~Analyzer~, ~PreferredThumbSize~, ~<CurrentSize>~, TRUE );
		}
		else
		{
			// Do nothing
		}
	}
}	

VOID LightTable::LogImageEdit( Line )
{
	Folder = ~<$App.Directory>\SessionLogs\ImageEdits~;
	Directory( Create, ~<Folder>~ );
	if ( !DefinedAndNotNull( KPDAWLogFileName ) )
	{
		KPDAWLogFileName = ~<Folder>\<$Date.%Y%m%d_%H%M%S>.txt~;
		PermanentSymbol( KPDAWLogFileName );
	}
	Type = ~Open~;
	if ( !Files( FileExists, ~<KPDAWLogFileName>~ ) )
	{
		Type = ~Create~;
	}
	if ( File( LogFile, Open, ~<KPDAWLogFileName>~, <Type>, Write ) )
	{
		LogFile( Seek, 0, End );
		LogFile( Translate( ~<Line>~ ) );
		LogFile( Close );
	}

	if ( <TotalImageEdits> >= 1000000000 )
	{
		++BillionEdits;
		TotalImageEdits = 0;
	}

	if (File( TotalEdits, Open, ~<Path>~, Create, Write ) )
	{
		TotalEdits( ~Billions=<BillionEdits>;~ );
		TotalEdits( ~Counter=<TotalImageEdits>;~ );
		TotalEdits( Close );
	}
}

VOID LightTable::ChangeThumbNailSize( IncreaseSize )
{
	if ( <IncreaseSize> )
	{
		ThumbView( PostViewMessage, 0x0100, 107,0 );
		ThumbView( PostViewMessage, 0x0101, 107,0 );
	}
	else
	{
		ThumbView( PostViewMessage, 0x0100, 109,0 );
		ThumbView( PostViewMessage, 0x0101, 109,0 );
	}
}

/*************************************************************
 *************** Initialization/View Functions ***************
 *************************************************************/

VOID LightTable::DefineLastCorrections()
{
	gLastDensity = 0;
	gLastRed = 0;
	gLastGreen = 0;
	gLastBlue = 0;
	gLastContrast = 0;
	gLastSaturation = 0;
	gLastGamma = 0.0;
	gCorrectionMade = FALSE;

	PermanentSymbol( gLastDensity );
	PermanentSymbol( gLastRed );
	PermanentSymbol( gLastGreen );
	PermanentSymbol( gLastBlue );
	PermanentSymbol( gLastContrast );
	PermanentSymbol( gLastSaturation );
	PermanentSymbol( gLastGamma );
	PermanentSymbol( gCorrectionMade );
}

VOID LightTable::SetToolbarState()
{
	DataView( SetState, TRUE, LightTableButton );
	ShowButton = !<KPDAWRender> || DefinedAndNotNull( WantStaticToolbars );
}

VOID LightTable::SetKeepLastCorrectionCheckBox()
{
	if ( Defined( View ) )
	{
		View( SetCheck, <ExtKeepCorrection>, KeepLastCorrectionsCheckBox );
	}
}

VOID LightTable::GetViews()
{
	if ( !Defined( ThumbView ) )
	{
		ImageWindow( GetViewOfWindow, ImagesThumbNailCategory, ThumbView );
		Global( ThumbView );
	}

	if ( !Defined( DataView ) )
	{
		ImageWindow( GetViewOfWindow, View, DataView );
		Global( DataView );
	}

	ImageWindow( Set, MinImageFrameSize, 100 );
	ImageWindow( Set, MaxImageFrameSize, 500 );
}

VOID LightTable::DeleteContents()
{
	InitCorrections();
	if ( Defined( CurImageList ) )
	{
		ForgetGlobal( CurImageList );
	}
}

VOID LightTable::Maximize()
{
	ImageWindow( Show, <DP2> ? ~Normal~ : ~Maximized~ );
}

VOID LightTable::GetSavedThumbnailSize()
{
	if ( GetWorkStationSettings( ~Analyzer~, ~PreferredThumbSize~, ThumbValue, Enabled ) )
	{
		if ( <ThumbValue> )
		{
			ImageWindow( Set, ImageFrameSize, <ThumbValue> );
			ThumbView( SetImageFrameSize, <ThumbValue> );
			ImageWindow( RefreshWindow );
		}
	}
}

VOID LightTable::EnableToolbar( Enable )
{
	DataView( EnableViewControls, <Enable>, NextButton );
	DataView( EnableViewControls, <Enable>, PrevButton );
	DataView( EnableViewControls, <Enable>, DensityUpButton );
	DataView( EnableViewControls, <Enable>, DensityDownButton );
	DataView( EnableViewControls, <Enable>, RedUpButton );
	DataView( EnableViewControls, <Enable>, RedDownButton );
	DataView( EnableViewControls, <Enable>, GreenUpButton );
	DataView( EnableViewControls, <Enable>, GreenDownButton );
	DataView( EnableViewControls, <Enable>, BlueUpButton );
	DataView( EnableViewControls, <Enable>, BlueDownButton );
	DataView( EnableViewControls, <Enable>, ResetButton );
	DataView( EnableViewControls, <Enable>, ApplyToAllButton );
	DataView( EnableViewControls, <Enable>, ModeButton);
	//DataView( EnableViewControls, <Enable>, LightTableButton );
	DataView( EnableViewControls, <Enable>, MakeRefButton );
	DataView( EnableViewControls, <Enable>, RecallRefButton );
	DataView( EnableViewControls, <Enable>, StoreButton );
	DataView( EnableViewControls, <Enable>, RecallButton );
	DataView( EnableViewControls, <Enable>, RecallLastButton );
}

VOID LightTable::DisableView()
{
	DisableWheelMan();
	if ( !<fFirstTime> )
	{
		ImageWindow( EnableWindow, FALSE );
	}
}

VOID LightTable::ShowWindow( Show )
{
	if ( !<Show> )
	{
		ImageWindow( Show, Hide );
	}
	else
	{
		ImageWindow( Show, <DP2> ? ~Normal~ : ~Maximized~ );
		ImageWindow( Activate );

		if ( Defined( DataView ) )
		{
			DataView( ShowControls, !<WheelManMode>, ColorGroupBox );
			DataView( ShowControls, <WheelManMode>, ColorGroupBox2 );
		}
	}
}

VOID InitLightTable( OrderID, Roll, Frame, RefImage, RefPath, Disable )
{
	ResetChangeFactor();
	if ( DefinedAndNotNull( Disable ) )
	{
		LightTableView.DisableView();
	}
	else if ( !Defined( Wheelman ) )
	{
		Sleep( 25 );
		LightWheelMan( New, Wheelman );
		Global( Wheelman );
		LightTableView.EnableWheelman();
	}
	
	if ( !Defined( Disable ) )
	{
		Disable = ~~;
	}

	if ( !Defined( OrderID ) )
	{
		OrderID = ~~;
	}

	if ( !Defined( LastOrderID ) )
	{
		LastOrderID = ~~;
		Global( LastOrderID );
	}

	if ( !DefinedAndNotNull( OrderID ) || (~<OrderID>~ != ~<LastOrderID>~) )
	{
		LightTableView.DeleteContents();
		LightTableView( GetReferenceTo, fOrderID, OrderID2 );
		OrderID2 = ~<OrderID>~;

		if ( <ExtShowOnlyImagesToAdjust> && !<ExtIgnoreAdjustImagesFlag> )
		{
			LightTableView.Init( ~Select * From Images Where OrderID = '<OrderID>' AND Inspect <> 0 Order By Roll, Frame~ );
		}
		else
		{
			LightTableView.Init( ~Select * From Images Where OrderID = '<OrderID>' Order By Roll, Frame~ );
		}

		LightTableView.ShowWindow( TRUE );
		LightTableView.GetViews();

		EnableTools = TRUE;
		if ( !DefinedAndNotNull( OrderID ) )
		{
			EnableTools = FALSE;
		}
		LightTableView.EnableToolbar( <EnableTools> );

		LightTableView.GetSavedThumbnailSize();
		//LightTableView.RefreshThumbnailView();
	}
	//else
	//{
	//	if ( !DefinedAndNotNull( Disable ) )
	//	{
	//		LightTableView.RefreshThumbnailView();
	//	}
	//}
	LastOrderID = ~<OrderID>~;

	LightTableView.SetToolbarState();
	if ( !DefinedAndNotNull( Disable ) )
	{		
		LightTableView.EnableViews();
	}

	LightTableView.ShowReferenceImage( ~<RefImage>~, ~<RefPath>~ );
	LightTableView.DoLeftClickInImageView( ~<Roll>~, ~<Frame>~ );
}

VOID LightTable::EnableViews()
{
	ImageWindow( EnableWindow, TRUE );

	GetSavedThumbnailSize();

	DataView( GetControlWithFocus, Control );
	if ( !DefinedAndNotNull( Control ) )
	{
		DataView( SetControlFocus, DensityText );
	}

	if (!Defined( Wheelman ) )
	{
		Sleep( 25 );
		LightWheelMan( New, Wheelman );
		Global( Wheelman );
		EnableWheelman();
	}

	SetToolbarState();
}

VOID LightTable::DisableWheelman()
{
	if ( Defined( Wheelman ) )
	{
		Wheelman.CloseInputDevice();
		Sleep( 50 );
		ForgetGlobal( Wheelman );
	}
	LightTableView.SaveThumbnailSize();
}


/************************************************
 *************** Wheelman support ***************
 ************************************************/

Class( LightWheelman, Extends, BaseWheelman );

VOID LightWheelMan::OnWheel1(amount)		{ LightTableView.OnDensityButton( LightTableView.GetChangeAmount( <amount> ) ); }
VOID LightWheelMan::OnWheel2(amount)		{ LightTableView.OnRedButton( LightTableView.GetChangeAmount( <amount> ) ); }
VOID LightWheelMan::OnWheel3(amount)		{ LightTableView.OnGreenButton( LightTableView.GetChangeAmount( <amount> ) ); }
VOID LightWheelMan::OnWheel4(amount)		{ LightTableView.OnBlueButton( LightTableView.GetChangeAmount( <amount> ) ); }
VOID LightWheelMan::OnButton1()			{ LightTableView.AcceptImageEdits( 0 ); }
VOID LightWheelMan::OnButton2()			{ LightTableView.OnNextButton(<amount>); }
VOID LightWheelMan::OnButton3()			{ LightTableView.OnPrevButton(<amount>); }
VOID LightWheelMan::OnButton4()			{ LightTableView.ToggleWheelMan(); }
VOID LightWheelMan::ToggleWheelmanMode()
{
	if ( <Port> > 0 )
	{
		WheelManMode = !<WheelManMode>;
		InputDevice( WriteString,0,<WheelManMode> ? ~M~ : ~m~ );
	}
}


/****************************************************
 *************** Context menu support ***************
 ****************************************************/

Class( LightTableMenu, Extends, BaseMenu );

VOID LightTableMenu::AddMenuItems()
{
	// Add items to context menu
	Action = ACTION EXEC ( LightTableView.RotateImages(90) );
	AddMenuItem( TRUE, FALSE, Translate(~Rotate Clockwise~), Action );

	Action = ACTION EXEC ( LightTableView.RotateImages(180) );
	AddMenuItem( TRUE, FALSE, Translate(~Rotate 180~), Action );

	Action = ACTION EXEC ( LightTableView.RotateImages(270) );
	AddMenuItem( TRUE, FALSE, Translate(~Rotate Counter-Clockwise~), Action );

	AddMenuSeparator( ThumbView );

	Action = ACTION EXEC ( LightTableView.AcceptImageEdits(0) );
	AddMenuItem( TRUE, FALSE, Translate(~Set To Print~), Action );

	Action = ACTION EXEC ( LightTableView.AcceptImageEdits(1) );
	AddMenuItem( TRUE, FALSE, Translate(~Set To No Print~), Action );

	AddMenuSeparator( ThumbView );

	Action = ACTION EXEC ( LightTableView.MakeReference() );
	AddMenuItem( TRUE, FALSE, Translate(~Make Reference Image~), Action );

	Action = ACTION EXEC ( LightTableView.AddThumbnail() );
	AddMenuItem( TRUE, FALSE, Translate(~Add Thumbnail~), Action );

	Action = ACTION EXEC ( LightTableView.SetInputProfileForImages() );
	AddMenuItem( TRUE, FALSE, Translate(~Set ICC Input Profile~), Action );

	Action = ACTION EXEC ( LightTableView.OpenAnImageExternal() );
	AddMenuItem( TRUE, FALSE, Translate(~Retouch~), Action );

	AddMenuSeparator( ThumbView );

	Action = ACTION EXEC ( LightTableView.ShowCrop() );
	AddMenuItem( TRUE, ThumbView(IsCropBoxShown) ? TRUE : FALSE, Translate(~Show Crop~), Action );

	Action = ACTION EXEC ( LightTableView.CopyCrop() );
	AddMenuItem( <ExtEnableCropping> ? TRUE : FALSE, FALSE, Translate(~Copy Crop~), Action );

	Action = ACTION EXEC ( LightTableView.PasteCrop() );
	AddMenuItem( <ExtEnableCropping> ? TRUE : FALSE, FALSE, Translate(~Paste Crop~), Action );

	AddMenuSeparator( ThumbView );

	Action = ACTION EXEC ( EndOrder() );
	AddMenuItem( TRUE, FALSE, Translate(~Finish Order~), Action );
}


Class( LightRefMenu, Extends, BaseMenu );

VOID LightRefMenu::AddMenuItems()
{
	// Add items to reference context menu
	Action = ACTION EXEC ( LightTableView.RecallReference() );
	AddMenuItem( TRUE, FALSE, Translate( ~Recall Reference Image~ ), Action );
}

VOID LightTable::RefContextMenu()
{
	LightRefMenu( New, theMenu );
	theMenu.DisplayInView( DataView );
}



/*******************************************************************************
 *******************************************************************************
 ****************************** Open Order Dialog ******************************
 *******************************************************************************
 *******************************************************************************/

VOID NotifyAnalyzerRefreshOrders(ImportedOrderID)
{
	Sleep(50);
	AnalyzerView.RefreshOrders(~<ImportedOrderID>~);
}

VOID Analyzer::RefreshOrders(ImportedOrderID)
{
	if ( Defined( OpenDlg ) )
	{
		OpenDlg.PopulateOrderListBox(~<ImportedOrderID>~);
		OpenDlg.OnOrderSelected();
	}
}



/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID OpenDialog::OpenDialog()
{
    if (!GetWorkStationSettings( ~Analyzer~, ~AutoRefreshSeconds~, AutoRefreshSeconds, Enabled ))
    {
        SetWorkStationSettings( ~Analyzer~,~AutoRefreshSeconds~,~10~,TRUE ); 
        GetWorkStationSettings( ~Analyzer~, ~AutoRefreshSeconds~, AutoRefreshSeconds, Enabled );
    }

    if (!GetWorkStationSettings( ~Analyzer~,~AutoRelease~,AutoRelease, Enabled ))
    {
        // Default AutoRelease to OFF
        SetWorkStationSettings( ~Analyzer~,~AutoRelease~,~0~,TRUE ); 
    }

    if (!GetWorkStationSettings( ~Analyzer~,~AutoReleaseLDP~,AutoReleaseLDP, Enabled ))
    {
        // Default AutoRelease of LDP to OFF
        SetWorkStationSettings( ~Analyzer~,~AutoReleaseLDP~,~0~,TRUE ); 
    }

    if (!GetWorkStationSettings( ~Analyzer~,~AutoReleaseMC~,AutoReleaseMC, Enabled ))
    {
        // Default AutoRelease of MediaClip to OFF
        SetWorkStationSettings( ~Analyzer~,~AutoReleaseMC~,~0~,TRUE ); 
    }
	// Set up window defaults
	Title = ~sRGB Converted Orders Awaiting Colour Correction (Refresh in <AutoRefreshSeconds> Seconds)~;
	Left = 200;
	ExitScriptOnClose = FALSE;
	StatusBar = ~~;
}

VOID OpenDialog::WindowDefinition()
{
	Fields:	WantsMinimizeBox		<DP2> ? TRUE : FALSE
			HActionsText			ACTION SHOWHELPPAGE( KPDAWHelpFile "Opening_an_Order.htm" )
}

VOID OpenDialog::DefineMessages()
{ 
	BaseDialog::DefineMessages();	

	// Define messages for dialog box
	Translations( AddText, Cancel, ~Cancel~ );
	Translations( AddText, Open, ~Open Order~ );
	Translations( AddText, Delete, ~Delete Order(s)~ );
//	Translations( AddText, Import, ~Import Images~ ); Button removed
	Translations( AddText, Refresh, ~Refresh~ );
	Translations( AddText, Convert, ~Raw Images~ );
	Translations( AddText, ListBoxTip, ~List of orders to analyze~ );
	Translations( AddText, OrderText, ~Enter Order ID:~ );
	Translations( AddText, EditTip, ~Enter an order ID~ );
}
NUMERIC OnExplorerButton()
{
    // By default open an explorer window for the entire PC
    Actions = ACTION DOC ( Explorer Open ExplorerDoc "Init(~Explore~,~~);" );


    return PerformActions( Actions );
}
VOID OpenDialog::DefineControls()
{
	Define: OrderListBox Using DDWinCtrlDef AsSymbol OrderListBox Private
			Fields:	TypeName				List
					ListViewType			Report
					Position				$hGap, $vGap,
											650, 300 
					GenConField				~Order~
					IActionsText			ACTIONS ( Get )
					DActionsText			ACTIONS ( Save "EXEC(<This>.OnOrderSelected())" )
					OActionsText			ACTIONS ( Save )
					AllowMultipleSelection	TRUE
					GridLines				TRUE
					FullRowSelect			TRUE
					//NoSortHeader			TRUE
					Border					TRUE
					ClientEdge				TRUE
					ShowSelAlways			TRUE
					InfoTip					TRUE
					Tooltip					Translate( Translations, ListBoxTip )
					ReturnKeyActionsText	ACTIONS ( Save "EXEC(<This>.OnOrderSelected())" )
					KeyboardActionsText		ACTIONS ( Save "EXEC(<This>.OnKeyDown())" )
					DoubleClickActionsText	ACTIONS ( Save "EXEC(<This>.OnOpenButton())" )
					ColumnClickActionsText	ACTIONS ( Save "EXEC(<This>.OnColumnClick())" )

	Define: RefreshButton Using DDWinCtrlDef AsSymbol RefreshButton Private
			Fields:	TypeName				Button
					Position				OrderListBox(GetRight,Position) + $hGap, OrderListBox(GetTop,Position)+70,
											<ButtonWidth>, <ButtonHeight>*2
					DActionsText			ACTION EXEC ( <This>.OnRefreshButton() )
					Text					Translate( Translations, Refresh )

    Define: ExplorerButton Using DDWinCtrlDef AsSymbol ExplorerButton 
                Fields: TypeName        Button
                        Text            Translate( ~Explorer~ )
                        Position        RefreshButton(GetLeft, Position), RefreshButton(GetBottom, Position) + $vGap ,$ButtonWidth, $ButtonHeight *2
                        DActionsText    ACTION EXEC ( OnExplorerButton() ) 
                        IsEnabled       T
//                      BGColorGreen    Defined(G) ? ~<G>~ : ~300~
                        ImageFile       ~<$App.Directory>\loxley.bmp~ 
                        Tooltip         Translate( ~Open an Explorer Window or if it Exists the Work Order Directory~ );

// Button Removed
//	Define: ImportButton Using DDWinCtrlDef AsSymbol ImportButton Private
//			Fields:	TypeName				Button
//					Position				OpenButton(GetLeft, Position), RefreshButton(GetBottom, Position) + $vGap,
//											<ButtonWidth>, <ButtonHeight>
//					DActionsText			ACTION EXEC ( <This>.OnImportButton() )
//					Text					Translate( Translations, Import )

	if ( !<DP2> )
	{
		Define: DeleteButton Using DDWinCtrlDef AsSymbol DeleteButton Private
				Fields:	TypeName				Button
						Position				RefreshButton(GetLeft, Position), ImportButton(GetBottom, Position) + $vGap,
												<ButtonWidth>*2, <ButtonHeight>*2
						DActionsText			ACTION EXEC ( <This>.OnDeleteButton() )
						Text					Translate( Translations, Delete )
	}


	Define: OrderPrompt Using DDWinCtrlDef AsSymbol OrderPrompt Private
			Fields:	TypeName				StaticText
					Position				OrderListBox(GetLeft, Position), OrderListBox(GetBottom, Position) + $vGap * 2,
											80, 20
					Text					Translate( Translations, OrderText )
					RightJustified			TRUE

	Define: TocolourPrompt Using DDWinCtrlDef AsSymbol TocolourPrompt Private
			Fields:	TypeName				StaticText
					Position				OrderListBox(GetLeft, Position), OrderPrompt(GetBottom, Position) + $vGap * 2,
											80, 20
					Text					~To Colour:~
					RightJustified			TRUE

	Define: TocolourField Using DDWinCtrlDef AsSymbol TocolourField Private
			Fields:	TypeName				StaticText
					Position				TocolourPrompt(GetRight, Position) + $vGap, TocolourPrompt(GetTop, Position),
											200, 20
					Text					~<QtyToColour> Images in <OrderQty> orders~
					RightJustified			FALSE
                    MaxTextSize				200

	Define: OrderIDField Using DDWinCtrlDef AsSymbol OrderIDField Private 
			Fields: TypeName				EditText  
					Position				OrderPrompt(GetRight,Position) + $hGap, OrderPrompt(GetTop,Position) - 4,
											150, 25
					IActionsText			ACTIONS ( Get )
					DActionsText			ACTIONS ( Save "EXEC(<This>.OnEditKeyDown())" )
					OActionsText			ACTIONS ( Save )
					Tooltip					Translate( Translations, EditTip )
					WantReturnKey			~T~
					ReturnKeyActionsText	 ACTION EXEC ( <THIS>.OnOpenButton() )
					MaxTextSize				<OrderIDLength>

	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
			Fields:	TypeName				DefaultButton
					Position				OrderIDField(GetRight,Position) + $hGap, OrderIDField(GetTop,Position)+3,
											<ButtonWidth>, <ButtonHeight>
					DActionsText			ACTION EXEC ( <This>.OnOpenButton() )
					Text					Translate( Translations, Open )

	Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton Private
			Fields:	TypeName				Button
					Position				OpenButton(GetRight, Position) + $hGap, OpenButton(GetTop, Position),
											<ButtonWidth>, <ButtonHeight>
					DActionsText			ACTION EXEC ( <This>.OnCancelButton() )
					Text					Translate( Translations, Cancel )


}

VOID OpenDialog::OnDialogEnd()
{
	ForgetGlobal( ManualEdit );

	if ( AnalyzerView.ValidateOrderID() )
	{
		// Re-enable menus
		EnableMenus( TRUE, FALSE );
	}

	// Release wheelman control
	DisableWheelman();

	// Re-enable correct view
	EnableCorrectWindow( TRUE );
}

/************************************************
 *************** Member functions ***************
 ************************************************/

NUMERIC	OpenDialog::OnCancelButton()
{
	// Close dialog
	DoCancelButton();
	return TRUE;
}
NUMERIC	NewImages( OrderID )
{
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate(~Could not connect to the database. <theErr>~) );
	}

    return dBase( RecordCountFor,~Select Frame from Images where OrderID = '<OrderID>'~ );
}

NUMERIC	Analyzer::ImageIndex( OrderID , Roll, Frame )
{
	Query = ~Select Roll, Frame From Images Where OrderID = '<OrderID>'  Order By Roll, Frame~;

//      Log(Session, ~ImageIndex Roll = <Roll>, Frame = <Frame> OrderID = <OrderID>~);
	if ( !PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{
		return FALSE;
	}

    Index = 1;
    while ( List( GetNext, Record ) )
    {
        if ((~<$pcon.Record[Roll]>~ == ~<Roll>~) &&  (~<$pcon.Record[Frame]>~ == ~<Frame>~))
        {
//          Log(Session, ~ImageIndex Index Found at <Index>~);
            return $Index;
        }
        ++Index;
    }
//  Log(Session, ~ImageIndex Index NOT Found~);
    return 0;
}
NUMERIC	OpenDialog::OnOpenButton()
{
	// Get correct order ID value
	if ( DefinedAndNotNull( ManualEdit ) )
	{
		Order = ~<ManualOrderID>~;
       
       	Query = ~SELECT ImagesOrderID From Orders Where ID = '<Order>'~;
		if ( ADO( dBase,Connect,GetValuesFor,~<Query>~,ImagesOrderID ) )
		{
			ImagesOrderID = ~<$Str.$ImagesOrderID.NoTrailingBlanks>~;
			if ( !SimilarStr( ~<ImagesOrderID>~,~~ ) )
			{
                // Only use the imagesOrderID if there are no additional images being added.
                // Its assumed old images will already be corrected.
                if (!NewImages(~<Order>~))
                { 
    				// Order = ~<ImagesOrderID>~;
                    OpenDialog::StopTimerRefresh();
                    if ( MessageBox( ~Order ID '<Order>' is a reorder from <ImagesOrderID>. Do you want to finish this order now?~, YESNO ) == YES)
                    {
                        OrderID = ~<Order>~;
                        EndOrder();
                        return TRUE;
                    }
                    else
                    {
  			            Warning( Translate( ~Opening Images from Source Order ID <ImagesOrderID>.~ ) );
                        OrderToRelease = ~<Order>~;
                        Global( OrderToRelease );
                        Order = ~<ImagesOrderID>~;
                        RecordAction( ~<OrderToRelease>~, ~Adjusting~);
                    }
                }
                else
                {
                    OpenDialog::StopTimerRefresh();
                    Warning( Translate( ~Order ID '<Order>' has new images to be corrected. NOTE: There are also images from a source order <ImagesOrderID>.~ ) );
                }
			}
		}
	}
	else
	{
		count = dlg( List, OrderListBox, GetSelectedCount );
		if ( <count> > 1 )
		{
			return Warning( ~You have more than one order selected.  Only one order can be opened at a time.~ );
		}


		Item = dlg( List, OrderListBox, GetSelectedItemByIndex, 0 );
		dlg( List, OrderListBox, GetItemText, <Item>, 0, Order);

//		dlg( List, OrderListBox, GetItemText, <Item>, 2, ImagesOrderID);
		dlg( List, OrderListBox, GetItemText, <Item>, 5, ImagesOrderID);
		ImagesOrderID = ~<$Str.$ImagesOrderID.NoTrailingBlanks>~;
		if ( !SimilarStr( ~<ImagesOrderID>~,~~ ) )
		{
           // Only use the imagesOrderID if there are no additional images being added.
           // Its assumed old images will already be corrected.
           if (!NewImages(~<Order>~))
           { 
                if ( MessageBox( ~Order ID '<Order>' is a reorder from <ImagesOrderID>. Do you want to finish this order now?~, YESNO ) == YES)
                {
                    OrderID = ~<Order>~;
                    EndOrder();
                    return TRUE;
                }
                else
                {
                    Warning( Translate( ~Opening Images from Source Order ID <ImagesOrderID>.~ ) );
                    OrderToRelease = ~<Order>~;
                    Global( OrderToRelease );
                    Order = ~<ImagesOrderID>~;
                    RecordAction( ~<OrderToRelease>~, ~Adjusting~);
                }
           }
           else
           {
                OpenDialog::StopTimerRefresh();
                Warning( Translate( ~Order ID '<Order>' has new images to be corrected. NOTE: There are also images from a source order <ImagesOrderID>.~ ) );
           }
		}
	}

	if ( IsNull(~<Order>~) )
	{
		return Warning( ~You must select or enter an OrderID First~ );
	}


	// Cancel previous order if necessary
	if ( DefinedAndNotNull( OrderID ) && !<ModifiedFlag> )
	{
		AnalyzerView.CancelOrder();
	}
	
	// Load order

	if ( StopForAEImages( ~<Order>~ ) )
	{
		return FALSE;
	}

	if ( AnalyzerView.LoadOrder( ~<Order>~ ) )
	{
		Actions = ACTION DOC ( ~OrderNotifyDoc~ OpenOnce OrderNotifyDoc "Init(~<Order>~,FALSE );" );
		PerformActions( Actions );
		
		ADO( database,Connect,LogActivity,Msg,~Analyzing Order <Order>~,Type,Info );

		// Close dialog
		DoCancelButton();
	}
	
	return TRUE;
}

VOID OpenDialog::OnImportButton()
{
	Actions = ACTION Doc ( ImportImagesDoc Open ImportImagesDoc "Init(~~, ~~, 1);" );
	PerformActions( Actions );
}

NUMERIC OpenDialog::OnDeleteButton()
{
	orderCount = 0;
	OrderList = ~~;

	StringList( OrdersToDelete,New );

	if ( DefinedAndNotNull( ManualEdit ) )
	{
		if ( !IsNull( ~<ManualOrderID>~ ) )
		{
			orderCount = 1;
			OrderList = ~'<ManualOrderID>'~;
			OrdersToDelete( AddString,~<ManualOrderID>~ );
		}
	}

	someOrdersNotComplete = FALSE;
	Done = FALSE;
	Index = -1;
	while ( !<Done> )
	{
		++Index;
		Item = dlg( List, OrderListBox, GetSelectedItemByIndex, <Index> );
		if ( <Item> >= 0 )
		{
			dlg( List, OrderListBox, GetItemText, <Item>, 0, OrderID);
			dlg( List, OrderListBox, GetItemText, <Item>, 3, Status);
			Status = ~<$Str.$Status.notrailingblanks>~;
			if ( !SimilarStr( ~<Status>~,~Complete~ ) )
			{
				someOrdersNotComplete = TRUE;
			}

			++orderCount;
			OrdersToDelete( AddString,~<OrderID>~ );
			if ( ~<OrderList>~ == ~~ )
			{
				OrderList = ~'<OrderID>'~;
			}
			else
			{
				OrderList = ~<OrderList>~ + ~,'<OrderID>'~;
			}
		}
		else
		{
			Done = TRUE;
		}
	}

	if ( <orderCount> == 0 )		
	{ 
		return Warning( Translate(~No orders have been entered or selected to delete.~) );
	}

	if ( <someOrdersNotComplete> )		
	{ 
		if ( MessageBox( ~One or more of the selected orders does not have a status of complete.  Are you sure you want to delete these orders?~,YESNO,DEFBUTTON2 ) != YES )
		{
			return FALSE;
		}
	}

	if ( MessageBox( Translate(OrdersMessages,RemovingAllForOrder,~<orderCount>~),YESNO,DEFBUTTON2 ) != YES )
	{
		return FALSE;
	}

	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate(DBMessages,ConnectionFailed,~<theErr>~) );
	}

	Cmd = ~Select count(1) from Images where OrderID In (<OrderList>)~;
	dbase( GetValuesFor, ~<Cmd>~, numRecs);
	if (<numRecs> > 0)
	{
		DeletingImageFiles = MessageBox( Translate(OrdersMessages,DeleteImagesToo),YESNOCANCEL,DEFBUTTON2 );

		if ( ~<DeletingImageFiles>~ == ~CANCEL~ )
		{
			return TRUE;
		}

		DeletingImageFiles = ~<DeletingImageFiles>~ == ~YES~;
	}
	else
	{
		DeletingImageFiles = FALSE;
	}

	Cmd = ~Select count(1) from RawImages where OrderID In (<OrderList>)~;
	dbase( GetValuesFor, ~<Cmd>~, numRecs);
	if (<numRecs> > 0)
	{
		DeletingRawFiles = MessageBox( Translate(OrdersMessages,DeleteRawImagesToo),YESNOCANCEL,DEFBUTTON2 );

		if ( ~<DeletingRawFiles>~ == ~CANCEL~ )
		{
			return TRUE;
		}

		DeletingRawFiles = ~<DeletingRawFiles>~ == ~YES~;
	}
	else
	{
		DeletingRawFiles = FALSE;
	}

	DeletedOrders = 0;
	num = 1;
	while ( OrdersToDelete( GetNextString, Order ) )
	{
		// Determine if the order can be deleted.  Open image and job files related
		// to the order would be a reason that deleting an order could fail since
		// we try to remove all order image and order item information and files
		// associated with the order.
		result = CanDeleteOrder(dBase,~<Order>~);
		if (<result> == TRUE)
		{
			StatusBar( 0,Translate(OrdersMessages,RemovingImagesItems,~<Order>~) );
			if ( DeleteOrdersItemsAndImages( dBase,~<Order>~,<DeletingImageFiles>, <DeletingRawFiles> ) )
			{
				StatusBar( 0,Translate(OrdersMessages,DeletedOrder,~<Order>~) );
				Log( Session,Translate(~Deleted order <Order>~) );

				++DeletedOrders;
			}
			else
			{
				if ( <num> == <orderCount> )
				{
					MessageBox( Translate(OrdersMessages,CantDeleteOrder1,~<Order>~),OK );
				}
				else
				{
					if ( MessageBox( Translate(OrdersMessages,CantDeleteOrderContinue1,~<Order>~),YESNO ) != YES)
					{
						break;
					}
				}
			}
		}
		else
		{
			if (<result> == -1)
			{
				if ( <num> == <orderCount> )
				{
					MessageBox( Translate(OrdersMessages,CantDeleteOrder2,~<Order>~),OK );
				}
				else
				{
					if ( MessageBox( Translate(OrdersMessages,CantDeleteOrderContinue2,~<Order>~),YESNO ) != YES)
					{
						break;
					}
				}
			}
			else
			{
				if ( <num> == <orderCount> )
				{
					MessageBox( Translate(OrdersMessages,CantDeleteOrder3,~<Order>~),OK );
				}
				else
				{
					if ( MessageBox( Translate(OrdersMessages,CantDeleteOrderContinue3,~<Order>~),YESNO ) != YES)
					{
						break;
					}
				}
			}
		}

		++num;
	}

	if ( <DeletedOrders> )
	{
		dlg( List, OrderListBox, DeleteSelected );
	}

	return TRUE;
}

NUMERIC OpenDialog::OnColumnClick()
{
	dlg( GetWinCtrl, OrderListBox, Ctrl );
	SortColumn = MakeNumber( ~<$con.Ctrl[ColumnClicked]>~ );
	return OnRefreshButton();
}

NUMERIC OpenDialog::OnRefreshButton()
{
	// Refresh 'Orders to Analyze' list
	PopulateOrderListBox(~~);

	return TRUE;
}

VOID OpenDialog::OnChangeOrder(Direction)
{
	// Move order list selector
	if ( <Direction> < 0 )
	{
		dlg( List, OrderListBox, SelectPrev );
	}
	else
	{
		dlg( List, OrderListBox, SelectNext );
	}
	OnOrderSelected();
}

VOID OpenDialog::ShowError( FilePath, ErrorText )
{
	FileName = ~<$Str.$FilePath.Filename.WithExt>~;
	Warning( Translate( ~Order file '<FileName>' is invalid:\n<ErrorText>~ ) );
}

VOID OpenDialog::ReadSingleTextOrder( FilePath )
{
	// Error messages
	BlankOrder = Translate( ~Order number is blank~ );
	BlankImage = Translate( ~Image folder is blank~ );
	BlankRender = Translate( ~Render folder is blank~ );
	BlankPath = Translate( ~Image filename is blank~ );
	BadImageInfo = Translate( ~Image information section invalid.  Last line read: ~ );
	NoImageData = Translate( ~Image data line missing for image: ~ );
	BadImageData = Translate( ~Image data invalid for image ~ );
	DupImage = Translate( ~Image already exists: ~ );
	NoImages = Translate( ~No images specified in file~ );
	BadPath = Translate( ~Invalid image path: ~ );
	BadOrder = Translate( ~Order ID contains an invalid character~ );

	ThumbThread( New, ImageThread );
	ImageThread.New();
	Global( ImageThread );

	// Initialize data
	OrderNumber = ~~;
	CustomerID = ~~;
	ImageFolder = ~~;
	RenderFolder = ~~;
	ImageName = ~~;
	ImageData = ~~;
	OrderSection = 1;
	ImageSection = 2;
	CurrentSection = 0;

	if ( !File( fp, Open, ~<FilePath>~, Read, Text ) ) 
	{
		Warning( Translate( ~Could not open <FilePath>: <$Func.GetLastErrorMsg()>~ ) );
		return;
	}

	Count = 0;
	Error = FALSE;
	HeaderValid = FALSE;
	while ( !<Error> && fp( ReadString, Buffer ) ) 
	{
		if ( DefinedAndNotNull( Buffer ) )
		{
			if ( substr( ~<Buffer>~, 0, 1, FirstChar ) )
			{
				if ( ~<FirstChar>~ == ~#~)
				{
					continue;	// Ignore comment lines
				}

				if ( ~<FirstChar>~ == ~[~ ) // Section headers
				{
					Buffer = Upper( ~<Buffer>~ );
				
					if ( ~<Buffer>~ == ~[ORDER INFO]~ )
					{
						CurrentSection = <OrderSection>;
						continue;
					}
					else if ( ~<Buffer>~ == ~[IMAGE INFO]~ )
					{
						if ( DefinedAndNotNull( OrderNumber ) &&
							 DefinedAndNotNull( ImageFolder ) &&
							 DefinedAndNotNull( RenderFolder ) )
						{
							HeaderValid = TRUE;
						}

						if ( !<HeaderValid> )
						{
							if ( !DefinedAndNotNull( OrderNumber ) )
							{
								ShowError( ~<FilePath>~, ~<BlankOrder>~ );
								Error = TRUE;
								break;
							}
							else if ( !DefinedAndNotNull( ImageFolder ) )
							{
								ShowError( ~<FilePath>~, ~<BlankImage>~ );
								Error = TRUE;
								break;
							}
							else if ( !DefinedAndNotNull( RenderFolder ) )
							{
								ShowError( ~<FilePath>~, ~<BlankRender>~ );
								Error = TRUE;
								break;
							}
						}

						CurrentSection = <ImageSection>;
						continue;
					}
					else if ( ~<Buffer>~ == ~[END FILE]~ )
					{
						if ( DefinedAndNotNull( ImageName ) )
						{
							ShowError( ~<FilePath>~, ~<NoImageData><ImageName>~ );
							Error = TRUE;
						}
						break;
					}
					continue;
				}
			}

			GetTokens( ~<Buffer>~, ~=~, Keyword, Value );
			Keyword = Upper( ~<Keyword>~ );
			Keyword = String( TrimRight, ~<Keyword>~ );
			Value = String( TrimLeft, ~<Value>~ );
			Value = String( TrimRight, ~<Value>~ );

			if ( <CurrentSection> == <OrderSection> )
			{
				if ( ~<Keyword>~ == ~SCHEMA~ )
				{
					// Do nothing
				}
				else if ( ~<Keyword>~ == ~ORDERNUMBER~ )
				{
					OrderNumber = ~<Value>~;
					if ( !DefinedAndNotNull( OrderNumber ) )
					{
						ShowError( ~<FilePath>~, ~<BlankOrder>~ );
						Error = TRUE;
						break;
					}

					len = strlen( ~<OrderNumber>~ );
					Loop = 0;
					while ( <Loop> < <Len> )
					{
						substr( ~<OrderNumber>~, <Loop>, 1, CompareChar );
						if ( ~<CompareChar>~ == ~.~ )
						{
							// Note that a tilda in the file will cause a strange error.
							ShowError( ~<FilePath>~, ~<BadOrder>~ );
							Error = TRUE;
							break;
						}
						Loop += 1;
					}
					if ( <Error> )
					{
						break;
					}
				}
				else if ( ~<Keyword>~ == ~CUSTOMERID~ )
				{
					CustomerID = ~<Value>~;
				}
				else if ( ~<Keyword>~ == ~IMAGEFOLDER~ )
				{
					ImageFolder = ~<Value>~;
					if ( !DefinedAndNotNull( ImageFolder ) )
					{
						ShowError( ~<FilePath>~, ~<BlankImage>~ );
						Error = TRUE;
						break;
					}

					len = strlen( ~<ImageFolder>~ );
					if ( substr( ~<ImageFolder>~, <len> - 1, 1, LastChar ) )
					{
						if ( ~<LastChar>~ != ~\~ )
						{
							ImageFolder = ~<ImageFolder>\~;
						}
					}
				}
				else if ( ~<Keyword>~ == ~RENDERFOLDER~ )
				{
					RenderFolder = ~<Value>~;
					if ( !DefinedAndNotNull( RenderFolder ) )
					{
						ShowError( ~<FilePath>~, ~<BlankRender>~ );
						Error = TRUE;
						break;
					}

					len = strlen( ~<RenderFolder>~ );
					if ( substr( ~<RenderFolder>~, <len> - 1, 1, LastChar ) )
					{
						if ( ~<LastChar>~ != ~\~ )
						{
							RenderFolder = ~<RenderFolder>\~;
						}
					}
				}
			}
			else if ( <CurrentSection> == <ImageSection> )
			{
				if ( ~<Keyword>~ == ~IMAGENAME~ )
				{
					++Count;

					if ( DefinedAndNotNull( ImageName ) )
					{
						ShowError( ~<FilePath>~, ~<NoImageData><ImageName>~ );
						Error = TRUE;
						break;
					}
					ImageName = ~<Value>~;

					len = strlen( ~<ImageName>~ );
					Loop = 0;
					while ( <Loop> < <Len> )
					{
						substr( ~<ImageName>~, <Loop>, 1, CompareChar );
						if ( (~<CompareChar>~ == ~'~) || (~<CompareChar>~ == ~(~) || (~<CompareChar>~ == ~)~) ||
							 (~<CompareChar>~ == ~,~) || (~<CompareChar>~ == ~"~) || (~<CompareChar>~ == ~^~) ||
							 (~<CompareChar>~ == ~&~) || (~<CompareChar>~ == ~*~) || (~<CompareChar>~ == ~=~) ||
							 (~<CompareChar>~ == ~|~) || (~<CompareChar>~ == ~<~) || (~<CompareChar>~ == ~>~) ||
							 (~<CompareChar>~ == ~?~) || (~<CompareChar>~ == ~<Tilda>~) )
						{
							// Note that a tilda in the file will cause a strange error.
							ShowError( ~<FilePath>~, ~<BadPath><Buffer>~ );
							Error = TRUE;
							break;
						}
						Loop += 1;
					}
					if ( <Error> )
					{
						break;
					}

					FileName = ~<$Str.$ImageName.Filename.WithExt>~;
					PathOnly = ~~;
					if ( ~<FileName>~ != ~<ImageName>~ )
					{
						PathOnly = ~<$Str.$ImageName.Path>\~;
					}
					if ( !DefinedAndNotNull( ImageName ) )
					{
						ShowError( ~<FilePath>~, ~<BlankPath>~ );
						Error = TRUE;
						break;
					}
				}
				else if ( ~<Keyword>~ == ~IMAGEDATA~ )
				{
					if ( !DefinedAndNotNull( ImageName ) )
					{
						ShowError( ~<FilePath>~, ~<BadImageInfo><Buffer>~ );
						Error = TRUE;
						break;
					}

					NumTokens = GetTokens( ~<Value>~, ~,~, Density, Red, Green, Blue, Contrast, Saturation );

					if ( <NumTokens> != 6 )
					{
						ShowError( ~<FilePath>~, ~<BadImageData><Buffer>~ );
						Error = TRUE;
						ImageName = ~~;
						break;
					}

					ImageList( Filter, ~Path = '<Path>'~ );
					if ( ImageList( GetFirst, Position ) )
					{
						ShowError( ~<FilePath>~, ~<DupImage><ImageName>~ );
						Error = TRUE;
						ImageName = ~~;
						break;
					}

					if ( !IsNumeric( ~<Density>~ ) || !IsNumeric( ~<Red>~ ) || !IsNumeric( ~<Green>~ ) ||
						 !IsNumeric( ~<Blue>~ ) || !IsNumeric( ~<Contrast>~ ) || !IsNumeric( ~<Saturation>~ ) )
					{
						// No range checking for now
						ShowError( ~<FilePath>~, ~<BadImageData><Buffer>~ );
						Error = TRUE;
						ImageName = ~~;
						break;
					}
					ImageList( ClearFilter );
					ImageList( AddNew, Position );

					Frame = Format( <Count>, ~%03.3d~ );
					//ImagePath = ~<ImageFolder><ImageName>~;
					ImagePath = ~<ImageFolder><PathOnly><FileName>~;
					Position( Set, Path, ~<ImagePath>~, Frame, ~<Frame>~, Density, ~<Density>~, Red, ~<Red>~,
							  Green, ~<Green>~, Blue, ~<Blue>~, Contrast, ~<Contrast>~, Saturation, ~<Saturation>~,
							  RelativePath, ~<PathOnly>~ );
					ImageList( Update );
					ImageThread.Enqueue( ~<ImagePath>~ );
					ImageName = ~~;
				}
			}
		}
	}

	if ( !<Error> && !<HeaderValid> )
	{
		if ( !DefinedAndNotNull( OrderNumber ) )
		{
			ShowError( ~<FilePath>~, ~<BlankOrder>~ );
			Error = TRUE;
		}
		else if ( !DefinedAndNotNull( ImageFolder ) )
		{
			ShowError( ~<FilePath>~, ~<BlankImage>~ );
			Error = TRUE;
		}
		else if ( !DefinedAndNotNull( RenderFolder ) )
		{
			ShowError( ~<FilePath>~, ~<BlankRender>~ );
			Error = TRUE;
		}
	}

	if ( !<Error> && !<Count> )
	{
		ShowError( ~<FilePath>~, ~<NoImages>~ );
		Error = TRUE;
	}

	fp( Close );

	if ( <Error> )
	{
		ThePath = ~File~;
		while ( !IsNULL( ~<ThePath>~ ) )
		{
			ThePath = ImageThread.Dequeue();
		}
		ImageThread.Post( MESSAGE_ABORT_THUMBS, 0, 0 );
		// Move file to error folder
		PathOnly = ~<$Str.$FilePath.Path>~;
		PathOnly = ~<PathOnly>\Error~;
		FileName = ~<$Str.$FilePath.Filename.WithExt>~;
		DestPath = ~<PathOnly>\<FileName>~;

		Directory( Create, ~<PathOnly>~ );
		Files( Delete, ~<DestPath>~ );	// Delete any pre-existing files with same name to avoid errors
		if ( !Files( Copy, ~<FilePath>~, ~<DestPath>~, FALSE ) )
		{ 
			GetLastError( ErrorString, err );
			Warning( ~Could not copy <FilePath> to <DestPath>: <err>~ );
			return;
		}
	}
	else
	{
		// Write order into Orders table in DP2 database
		UpdateOrder( ~<OrderNumber>~, ~Status~, ~Adjust~, ~Description~, ~<RenderFlag><RenderFolder>~,
					 ~OrderDate~, ~<$Date.%m/%d/%Y>~, ~CustomerID~, ~<CustomerID>~ );
		
		// Start thumbnail thread
		ImageThread.Post( MESSAGE_START_THUMBS, 0, 0 );

		// Write image list into Images table in DP2 database
		ImageList( ClearFilter );
		More = ImageList( GetFirst, Item );
		while ( <More> )
		{
			//UpdateImage( ~<OrderNumber>~, ~0001~, ~<$pcon.Item[Frame]>~, ~Path~, ~<$pcon.Item[Path]>~ );
			//ImageEditData( SetValue, cDensity, MakeNumber( ~<$pcon.Item[Density]>~ ) );
			//ImageEditData( SetValue, cRed, MakeNumber( ~<$pcon.Item[Red]>~ ) );
			//ImageEditData( SetValue, cGreen, MakeNumber( ~<$pcon.Item[Green]>~ ) );
			//ImageEditData( SetValue, cBlue, MakeNumber( ~<$pcon.Item[Blue]>~ ) );
			//ImageEditData( SetValue, cContrast, MakeNumber( ~<$pcon.Item[Contrast]>~ ) );
			//ImageEditData( SetValue, cSaturation, MakeNumber( ~<$pcon.Item[Saturation]>~ ) );
			//ImageEditData( UpdateCorrections, ~<$pcon.Item[Path]>~ );
			//ImageEditData( SaveCorrections, ~<$pcon.Item[Path]>~ );

			UpdateImage( ~<OrderNumber>~, ~0001~, ~<$pcon.Item[Frame]>~, ~Path~, ~<$pcon.Item[Path]>~,
						 ~Brt~, ~<$pcon.Item[Density]>~, ~Red~, ~<$pcon.Item[Red]>~, ~Grn~, ~<$pcon.Item[Green]>~,
						 ~Blu~, ~<$pcon.Item[Blue]>~, ~Con~, ~<$pcon.Item[Contrast]>~,
						 ~Saturation~, ~<$pcon.Item[Saturation]>~, ~Description~, ~<$pcon.Item[RelativePath]>~ );

			More = ImageList( GetNext, Item );
		}
	}

	if ( !Files( Delete, ~<FilePath>~ ) )
	{
		List( GetErrorDescription, 0, err );
		//GetLastError( ErrorString, err );
		Warning( ~Could not delete <FilePath>: <err>~ );
		return;
	}

	// Delete image list
	ImageList( ClearFilter );
	More = ImageList( GetFirst, Item );
	while ( <More> )
	{
		ImageList( Remove );
		More = ImageList( GetNext, Item );
	}
}

VOID OpenDialog::ReadTextOrders()
{
	WaitCursor( Begin );
	// Create list of images
	PGenConList( ImageList, Create );
	Global( ImageList );

	ImageList( AppendField, Frame,			Char,		<FrameLength> + 1, FldUpdatable );
	ImageList( AppendField, Path,			Char,		255,FldUpdatable );
	ImageList( AppendField, Density,		Integer,	4,	FldUpdatable );
	ImageList( AppendField, Red,			Integer,	4,	FldUpdatable );
	ImageList( AppendField, Green,			Integer,	4,	FldUpdatable );
	ImageList( AppendField, Blue,			Integer,	4,	FldUpdatable );
	ImageList( AppendField, Contrast,		Integer,	4,	FldUpdatable );
	ImageList( AppendField, Saturation,		Integer,	4,	FldUpdatable );
	ImageList( AppendField, RelativePath,	Char,		255,FldUpdatable );

	ImageList( Open );

	// Read any text orders if they exist
	if ( <ExtTextCheck> )
	{
		if ( DefinedAndNotNull( ExtTextPath ) )
		{
			len = strlen( ~<ExtTextPath>~ );
			substr( ~<ExtTextPath>~, <len> - 1, 1, LastChar );
			if ( ~<LastChar>~ == ~\~ )
			{
				Search = ~<ExtTextPath>*.txt~;
			}
			else
			{
				Search = ~<ExtTextPath>\*.txt~;
			}

			MoreFiles = FindFile( DirectoryEntry, Find, ~<Search>~ );
			while ( $MoreFiles )
			{
				MoreFiles = DirectoryEntry( Next );

				DirectoryEntry( Get, Path, FilePath );
					
				if ( DirectoryEntry( Dots ) || DirectoryEntry( IsDirectory ) )
				{
					continue;
				}
				ReadSingleTextOrder( ~<FilePath>~ );
			}
		}
	}
	ForgetGlobal( ImageList );

	WaitCursor( End );
}


// FUNCTION: OrderConverted()
//
//  This function checks that the order has been converted
//
NUMERIC OrderConverted(OrderID)
{
    connected = ADO( database,Connect );
    if ( !<connected> ) 
    {
        Invoke( UserMessage,Translate( ~Failed to connect in OrderConverted <OrderID>~ ) );
        Log( Session, ~Analyzer:********* Could not connect to database in OrderConverted !!!!!~ );
        return FALSE;
    }
    
    // Query the processing workstation
    Query = ~Select ConversionStatus from conversion WHERE (OrderID='<OrderID>')~;

    if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
    {
        Invoke( UserMessage,Translate( ~Failed to connect in OrderConverted~ ) );
        Log( Session, ~Analyzer:********* Failed to retrieve the Conversion list !!!!!~ );
        return FALSE;
    }

    Count = List( NumEntries );

    if ( <Count> > 0 ) 
    {
        List( GetFirst, Order );
        if (~<$pcon.Order[ConversionStatus]>~ == ~10~)
        {
//            Log( Session, ~Analyser:********* <OrderID> Has Been Converted *********~ );
            return TRUE;
        }
    }

    return FALSE;
}
// FUNCTION: OrderConverted()
//
//  This function checks that the order has been converted
//
NUMERIC OrderInConversionTable(OrderID)
{
    connected = ADO( database,Connect );
    if ( !<connected> ) 
    {
        Invoke( UserMessage,Translate( ~Failed to connect in OrderInConversionTable <OrderID>~ ) );
        Log( Session, ~Analyzer:********* Could not connect to database in OrderInConversionTable !!!!!~ );
        return FALSE;
    }
    
    // Query the processing workstation
    Query = ~Select ConversionStatus from conversion WHERE (OrderID='<OrderID>')~;

    if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
    {
        Invoke( UserMessage,Translate( ~Failed to connect in OrderInConversionTable~ ) );
        Log( Session, ~Analyzer:********* Failed to retrieve the Conversion list !!!!!~ );
        return FALSE;
    }

    Count = List( NumEntries );

    if ( <Count> > 0 ) 
    {
        return TRUE;
    }

    return FALSE;
}

// FUNCTION: OrderExists()
//
//  This function checks that the order exists Orders
//
NUMERIC OrderExists(OrderID)
{
    connected = ADO( database,Connect );
    if ( !<connected> ) 
    {
        Invoke( UserMessage,Translate( ~Failed to connect in OrderExists <OrderID>~ ) );
        Log( Session, ~Analyzer:********* Could not connect to database in OrderExists !!!!!~ );
        return FALSE;
    }
    
    Query = ~Select * from orders WHERE (ID='<OrderID>')~;

    if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
    {
        Invoke( UserMessage,Translate( ~Failed to connect in OrderExists~ ) );
        Log( Session, ~Analyzer:********* Failed to retrieve the orders list !!!!!~ );
        return FALSE;
    }

    Count = List( NumEntries );

    if ( <Count> > 0 ) 
    {
        return TRUE;
    }

    return FALSE;
}

// FUNCTION: ProofOrder()
//
//  This function checks that the order is set to "Proof" 
//
NUMERIC ProofOrder(OrderID)
{
    connected = ADO( database,Connect );
    if ( !<connected> ) 
    {
        Invoke( UserMessage,Translate( ~Failed to connect in ProofOrder <OrderID>~ ) );
        Log( Session, ~Analyzer:********* Could not connect to database in ProofOrder !!!!!~ );
        return FALSE;
    }
    
    // Query the processing workstation
    Query = ~Select Status from Orders WHERE (ID='<OrderID>')~;

    if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
    {
        Invoke( UserMessage,Translate( ~Failed to connect in ProofOrder~ ) );
        Log( Session, ~Analyzer:********* Failed to retrieve the Conversion list !!!!!~ );
        return FALSE;
    }

    Count = List( NumEntries );

    if ( <Count> > 0 ) 
    {
        List( GetFirst, Order );
        if (~<$pcon.Order[Status]>~ == ~Proof~)
        {
            return TRUE;
        }
    }

    return FALSE;
}
STR OpenDialog::GetCustomerName( CustomerID )
{
    Query = ~Select Name From Customers Where ID = '<CustomerID>'~;

    if ( PGenConList( CustomerList,Connect,Cursor,Forward,Query,~<Query>~ ) )
    {
        if ( CustomerList( GetFirst,Customer ) )
        {
           return ~<$pcon.Customer[Name]>~;
        }
    }
    Log(Session, ~**** Customer name Not Found for <CustomerID>~);
    return ~~;
}

VOID OpenDialog::PopulateOrderListBox(ImportedOrderID)
{
	Count = 0;

	ReadTextOrders();

	dlg( List, OrderListBox, ResetContent );

    if (!GetWorkStationSettings( ~Analyzer~, ~DisplayProofOrders~, DisplayProofOrders, Enabled ))
    {
        SetWorkStationSettings( ~Analyzer~,~DisplayProofOrders~,~0~,TRUE ); 
        GetWorkStationSettings( ~Analyzer~, ~DisplayProofOrders~, DisplayProofOrders, Enabled );
    }

    if (!GetWorkStationSettings( ~Analyzer~, ~DisplayHoldOrders~, DisplayHoldOrders, Enabled ))
    {
        SetWorkStationSettings( ~Analyzer~,~DisplayHoldOrders~,~0~,TRUE ); 
        GetWorkStationSettings( ~Analyzer~, ~DisplayHoldOrders~, DisplayHoldOrders, Enabled );
    }

    WhereTxt = ~Status = 'Adjust'~;
    if (~<DisplayProofOrders>~ == ~1~)
    {
        WhereTxt = ~<WhereTxt> or Status = 'Proof'~;
    }

    if (~<DisplayHoldOrders>~ == ~1~)
    {
        WhereTxt = ~<WhereTxt> or Status = 'Hold'~;
    }

    if ((~<DisplayProofOrders>~ == ~1~) || (~<DisplayHoldOrders>~ == ~1~))
    {
        // Only select those at Adjust and that have been converted to SRGB.
        Query = ~Select * From Orders inner join conversion on Orders.ID=Conversion.OrderID where (<WhereTxt>) and conversionStatus='10' Order By~;
    }
    else
    {
        Query = ~Select * From Orders inner join conversion on Orders.ID=Conversion.OrderID where (Status = 'Adjust') and conversionStatus='10' Order By~;
    }

	SortString = ~conversion.priority DESC, conversion.Date~;
	if ( <SortColumn> == 1 )
	{
		SortString = ~conversion.ImagesToProcess DESC~;
	}
	else if ( <SortColumn> == 2 )
	{
		SortString = ~conversion.Date~;
	}
	else if ( <SortColumn> == 3 )
	{
		SortString = ~conversion.Date~;
	}
	else if ( <SortColumn> == 4 )
	{
		SortString = ~conversion.Priority DESC~;
	}


	if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query> <SortString>~ ) )
	{
        QtyToColour = 0;
        OrderQty    = 0;

		while ( List( GetNext, Record ) )
		{
			theOrderID = ~~;
			okToAddOrder = FALSE;
			if ( !IsNULL(~<$pcon.Record[ID]>~) )
			{
				theOrderID = ~<$pcon.Record[ID]>~;
				okToAddOrder = TRUE;
			}
			else
			{
				// Added the following to help debug a problem we have seen where the order ID
				// comes back NULL (which should never happen).
				result = Record( GetValue,~ID~,theOrderID );
				if ( <result> && !IsNull(~<theOrderID>~) )
				{
					okToAddOrder = TRUE;
				}
				else
				{
					hResult = Record( GetHResult );
					Log( Session,~Error in Digital Analyzer getting order ID.  HResult = <hResult>~ );
				}
			}

			if ( <okToAddOrder> )
			{
                substr(~<Roll>~, 0, <MaxFileName>, Roll);

                substr(~<$pcon.Record[Date]>~, 0, 10, Date);
                substr(~<$pcon.Record[Date]>~, 11, 8, Time);

                // This dodgy bit of logic select the image quantity.
                // If the order contains new images then count them otherwise count
                // the old ones.
                if (~<$pcon.Record[ImagesOrderID]>~ != ~~)
                {
                     OldImageQty = NewImages(~<$pcon.Record[ImagesOrderID]>~);
                     NewImageQty = NewImages(~<theOrderID>~);

                     if (~<NewImageQty>~ == ~0~)
                     {
                         ImageQty = ~<OldImageQty> (Old) ~; // Mark it 
                     }
                     else
                     {
                         ImageQty = ~<NewImageQty> (<OldImageQty> Old)~;
                     }
                     QtyToColour = <QtyToColour> + Numeric(~<OldImageQty>~) + Numeric(~<NewImageQty>~) ;
                     ++OrderQty;
                }
                else
                {
//                  ImageQty = ~<$pcon.Record[ImagesToProcess]>~;
                    ImageQty = NewImages(~<theOrderID>~);
                    QtyToColour = <QtyToColour> + Numeric(~<ImageQty>~);
                     ++OrderQty;
                }

                if (~<$pcon.Record[Status]>~ == ~Proof~)
                {
                    ImageQty = ~<ImageQty> (Proof)~;
                } 

                if (~<$pcon.Record[Status]>~ == ~Hold~)
                {
                    ImageQty = ~<ImageQty> (Hold)~;
                } 

                Customer = GetCustomerName( ~<$pcon.Record[CustomerID]>~);

				ItemNum = dlg( List, OrderListBox, InsertItem, <Count>, ~<theOrderID>~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 1, ~<ImageQty>~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 2, ~<Date> ~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 3, ~<Time>~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 4, ~<$pcon.Record[Priority]>~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 5, ~<$pcon.Record[ImagesOrderID]>~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 6, ~<Customer>~ );
				++Count;
			}
		}
	}
    dlg( SetControlValue, TocolourField, ~<QtyToColour> images in <OrderQty> orders~ );
	itemToSelect = 0;
	if ( DefinedAndNotNull( ImportedOrderID ) )
	{
		foundIndex = dlg( List, OrderListBox, FindItem, ~<ImportedOrderID>~ );
		if ( <foundIndex> != -1 )
		{
			itemToSelect = <foundIndex>;
		}
	}

	dlg( List, OrderListBox, Select, <itemToSelect> );

	// Set focus to order ID field
	dlg( SetControlFocus, OrderIDField );
}

if (0)
{
  // Backup Copy
VOID OpenDialog::PopulateOrderListBox(ImportedOrderID)
{
	Count = 0;

	if ( DefinedAndNotNull( AnalyzerDebug ) )
	{
		if ( KeyState( Shift ) && KeyState( Control ) && KeyState( Alt ) )
		{
			DebugMe = TRUE;
		}
	}
	
	ReadTextOrders();

	dlg( List, OrderListBox, ResetContent );

	// Query list of orders to analyze/delete to populate order list
	Query = ~Select * From Orders where Status = 'Adjust' Or Status = 'Complete' Order By~;

	if ( DefinedAndNotNull( DebugMe ) )
	{
		Query = ~Select * From Orders where Status = 'Ready' OR Status = 'Adjusting' Order By~;
	}

	SortString = ~ID~;
	if ( <SortColumn> == 1 )
	{
		SortString = ~CustomerID~;
	}
	else if ( <SortColumn> == 2 )
	{
		SortString = ~ImagesOrderID~;
	}
	else if ( <SortColumn> == 3 )
	{
		SortString = ~Status~;
	}
	else if ( <SortColumn> == 4 )
	{
		SortString = ~Copyright~;
	}

	if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query> <SortString>~ ) )
	{
		while ( List( GetNext, Record ) )
		{
			theOrderID = ~~;
			okToAddOrder = FALSE;
			if ( !IsNULL(~<$pcon.Record[ID]>~) )
			{
				theOrderID = ~<$pcon.Record[ID]>~;
				okToAddOrder = TRUE;
			}
			else
			{
				// Added the following to help debug a problem we have seen where the order ID
				// comes back NULL (which should never happen).
				result = Record( GetValue,~ID~,theOrderID );
				if ( <result> && !IsNull(~<theOrderID>~) )
				{
					okToAddOrder = TRUE;
				}
				else
				{
					hResult = Record( GetHResult );
					Log( Session,~Error in Digital Analyzer getting order ID.  HResult = <hResult>~ );
				}
			}

			if ( <okToAddOrder> )
			{
				ItemNum = dlg( List, OrderListBox, InsertItem, <Count>, ~<theOrderID>~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 1, ~<$pcon.Record[CustomerID]> ~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 2, ~<$pcon.Record[ImagesOrderID]> ~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 3, ~<$pcon.Record[Status]> ~ );
				dlg( List, OrderListBox, SetItemText, <ItemNum>, 4, ~<$pcon.Record[Copyright]> ~ );
				++Count;
			}
		}
	}

	itemToSelect = 0;
	if ( DefinedAndNotNull( ImportedOrderID ) )
	{
		foundIndex = dlg( List, OrderListBox, FindItem, ~<ImportedOrderID>~ );
		if ( <foundIndex> != -1 )
		{
			itemToSelect = <foundIndex>;
		}
	}

	dlg( List, OrderListBox, Select, <itemToSelect> );

	// Set focus to order ID field
	dlg( SetControlFocus, OrderIDField );
}
}
VOID OpenDialog::SetupList()
{
	// Insert columns
	dlg( List, OrderListBox, InsertColumn, 0, ~Order ID~, Right, 90, 0 );
    dlg( List, OrderListBox, InsertColumn, 1, ~Image Qty~, Left, 85, 0 );
    dlg( List, OrderListBox, InsertColumn, 2, ~Date~, Left, 80, 0 );
    dlg( List, OrderListBox, InsertColumn, 3, ~Time~, Left, 60, 0 );
    dlg( List, OrderListBox, InsertColumn, 4, ~Priority~, Left, 45, 0 );
//  dlg( List, OrderListBox, InsertColumn, 5, ~Status~, Left, 90, 0 );
    dlg( List, OrderListBox, InsertColumn, 6, ~Images Order~, Left, 90, 0 );
    dlg( List, OrderListBox, InsertColumn, 7, ~Customer~, Left, 230, 0 );

//	dlg( List, OrderListBox, InsertColumn, 1, ~Customer~, Left, 90, 0 );
//	dlg( List, OrderListBox, InsertColumn, 2, ~Images Order~, Left, 90, 0 );
//	dlg( List, OrderListBox, InsertColumn, 3, ~Status~, Left, 90, 0 );
//	dlg( List, OrderListBox, InsertColumn, 4, ~Copyright Text~, Left, 136, 0 );

//	Action = STR ( OpenDialog::OnRefreshButton(); );
//	QueueContentsAfter( Action,5000 );
}

VOID OpenDialog::OnTimerRefresh()
{
    Analyzer::RefreshOrders(~~);
    OpenDialog::StartTimerRefresh();
}


VOID OpenDialog::StartTimerRefresh()
{
    OpenDialog::StopTimerRefresh();
    if (!GetWorkStationSettings( ~Analyzer~, ~AutoRefreshSeconds~, AutoRefreshSeconds, Enabled ))
    {
        SetWorkStationSettings( ~Analyzer~,~AutoRefreshSeconds~,~10~,TRUE ); 
        GetWorkStationSettings( ~Analyzer~, ~AutoRefreshSeconds~, AutoRefreshSeconds, Enabled );
    }

    SetTimer( 2,1000 * <AutoRefreshSeconds>,~OpenDialog::OnTimerRefresh()~ );	// EXPIRE IN AutoRefreshSeconds
}


VOID OpenDialog::StopTimerRefresh()
{
    KillTimer( 2 );
}

NUMERIC OpenDialog::OnOrderSelected()
{
	// Retrieve selected item and populate Order ID field
	Item = dlg( List, OrderListBox, GetSelectedItemByIndex, 0 );
	dlg( List, OrderListBox, GetItemText, <Item>, 0, Order);
	
	SetOrder = TRUE;
	IsSelectingOrder = TRUE;
	Global( SetOrder );
	dlg( SetControlValue, OrderIDField, ~<Order>~ );
	dlg( EditText, OrderIDField, SetSel, 0, -1, TRUE );

	return TRUE;	
}

VOID OpenDialog::OnKeyDown()
{
	// Get key pressed
	Key = dlg( GetLastKey, KeyString );

	// Process keystroke
	ProcessKey( ~<KeyString>~ );

	// Process dialog Ok/Cancel actions
	if ( ~<KeyString>~ == ~<pPrint>~ )
	{
		Execute = ~<This>.OnOpenButton();~;
	}
	else if ( ~<KeyString>~ == ~<pNoPrint>~ )
	{
		Execute = ~<This>.OnCancelButton();~;
	}
	if ( DefinedAndNotNull( Execute ) )
	{
		<Execute>
	}
}

VOID OpenDialog::OnEditKeyDown()
{
	if ( <IsSelectingOrder> )
	{
		IsSelectingOrder = FALSE;
		return;
	}

	// Initialize
	Loop = 0;
	dlg( GetControlValue, OrderIDField, Line );
	len = strlen( ~<Line>~ );
	Order = ~~;
	NavKey = ~~;

	// Get any navigation key pressed
	while ( <Loop> < <Len> )
	{
		substr( ~<Line>~, <Loop>, 1, Key );

		if ( !ProcessKey( ~<Key>~ ) )
		{
			Order = ~<Order><Key>~;
		}
		else
		{
			NavKey = ~<Key>~;
		}
		Loop += 1;
	}

	// Process dialog Ok/Cancel actions
	if ( ~<NavKey>~ == ~<pPrint>~ )
	{
		Execute = ~<This>.OnOpenButton();~;
	}
	else if ( ~<NavKey>~ == ~<pNoPrint>~ )
	{
		Execute = ~<This>.OnCancelButton();~;
	}

	// Handle dialog Ok/Cancel actions
	if ( !DefinedAndNotNull( Execute ) )
	{
		// Set focus back to edit control if necessary
		if ( ~<NavKey>~ != ~~ )
		{
			dlg( SetControlFocus, OrderIDField );
		}
		else
		{
			// Set manual entry flag
			if ( <SetOrder> )
			{
				SetOrder = FALSE;
			}
			else
			{
				ManualEdit = TRUE;
				ManualOrderID = ~<Order>~;
				Global( ManualEdit );
			}
		}
	}
	else
	{
		// Execute dialog Ok/Cancel actions
		<Execute>
	}
}

NUMERIC OpenDialog::ProcessKey( Key )
{
	Handled = FALSE;

	// Process keypress
	if ( ~<Key>~ == ~<pDensity>~ )
	{
		Handled = TRUE;
		OnChangeOrder( -1 );
	}
	else if ( ~<Key>~ == ~<pDensity2>~ )
	{
		Handled = TRUE;
		OnChangeOrder( 1 );
	}
	else if ( ~<Key>~ == ~<pNext>~ )
	{
		Handled = TRUE;
		OnChangeOrder( 1 );
	}
	else if ( ~<Key>~ == ~<pPrev>~ )
	{
		Handled = TRUE;
		OnChangeOrder( -1 );
	}
	else if ( ~<Key>~ == ~<pPrint>~ )
	{
		Handled = TRUE;
	}
	else if ( ~<Key>~ == ~<pNoPrint>~ )
	{
		Handled = TRUE;
	}

	return <Handled>;
}



/***********************************************************************************
 ***********************************************************************************
 ****************************** Store Settings Dialog ******************************
 ***********************************************************************************
 ***********************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID StoreDialog::StoreDialog()
{
	// Set up window defaults
	Title = ~Store Corrections~;
	Left = 200;
	ExitScriptOnClose = FALSE;
	StatusBar = ~~;
}

VOID StoreDialog::WindowDefinition()
{
	Fields:	WantsMinimizeBox		<DP2> ? TRUE : FALSE
			HActionsText			ACTION SHOWHELPPAGE ( KPDAWHelpFile "Storing_Image_Corrections.htm" )
}

VOID StoreDialog::DefineMessages()		
{ 
	BaseDialog::DefineMessages();	

	// Define messages for dialog box
	Translations( AddText, Cancel, ~Cancel~ );
	Translations( AddText, Open, ~OK~ );
	Translations( AddText, Setting, ~Description:~ );
	Translations( AddText, Instructions, ~Press a numeric key and/or enter a setting description, then select OK or type a number~ );
	Translations( AddText, SettingTip, ~Enter correction name~ );
	Translations( AddText, ListTip, ~List of defined corrections~ );
	Translations( AddText, NoDescription, ~Please enter a number or description for the correction.~ );
	Translations( AddText, Column1, ~Number~ );
	Translations( AddText, Column2, ~Description~ );
}

VOID StoreDialog::DefineControls()
{
	Define: SettingPrompt Using DDWinCtrlDef AsSymbol SettingPrompt Private
			Fields:	TypeName			StaticText
					Position			$hGap, 35,
										55, 15
					Text				Translate( Translations, Setting )

	Define: TextPrompt Using DDWinCtrlDef AsSymbol TextPrompt Private
			Fields:	TypeName			StaticText
					Position			SettingPrompt(GetRight, Position) + $hGap, 4,
										230, 26
					Text				Translate( Translations, Instructions )

	Define: SettingField Using DDWinCtrlDef AsSymbol SettingField Private 
			Fields: TypeName			EditText  
					Position			SettingPrompt(GetRight, Position) + $hGap, SettingPrompt(GetTop, Position) - 4,
										245, 25
					IActionsText		ACTIONS ( Get )
					DActionsText		ACTIONS ( Save "Exec(<This>.OnKeyDown();)" )
					OActionsText		ACTIONS ( Save )
					Tooltip				Translate( Translations, SettingTip )
					MaxTextSize			<CorrectionLength>

	Define: SettingListBox Using DDWinCtrlDef AsSymbol SettingListBox Private
		Fields:	TypeName				List
				ListViewType			Report
				Position				SettingPrompt(GetLeft, Position), SettingPrompt(GetBottom, Position) + $vGap * 2,
										400, 400
				GenConField				~Setting~
				IActionsText			ACTIONS ( Get )
				DActionsText			ACTIONS ( Save "EXEC(<This>.OnCorrectionSelected())" )
				OActionsText			ACTIONS ( Save )
				AllowMultipleSelection	FALSE
				GridLines				TRUE
				FullRowSelect			TRUE
				NoSortHeader			TRUE
				Border					TRUE
				ClientEdge				TRUE
				ShowSelAlways			TRUE
				InfoTip					TRUE
				Tooltip					Translate( Translations, ListTip )
				ReturnKeyActionsText	ACTIONS ( Save "EXEC(<This>.OnCorrectionSelected())" )
				KeyboardActionsText		ACTIONS ( Save "EXEC(<This>.OnKeyDown())" )
	
	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
			Fields:	TypeName			DefaultButton
					Position			SettingListBox(GetRight, Position) - <ButtonWidth>, $vGap, <ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnOpenButton() )
					Text				Translate( Translations, Open )

	Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton Private
			Fields:	TypeName			Button
					Position			OpenButton(GetLeft, Position), OpenButton(GetBottom, Position) + $vGap,
										<ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnCancelButton() )
					Text				Translate( Translations, Cancel )
}

VOID StoreDialog::OnDialogEnd()
{
	// Release wheelman control
	DisableWheelman();

	// Re-enable menus
	EnableMenus( TRUE, FALSE );

	// Re-enable correct view
	EnableCorrectWindow( TRUE );
}

/************************************************
 *************** Member functions ***************
 ************************************************/

NUMERIC	StoreDialog::OnCancelButton()
{
	DoCancelButton();	// Do this last (destroys object)
	return TRUE;
}

NUMERIC	StoreDialog::OnOpenButton()
{
	// Add current correction to correction list
	dlg( GetControlValue, SettingField, Description );
	if ( ~<Description>~ == ~~ )
	{
		// No number and no description, warn user
		Warning( Translate( Translations, NoDescription ) );
	}
	else
	{
		CorrectionList( Filter, ~Description = '<Description>'~ );
		if ( !CorrectionList( GetFirst, Position ) )
		{
			CorrectionList( AddNew,Position );
		}
		Position( Set, Description, ~<Description>~, Number, ~-1~, Density, ~<CurDensity>~, Red, ~<CurRed>~,
				  Green, ~<CurGreen>~, Blue, ~<CurBlue>~, Contrast, ~<CurContrast>~, Saturation, ~<CurSaturation>~,
				  Gamma, ~<CurGamma>~, LastUsed, ~0~ );
		CorrectionList( Update );

		AnalyzerView.ForgetCurrentCorrections();

		DoCancelButton();
	}
	return TRUE;
}

VOID StoreDialog::OnChangeCorrection( Direction )
{
	// Move setting list selector
	if (<Direction> < 0 )
	{
		dlg( List, SettingListBox, SelectPrev );
	}
	else
	{
		dlg( List, SettingListBox, SelectNext );
	}
	OnSettingSelected();
}

NUMERIC StoreDialog::PopulateCorrectionListBox()
{
	Count = 0;

	// Insert columns
	dlg( List, SettingListBox, InsertColumn, 0, Translate( Translations, Column1 ), Right, 50, 0 );
	dlg( List, SettingListBox, InsertColumn, 1, Translate( Translations, Column2 ), Left, 346, 0 );

	// Add numbered corrections to list
	CorrectionList( Filter, ~Number >= 0~ );
	CorrectionList( Sort, ~Number ASC~ );
	More = CorrectionList( GetFirst, Item );
	while ( <More> )
	{
		ItemNum = dlg( List, SettingListBox, InsertItem, <Count>, ~<$pcon.Item[Number]>~ );
		dlg( List, SettingListBox, SetItemText, <ItemNum>, 1, ~<$pcon.Item[Description]> ~ );
		Count += 1;
		More = CorrectionList( GetNext, Item );
	}

	// Add non-numbered corrections to list
	CorrectionList( Filter, ~Number < 0~ );
	CorrectionList( Sort, ~Description ASC~ );
	More = CorrectionList( GetFirst, Item );
	while ( <More> )
	{
		ItemNum = dlg( List, SettingListBox, InsertItem, <Count>, ~ ~ );
		dlg( List, SettingListBox, SetItemText, <ItemNum>, 1, ~<$pcon.Item[Description]>~ );
		Count += 1;
		More = CorrectionList( GetNext, Item );
	}

	// Set focus to description field
	dlg( SetControlFocus, SettingField );
	
	return TRUE;
}

NUMERIC StoreDialog::OnCorrectionSelected()
{
	// Do nothing
	return TRUE;	
}

NUMERIC StoreDialog::OnKeyDown()
{
	// Get the last character in the description field
	dlg( GetControlValue, SettingField, Setting );
	len = strlen( ~<Setting>~ );
	substr( ~<Setting>~, <len> - 1, <len>, Number );
	substr( ~<Setting>~, 0, <len> - 1, Description );

	// If 1-9 was pressed as the last character, add the correction using that number and set the description
	if ( MakeNumber( ~<Number>~ ) > 0 )
	{
		CorrectionList( Filter, ~Number = <Number>~ );
		if ( !CorrectionList( GetFirst, Position ) )
		{
			CorrectionList( AddNew,Position );
		}
		Position( Set, Description, ~<Description>~, Number, ~<Number>~, Density, ~<CurDensity>~, Red, ~<CurRed>~,
				  Green, ~<CurGreen>~, Blue, ~<CurBlue>~, Contrast, ~<CurContrast>~, Saturation, ~<CurSaturation>~, Gamma, ~<CurGamma>~ );
		CorrectionList( Update );

		AnalyzerView.ForgetCurrentCorrections();

		DoCancelButton();
		return TRUE;
	}
	return TRUE;
}



/************************************************************************************
 ************************************************************************************
 ****************************** Recall Settings Dialog ******************************
 ************************************************************************************
 ************************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID RecallDialog::RecallDialog()
{
	// Set up window defaults
	Title = ~Recall Corrections~;
	Left = 200;
	ExitScriptOnClose = FALSE;
	StatusBar = ~~;
}

VOID RecallDialog::WindowDefinition()
{
	Fields:	WantsMinimizeBox		<DP2> ? TRUE : FALSE
			HActionsText			ACTION SHOWHELPPAGE ( KPDAWHelpFile "Recalling_Stored_Corrections" )
}

VOID RecallDialog::DefineMessages()		
{ 
	BaseDialog::DefineMessages();	

	// Define messages for dialog box
	Translations( AddText, Open, ~Open~ );
	Translations( AddText, ListTip, ~Select a correction to apply~ );
}

VOID RecallDialog::DefineControls()
{
	// Add mnemonic buttons
	AddPromptControl( ~<pNum0>~ );
	AddPromptControl( ~<pNum1>~ );
	AddPromptControl( ~<pNum2>~ );
	AddPromptControl( ~<pNum3>~ );
	AddPromptControl( ~<pNum4>~ );
	AddPromptControl( ~<pNum5>~ );
	AddPromptControl( ~<pNum6>~ );
	AddPromptControl( ~<pNum7>~ );
	AddPromptControl( ~<pNum8>~ );
	AddPromptControl( ~<pNum9>~ );
	AddPromptControl( ~<pDensity>~ );
	AddPromptControl( ~<pDensity2>~ );
	AddPromptControl( ~<pNext>~ );
	AddPromptControl( ~<pPrev>~ );
	AddPromptControl( ~<pPrint>~ );
	AddPromptControl( ~<pNoPrint>~ );

	Define: SettingListBox Using DDWinCtrlDef AsSymbol SettingListBox Private
		Fields:	TypeName				List
				ListViewType			Report
				Position				$hGap, $vGap,
										400, 400
				GenConField				~Setting~
				IActionsText			ACTIONS ( Get )
				DActionsText			ACTIONS ( Save "EXEC(<This>.OnCorrectionSelected())" )
				OActionsText			ACTIONS ( Save )
				AllowMultipleSelection	FALSE
				GridLines				TRUE
				FullRowSelect			TRUE
//				HeaderDragDrop			TRUE
				NoSortHeader			TRUE
				Border					TRUE
				ClientEdge				TRUE
				ShowSelAlways			TRUE
				InfoTip					TRUE
				Tooltip					Translate( Translations, ListTip )
				ReturnKeyActionsText	ACTIONS ( Save "EXEC(<This>.OnCorrectionSelected())" )
				KeyboardActionsText		ACTIONS ( Save "EXEC(<This>.OnKeyDown())" )
				DoubleClickActionsText	ACTIONS ( Save "EXEC(<This>.OnOpenButton())" )

	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
		Fields:	TypeName				DefaultButton
				Position				SettingListBox(GetRight, Position) - <ButtonWidth>, $vGap,
										<ButtonWidth>, <ButtonHeight>
				DActionsText			ACTION EXEC ( <This>.OnOpenButton() )
				Text					Translate( Translations, Open )
				IsHidden				T
}

VOID RecallDialog::OnDialogEnd()
{
	// Release wheelman control
	DisableWheelman();

	EnableMenus( TRUE, FALSE );

	// Re-enable correct view
	EnableCorrectWindow( TRUE );
}

/************************************************
 *************** Member functions ***************
 ************************************************/

VOID RecallDialog::AddPromptControl( Character )
{
	// Add mnemonic control, changing button name if invalid character is mnemonic
	NewCharacter = ~<Character>~;
	if ( ~<Character>~ == ~<pDensity>~ )
	{
		NewCharacter = ~01~;
	}
	else if ( ~<Character>~ == ~<pDensity2>~ )
	{
		NewCharacter = ~02~;
	}
	else if ( ~<Character>~ == ~<pPrint>~ )
	{
		NewCharacter = ~03~;
	}
	else if ( ~<Character>~ == ~<pNoPrint>~ )
	{
		NewCharacter = ~04~;
	}
	else if ( ~<Character>~ == ~<pNext>~ )
	{
		NewCharacter = ~05~;
	}
	else if ( ~<Character>~ == ~<pPrev>~ )
	{
		NewCharacter = ~06~;
	}

	Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
			Fields:	TypeName			Button
					DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
					Text				Translate( ~&<Character>~ );
}

NUMERIC	RecallDialog::OnCancelButton()
{
	DoCancelButton();
	return TRUE;
}

NUMERIC	RecallDialog::OnOpenButton()
{
	// Get current selection
	Item = dlg( List, SettingListBox, GetSelectedItemByIndex, 0 );
	dlg( List, SettingListBox, GetItemText, <Item>, 0, Value);
	dlg( List, SettingListBox, GetItemText, <Item>, 1, Description);
	
	// Apply selected correction
	if (~<Value>~ == ~ ~)
	{
		Value = ~-1~;
	}
	CorrectionNum = MakeNumber( ~<Value>~ );
	ApplyCorrections( <CorrectionNum>, ~<Description>~ );

	DoCancelButton();
	return TRUE;
}

VOID RecallDialog::OnButton( Value )
{
	// Process 'keypress' -- mnemonic buttons
	if ( (~<Value>~ == ~0~) || (MakeNumber( ~<Value>~ ) > 0 ) )
	{
		ApplyCorrections( <Value>, ~~ );

		Exit = TRUE;
	}
	else if ( ~<Value>~ == ~<pDensity>~ )
	{
		OnChangeCorrection(-1);
	}
	else if ( ~<Value>~ == ~<pDensity2>~ )
	{
		OnChangeCorrection(1);
	}
	else if ( ~<Value>~ == ~<pNext>~ )
	{
		OnChangeCorrection(1);
	}
	else if ( ~<Value>~ == ~<pPrev>~ )
	{
		OnChangeCorrection(-1);
	}
	else if ( ~<Value>~ == ~<pPrint>~ )
	{
		Execute = ~OnOpenButton();~;
	}
	else if ( ~<Value>~ == ~<pNoPrint>~ )
	{
		Execute = ~OnCancelButton();~;
	}

	// Execute dialog Ok/Cancel function
	if ( DefinedAndNotNull( Execute ) )
	{
		<Execute>
	}
}

VOID RecallDialog::OnChangeCorrection(Direction)
{
	// Move setting list selector
	if (<Direction> < 0 )
	{
		dlg( List, SettingListBox, SelectPrev );
	}
	else
	{
		dlg( List, SettingListBox, SelectNext );
	}

	OnCorrectionSelected();
}

NUMERIC RecallDialog::PopulateCorrectionListBox()
{
	Count = 0;

	// Add columns
	dlg( List, SettingListBox, InsertColumn, 0, ~Number~, Right, 50, 0 );
	dlg( List, SettingListBox, InsertColumn, 1, ~Description~, Left, 346, 0 );

	// Fill list with last used corrections first (descending), then numbered
	// corrections (ascending), then non-numbered corrections (ascending).

	// Add any previously applied corrections and any numbered corrections left
	CorrectionList( Filter, ~LastUsed > 0 OR Number >= 0~ );
	CorrectionList( Sort, ~LastUsed DESC, Number ASC~ );
	More = CorrectionList( GetFirst, Item );
	while ( <More> )
	{
		Used = MakeNumber( ~<$pcon.Item[LastUsed]>~ );
		Number = ~<$pcon.Item[Number]>~;
		if ( MakeNumber( ~<Number>~ ) < 0 )
		{
			Number = ~ ~;
		}
		ItemNum = dlg( List, SettingListBox, InsertItem, <Count>, ~<Number>~ );
		dlg( List, SettingListBox, SetItemText, <ItemNum>, 1, ~<$pcon.Item[Description]> ~ );
		Count += 1;
		More = CorrectionList( GetNext, Item );
	}

	// Add any non-numbered corrections left
	CorrectionList( Filter, ~LastUsed = 0 AND Number < 0~ );
	CorrectionList( Sort, ~Description ASC~ );
	More = CorrectionList( GetFirst, Item );
	while ( <More> )
	{
		Used = MakeNumber( ~<$pcon.Item[LastUsed]>~ );
		Number = ~<$pcon.Item[Number]>~;
		if ( MakeNumber( ~<Number>~ ) < 0 )
		{
			Number = ~ ~;
		}
		ItemNum = dlg( List, SettingListBox, InsertItem, <Count>, ~<Number>~ );
		dlg( List, SettingListBox, SetItemText, <ItemNum>, 1, ~<$pcon.Item[Description]> ~ );
		Count += 1;
		More = CorrectionList( GetNext, Item );
	}

	dlg( List, SettingListBox, Select, 0 );

	return TRUE;
}

NUMERIC RecallDialog::OnCorrectionSelected()
{
	// Do nothing
	return TRUE;	
}

VOID RecallDialog::OnKeyDown()
{
	// Process keypress
	Key = dlg( GetLastKey, KeyString );
	if ( (~<KeyString>~ == ~0~) || (MakeNumber( ~<KeyString>~ ) > 0) )
	{
		Value = MakeNumber( ~<KeyString>~ );
		ApplyCorrections( <Value>, ~~ );

		Execute = ~<This>.OnCancelButton();~;
	}
	else
	{
		OnSimilarStr( ~<KeyString>~,
			~<pDensity>~,	~<This>.OnChangeCorrection( 1 )~,
			~<pDensity2>~,	~<This>.OnChangeCorrection( -1 )~,
			~<pNext>~,	~<This>.OnChangeCorrection( 1 )~,
			~<pPrev>~,	~<This>.OnChangeCorrection( -1 )~ );
		
		if ( ~<KeyString>~ == ~<pPrint>~ )
		{
			Execute = ~<This>.OnOpenButton();~;
		}
		else if ( ~<KeyString>~ == ~<pNoPrint>~ )
		{
			Execute = ~<This>.OnCancelButton();~;
		}
	}

	// Execute dialog Ok/Cancel functions
	if ( DefinedAndNotNull( Execute ) )
	{
		<Execute>
	}
}



/******************************************************************************
 ******************************************************************************
 ****************************** Apply All Dialog ******************************
 ******************************************************************************
 ******************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID ApplyAllDialog::ApplyAllDialog()
{
	// Set up window defaults

	Title = ~Apply Corrections To All~;
	Left = 200;
	ExitScriptOnClose = FALSE;
	StatusBar = ~~;
}

VOID ApplyAllDialog::WindowDefinition()
{
	Fields:	WantsMinimizeBox		<DP2> ? TRUE : FALSE
			HActionsText			ACTION SHOWHELPPAGE ( KPDAWHelpFile "Apply_Settings_to_All_Dialog_Box.htm" )
}

VOID ApplyAllDialog::DefineMessages()		
{ 
	BaseDialog::DefineMessages();	

	// Define messages for dialog box
	Translations( AddText, Cancel, ~Cancel~ );
	Translations( AddText, Open, ~OK~ );
	Translations( AddText, Replace, ~Replace Existing Corrections~ );
	Translations( AddText, Add, ~Add To Existing Corrections~ );
}

VOID ApplyAllDialog::DefineControls()
{
	// Add mnemonic buttons
	AddPromptControl( ~<pNext>~ );
	AddPromptControl( ~<pPrev>~ );
	AddPromptControl( ~<pPrint>~ );
	AddPromptControl( ~<pNoPrint>~ );

	Define: ApplyType0 Using DDWinCtrlDef AsSymbol ApplyType0 Private
		Fields: TypeName				RadioButton  
				Position				$hGap, $vGap,
										180, 20 
				GenConField				~ApplyType~
				RadioTrueValue			~0~
				IActionsText			~[Get]~
				DActionsText			~["Exec( <This>.OnChangeApplyType( 0 ); )"]~
				OActionsText			~[Save]~
 				Text					Translate( Translations, Replace )
				Tooltip					Translate( Translations, Replace )

	Define: ApplyType1 Using DDWinCtrlDef AsSymbol ApplyType1 Private
		Fields: TypeName				RadioButton  
				Position				ApplyType0(GetLeft, Position), ApplyType0(GetBottom, Position),
										180, 20 
				GenConField				~ApplyType~
				RadioTrueValue			~1~
				IActionsText			~[Get]~
				DActionsText			~["Exec( <This>.OnChangeApplyType( 1 ); )"]~
				OActionsText			~[Save]~
 				Text					Translate( Translations, Add )
				Tooltip					Translate( Translations, Add )

	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
		Fields:	TypeName				DefaultButton
				Position				200, $vGap,
										<ButtonWidth>, <ButtonHeight>
				DActionsText			ACTION EXEC ( <This>.OnOpenButton() )
				Text					Translate( Translations, Open)

	Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton Private
			Fields:	TypeName			Button
					Position			OpenButton(GetLeft, Position), OpenButton(GetBottom, Position) + $vGap,
										<ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnCancelButton() )
					Text				Translate( Translations, Cancel)
}

VOID ApplyAllDialog::OnDialogEnd()
{
	// Release wheelman control
	DisableWheelman();

	// Re-enable menus
	EnableMenus( TRUE, FALSE );

	// Re-enable correct view
	EnableCorrectWindow( TRUE );
}

/************************************************
 *************** Member functions ***************
 ************************************************/

VOID ApplyAllDialog::AddPromptControl( Character )
{
	// Add mnemonic control, changing button name if invalid character is mnemonic
	NewCharacter = ~<Character>~;
	if ( ~<Character>~ == ~<pDensity>~ )
	{
		NewCharacter = ~01~;
	}
	else if ( ~<Character>~ == ~<pDensity2>~ )
	{
		NewCharacter = ~02~;
	}
	else if ( ~<Character>~ == ~<pPrint>~ )
	{
		NewCharacter = ~03~;
	}
	else if ( ~<Character>~ == ~<pNoPrint>~ )
	{
		NewCharacter = ~04~;
	}
	else if ( ~<Character>~ == ~<pNext>~ )
	{
		NewCharacter = ~05~;
	}
	else if ( ~<Character>~ == ~<pPrev>~ )
	{
		NewCharacter = ~06~;
	}

	Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
			Fields:	TypeName			Button
					DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
					Text				Translate( ~&<Character>~ );
}

NUMERIC	ApplyAllDialog::OnCancelButton()
{
	DoCancelButton();	// Do this last (destroys object)
	return TRUE;
}

NUMERIC	ApplyAllDialog::OnOpenButton()
{
	// Apply correction
	ApplyToAll( <ApplyType> );

	DoCancelButton();
	return TRUE;
}

VOID ApplyAllDialog::OnButton( Value )
{
	// Process 'keypress' -- mnemonic buttons
	if ( ~<Value>~ == ~<pPrev>~ )
	{
		ApplyType = 0;
		OnChangeApplyType(0);
	}
	else if ( ~<Value>~ == ~<pNext>~ )
	{
		ApplyType = 1;
		OnChangeApplyType(1);
	}
	else if ( ~<Value>~ == ~<pPrint>~ )
	{
		Execute = ~OnOpenButton();~;
	}
	else if ( ~<Value>~ == ~<pNoPrint>~ )
	{
		Execute = ~OnCancelButton();~;
	}

	if ( DefinedAndNotNull( Execute ) )
	{
		<Execute>
	}
}

VOID ApplyAllDialog::OnChangeApplyType( Which )
{
	ApplyType = <Which>;

	// Check appropriate apply type
	if ( <Which> == 0 )
	{
		dlg( SetCheck, TRUE, ApplyType0 );
		dlg( SetCheck, FALSE, ApplyType1 );
	}
	else if ( <Which> == 1 )
	{
		dlg( SetCheck, TRUE, ApplyType1 );
		dlg( SetCheck, FALSE, ApplyType0 );
	}
}



/**********************************************************************************
 **********************************************************************************
 ****************************** Apply Average Dialog ******************************
 **********************************************************************************
 **********************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID FinishDialog::FinishDialog()
{
	// Set up window defaults

	Title = ~End of Order Analysis~;
	Left = 200;
	ExitScriptOnClose = FALSE;
	StatusBar = ~~;
	ShutDownAppFlag = FALSE;

	Dictionary = ~DDFinishDialogDoc~;
}

VOID FinishDialog::WindowDefinition()
{
	Fields:	WantsMinimizeBox		<DP2> ? TRUE : FALSE
			HActionsText			ACTION SHOWHELPPAGE ( KPDAWHelpFile "End_of_Order_Analysis_Dialog_Box.htm" )
}

VOID FinishDialog::DefineDictionary()
{
	Dictionary: <Dictionary>
		Fields: Name OrderStatus type text;
}

VOID FinishDialog::DefineMessages()		
{ 
	BaseDialog::DefineMessages();	

	// Define messages for dialog box
	Translations( AddText, Cancel, ~Cancel~ );
	Translations( AddText, Open, ~OK~ );
	Translations( AddText, Run, ~Run~ );
	Translations( AddText, Export, ~Export~ );
	Translations( AddText, Instructions, ~Select an option below and click 'OK' to finish this order.  Click 'Cancel' to continue analyzing this order.~ );
	Translations( AddText, Option1, ~End order and set status to~ );
	Translations( AddText, Option1Tooltip, ~Ends the order and sets the order status to the selected value~ );
	Translations( AddText, Option2, ~End order and leave for further analysis~ );
	Translations( AddText, Option2Tooltip, ~Ends the order and leaves the order status at the original status~ );
	Translations( AddText, OrderStatus, ~Select the desired order status~ );
}

NUMERIC FinishDialog::DefineDialog()
{
	BaseDialog::DefineDialog();

	LoadComboBox();
	
	return TRUE;
}


VOID FinishDialog::DefineControls()
{
	// Add mnemonic buttons

	AddPromptControl( ~<pNext>~ );
	AddPromptControl( ~<pPrev>~ );
	AddPromptControl( ~<pPrint>~ );
	AddPromptControl( ~<pNoPrint>~ );

	Define: TextPrompt Using DDWinCtrlDef AsSymbol TextPrompt Private
		Fields:	TypeName				StaticText
				Position				$hGap+5, $vGap,
										260, 50
				Text					Translate( Translations, Instructions )

	Define: FinishType0 Using DDWinCtrlDef AsSymbol FinishType0 Private
		Fields: TypeName				RadioButton  
				Position				10, TextPrompt(GetBottom,Position),
										150, 20 
				GenConField				~FinishType~
				RadioTrueValue			~0~
				IActionsText			~[Get]~
				DActionsText			~["Exec( <This>.OnChangeFinishType( 0 ); )"]~
				OActionsText			~[Save]~
 				Text					Translate( Translations, Option1 )
				IsTabStop				T
				Tooltip					Translate( Translations, Option1Tooltip );

	Define: StatusComboBox Using DDWinCtrlDef AsSymbol StatusComboBox
		Fields: TypeName				SComboBox  
				Position				FinishType0(GetRight, Position)+5, FinishType0(GetTop, Position),
										120 ,500 
				DActionsText			ACTIONS ( Save )
				OActionsText			ACTIONS ( Save )
				GenConField				~OrderStatus~
				IsTabStop				T
				Tooltip					Translate( Translations, OrderStatus );

	Define: FinishType1 Using DDWinCtrlDef AsSymbol FinishType1 Private
		Fields: TypeName				RadioButton  
				Position				FinishType0(GetLeft, Position), FinishType0(GetBottom, Position)+3,
										205, 20 
				GenConField				~FinishType~
				RadioTrueValue			~1~
				IActionsText			~[Get]~
				DActionsText			~["Exec( <This>.OnChangeFinishType( 1 ); )"]~
				OActionsText			~[Save]~
 				Text					Translate( Translations, Option2 )
				IsTabStop				T
				Tooltip					Translate( Translations, Option2Tooltip )

	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
		Fields:	TypeName				DefaultButton
				Position				300, $vGap,
										<ButtonWidth>, <ButtonHeight>
				DActionsText			ACTION EXEC ( <This>.OnOpenButton() )
				IsTabStop				T
				Text					Translate( Translations, Open)

	Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton Private
		Fields:	TypeName				Button
				Position				OpenButton(GetLeft, Position), OpenButton(GetBottom, Position) + $vGap,
										<ButtonWidth>, <ButtonHeight>
				DActionsText			ACTION EXEC ( <This>.OnCancelButton() )
				IsTabStop				T
				Text					Translate( Translations, Cancel)

	if ( !<KPDAWRender> )
	{
		Define: RunButton Using DDWinCtrlDef AsSymbol RunButton Private
			Fields:	TypeName				Button
					Position				300, CancelButton(GetBottom, Position) + $vGap,
											<ButtonWidth>, <ButtonHeight>
					DActionsText			ACTION EXEC ( <This>.OnRunButton() )
					IsTabStop				T
					Text					Translate( Translations, Run)

		Define: ExportButton Using DDWinCtrlDef AsSymbol ExportButton Private
			Fields:	TypeName				Button
					Position				RunButton(GetLeft, Position), RunButton(GetBottom, Position) + $vGap,
											<ButtonWidth>, <ButtonHeight>
					DActionsText			ACTION EXEC ( <This>.OnExportButton() )
					IsTabStop				T
					Text					Translate( Translations, Export)
	}
}

NUMERIC FinishDialog::LoadComboBox()
{
	Query = ~Select * From WorkstationSettings Where Computer = '<$App.ComputerName>' AND Category = 'OrderStatus' AND Enabled <> 0 Order By Item~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Failed to query the WorkstationSettings table.\n\n<Query>\n\n<theErr>~ ) ); 
	}

	if ( List( NumEntries ) == 0 )
	{
		ForgetLocal( List );

		Query = ~Select * From SystemSettings Where Category = 'OrderStatus' AND Enabled <> 0 Order By Item~;

		if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
		{ 
			List( GetErrorDescription,0,theErr );
			return Warning( Translate( ~Failed to query the SystemSettings table.\n\n<Query>\n\n<theErr>~ ) ); 
		}
	}

	if ( List( NumEntries ) == 0 )
	{
		StringList( theStringList,New,Is,~<$[DATABASE FieldTypes].OrderStatus[ChoiceList]>~ );

		more = theStringList( GetFirstString,aString );

		while ( <more> )
		{
			dlg( ComboBox,StatusComboBox,AddString,~<aString>~ );
			more = theStringList( GetNextString,aString );
		}
	}
	else
	{
		while ( List( GetNext,Item ) )
		{
			dlg( ComboBox,StatusComboBox,AddString,~<$pcon.Item[SettingsText]>~ );
		}
	}

	DefaultOrderStatus = ~Ready~;
	GetWorkStationSettings( ~Analyzer~, ~DefaultEndOfOrderStatus~, DefaultOrderStatus, Enabled );
	if ( IsNULL( ~<DefaultOrderStatus>~ ) )
	{
		DefaultOrderStatus = ~Ready~;
	}

	dlg( ComboBox,StatusComboBox,SelectString,~<DefaultOrderStatus>~,-1 );

	return TRUE;
}

VOID FinishDialog::SetPosition()
{
	DialogWidth = aDialog(GetMaxRight,Position) + $hGap * 2;
	DialogHeight = 143;

	aDialog( Set,Position,~<Left> <Top> <DialogWidth> <DialogHeight>~ );
}

VOID FinishDialog::OnDialogEnd()
{
	LocalOk = FALSE;
	// Release wheelman control
	DisableWheelman();

	// Re-enable menus
	if ( DefinedAndNotNull( OkSelected ) )
	{
		LocalOk = <OkSelected>;
		EnableMenus( TRUE, FALSE );
		ForgetGlobal( OkSelected );
	}

	if ( DefinedAndNotNull( CancelSelected ) )
	{
		ForgetGlobal( CancelSelected );
	}

	// Re-enable main view
	if ( !<LocalOk> )
	{
		EnableMenus( TRUE, FALSE );
		EnableCorrectWindow( TRUE );
	}
	else
	{
		// Apply average correction to all images
		AnalyzerView.FinishOrder( <FinishType>, ~<OrderStatus>~, <ShutDownAppFlag> );
                Log(Session, ~************* Analyser FinishOrder setting Order Status <OrderStatus> Coloured by <$App.UserName>~);
                
	}
}

NUMERIC FinishDialog::OkayToCancel()
{
	okToCancel = TRUE;
	if ( !<PreDP2_42> )
	{
		if ( !DefinedAndNotNull( OkSelected ) && !DefinedAndNotNull( CancelSelected ) )
		{
			if ( IsAppShuttingDown() )
			{
				ShutDownAppFlag = TRUE;
				okToCancel = FALSE;
			}
		}
	}
	
	return <okToCancel>;
}
/*
NUMERIC FinishDialog::DoCancelButton()
{
	if ( !<PreDP2_42> )
	{
		if ( !OkayToCancel() )	
		{
			CancelAppShutDown();

			dlg( SetDlgHandleActionsFlag,TRUE ) ;	// re-enable handling actions
			return FALSE;							
		}
	}

	OnDialogEnd();

	dlg( End );

	if ( <ExitScriptOnClose> )
	{
		Exit();
	}

	ForgetGlobal( <THIS> );

	return TRUE;
}
*/

/************************************************
 *************** Member functions ***************
 ************************************************/

VOID FinishDialog::AddPromptControl( Character )
{
	// Add mnemonic control, changing button name if invalid character is mnemonic
	NewCharacter = ~<Character>~;
	if ( ~<Character>~ == ~<pDensity>~ )
	{
		NewCharacter = ~01~;
	}
	else if ( ~<Character>~ == ~<pDensity2>~ )
	{
		NewCharacter = ~02~;
	}
	else if ( ~<Character>~ == ~<pPrint>~ )
	{
		NewCharacter = ~03~;
	}
	else if ( ~<Character>~ == ~<pNoPrint>~ )
	{
		NewCharacter = ~04~;
	}
	else if ( ~<Character>~ == ~<pNext>~ )
	{
		NewCharacter = ~05~;
	}
	else if ( ~<Character>~ == ~<pPrev>~ )
	{
		NewCharacter = ~06~;
	}

	Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
			Fields:	TypeName			Button
					DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
					Text				Translate( ~&<Character>~ );
}

NUMERIC FinishDialog::OnCancelButton()
{
	CancelSelected = TRUE;
	Global( CancelSelected );
	DoCancelButton();	// Do this last (destroys object)

	return TRUE;
}

STR GetBravoSetup ( OrderID )
{
    Setup = ~~;

    Query = ~SELECT BravoCDProfile FROM Conversion where OrderID='<OrderID>'~;

    if ( !Ado( dBase,Connect,GetValuesFor,~<Query>~,BravoCDProfile ) )
    {
        dBase( GetErrorDescription,theErr );
        Log( Session, ~**************** GetBravoSetup: Error on query:<Query>.<theErr> ~);
        return ~<Setup>~;
    }

    if (DefinedAndNotNULL( BravoCDProfile ))
    {
        Setup = ~<BravoCDProfile>~;
    }
    Log( Session, ~**************** GetBravoSetup: Setup = "<Setup>" for <OrderID>~);
    return ~<Setup>~;
}
// FUNCTION: GetQueueName()
//
//  This function gets...the Queue Name for a given product.
//
STR GetQueueName ( ProductID )
{
    // Deduce from products target Queue 
    ProductLayoutPath = ~~; IsPackage = FALSE;
    
    if ( !GetLayoutForProductID( database,~<ProductID>~,ProductLayoutPath,IsPackage ) )
    {
        Log(Session, ~******** Analyzer GetQueueName: Failed To GetLayoutForProductID~);
        return ~~;
    }

    if ( !Document( Job,ParseFile,~<ProductLayoutPath>~ ) )
    {
        Log(Session, ~******** Analyzer GetQueueName: An error occured while parsing the layout at <ProductLayoutPath>~);
        return ~~;
    }

    if ( !Job( GetRenderList,0,RenderList ) )
    { 
        Log(Session, ~******** Analyzer GetQueueName: There was no render list for <ProductLayoutPath>~);
        return ~~;
    }

    if ( !RenderList( GetOutputNode,OutputNode ) )
    {
        Log(Session, ~******** Analyzer GetQueueName: There was no output device specified for <ProductLayoutPath>~);
        return ~~;
    }

    OutputNode( Get,~QueueName:~,QueueName );
    ForgetLocal( OutputNode );

    return ~<QueueName>~;
}
// FUNCTION: IndexOrBatchCard()
//
//  This function returns true if the specified product is an index or batch card
//
NUMERIC IndexOrBatchCard(ProductID)
{
    aStr = String( StringInString, ~Index~, ~<ProductID>~);

    if (~<aStr>~ != ~~)
    {
        return TRUE;
    }

    aStr = String( StringInString, ~Batch~, ~<ProductID>~);

    if (~<aStr>~ != ~~)
    {
        return TRUE;
    }
    return FALSE;
}

STR NewBatchID ()
{
    while ( TRUE )
    {
        if ( !ADO( uniqueDB,Connect ) )
        {
            uniqueDB( GetErrorDescription,theErr );
            Log( Session,~Error connecting to the shared database: <theErr>~ );
            return ~~;
        }

        GenerateUniqueID( WebBatchID, UniqueWebBatchID );

        BatchID = FormattedBatchID( ~<UniqueWebBatchID>~ );

        Query = ~Select OrderID From WebBatchQueue where BatchID = '<BatchID>'~;

        if ( !uniqueDB( RecordCountFor, ~<Query>~ ) )
            break;
    }

    return ~<BatchID>~;
}

NUMERIC ThetaOrder ( OrderID )
{
    Query = ~SELECT DISTINCT ProductID FROM OrderItems where OrderID = '<OrderID>'~;

    if ( !PGenConList( ProductList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
    {
        Warning( ~Failed to retrieve the Product list~ );
        return FALSE;
    }

    while ( ProductList( GetNext, Product ))
    {
        // Ignore batch and index cards
        if (IndexOrBatchCard( ~<$pcon.Product[ProductID]>~ ))
        {
            continue;
        }

        // Deduce from products target Queue to work out the size of index card to use.
        QueueName = GetQueueName(~<$pcon.Product[ProductID]>~);
    
        if ( ~<QueueName>~ == ~~ )
        {
            Log( Session, ~Analyzer:************* Unable to get QueueName for <$pcon.Product[ProductID]>~ );
            return FALSE;
        }
        Log( Session, ~Analyzer:************* QueueName = <QueueName>~ );

        // OK Queue names look like 05_Inch_G, so extract the second digit or first 2
        substr(~<QueueName>~, 0, 1, FirstChar);
        if (~<FirstChar>~ == ~0~)
        {
            substr(~<QueueName>~, 1, 1, Size);
        }
        else
        {
            substr(~<QueueName>~, 0, 2, Size);
        }
    
        //Assume Theta or canvas or anything that doesnt have a numeric prepended Queue Name.
        if (!IsNumeric(~<Size>~))
        {
            Log( Session, ~Analyzer:************* Size <Size> is not Numeric, therefore this is a Theta / canvas order for Product <$pcon.Product[ProductID]>~ );
            return TRUE;
        }
    }

    return FALSE;
}

STR GetProxiesSetup ( OrderID )
{
    Setup = ~~;

    Query = ~SELECT ROESProxies FROM Conversion where OrderID='<OrderID>'~;

    if ( !Ado( dBase,Connect,GetValuesFor,~<Query>~, ROESProxies ) )
    {
        dBase( GetErrorDescription,theErr );
        Log( Session, ~**************** GetProxiesSetup: Error on query:<Query>.<theErr> ~);
        return ~<Setup>~;
    }

    if (~<ROESProxies>~ == ~1~)
    {
        GetWorkStationSettings( ~ConversionStation~,~ROESProxiesSetup~,Setup,Enabled );
    }
    Log( Session, ~**************** GetProxiesSetup: Setup = "<Setup>" for <OrderID>~);
    return ~<Setup>~;
}

STR GetLDPSetup ( OrderID )
{
    Setup = ~LDP Export~;

    Log( Session, ~**************** GetLDPSetup: Setup = "<Setup>" for <OrderID>~);
    return ~<Setup>~;
}

STR GetMCSetup ( OrderID )
{
    Setup = ~MediaClip Export~;

    Log( Session, ~**************** GetMCSetup: Setup = "<Setup>" for <OrderID>~);
    return ~<Setup>~;
}

STR GetPriority ( OrderID )
{
    Query = ~SELECT Priority FROM Conversion where OrderID='<OrderID>'~;

    if ( !Ado( dBase,Connect,GetValuesFor,~<Query>~,Priority ) )
    {
        dBase( GetErrorDescription,theErr );
        Log( Session, ~**************** GetBravoSetup: Error on query:<Query>.<theErr> ~);
        return ~~;
    }

    Log( Session, ~**************** GetPriority: Priority = "<Priority>" for <OrderID>~);
    return ~<Priority>~;
}

VOID CreateLDPReleaseScript ( OrderID, BatchID )
{
    Priority = GetPriority(~<OrderID>~);

    if (!GetWorkStationSettings( ~JobImport~ ,TempPath,TempPath,Enabled ))
    {
        Log( Session, ~TempPath Setting Unconfigured!!!!!!~);
        return;
    }

    if (!GetWorkStationSettings( ~LoxleyWebInterface~ ,LDPPrintCmdDir,PrintDirectory, Enabled ))
    {
        SetWorkStationSettings( ~LoxleyWebInterface~,LDPPrintCmdDir,~\\loxdp2srv01\hotdir~,TRUE ); 

        GetWorkStationSettings( ~LoxleyWebInterface~,LDPPrintCmdDir,PrintDirectory,Enabled );
    }


    theLDPFile = ~<TempPath>\LPDPrints_<BatchID>_<OrderID>.txt~;

    theLDPTarget= ~<PrintDirectory>\LDPPrints_<BatchID>_<OrderID>.txt~;

    ProxiesSetup = GetLDPSetup(~<OrderID>~);

    Log( Session, ~**************** CreateLDPReleaseScript: for <OrderID>~);

    // Open up a temp file in the temp directory for prints
    if ( !File( LDPJob, AsciiOutput, OPEN, ~<theLDPFile>~, WRITE, CREATE ) )
    {
        Log(Session, ~Could not open <theLDPFile> Contact the IT Department~);
        Warning( Translate( ~Could not open <theLDPFile> Contact the IT Department!~ ) );
        return;
    }

    LDPJob( ~// LDP release Script for Work Order <OrderID>~);
    LDPJob( ~Log( Session, |********************** Running LDP Release for <OrderID>|);~);
    LDPJob( ~Include: |../Scripts/ExportCmds|;~);

    LDPJob( ~TimeOut=FALSE;~);
    LDPJob( ~UpdateStatus(|<OrderID>|, $ConversionExportPending, |ProxiesStatus|);~);

    LDPJob( ~Actions = ACTION Doc ( ExportImagesDoc OpenOnce ExportImagesDoc "Init(|<OrderID>|, <ProxiesExport>); " );~);
    LDPJob( ~PerformActions( Actions );~);

    LDPJob( ~if (!WaitForStatusField($ConversionExportImagesAdded, |<OrderID>|, 5, |ProxiesStatus|))~);
    LDPJob( ~{~);
    LDPJob( ~  // We timed out~);
    LDPJob( ~  Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportImagesAdded| );~);
    LDPJob( ~  TimeOut=TRUE;~);
    LDPJob( ~}~);

    LDPJob( ~if (!<TimeOut>)~);
    LDPJob( ~{~);
    LDPJob( ~  Actions = ACTION Doc ( ExportImagesDoc "UseSetup(|<ProxiesSetup>|); " );~);
    LDPJob( ~  PerformActions( Actions );~);
    LDPJob( ~  if (!WaitForStatusField($ConversionExportSetupComplete, |<OrderID>|, 1, |ProxiesStatus|))~);
    LDPJob( ~  {~);
    LDPJob( ~       // We timed out~);
    LDPJob( ~       Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportSetupComplete| );~);
    LDPJob( ~       TimeOut=TRUE;~);
    LDPJob( ~  }~);
    LDPJob( ~}~);

    LDPJob( ~if (!<TimeOut>)~);
    LDPJob( ~{~);
    LDPJob( ~  // Export the images~);
    LDPJob( ~  Actions = ACTION Doc ( ExportImagesDoc "OnGoButton(FALSE); " );~);
    LDPJob( ~  PerformActions( Actions );~);

    LDPJob( ~  if (!WaitForStatusField($ConversionExportRunComplete, |<OrderID>|, 5, |ProxiesStatus|))~);
    LDPJob( ~  {~);
    LDPJob( ~    // We timed out~);
    LDPJob( ~    Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportRunComplete| );~);
    LDPJob( ~    TimeOut=TRUE;~);
    LDPJob( ~  }~);
    LDPJob( ~}~);

    LDPJob( ~if (!<TimeOut>)~);
    LDPJob( ~{~);
    LDPJob( ~  Actions = ACTION Doc ( ExportImagesDoc "CloseDialogNOWarn(|<OrderID>|); " );~);
    LDPJob( ~  PerformActions( Actions );~);
    LDPJob( ~  if (!WaitForStatusField($ConversionCompleted, |<OrderID>|, 2, |ProxiesStatus|))~);
    LDPJob( ~  {~);
    LDPJob( ~    // We timed out~);
    LDPJob( ~    Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionCompleted| );~);
    LDPJob( ~    TimeOut=TRUE;~);
    LDPJob( ~  }~);
    LDPJob( ~}~);

    LDPJob( ~Log( Session, |FrameSelectorDoc:********* LDPExport Completed for <OrderID> **********| );~);
    LDPJob( Close );


    // Copy the files to the target directory.
    if ( !Files( Copy, ~<theLDPFile>~, ~<theLDPTarget>~ ) )
    {
       // There was a problem copying the file
       Log( Session, ~********************** Error LDP Print Release file for <OrderID> NOT copied To <theLDPTarget>~);
       Warning( Translate( ~LPD Print Release file for <OrderID> NOT copied To <theLDPTarget> 
Contact the IT Department!~ ) );
       return;
    }
	// Remove the order items and temp order items for the order and Zero the rotation
	
	if ( !database( CMD, ~delete from Images where OrderID = '<OrderID>' and roll = 'rendered'~) )
    {
        Log( Session, ~FAILED to remove rendered images for <OrderID>~ );
        return FALSE;
    }

	
    if ( !database( CMD, ~DELETE from OrderItems where OrderID = '<OrderID>'~ ) )
    {
        Log( Session, ~FAILED to remove order items for <OrderID>~ );
        return FALSE;
    }
	if ( !database( CMD, ~DELETE from ImportOrderItemsTemp where OrderID = '<OrderID>'~ ) )
    {
        Log( Session, ~FAILED to remove temp order items for <OrderID>~ );
        return FALSE;
    }
	if ( !database( CMD, ~DELETE from importimagestemp where OrderID = '<OrderID>'~ ) )
    {
        Log( Session, ~FAILED to remove temp order items for <OrderID>~ );
        return FALSE;
    }
	if ( !database( CMD, ~update images set rotatefromdisk = '0' where OrderID = '<OrderID>'~ ) )
    {
        Log( Session, ~FAILED to reset image rotations for <OrderID>~ );
        return FALSE;
    }
}


VOID CreateMCReleaseScript ( OrderID, BatchID )
{
    Priority = GetPriority(~<OrderID>~);

    if (!GetWorkStationSettings( ~JobImport~ ,TempPath,TempPath,Enabled ))
    {
        Log( Session, ~TempPath Setting Unconfigured!!!!!!~);
        return;
    }

    if (!GetWorkStationSettings( ~LoxleyWebInterface~ ,MCPrintCmdDir,PrintDirectory, Enabled ))
    {
        SetWorkStationSettings( ~LoxleyWebInterface~,MCPrintCmdDir,~\\loxdp2srv01\hotdir~,TRUE ); 

        GetWorkStationSettings( ~LoxleyWebInterface~,MCPrintCmdDir,PrintDirectory,Enabled );
    }


    theMCFile = ~<TempPath>\MCPrints_<BatchID>_<OrderID>.txt~;

    theMCTarget= ~<PrintDirectory>\MCPrints_<BatchID>_<OrderID>.txt~;

    ProxiesSetup = GetMCSetup(~<OrderID>~);

    Log( Session, ~**************** CreateMCReleaseScript: for <OrderID>~);

    // Open up a temp file in the temp directory for prints
    if ( !File( MCJob, AsciiOutput, OPEN, ~<theMCFile>~, WRITE, CREATE ) )
    {
        Log(Session, ~Could not open <theMCFile> Contact the IT Department~);
        Warning( Translate( ~Could not open <theMCFile> Contact the IT Department!~ ) );
        return;
    }

    MCJob( ~// MediaClip release Script for Work Order <OrderID>~);
    MCJob( ~Log( Session, |********************** Running MediaClip Release for <OrderID>|);~);
    MCJob( ~Include: |../Scripts/ExportCmds|;~);

    MCJob( ~TimeOut=FALSE;~);
    MCJob( ~UpdateStatus(|<OrderID>|, $ConversionExportPending, |ProxiesStatus|);~);

    MCJob( ~Actions = ACTION Doc ( ExportImagesDoc OpenOnce ExportImagesDoc "Init(|<OrderID>|, <ProxiesExport>); " );~);
    MCJob( ~PerformActions( Actions );~);

    MCJob( ~if (!WaitForStatusField($ConversionExportImagesAdded, |<OrderID>|, 5, |ProxiesStatus|))~);
    MCJob( ~{~);
    MCJob( ~  // We timed out~);
    MCJob( ~  Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportImagesAdded| );~);
    MCJob( ~  TimeOut=TRUE;~);
    MCJob( ~}~);

    MCJob( ~if (!<TimeOut>)~);
    MCJob( ~{~);
    MCJob( ~  Actions = ACTION Doc ( ExportImagesDoc "UseSetup(|<ProxiesSetup>|); " );~);
    MCJob( ~  PerformActions( Actions );~);
    MCJob( ~  if (!WaitForStatusField($ConversionExportSetupComplete, |<OrderID>|, 1, |ProxiesStatus|))~);
    MCJob( ~  {~);
    MCJob( ~       // We timed out~);
    MCJob( ~       Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportSetupComplete| );~);
    MCJob( ~       TimeOut=TRUE;~);
    MCJob( ~  }~);
    MCJob( ~}~);

    MCJob( ~if (!<TimeOut>)~);
    MCJob( ~{~);
    MCJob( ~  // Export the images~);
    MCJob( ~  Actions = ACTION Doc ( ExportImagesDoc "OnGoButton(FALSE); " );~);
    MCJob( ~  PerformActions( Actions );~);

    MCJob( ~  if (!WaitForStatusField($ConversionExportRunComplete, |<OrderID>|, 5, |ProxiesStatus|))~);
    MCJob( ~  {~);
    MCJob( ~    // We timed out~);
    MCJob( ~    Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportRunComplete| );~);
    MCJob( ~    TimeOut=TRUE;~);
    MCJob( ~  }~);
    MCJob( ~}~);

    MCJob( ~if (!<TimeOut>)~);
    MCJob( ~{~);
    MCJob( ~  Actions = ACTION Doc ( ExportImagesDoc "CloseDialogNOWarn(|<OrderID>|); " );~);
    MCJob( ~  PerformActions( Actions );~);
    MCJob( ~  if (!WaitForStatusField($ConversionCompleted, |<OrderID>|, 2, |ProxiesStatus|))~);
    MCJob( ~  {~);
    MCJob( ~    // We timed out~);
    MCJob( ~    Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionCompleted| );~);
    MCJob( ~    TimeOut=TRUE;~);
    MCJob( ~  }~);
    MCJob( ~}~);

    MCJob( ~Log( Session, |FrameSelectorDoc:********* MCExport Completed for <OrderID> **********| );~);
    MCJob( Close );


    // Copy the files to the target directory.
    if ( !Files( Copy, ~<theMCFile>~, ~<theMCTarget>~ ) )
    {
       // There was a problem copying the file
       Log( Session, ~********************** Error MC Print Release file for <OrderID> NOT copied To <theMCTarget>~);
       Warning( Translate( ~MediaClip Print Release file for <OrderID> NOT copied To <theMCTarget> 
Contact the IT Department!~ ) );
       return;
    }
}

VOID CreateReleaseScript ( OrderID, BatchID )
{
    BravoOrder  = FALSE;
    ProxiesOrder = FALSE;

    Priority = GetPriority(~<OrderID>~);

    if (!GetWorkStationSettings( ~JobImport~ ,TempPath,TempPath,Enabled ))
    {
        Log( Session, ~TempPath Setting Unconfigured!!!!!!~);
        return;
    }

    if (!GetWorkStationSettings( ~LoxleyWebInterface~ ,ProxyOrBravoCmdDir,ExportDirectory, Enabled ))
    {
        SetWorkStationSettings( ~LoxleyWebInterface~,ProxyOrBravoCmdDir,~\\loxdp2srv01\hotdir~,TRUE ); 

        GetWorkStationSettings( ~LoxleyWebInterface~,ProxyOrBravoCmdDir,ExportDirectory,Enabled );
    }

    if (!GetWorkStationSettings( ~LoxleyWebInterface~ ,PrintCmdDir,PrintDirectory, Enabled ))
    {
        SetWorkStationSettings( ~LoxleyWebInterface~,PrintCmdDir,~\\loxdp2srv01\hotdir~,TRUE ); 

        GetWorkStationSettings( ~LoxleyWebInterface~,PrintCmdDir,PrintDirectory,Enabled );
    }

    thePrintFile = ~<TempPath>\Prints_<BatchID>_<OrderID>.txt~;
    theProxyFile = ~<TempPath>\Proxies_<BatchID>_<OrderID>.txt~;
    theBravoFile = ~<TempPath>\Bravo_<BatchID>_<OrderID>.txt~;

    thePrintTarget= ~<PrintDirectory>\Prints_<BatchID>_<OrderID>.txt~;
    theProxyTarget= ~<ExportDirectory>\Proxies_<BatchID>_<OrderID>.txt~;
    theBravoTarget= ~<ExportDirectory>\Bravo_<BatchID>_<OrderID>.txt~;

    // If this is a bravo order then Bravo Export is required.
    BravoSetup = GetBravoSetup(~<OrderID>~);

    if (!IsNULL(~<BravoSetup>~))
    {
        BravoOrder = TRUE;
    }

    // If this is a Proxies order then Proxy Export is required.
    ProxiesSetup = GetProxiesSetup(~<OrderID>~);

    if (!IsNULL(~<ProxiesSetup>~))
    {
        ProxiesOrder = TRUE;
    }

    Log( Session, ~**************** CreateReleaseScript: BravoSetup   = "<BravoSetup>"   for <OrderID> BravoOrder   = <BravoOrder>~);
    Log( Session, ~**************** CreateReleaseScript: ProxiesSetup = "<ProxiesSetup>" for <OrderID> ProxiesOrder = <ProxiesOrder>~);

    // Open up a temp file in the temp directory for prints
    if ( !File( PrintJob, AsciiOutput, OPEN, ~<thePrintFile>~, WRITE, CREATE ) )
    {
        Log(Session, ~Could not open <thePrintFile> Contact the IT Department~);
        Warning( Translate( ~Could not open <thePrintFile> Contact the IT Department!~ ) );
        return;
    }

    if (<ProxiesOrder>)
    {
        // Open up a temp file in the temp directory for proxies
        if ( !File( ProxyJob, AsciiOutput, OPEN, ~<theProxyFile>~, WRITE, CREATE ) )
        {
            Log(Session, ~Could not open <theProxyFile> Contact the IT Department~);
            Warning( Translate( ~Could not open <theProxyFile> Contact the IT Department!~ ) );
            return;
        }
    }

    if (<BravoOrder>)
    {
        // Open up a temp file in the temp directory for Bravo
        if ( !File( BravoJob, AsciiOutput, OPEN, ~<theBravoFile>~, WRITE, CREATE ) )
        {
            Log(Session, ~Could not open <theBravoFile> Contact the IT Department~);
            Warning( Translate( ~Could not open <theBravoFile> Contact the IT Department!~ ) );
            return;
        }
    }

    // Create the scripts
    if (<ProxiesOrder>)
    {
        ProxyJob( ~// Proxy release Script for Work Order <OrderID>~);
        ProxyJob( ~Log( Session, |********************** Running Proxy Release for <OrderID>|);~);
        ProxyJob( ~Include: |../Scripts/ExportCmds|;~);

        ProxyJob( ~TimeOut=FALSE;~);
        ProxyJob( ~UpdateStatus(|<OrderID>|, $ConversionExportPending, |ProxiesStatus|);~);

        ProxyJob( ~Actions = ACTION Doc ( ExportImagesDoc OpenOnce ExportImagesDoc "Init(|<OrderID>|, <ProxiesExport>); " );~);
        ProxyJob( ~PerformActions( Actions );~);

        ProxyJob( ~if (!WaitForStatusField($ConversionExportImagesAdded, |<OrderID>|, 5, |ProxiesStatus|))~);
        ProxyJob( ~{~);
        ProxyJob( ~  // We timed out~);
        ProxyJob( ~  Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportImagesAdded| );~);
        ProxyJob( ~  TimeOut=TRUE;~);
        ProxyJob( ~}~);

        ProxyJob( ~if (!<TimeOut>)~);
        ProxyJob( ~{~);
        ProxyJob( ~  Actions = ACTION Doc ( ExportImagesDoc "UseSetup(|<ProxiesSetup>|); " );~);
        ProxyJob( ~  PerformActions( Actions );~);
        ProxyJob( ~  if (!WaitForStatusField($ConversionExportSetupComplete, |<OrderID>|, 1, |ProxiesStatus|))~);
        ProxyJob( ~  {~);
        ProxyJob( ~       // We timed out~);
        ProxyJob( ~       Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportSetupComplete| );~);
        ProxyJob( ~       TimeOut=TRUE;~);
        ProxyJob( ~  }~);
        ProxyJob( ~}~);

        ProxyJob( ~if (!<TimeOut>)~);
        ProxyJob( ~{~);
        ProxyJob( ~  // Export the images~);
        ProxyJob( ~  Actions = ACTION Doc ( ExportImagesDoc "OnGoButton(FALSE); " );~);
        ProxyJob( ~  PerformActions( Actions );~);

        ProxyJob( ~  if (!WaitForStatusField($ConversionExportRunComplete, |<OrderID>|, 5, |ProxiesStatus|))~);
        ProxyJob( ~  {~);
        ProxyJob( ~    // We timed out~);
        ProxyJob( ~    Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionExportRunComplete| );~);
        ProxyJob( ~    TimeOut=TRUE;~);
        ProxyJob( ~  }~);
        ProxyJob( ~}~);

        ProxyJob( ~if (!<TimeOut>)~);
        ProxyJob( ~{~);
        ProxyJob( ~  Actions = ACTION Doc ( ExportImagesDoc "CloseDialogNOWarn(|<OrderID>|); " );~);
        ProxyJob( ~  PerformActions( Actions );~);
        ProxyJob( ~  if (!WaitForStatusField($ConversionCompleted, |<OrderID>|, 2, |ProxiesStatus|))~);
        ProxyJob( ~  {~);
        ProxyJob( ~    // We timed out~);
        ProxyJob( ~    Log( Session, |FrameSelectorDoc:********* RunProxiesExport Timed out on <OrderID> waiting for ConversionCompleted| );~);
        ProxyJob( ~    TimeOut=TRUE;~);
        ProxyJob( ~  }~);
        ProxyJob( ~}~);
        ProxyJob( ~Log( Session, |FrameSelectorDoc:********* RunProxiesExport Completed for <OrderID> **********| );~);
        ProxyJob( Close );

        if ( !Files( Copy, ~<theProxyFile>~, ~<theProxyTarget>~ ) )
        {
           // There was a problem copying the file
           Log( Session, ~********************** Error Proxy Release file for <OrderID> NOT copied To <theProxyTarget>~);
           Warning( Translate( ~Proxy Release file for <OrderID> NOT copied To <theProxyTarget> 
Contact the IT Department!~ ) );
           return;
        }
    }

    if (<BravoOrder>)
    {
        BravoJob( ~// Bravo release Script for Work Order <OrderID>~);
        BravoJob( ~Log( Session, |********************** Running Bravo Release for <OrderID>|);~);
        BravoJob( ~Include: |../Scripts/ExportCmds|;~);

        BravoJob( ~TimeOut=FALSE;~);
        BravoJob( ~UpdateStatus(|<OrderID>|, $ConversionExportPending, |BravoStatus|);~);

        BravoJob( ~Actions = ACTION Doc ( ExportImagesDoc OpenOnce ExportImagesDoc "Init(|<OrderID>|, <BravoExport>); " );~);
        BravoJob( ~PerformActions( Actions );~);

        BravoJob( ~if (!WaitForStatusField($ConversionExportImagesAdded, |<OrderID>|, 5, |BravoStatus|))~);
        BravoJob( ~{~);
        BravoJob( ~    // We timed out~);
        BravoJob( ~    Log( Session, |FrameSelectorDoc:********* RunBravoExport Timed out on <OrderID> waiting for ConversionExportImagesAdded| );~);
        BravoJob( ~    TimeOut=TRUE;~);
        BravoJob( ~}~);

        BravoJob( ~if (!<TimeOut>)~);
        BravoJob( ~{~);
        BravoJob( ~  Actions = ACTION Doc ( ExportImagesDoc "UseSetup(|<BravoSetup>|); " );~);
        BravoJob( ~  PerformActions( Actions );~);
        BravoJob( ~  if (!WaitForStatusField($ConversionExportSetupComplete, |<OrderID>|, 1, |BravoStatus|))~);
        BravoJob( ~  {~);
        BravoJob( ~       // We timed out~);
        BravoJob( ~       Log( Session, |FrameSelectorDoc:********* RunBravoExport Timed out on <OrderID> waiting for ConversionExportSetupComplete| );~);
        BravoJob( ~       TimeOut=TRUE;~);
        BravoJob( ~  }~);
        BravoJob( ~}~);

        BravoJob( ~if (!<TimeOut>)~);
        BravoJob( ~{~);
        BravoJob( ~  // Export the images~);
        BravoJob( ~  Actions = ACTION Doc ( ExportImagesDoc "OnGoButton(FALSE); " );~);
        BravoJob( ~  PerformActions( Actions );~);

        BravoJob( ~  if (!WaitForStatusField($ConversionExportRunComplete, |<OrderID>|, 5, |BravoStatus|))~);
        BravoJob( ~  {~);
        BravoJob( ~    // We timed out~);
        BravoJob( ~    Log( Session, |FrameSelectorDoc:********* RunBravoExport Timed out on <OrderID> waiting for ConversionExportRunComplete| );~);
        BravoJob( ~    TimeOut=TRUE;~);
        BravoJob( ~  }~);
        BravoJob( ~}~);

        BravoJob( ~if (!<TimeOut>)~);
        BravoJob( ~{~);
        BravoJob( ~  Actions = ACTION Doc ( ExportImagesDoc "OnBravoFinaliseCDButton(FALSE); " );~);
        BravoJob( ~  PerformActions( Actions );~);
        BravoJob( ~  if (!WaitForStatusField($ConversionExportFinaliseDone, |<OrderID>|, 2, |BravoStatus|))~);
        BravoJob( ~  {~);
        BravoJob( ~    // We timed out~);
        BravoJob( ~    Log( Session, |FrameSelectorDoc:********* RunBravoExport Timed out on <OrderID> waiting for ConversionExportFinaliseDone| );~);
        BravoJob( ~    TimeOut=TRUE;~);
        BravoJob( ~  }~);
        BravoJob( ~}~);

        BravoJob( ~if (!<TimeOut>)~);
        BravoJob( ~{~);
        BravoJob( ~  Actions = ACTION Doc ( ExportImagesDoc "CloseDialogNOWarn(|<OrderID>|); " );~);
        BravoJob( ~  PerformActions( Actions );~);
        BravoJob( ~  if (!WaitForStatusField($ConversionCompleted, |<OrderID>|, 2, |BravoStatus|))~);
        BravoJob( ~  {~);
        BravoJob( ~    // We timed out~);
        BravoJob( ~    Log( Session, |FrameSelectorDoc:********* RunBravoExport Timed out on <OrderID> waiting for ConversionCompleted| );~);
        BravoJob( ~    TimeOut=TRUE;~);
        BravoJob( ~  }~);
        BravoJob( ~}~);
        BravoJob( ~Log( Session, |FrameSelectorDoc:********* RunBravoExport Completed for <OrderID> **********| );~);
        BravoJob( Close );

        if ( !Files( Copy, ~<theBravoFile>~, ~<theBravoTarget>~ ) )
        {
           // There was a problem copying the file
           Log( Session, ~********************** Error Bravo Release file for <OrderID> NOT copied To <theBravoTarget>~);
           Warning( Translate( ~Bravo Release file for <OrderID> NOT copied To <theBravoTarget> 
Contact the IT Department!~ ) );
           return;
        }
    }

    PrintJob( ~// Print release Script for Work Order <OrderID>~);
    PrintJob( ~Log( Session, |********************** Running Print Release for <OrderID>|);~);
    PrintJob( ~Include: |../Scripts/ExportCmds|;~);

    PrintJob( ~Actions = ACTION Doc ( FrameSelectorDoc Open FrameSelectorDoc );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(1000);~);
    PrintJob( ~Log( Session, |********************** |);~);
    PrintJob( ~Actions = ACTION Doc ( FrameSelectorDoc "RunWholeOrderNoPrompt(|<BatchID>|,|<OrderID>|, |1|, |0|);" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(10000);~);
    PrintJob( ~Log( Session, |********************** Closing Dialog for <OrderID> release|);~);
    PrintJob( ~Actions = ACTION Doc ( FrameSelectorDoc "CloseDialog();" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep( 3000 );~);
    PrintJob( ~Log( Session, |********************** Doing Select for <OrderID> release|);~);
    PrintJob( ~Query = |Select * From JobQueue Where OrderID = '<OrderID>'|;~);
    PrintJob( ~Actions = ACTION Doc ( JobQueue OpenOnce JobQueueDoc "Init(||, |<Query>|);" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(5000);~);
    PrintJob( ~Log( Session, |********************** Setting priority for <OrderID> release|);~);
    PrintJob( ~Actions = ACTION Doc ( JobQueueDoc "SetPriorityRemoteNoQueue(|<OrderID>|, |<Priority>|);" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(10000);~);
    PrintJob( ~Log( Session, |********************** Release done for <OrderID> BatchID <BatchID>|);~);
    PrintJob( Close );


    // Copy the files to the target directory.
    if ( !Files( Copy, ~<thePrintFile>~, ~<thePrintTarget>~ ) )
    {
       // There was a problem copying the file
       Log( Session, ~********************** Error Print Release file for <OrderID> NOT copied To <thePrintTarget>~);
       Warning( Translate( ~Print Release file for <OrderID> NOT copied To <thePrintTarget> 
Contact the IT Department!~ ) );
       return;
    }
}

VOID CreateProofReleaseScript ( OrderID, BatchID )
{
    Priority = GetPriority(~<OrderID>~);

    if (!GetWorkStationSettings( ~JobImport~ ,TempPath,TempPath,Enabled ))
    {
        Log( Session, ~TempPath Setting Unconfigured!!!!!!~);
        return;
    }

    if (!GetWorkStationSettings( ~LoxleyWebInterface~ ,ProofCmdDir,PrintDirectory, Enabled ))
    {
        SetWorkStationSettings( ~LoxleyWebInterface~,ProofCmdDir,~\\loxdp2srv01\hotdir~,TRUE ); 

        GetWorkStationSettings( ~LoxleyWebInterface~,ProofCmdDir,PrintDirectory,Enabled );
    }

    if (!GetWorkStationSettings( ~LoxleyWebInterface~ ,ProofQueue,Queue, Enabled ))
    {
        SetWorkStationSettings( ~LoxleyWebInterface~,ProofQueue,~ProofQueue~,TRUE ); 

        GetWorkStationSettings( ~LoxleyWebInterface~,ProofQueue,Queue,Enabled );
    }

    thePrintFile = ~<TempPath>\Proof_<BatchID>_<OrderID>.txt~;

    thePrintTarget= ~<PrintDirectory>\Proof_<BatchID>_<OrderID>.txt~;

    // Open up a temp file in the temp directory for prints
    if ( !File( PrintJob, AsciiOutput, OPEN, ~<thePrintFile>~, WRITE, CREATE ) )
    {
        Log(Session, ~Could not open <thePrintFile> Contact the IT Department~);
        Warning( Translate( ~Could not open <thePrintFile> Contact the IT Department!~ ) );
        return;
    }

    PrintJob( ~// Proof release Script for Work Order <OrderID>~);
    PrintJob( ~Log( Session, |********************** Running Proof Release for <OrderID>|);~);
    PrintJob( ~Include: |../Scripts/ExportCmds|;~);

    PrintJob( ~Actions = ACTION Doc ( FrameSelectorDoc Open FrameSelectorDoc );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(1000);~);
    PrintJob( ~Log( Session, |********************** |);~);
    PrintJob( ~Actions = ACTION Doc ( FrameSelectorDoc "RunWholeProofOrderNoPrompt(|<BatchID>|,|<OrderID>|, |1|, |<Queue>| );" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(10000);~);
    PrintJob( ~Log( Session, |********************** Closing Dialog for <OrderID> release|);~);
    PrintJob( ~Actions = ACTION Doc ( FrameSelectorDoc "CloseDialog();" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep( 3000 );~);
    PrintJob( ~Log( Session, |********************** Doing Select for <OrderID> release|);~);
    PrintJob( ~Query = |Select * From JobQueue Where OrderID = '<OrderID>'|;~);
    PrintJob( ~Actions = ACTION Doc ( JobQueue OpenOnce JobQueueDoc "Init(||, |<Query>|);" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(5000);~);
    PrintJob( ~Log( Session, |********************** Setting priority for <OrderID> release|);~);
    PrintJob( ~Actions = ACTION Doc ( JobQueueDoc "SetPriorityRemoteNoQueue(|<OrderID>|, |<Priority>|);" );~);
    PrintJob( ~PerformActions( Actions );~);
    PrintJob( ~Sleep(10000);~);
    PrintJob( ~Log( Session, |********************** Release done for <OrderID> BatchID <BatchID>|);~);
    PrintJob( Close );


    // Copy the files to the target directory.
    if ( !Files( Copy, ~<thePrintFile>~, ~<thePrintTarget>~ ) )
    {
       // There was a problem copying the file
       Log( Session, ~********************** Error Proof Release file for <OrderID> NOT copied To <thePrintTarget>~);
       Warning( Translate( ~Print Release file for <OrderID> NOT copied To <thePrintTarget> 
Contact the IT Department!~ ) );
       return;
    }
}

STR GetImageQty( OrderID )
{
    Query = ~Select * from Images where OrderID='<OrderID>'~;

    ImageCount = ADO( dBase,Connect,RecordCountFor,~<Query>~ );

    return ~<ImageCount>~;
}

NUMERIC CountPrints( Point )
{
   Query = ~declare @startdate datetime
            set @startdate = getdate()
            Select * From WebBatchQueue where AssemblyPoint='<Point>' and Date > @startdate - 0.04 order by Date DESC~;

    if ( !PGenConList( OrderList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
    {
        Log( Session, ~Dash:********* Failed to retrieve the OrderList list !!!!!~ );
        return 0;
    }

    ImageCount = 0;
    OrderCount= OrderList( NumEntries );
    while (OrderList( GetNext, Order ))
    {
         ImageCount = $ImageCount + Numeric( GetImageQty(~<$pcon.Order[OrderID]>~));
    }

    return <ImageCount>;
}

VOID GetAndSetAssemblyPoint( OrderID, &BatchID )
{
    // The assembly point is deduced as being the one with the least prints over the last hour.
    // So work out how many there were for each Queue
    AQueue = BQueue = CQueue = DQueue = EQueue = GQueue = 0;

    // Theta orders alway goto F
    if (ThetaOrder( ~<OrderID>~ ))
    {
        AssemblyPoint = ~F~;
    }
    else
    {
        AQueue = CountPrints(~A~);
        BQueue = CountPrints(~B~);
        CQueue = CountPrints(~C~);
        DQueue = CountPrints(~D~);
        EQueue = CountPrints(~E~);
        GQueue = CountPrints(~G~);

        AssemblyPoint = ~A~;
        TargetQueue = $AQueue;

        if ($BQueue < $TargetQueue)
        {
            AssemblyPoint = ~B~;
            TargetQueue = $BQueue;
        }

        if ($CQueue < $TargetQueue)
        {
            AssemblyPoint = ~C~;
            TargetQueue = $CQueue;
        }

        if ($DQueue < $TargetQueue)
        {
            AssemblyPoint = ~D~;
            TargetQueue = $DQueue;
        }

        if ($EQueue < $TargetQueue)
        {
            AssemblyPoint = ~E~;
            TargetQueue = $EQueue;
        }

        if ($GQueue < $TargetQueue)
        {
            AssemblyPoint = ~G~;
            TargetQueue = $GQueue;
        }


        Log(Session, ~Selected AssemblyPoint = <AssemblyPoint> (Current Stats A=<AQueue>, B=<BQueue>, C=<CQueue>, D=<DQueue>, E=<EQueue>, G=<GQueue>)~);
    }

    BatchID = NewBatchID();

    User = ~<$App.Username>~;
    Priority = GetPriority(~<OrderID>~);

    Columns = ~BatchID, OrderID, UserID, AssemblyPoint, Priority~;

    Values  = ~'<BatchID>', '<OrderID>', '<User>', '<AssemblyPoint>', '<Priority>'~;

    if (!database( CMD, ~INSERT INTO WebBatchQueue (<Columns>) VALUES (<Values>)~ ))
    {
        Log( Session, ~Failed to Add <OrderID> to <BatchID>~);
    }
    else
    {
        Log( Session, ~****** Adding <OrderID> to <BatchID> Queue ******~ );
    }
}

NUMERIC FinishDialog::OnOpenButton()
{
	dlg( GetInput );

	OrderStatus = ~<$con.dlgData[OrderStatus]>~;
	if ( IsNULL( ~<OrderStatus>~ ) )
	{
		OrderStatus = ~~;
	}

    // Batch Release Code Start
    if (<ReleaseScript> && (~<OrderStatus>~ == ~Print~))
    {
        if (!GetWorkStationSettings( ~Analyzer~,~AutoRelease~,AutoRelease, Enabled ))
        {
            SetWorkStationSettings( ~Analyzer~,~AutoRelease~,~0~,TRUE ); 
            GetWorkStationSettings( ~Analyzer~,~AutoRelease~,AutoRelease,Enabled );
        } 

        // Only release if AutoRelease is configured as on
        if (~<AutoRelease>~ == ~1~)
        {
            // Deduce and update the assembly point
            BatchID = ~00001~;
            if (DefinedAndNotNULL( OrderToRelease ))
            {
                GetAndSetAssemblyPoint(~<OrderToRelease>~, BatchID);
                CreateReleaseScript(~<OrderToRelease>~, ~<BatchID>~);
            }
            else
            {
                GetAndSetAssemblyPoint(~<OrderID>~, BatchID);
                CreateReleaseScript(~<OrderID>~, ~<BatchID>~);
            }
        }

        // Check if this is a LDP order
        if (DefinedAndNotNULL( OrderToRelease ))
        {
            order = ~<OrderToRelease>~;
        }
        else
        {
            order = ~<OrderID>~;
        }

        substr( ~<order>~, 0, 3, startChars );
        startChars = Upper( ~<startChars>~ );

        if ( ~<startChars>~ == ~LDP~)
        {
            if (!GetWorkStationSettings( ~Analyzer~,~AutoReleaseLDP~,AutoReleaseLDP, Enabled ))
            {
                SetWorkStationSettings( ~Analyzer~,~AutoReleaseLDP~,~0~,TRUE ); 
                GetWorkStationSettings( ~Analyzer~,~AutoReleaseLDP~,AutoReleaseLDP,Enabled );
            } 

            // Only release LDP if AutoReleaseLDP is configured as on
            if (~<AutoReleaseLDP>~ == ~1~)
            {
                // Create the LDP phase 1 release script
                BatchID = ~00001~;
                CreateLDPReleaseScript(~<order>~, ~<BatchID>~);
            }
        }

        // Check if this is a MediaClip Order.
        substr( ~<order>~, 0, 2, startChars );
        startChars = Upper( ~<startChars>~ );

        if ( ~<startChars>~ == ~MC~)
        {
            if (!GetWorkStationSettings( ~Analyzer~,~AutoReleaseMC~,AutoReleaseMC, Enabled ))
            {
                SetWorkStationSettings( ~Analyzer~,~AutoReleaseMC~,~0~,TRUE ); 
                GetWorkStationSettings( ~Analyzer~,~AutoReleaseMC~,AutoReleaseMC,Enabled );
            } 

            // Only release MC if AutoReleaseMC is configured as on
            if (~<AutoReleaseMC>~ == ~1~)
            {
                // Create the MC phase 1 release script
                BatchID = ~00001~;
                CreateMCReleaseScript(~<order>~, ~<BatchID>~);
            }
        }
    }

    // Batch Release Code End

	// Set to true to tell if dialog was Ok'ed or cancelled
	OkSelected = TRUE;
	Global( OkSelected );

	DoCancelButton();
	return TRUE;
}

VOID FinishDialog::OnButton( Value )
{
	// Process 'keypress' -- mnemonic buttons
	if ( ~<Value>~ == ~<pPrev>~ )
	{
		FinishType = 0;
		OnChangeFinishType(0);
	}
	else if ( ~<Value>~ == ~<pNext>~ )
	{
		FinishType = 1;
		OnChangeFinishType(1);
	}
	else if ( ~<Value>~ == ~<pPrint>~ )
	{
		Execute = ~OnOpenButton();~;
	}
	else if ( ~<Value>~ == ~<pNoPrint>~ )
	{
		Execute = ~OnCancelButton();~;
	}

	if ( DefinedAndNotNull( Execute ) )
	{
		<Execute>
	}
}

NUMERIC FinishDialog::OnRunButton()
{
	ChangeOwner = ~<$WorkStationSettings.ColorBalance[ChangeOwner].boolean>~;

	if ( <ChangeOwner> )
	{
		Cmd = ~Update Orders Set Owner='<$App.UserName>' Where ID = '<OrderID>'~;
		ADO( dbase,Connect,Cmd,~<Cmd>~ );
	}

	Title = ~Run Order Items for <OrderID>~;
	Actions = ACTION DOC ( OrderItemsDoc OpenOnce "OrderItemsDoc" "InitRunPropertiesDialog( ~<Title>~, TRUE, ~<OrderID>~ )" );
	PerformActions( Actions );

	return TRUE;
}

NUMERIC FinishDialog::OnExportButton()
{
	Actions = ACTION Doc ( ExportImagesDoc OpenOnce ExportImagesDoc "Init(~<OrderID>~);" );
	PerformActions( Actions );

	return TRUE;
}

VOID FinishDialog::OnChangeFinishType( Which )
{
	FinishType = <Which>;

	// Check appropriate average type
	if ( <Which> == 0 )
	{
		dlg( SetCheck, TRUE, FinishType0 );
		dlg( SetCheck, FALSE, FinishType1 );
		dlg( EnableControls, TRUE, StatusComboBox );
        ReleaseScript = TRUE;
	}
	else if ( <Which> == 1 )
	{
		dlg( SetCheck, TRUE, FinishType1 );
		dlg( SetCheck, FALSE, FinishType0 );
		dlg( EnableControls, FALSE, StatusComboBox );
        ReleaseScript = FALSE;
	}
}

VOID FinishDialog::Activate()
{
	dlg( SetControlFocus, FinishType0 );
}



/*************************************************************************************
 *************************************************************************************
 ****************************** Recall Reference Dialog ******************************
 *************************************************************************************
 *************************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID RecallRefDialog::RecallRefDialog()
{
	// Set up window defaults

	Title = ~Select Reference Image~;
	Left = 200;
	ExitScriptOnClose = FALSE;
	StatusBar = ~~;
}

VOID RecallRefDialog::WindowDefinition()
{
	Fields:	WantsMinimizeBox		<DP2> ? TRUE : FALSE
			HActionsText			ACTION SHOWHELPPAGE ( KPDAWHelpFile "Removing_a_Reference_Image.htm" )
}

VOID RecallRefDialog::DefineMessages()
{ 
	BaseDialog::DefineMessages();	

	// Define messages for dialog box
	Translations( AddText, Cancel, ~Cancel~ );
	Translations( AddText, Open, ~OK~ );
	Translations( AddText, Remove, ~Remove~ );
	Translations( AddText, Add, ~Add~ );
	Translations( AddText, SetDefault, ~Set As Default~ );
	Translations( AddText, ShowPreview, ~Show Preview~ );
}

VOID RecallRefDialog::DefineControls()
{
	// Add mnemonic buttons
	AddPromptControl( ~<pDensity>~ );
	AddPromptControl( ~<pDensity2>~ );
	AddPromptControl( ~<pPrint>~ );
	AddPromptControl( ~<pNoPrint>~ );
	AddPromptControl( ~<pNext>~ );
	AddPromptControl( ~<pPrev>~ );
	AddPromptControl( ~<pMode>~ );

	Define: TypePrompt Using DDWinCtrlDef AsSymbol TypePrompt Private
			Fields:	TypeName			StaticText
					Position			$hGap, $vGap * 2, 25, 20
					Text				~Type~

	Define:	TypeCombo Using DDWinCtrlDef AsSymbol TypeCombo Private
			Fields:	TypeName			eComboBox
					ComboType			DropDownList
					Position			TypePrompt(GetRight, Position) + $hGap, TypePrompt(GetTop, Position) - 4,
										200, 100
					GenConField			~Type~
					IActionsText		ACTIONS ( Get )
					DActionsText		ACTIONS ( Save "Exec(<This>.OnTypeSelected();)" )
					OActionsText		ACTIONS ( Save )
					WantReturnKey		TRUE
					ReturnKeyActionsText ACTION EXEC ( <THIS>.OnOpenButton() )
					KeyboardActionsText	ACTIONS ( Save "EXEC(<This>.OnKeyDown())" )

	Define: RefListBox Using DDWinCtrlDef AsSymbol RefListBox Private
			Fields:	TypeName			ListBox
					Position			TypePrompt(GetLeft, Position), TypeCombo(GetTop, Position) + 30 + $vGap,
										300, 300 
					GenConField			~Ref~
					IActionsText		ACTIONS ( Get )
					DActionsText		ACTIONS ( Save "Exec(<This>.OnRefSelected();)" )
					OActionsText		ACTIONS ( Save )
					KeyboardActionsText	ACTIONS ( Save "Exec(<This>.OnKeyDown())" )
					DoubleClickActionsText	ACTIONS ( Save "EXEC(<This>.OnOpenButton())" )

	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
			Fields:	TypeName			DefaultButton
					Position			RefListBox(GetRight, Position) + $hGap, RefListBox(GetTop, Position),
										<ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnOpenButton() )
					Text				Translate( Translations, Open )

	Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton Private
			Fields:	TypeName			Button
					Position			OpenButton(GetLeft, Position), OpenButton(GetBottom, Position) + $vGap,
										<ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnCancelButton() )
					Text				Translate( Translations, Cancel )

	Define: AddButton Using DDWinCtrlDef AsSymbol AddButton Private
			Fields:	TypeName			Button
					Position			OpenButton(GetLeft, Position), CancelButton(GetBottom, Position) + $vGap * 4,
										<ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnAddButton() )
					Text				Translate( Translations, Add )

	Define: RemoveButton Using DDWinCtrlDef AsSymbol RemoveButton Private
			Fields:	TypeName			Button
					Position			OpenButton(GetLeft, Position), AddButton(GetBottom, Position) + $vGap,
										<ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnRemoveButton() )
					Text				Translate( Translations, Remove )

	Define: DefaultRefButton Using DDWinCtrlDef AsSymbol DefaultRefButton Private
			Fields:	TypeName			Button
					Position			OpenButton(GetLeft, Position), RemoveButton(GetBottom, Position) + $vGap,
										<ButtonWidth>, <ButtonHeight>
					DActionsText		ACTION EXEC ( <This>.OnDefaultButton() )
					Text				Translate( Translations, SetDefault )

	Define: PreviewImage Using DDWinCtrlDef AsSymbol PreviewImage Private 
			Fields:	TypeName			StaticText
					Position			OpenButton(GetLeft, Position), DefaultRefButton(GetBottom, Position) + $vGap,
										<ButtonWidth>, <ButtonWidth> * 10 / 8
//					TextColorRed		255,		TextColorGreen 255,			TextColorBlue 255
//					BGColorRed			<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
					Tooltip				Translate( ~Image preview~ )
					Sunken				TRUE

	Define: PreviewCheck Using DDWinCtrlDef AsSymbol PreviewCheck Private
			Fields:	TypeName			CheckBox
					Position			OpenButton(GetLeft, Position), PreviewImage(GetBottom, Position) + $vGap,
										<ButtonWidth>, 15
					GenConField			~PreviewTheImage~
					IActionsText		ACTIONS ( Get ) 
					DActionsText		ACTIONS ( Save "EXEC(<This>.OnPreviewSelected())" )
					OActionsText		ACTIONS ( Save )
					Text				Translate( Translations, ShowPreview )
					Tooltip				Translate( Translations, ShowPreview )
}

VOID RecallRefDialog::OnDialogEnd()
{
	// Release wheelman control
	DisableWheelman();

	// Re-enable menus
	EnableMenus( TRUE, FALSE );

	// Re-enable correct view
	EnableCorrectWindow( TRUE );
}

/************************************************
 *************** Member functions ***************
 ************************************************/

VOID RecallRefDialog::AddPromptControl( Character )
{
	// Add mnemonic control, changing button name if invalid character is mnemonic
	NewCharacter = ~<Character>~;
	if ( ~<Character>~ == ~<pDensity>~ )
	{
		NewCharacter = ~01~;
	}
	else if ( ~<Character>~ == ~<pDensity2>~ )
	{
		NewCharacter = ~02~;
	}
	else if ( ~<Character>~ == ~<pPrint>~ )
	{
		NewCharacter = ~03~;
	}
	else if ( ~<Character>~ == ~<pNoPrint>~ )
	{
		NewCharacter = ~04~;
	}
	else if ( ~<Character>~ == ~<pNext>~ )
	{
		NewCharacter = ~05~;
	}
	else if ( ~<Character>~ == ~<pPrev>~ )
	{
		NewCharacter = ~06~;
	}
	else if ( ~<Character>~ == ~<pMode>~ )
	{
		NewCharacter = ~07~;
	}

	Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
			Fields:	TypeName			Button
					DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
					Text				Translate( ~&<Character>~ );
}

NUMERIC	RecallRefDialog::OnCancelButton()
{
	DoCancelButton();
	return TRUE;
}

NUMERIC	RecallRefDialog::OnOpenButton()
{
	
	dlg( GetControlValue, RefListBox, RefImage );
	dlg( GetControlValue, TypeCombo, RefType );

	// Throw out any selection of place-holder item
	if ( ~<RefImage>~ == ~ ~ )
	{
		return TRUE;
	}

	// Show the correct reference image
	if ( ~<RefType>~ != ~Order~ )
	{
		// For lab and studio reference image types, read the database
		Query = ~Select Frame,Path From Images where OrderID = 'Reference' AND Frame = '<RefImage>' Order By Frame~;	
		if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
		{
			if ( List( GetNext, Record ) )
			{
				if ( IsNULL( ~<$pcon.Record[Path]>~ ) )
				{
					return Warning( ~The selected image cannot be used as the reference image because the path for the image is blank.  Please select another image to use as the reference image.~ );
				}

				ShowTheReferenceImage( ~<$pcon.Record[Frame]>~, ~<$pcon.Record[Path]>~ );
			}
		}
	}
	else
	{
		// For order reference images, read the PGenCon in memory
		OrderRefList( Filter, ~Frame = '<RefImage>'~ );

		if ( OrderRefList( GetFirst, Item ) )
		{
			if ( IsNULL( ~<$pcon.Item[Path]>~ ) )
			{
				return Warning( ~The selected image cannot be used as the reference image because the path for the image is blank.  Please select another image to use as the reference image.~ );
			}

			ShowTheReferenceImage( ~<$pcon.Item[Frame]>~, ~<$pcon.Item[Path]>~ );
		}
	}

	DoCancelButton();
	return TRUE;
}

VOID RecallRefDialog::OnButton( Value )
{
	// Process 'keypress' -- mnemonic buttons
	if ( ~<Value>~ == ~<pDensity>~ )
	{
		OnChangeRef(-1);
	}
	else if ( ~<Value>~ == ~<pDensity2>~ )
	{
		OnChangeRef(1);
	}
	else if ( ~<Value>~ == ~<pNext>~ )
	{
		OnChangeRef(1);
	}
	else if ( ~<Value>~ == ~<pPrev>~ )
	{
		OnChangeRef(-1);
	}
	else if ( ~<Value>~ == ~<pPrint>~ )
	{
		Execute = ~OnOpenButton();~;
	}
	else if ( ~<Value>~ == ~<pNoPrint>~ )
	{
		Execute = ~OnCancelButton();~;
	}
	else if ( ~<Value>~ == ~<pMode>~ )
	{
		SelectNextType();
	}

	// Process cancel last
	if ( DefinedAndNotNull( Execute ) )
	{
		<Execute>
	}
}

NUMERIC RecallRefDialog::OnAddButton()
{
	// Browse for image
	Title = ~Search for reference image~;
	ReturnOnFailure( FileDialog( DefaultDirectory, ~<$App.ShareDirectory\Images>~, Title, ~<Title>~, PATH, Path, Open ) );
	Path = MakePath( Type, UNC, ~<Path>~);
	if ( !Files( IsUNC, ~<Path>~ ) && NetworkOperation() )
	{
		Msg = Translate( UIMessages, UnsharedFile, ~<Path>~ );

		if ( MessageBox( ~<Msg>~, YESNO ) != YES )
			{ return FALSE; }
	}

	// Initialize query
	Filename = ~<$Str.$Path.Filename.WithoutExt>~;
	Query = ~Select * From Images Where OrderID = 'Reference' and Frame = '<FileName>'~;
	dlg( GetControlValue, TypeCombo, RefType );

	// Connect to database if necessary
	if ( ~<RefType>~ != ~Order~ )
	{
		if ( ADO( dBase,Connect,RecordCountFor,~<Query>~ ) )
		{
			return Warning( ~The reference image name <Filename> already exists in the database~ );
		}
	}
	
	// Set database command (Lab & studio reference images) or insert image into list (Order reference images)
	if ( ~<RefType>~ == ~Lab~ )
	{
		Cmd= ~Insert Into Images(OrderID, Roll, Frame, Path) Values('Reference','Ref','<FileName>','<Path>')~;
	}
	else if ( ~<RefType>~ == ~Studio~ )
	{
		Cmd= ~Insert Into Images(OrderID, Roll, Frame, SubjectID, Path) Values('Reference','Ref','<FileName>','<CustomerID>','<Path>')~;
	}
	else
	{
		OrderRefList( Filter, ~Frame = '<FileName>'~ );

		if ( OrderRefList( GetFirst, Item ) )
		{
			return Warning( ~The reference image name <FileName> already exists in the database~ );
		}

		OrderRefList( AddNew, Position );
		Position( Set, Frame, ~<FileName>~, Path, ~<Path>~ );
	}

	// Add Lab or Studio reference image to database
	if ( ~<RefType>~ != ~Order~ )
	{
		// Add reference order first if necessary
		if ( !PGenConList( List, Connect, Cursor, Forward, Query, ~Select * from Orders where ID = 'Reference'~ ) )
		{
			dBase( GetErrorDescription, theErr );
			return Warning( ~Failed to load Reference order. <theErr>~ );
		}

		if ( !List( GetNext,Record ) )
		{
			if ( !dBase( Cmd, ~Insert Into Orders(ID,OrderDate,ShipDate) Values('Reference',<$Date.Date.SharedDateQuoted>,<$Date.Date.SharedDateQuoted>)~ ) )
			{
				dBase( GetErrorDescription, theErr );
				return Warning( ~Failed to add Reference order. <theErr>~ );
			}
		}

		if ( !dBase( Cmd,~<Cmd>~ ) )
		{
			dBase( GetErrorDescription, theErr );
			return Warning( ~Failed to add reference image. <theErr>~ );
		}
	}

	// Add and select new reference image in listbox
	if ( dlg( ListBox, RefListBox, SelectString, 0, ~ ~ ) > -1 )
	{
		dlg( ListBox, RefListBox, DeleteSelected );
	}
	dlg( ListBox, RefListBox, AddString, ~<FileName>~ );
	dlg( ListBox, RefListBox, SelectString, 0, ~<FileName>~ );

	OnRefSelected( ~<Path>~ );

	return TRUE;
}

NUMERIC RecallRefDialog::OnRemoveButton()
{
	// Get values and ignore invalid deletions
	dlg( GetControlValue, RefListBox, RefImage );
	dlg( GetControlValue, TypeCombo, RefType );

	// Ignore invalid selection
	if ( IsNULL( ~<RefImage>~ ) || (~<RefImage>~ == ~ ~) )
	{
		return TRUE;
	}

	// Delete image from database (Lab and studio reference images) or from list (Order reference images)
	if ( ~<RefType>~ != ~Order~ )
	{
		cmd = ~Delete From Images Where OrderID = 'Reference' And Frame = '<RefImage>'~;

		if ( !ADO( dBase, Connect, Cmd, ~<cmd>~ ) )
		{
			dBase( GetErrorDescription, theErr );
			return Warning( ~Could not delete reference image <RefImage>: <theErr>~ );
		}
	}
	else
	{
		OrderRefList( Filter, ~Frame = '<RefImage>'~ );

		if ( OrderRefList( GetFirst, Item ) )
		{
			OrderRefList( Remove, ~Frame = '<RefImage>'~ );
		}
	}

	// Delete entry from listbox
	dlg( ListBox, RefListBox, DeleteSelected );

	OnRefSelected();

	return TRUE;	
}

NUMERIC RecallRefDialog::OnDefaultButton()
{
	dlg( GetControlValue, RefListBox, RefImage );
	dlg( GetControlValue, TypeCombo, RefType );

	// Ignore invalid selection
	if ( IsNULL( ~<RefImage>~ ) || (~<RefImage>~ == ~ ~) )
	{
		return TRUE;
	}

	// Warn about order-level reference image selection
	if ( ~<RefType>~ == ~Order~ )
	{
		return Warning( ~Cannot use Order-level reference image as default~ );
	}

	// Save the correct default reference image
	if ( ~<RefType>~ != ~Order~ )
	{
		// For lab and studio reference image types, read the database
		Query = ~Select * From Images where OrderID = 'Reference' AND Frame = '<RefImage>' Order By Frame~;	
		if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
		{
			if ( List( GetNext, Record ) )
			{
				SetWorkStationSettings( ~Analyzer~, ~DefaultImagePath~, ~<$pcon.Record[Path]>~, TRUE );
				OnOpenButton();
			}
		}
	}
	else
	{
		// For order reference images, read the PGenCon in memory
		OrderRefList( Filter, ~Frame = '<RefImage>'~ );

		if ( OrderRefList( GetFirst, Item ) )
		{
			SetWorkStationSettings( ~Analyzer~, ~DefaultImagePath~, ~<$pcon.Item[Path]>~, TRUE );
			OnOpenButton();
		}
	}

	

	return TRUE;
}

VOID RecallRefDialog::OnChangeRef(Direction)
{
	// Move reference list selector
	if (<Direction> < 0 )
	{
		dlg( ListBox, RefListBox, SelectPrev );
	}
	else
	{
		dlg( ListBox, RefListBox, SelectNext );
	}

	OnRefSelected();
}

NUMERIC RecallRefDialog::PopulateRefListBox()
{
	StringList( RefList,New );

	// Query list of reference images to populate reference list
	dlg( GetControlValue, TypeCombo, RefType );
	if ( ~<RefType>~ == ~Lab~ )
	{
		Query = ~Select * From Images where OrderID = 'Reference' AND SubjectID Is Null Order By Frame~;	
	}
	else if ( ~<RefType>~ == ~Studio~ )
	{
		Query = ~Select * From Images where OrderID = 'Reference' AND SubjectID Like '<CustomerID>%' Order By Frame~;	
	}
	else
	{
		// Add entry to listbox for order reference images
		OrderRefList( ClearFilter );
		More = OrderRefList( GetFirst, Item );

		while ( <More> )
		{
			RefList( AddString, ~<$pcon.Item[Frame]>~ );
			More = OrderRefList( GetNext, Item );
		}
	}

	// Add entry to listbox for lab and studio reference images
	if ( ~<RefType>~ != ~Order~ )
	{
		if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
		{
			while ( List( GetNext, Record ) )
			{
				RefList( AddString, ~<$pcon.Record[Frame]>~ );
				++Count;
			}
		}
	}

	// Add blank entry for empty listboxes to avoid losing keypresses
	if ( !DefinedAndNotNull( Count ) )
	{
		RefList( AddString, ~ ~ );
	}

	// Fill and select listbox
	dlg( SetControlFromStringList, RefListBox, RefList );
	dlg( ListBox, RefListBox, Select, 0 );

	return TRUE;
}

NUMERIC RecallRefDialog::OnRefSelected( Path )
{
	if ( !<PreviewTheImage> )
	{
		Status = dlg( SetControlImageFilePath, PreviewImage, ~ ~ );
		return TRUE;
	}

	if ( DefinedAndNotNull( Path ) )
	{
		Status = dlg( SetControlImageFilePath, PreviewImage, ~<Path>~ );
		return TRUE;
	}
	dlg( GetControlValue, RefListBox, RefImage );
	dlg( GetControlValue, TypeCombo, RefType );

	// Ignore invalid selection
	if ( IsNULL( ~<RefImage>~ ) || (~<RefImage>~ == ~ ~) )
	{
		Status = dlg( SetControlImageFilePath, PreviewImage, ~ ~ );
		return TRUE;
	}

	// Save the correct default reference image
	if ( ~<RefType>~ != ~Order~ )
	{
		// For lab and studio reference image types, read the database
		Query = ~Select * From Images where OrderID = 'Reference' AND Frame = '<RefImage>' Order By Frame~;	
		if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
		{
			if ( List( GetNext, Record ) )
			{
				if ( IsNULL( ~<$pcon.Record[Path]>~ ) )
				{
					return Warning( ~The selected image cannot be used as the reference image because the path for the image is blank.~ );
				}

				Status = dlg( SetControlImageFilePath, PreviewImage, ~<$pcon.Record[Path]>~ );
			}
			else
			{
				Status = dlg( SetControlImageFilePath, PreviewImage, ~ ~ );
			}
		}
	}
	else
	{
		// For order reference images, read the PGenCon in memory
		OrderRefList( Filter, ~Frame = '<RefImage>'~ );

		if ( OrderRefList( GetFirst, Item ) )
		{
			Status = dlg( SetControlImageFilePath, PreviewImage, ~<$pcon.Item[Path]>~ );
		}
		else
		{
			Status = dlg( SetControlImageFilePath, PreviewImage, ~ ~ );
		}
	}

	return TRUE;	
}

VOID RecallRefDialog::OnPreviewSelected()
{
	dlg( GetControlValue, PreviewCheck, PreviewTheImage );
	SetWorkStationSettings( ~Analyzer~, ~PreviewReference~, ~<PreviewTheImage>~, TRUE );
	OnRefSelected();
}


VOID RecallRefDialog::OnChangeType()
{
	OnTypeSelected();
}

VOID RecallRefDialog::SelectNextType()
{
	Item = dlg( ComboBox, TypeCombo, GetSelectedIndex );
	if ( <++Item> >= dlg( ComboBox, TypeCombo, GetCount ) )
	{
		Item = 0;
	}
	dlg( ComboBox, TypeCombo, SetSelectedIndex, <Item> );
	OnChangeType();
}

NUMERIC RecallRefDialog::PopulateTypeCombo()
{
	StringList( TypeList, New);

	// Add reference images types to combobox
	TypeList( AddString, ~Lab~ );
	TypeList( AddString, ~Studio~ );
	TypeList( AddString, ~Order~ );

	dlg( SetControlFromStringList, TypeCombo, TypeList );
	
	GetWorkStationSettings( ~Analyzer~, ~PreviewReference~, PreviewTheImage, Enabled );
	dlg( SetCheck, <PreviewTheImage>, PreviewCheck );

	dlg( SetControlFocus, RefListBox);

	return TRUE;
}

NUMERIC RecallRefDialog::OnTypeSelected()
{
	PopulateRefListBox();
	OnRefSelected();

	return TRUE;
}

VOID RecallRefDialog::OnKeyDown()
{
	// Process any keypresses
	Key = dlg( GetLastKey, KeyString );

	OnSimilarStr( ~<KeyString>~,
		~<pDensity>~,	~<This>.OnChangeRef( 1 )~,
		~<pDensity2>~,	~<This>.OnChangeRef( -1 )~,
		~<pNext>~,	~<This>.OnChangeRef( 1 )~,
		~<pPrev>~,	~<This>.OnChangeRef( -1 )~ );
	
	KeyString = Upper( ~<KeyString>~ );
	if ( ~<KeyString>~ == ~<pPrint>~ )
	{
		Execute = ~<This>.OnOpenButton();~;
	}
	else if ( ~<KeyString>~ == ~<pNoPrint>~ )
	{
		Execute = ~<This>.OnCancelButton();~;
	}
	else if ( ~<KeyString>~ == ~<pMode>~ )
	{
		SelectNextType();
	}

	// Execute dialog Ok/Cancel actions
	if ( DefinedAndNotNull( Execute ) )
	{
		<Execute>
	}
}



/****************************************************************************
 ****************************************************************************
 ****************************** Options Dialog ******************************
 ****************************************************************************
 ****************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/

VOID OptionsDialog::OptionsDialog()
{
	// Set up window defaults

	Title = ~Program Options~;
	Left = 200;
	ExitScriptOnClose = FALSE;
	StatusBar = ~~;

}

VOID OptionsDialog::WindowDefinition()
{
	Fields:	WantsMinimizeBox		<DP2> ? TRUE : FALSE
			HActionsText			ACTION SHOWHELPPAGE ( KPDAWHelpFile "Rendering_Options.htm" );
}

VOID OptionsDialog::DefineMessages()		
{ 
	BaseDialog::DefineMessages();	

	// Define messages for dialog box
	Translations( AddText, Cancel, ~Cancel~ );
	Translations( AddText, Open, ~OK~ );
	Translations( AddText, Render0, ~Do not render corrections to image~ );
	Translations( AddText, Render1, ~Render changes to location specified in input file~ );
	Translations( AddText, Render2, ~Render changes to new location~ );
	Translations( AddText, RenderLocation, ~Rendered Image Location~ );
	Translations( AddText, SelectFolder, ~Select An Output Folder~ );
	Translations( AddText, InputLocation, ~Input File Location~ );
	Translations( AddText, SelectInput, ~Select An Input Folder~ );
	Translations( AddText, Browse, ~>~ );
	Translations( AddText, DRGBFactor, ~RGB to density scale~ );
	Translations( AddText, HoldCorrectionMode, ~Hold correction mode~ );
	Translations( AddText, HoldCorrectionModeTooltip, ~Hold the current correction mode when moving from one image to the next after setting an image to Print/No Print~ );
	Translations( AddText, AllowResetOfNoPrint, ~Allow Reset Of No Print Flag~ );
	Translations( AddText, AllowResetOfNoPrintTooltip, ~When checked, an image that is set to No Print can be set to Print.  An image that is set to No Print cannot be set to Print when this box is not checked~ );
	Translations( AddText, PreserveLum, ~Preserve luminosity~ );
	Translations( AddText, ShowOnlyImagesToAdjust, ~Show only images set to adjust~ );
	Translations( AddText, ShowOnlyImagesToAdjustTooltip, ~Show only images set to adjust when opening an order~ );
	Translations( AddText, DeleteOldText, ~Delete original image after rendering~ );
	Translations( AddText, File0, ~Render as same file type~ );
	Translations( AddText, File1, ~Render as type:~ );
	Translations( AddText, FileType, ~File type to save rendered images as~ );
	Translations( AddText, ThumbSize, ~Longest side for thumbnails~ );
	Translations( AddText, EOOrderStatus, ~Default end of order status~ );
	Translations( AddText, EOOrderStatusTooltip, ~The default status for the end of an order~ );
	Translations( AddText, Profile0, ~Render using the Working Space profile~ );
	Translations( AddText, Profile1, ~Render to:~ );
	Translations( AddText, RenderProfileTip, ~Profile to render image to~ );
	Translations( AddText, SbaSetupLabel, ~Auto Balance Preference~ );
	Translations( AddText, SbaSetupTip, ~Specify the Digital SBA Preferences file to use when auto balancing an image.~ );
	Translations( AddText, SbaPrefsTableTip, ~View the Auto Balance Preferences table.~ );
	Translations( AddText, TrackSbaLabel, ~Track Auto Balance Data~ );
	Translations( AddText, TrackSbaTip, ~Save the Auto Balance analysis data for each image in the DSBAImages table.~ );
	Translations( AddText, EnableCropping, ~Allow Cropping of Images~ );
	Translations( AddText, EnableCroppingTip, ~When checked, the user can crop images in Digital Analyzer.~ );
	Translations( AddText, AutoAutoBal, ~Always run Auto Balance first~ );
	Translations( AddText, AutoAutoBalTip, ~Automatically run Auto Balance when an image is selected.~ );

	Translations( AddText, AskKeepCorrectionsOff, ~Are you sure you want to disable keeping last corrections?~ );

}

NUMERIC OptionsDialog::DefineDialog()
{
	BaseDialog::DefineDialog();

	LoadComboBox();
	
	return TRUE;
}

VOID OptionsDialog::LoadSbaTracking()
{
	GetWorkstationSettings( ~Analyzer~,~SaveAutoBalData~,saveSbaData,Enabled );

	if ( !IsNull( ~<saveSbaData>~ ) )
	{
		dlg( SetCheck, <saveSbaData>, TrackAutoBalCheckBox );
	}
	else
	{
		dlg( SetCheck, 0, TrackAutoBalCheckBox );
	}

}

VOID OptionsDialog::DefineControls()
{
	// Add mnemonic buttons
	MaxWidth = 315;
	LeftPos = $hGap;
	TopPos = $vGap;

	Define: RenderOption0 Using DDWinCtrlDef AsSymbol RenderOption0 Private
		Fields: TypeName			RadioButton  
				Position			<LeftPos> + ($hGap * 2), <TopPos> + ($vGap * 3),190, 20 
				GenConField			~RenderOption~
				RadioTrueValue		~0~
				IActionsText		~[Get]~
				DActionsText		~["Exec( <This>.OnChangeRenderOption( 0 ); )"]~
				OActionsText		~[Save]~
 				Text				Translate( Translations, Render0 )
				Tooltip				Translate( Translations, Render0 )
				IsHidden			<DP2> ? T : F;
	
	Define: RenderOption1 Using DDWinCtrlDef AsSymbol RenderOption1 Private
		Fields: TypeName			RadioButton  
				Position			RenderOption0(GetLeft, Position), RenderOption0(GetBottom, Position),
									260, 20 
				GenConField			~RenderOption~
				RadioTrueValue		~1~
				IActionsText		~[Get]~
				DActionsText		~["Exec( <This>.OnChangeRenderOption( 1 ); )"]~
				OActionsText		~[Save]~
 				Text				Translate( Translations, Render1 )
				Tooltip				Translate( Translations, Render1 )
				IsHidden			<DP2> ? T : F;

	Define: RenderOption2 Using DDWinCtrlDef AsSymbol RenderOption2 Private
		Fields: TypeName			RadioButton  
				Position			RenderOption0(GetLeft, Position), RenderOption1(GetBottom, Position),
									190, 20 
				GenConField			~RenderOption~
				RadioTrueValue		~2~
				IActionsText		~[Get]~
				DActionsText		~["Exec( <This>.OnChangeRenderOption( 2 ); )"]~
				OActionsText		~[Save]~
 				Text				Translate( Translations, Render2 )
				Tooltip				Translate( Translations, Render2 )
				IsHidden			<DP2> ? T : F;

	Define: RenderFolderLabel Using DDWinCtrlDef AsSymbol RenderFolderLabel Private
		Fields:	TypeName			StaticText
				Position			RenderOption0(GetLeft, Position) + ($hGap * 3), RenderOption2(GetBottom, Position),
									150, 15
				Text				Translate( Translations, RenderLocation )
				Tooltip				Translate( Translations, RenderLocation )
				IsHidden			<DP2> ? T : F

	Define: RenderFolder Using DDWinCtrlDef AsSymbol RenderFolder Private
		Fields:	TypeName			EditText
				Position			RenderFolderLabel(GetLeft, Position), RenderFolderLabel(GetBottom, Position),
									250, 25
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				Tooltip				Translate( Translations, RenderLocation )
				IsHidden			<DP2> ? T : F;

	Define: BrowseButton Using DDWinCtrlDef AsSymbol BrowseButton Private
		Fields:	TypeName			Button
				Position			RenderFolder(GetRight, Position), RenderFolder(GetTop, Position),
									15, 25
				DActionsText		ACTION EXEC ( <This>.OnBrowseButton() )
				Text				Translate( Translations, Browse )
				Tooltip				Translate( Translations, SelectFolder )
				IsHidden			<DP2> ? T : F;

	Define: FileGroupBox Using DDWinCtrlDef AsSymbol FileGroupBox
		Fields:	TypeName			GroupBox
				IsHidden			<DP2> ? T : F
				Text				Translate(~Rendered Image File Type~)
				Position			RenderOption0(GetLeft, Position), RenderFolder(GetBottom, Position) + $vGap,
									<MaxWidth> - ($hGap * 4), 65

	Define: FileOption0 Using DDWinCtrlDef AsSymbol FileOption0 Private
		Fields: TypeName			RadioButton  
				Position			RenderOption0(GetLeft, Position) + ($hGap * 2), FileGroupBox(GetTop, Position) + ($vGap * 3),
									190, 18
				GenConField			~FileOption~
				RadioTrueValue		~0~
				IActionsText		~[Get]~
				DActionsText		~["Exec( <This>.OnChangeFileOption( 0 ); )"]~
				OActionsText		~[Save]~
 				Text				Translate( Translations, File0 )
				Tooltip				Translate( Translations, File0 )
				IsHidden			<DP2> ? T : F

	Define: FileOption1 Using DDWinCtrlDef AsSymbol FileOption1 Private
		Fields: TypeName			RadioButton  
				Position			FileOption0(GetLeft, Position), FileOption0(GetBottom, Position) + 2,
									70, 20
				GenConField			~FileOption~
				RadioTrueValue		~0~
				IActionsText		~[Get]~
				DActionsText		~["Exec( <This>.OnChangeFileOption( 1 ); )"]~
				OActionsText		~[Save]~
 				Text				Translate( Translations, File1 )
				Tooltip				Translate( Translations, File1 )
				IsHidden			<DP2> ? T : F

	Define: FileTypeComboBox Using DDWinCtrlDef AsSymbol FileTypeComboBox
		Fields: TypeName			SComboBox  
				Position			FileOption1(GetRight, Position), FileOption1(GetTop, Position) - 1,
									120 ,150 
				IActionsText		~[GetList(SaveImageFileTypeChoices) Get]~
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConField			~SaveFileType~
				IsHidden			<DP2> ? T : F
				Tooltip				Translate( Translations, FileType );

	Define: ProfileGroupBox Using DDWinCtrlDef AsSymbol ProfileGroupBox
		Fields:	TypeName			GroupBox
				Text				Translate(~Rendered Image Profile~)
				IsHidden			<DP2> ? T : F
				Position			FileGroupBox(GetLeft, Position), FileGroupBox(GetBottom, Position) + $vGap,
									FileGroupBox(GetWidth, Position), 65

	Define: ProfileOption0 Using DDWinCtrlDef AsSymbol ProfileOption0 Private
		Fields: TypeName			RadioButton  
				Position			RenderOption0(GetLeft, Position) + ($hGap * 2), ProfileGroupBox(GetTop, Position) + ($vGap * 3),
									210, 18
				GenConField			~ProfileOption~
				RadioTrueValue		~0~
				IActionsText		~[Get]~
				DActionsText		~["Exec( <This>.OnChangeProfileOption( 0 ); )"]~
				OActionsText		~[Save]~
 				Text				Translate( Translations, Profile0 )
				Tooltip				Translate( Translations, Profile0 )
				IsHidden			<DP2> ? T : F;

	Define: ProfileOption1 Using DDWinCtrlDef AsSymbol ProfileOption1 Private
		Fields: TypeName			RadioButton  
				Position			ProfileOption0(GetLeft, Position), ProfileOption0(GetBottom, Position) + 2,
									70, 20
				GenConField			~ProfileOption~
				RadioTrueValue		~0~
				IActionsText		~[Get]~
				DActionsText		~["Exec( <This>.OnChangeProfileOption( 1 ); )"]~
				OActionsText		~[Save]~
 				Text				Translate( Translations, Profile1 )
				Tooltip				Translate( Translations, Profile1 )
				IsHidden			<DP2> ? T : F

	Define: RenderProfileComboBox Using DDWinCtrlDef AsSymbol RenderProfileComboBox
		Fields: TypeName			SComboBox  
				Position			ProfileOption1(GetRight, Position), ProfileOption1(GetTop, Position) - 1,
									190 ,250 
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConField			~RenderProfile~
				IsHidden			<DP2> ? T : F
				Tooltip				Translate( Translations, RenderProfileTip );

	Define: DeleteOldCheck Using DDWinCtrlDef AsSymbol DeleteOldCheck Private
		Fields:	TypeName			CheckBox
				Position			RenderOption0(GetLeft, Position), ProfileGroupBox(GetBottom, Position) + ($vGap * 2),
									190, 15
				GenConField			~DeleteCheck~
				IActionsText		ACTIONS ( Get ) 
				DActionsText		ACTIONS ( Save "EXEC(<This>.OnDeleteSelected())" )
				OActionsText		ACTIONS ( Save )
				Text				Translate( Translations, DeleteOldText )
				IsHidden			<DP2> ? T : F
				Tooltip				Translate( Translations, DeleteOldText );

	Define: RenderGroupBox Using DDWinCtrlDef AsSymbol RenderGroupBox
		Fields:	TypeName			GroupBox
				Text				Translate(~Render Options~)
				IsHidden			<DP2> ? T : F
				Position			$hGap, $vGap,
									<MaxWidth>, DeleteOldCheck(GetBottom, Position) - <TopPos> + ($vGap * 2)

	Define: TextFolderCheck Using DDWinCtrlDef AsSymbol TextFolderCheck Private
		Fields:	TypeName			CheckBox
				Position			<LeftPos> + ($hGap * 2), RenderGroupBox(GetBottom, Position) + ($vGap * 2),
									170, 15
				IsHidden			<DP2> ? T : F
				GenConField			~TextCheck~
				IActionsText		ACTIONS ( Get ) 
				DActionsText		ACTIONS ( Save "EXEC(<This>.OnTextSelected())" )
				OActionsText		ACTIONS ( Save )
				Text				Translate( Translations, InputLocation )
				Tooltip				Translate( Translations, InputLocation );

	Define: TextFolder Using DDWinCtrlDef AsSymbol TextFolder Private
		Fields:	TypeName			EditText
				Position			TextFolderCheck(GetLeft, Position) + ($hGap * 3), TextFolderCheck(GetBottom, Position),
									260, 25
				IsHidden			<DP2> ? T : F
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				Tooltip				Translate( Translations, InputLocation )

	Define: TextBrowseButton Using DDWinCtrlDef AsSymbol TextBrowseButton Private
		Fields:	TypeName			Button
				Position			TextFolder(GetRight, Position), TextFolder(GetTop, Position),
									15, 25
				IsHidden			<DP2> ? T : F
				DActionsText		ACTION EXEC ( <This>.OnTextBrowseButton() )
				Text				Translate( Translations, Browse )
				Tooltip				Translate( Translations, SelectInput )

	if ( <DP2> )
	{
		Define: DRGBScaleLabel Using DDWinCtrlDef AsSymbol DRGBScaleLabel Private
			Fields:	TypeName			StaticText
					Position			$hGap, $vGap, 110, 25
					Text				Translate( Translations, DRGBFactor )
					Tooltip				Translate( Translations, DRGBFactor );
	}
	else
	{
		Define: DRGBScaleLabel Using DDWinCtrlDef AsSymbol DRGBScaleLabel Private
			Fields:	TypeName			StaticText
					Position			TextFolderCheck(GetLeft, Position), TextFolder(GetBottom, Position) + ($vGap * 2),
										110, 25
					Text				Translate( Translations, DRGBFactor )
					Tooltip				Translate( Translations, DRGBFactor );
	}

	Define: DRGBScale Using DDWinCtrlDef AsSymbol DRGBScale Private
		Fields:	TypeName			EditText
				Position			DRGBScaleLabel(GetRight, Position), DRGBScaleLabel(GetTop, Position) - 4,
									40, 25
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				Tooltip				Translate( Translations, DRGBFactor )

	Define: HoldCorrectionModeCheck Using DDWinCtrlDef AsSymbol HoldCorrectionModeCheck Private
		Fields:	TypeName			CheckBox
				Position			DRGBScaleLabel(GetLeft, Position), DRGBScaleLabel(GetBottom, Position) + $vGap,
									170, 15
				GenConField			~HoldCorrectionMode~
				IActionsText		ACTIONS ( Get ) 
				DActionsText		ACTIONS ( Save "EXEC(<This>.OnHoldCorrectionMode())" )
				OActionsText		ACTIONS ( Save )
				Text				Translate( Translations, HoldCorrectionMode )
				Tooltip				Translate( Translations, HoldCorrectionModeTooltip );

	Define: AllowResetOfNoPrintCheck Using DDWinCtrlDef AsSymbol AllowResetOfNoPrintCheck Private
		Fields:	TypeName			CheckBox
				Position			DRGBScaleLabel(GetLeft, Position), HoldCorrectionModeCheck(GetBottom, Position) + ($vGap * 2),
									170, 15
				GenConField			~AllowResetOfNoPrint~
				IActionsText		ACTIONS ( Get ) 
				DActionsText		ACTIONS ( Save "EXEC(<This>.OnAllowResetOfNoPrint())" )
				OActionsText		ACTIONS ( Save )
				Text				Translate( Translations, AllowResetOfNoPrint )
				Tooltip				Translate( Translations, AllowResetOfNoPrintTooltip );

	Define: PreserveLumCheck Using DDWinCtrlDef AsSymbol PreserveLumCheck Private
		Fields:	TypeName			CheckBox
				Position			DRGBScaleLabel(GetLeft, Position), AllowResetOfNoPrintCheck(GetBottom, Position) + ($vGap * 2),
									170, 15
				GenConField			~PreserveCheck~
				IActionsText		ACTIONS ( Get ) 
				DActionsText		ACTIONS ( Save "EXEC(<This>.OnPreserveSelected())" )
				OActionsText		ACTIONS ( Save )
				Text				Translate( Translations, PreserveLum )
				Tooltip				Translate( Translations, PreserveLum );

	Define: ShowOnlyImagesToAdjustCheck Using DDWinCtrlDef AsSymbol ShowOnlyImagesToAdjustCheck Private
		Fields:	TypeName			CheckBox
				Position			DRGBScaleLabel(GetLeft, Position), PreserveLumCheck(GetBottom, Position) + ($vGap * 2),
									170, 15
				GenConField			~ShowOnlyImagesToAdjust~
				IActionsText		ACTIONS ( Get ) 
				DActionsText		ACTIONS ( Save "EXEC(<This>.OnShowOnlyImagesToAdjustSelected())" )
				OActionsText		ACTIONS ( Save )
				Text				Translate( Translations, ShowOnlyImagesToAdjust )
				Tooltip				Translate( Translations, ShowOnlyImagesToAdjustTooltip );

	Define: TrackAutoBalCheckBox Using DDWinCtrlDef AsSymbol TrackAutoBalCheckBox 
		Fields: TypeName			CheckBox  
				POSITION			ShowOnlyImagesToAdjustCheck(GetLeft,Position), ShowOnlyImagesToAdjustCheck(GetBottom,Position)+$vGap, 190, $ButtonHeight
				IActionsText		~[Get]~
				DActionsText		~[Save "Exec(<THIS>.OnTrackAutoBalData())"]~
				OActionsText		~[Save]~
				IsEnabled			T
				GenConName			THIS
				GenConField			~TrackAutoBalData~
				Text				Translate( Translations, TrackSbaLabel )
				Tooltip				Translate( Translations, TrackSbatip );

	Define: AutoBalCheckBox Using DDWinCtrlDef AsSymbol AutoBalCheckBox 
		Fields: TypeName			CheckBox  
				POSITION			TrackAutoBalCheckBox(GetLeft,Position), TrackAutoBalCheckBox(GetBottom,Position)+$vGap, 190, $ButtonHeight
				IActionsText		~[Get]~
				DActionsText		~[Save "Exec(<THIS>.OnAutoAutoBal())"]~
				OActionsText		~[Save]~
				IsEnabled			T
				GenConName			THIS
				GenConField			~AutomaticAutoBal~
				Text				Translate( Translations, AutoAutoBal )
				Tooltip				Translate( Translations, AutoAutoBalTip ) ;

	Define: ThumbSizeLabel Using DDWinCtrlDef AsSymbol ThumbSizeLabel Private
		Fields:	TypeName			StaticText
				Position			DRGBScaleLabel(GetLeft, Position), AutoBalCheckBox(GetBottom, Position) + ($vGap * 2),
									130, 25
				Text				Translate( Translations, ThumbSize )
				Tooltip				Translate( Translations, ThumbSize )

	Define: ThumbSizeEdit Using DDWinCtrlDef AsSymbol ThumbSizeEdit Private
		Fields:	TypeName			EditText
				Position			ThumbSizeLabel(GetRight, Position) + 5, ThumbSizeLabel(GetTop, Position) - 4,
									40, 25
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				Tooltip				Translate( Translations, ThumbSize );

	Define: PreferenceStaticText Using DDWinCtrlDef AsSymbol PreferenceStaticText 
		Fields: TypeName        StaticText
				Text            Translate( Translations, SbaSetupLabel )
				RightJustified	FALSE
				Position			DRGBScaleLabel(GetLeft, Position), ThumbSizeLabel(GetBottom, Position) + ($vGap * 2)
									130, 25;

	Define: AutoBalComboBox Using DDWinCtrlDef AsSymbol AutoBalComboBox
		Fields:	TypeName			SComboBox  
				Position			PreferenceStaticText(GetRight,Position) + 5, PreferenceStaticText(GetTop,Position),
									170, 100
				DropDownActionsText	ACTION EXEC ( <THIS>.UpdateAutoBalList( FALSE ) )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConField			~AutoBalanceSetup~
				TOOLTIP				Translate( Translations, SbaSetupTip );

	Define: PrefsSetupButton Using DDWinCtrlDef AsSymbol PrefsSetupButton 
		Fields: TypeName			Button
				Text				Translate(~?~)
				Position			AutoBalComboBox(GetRight,Position) + $hGap,AutoBalComboBox(GetTop,Position), 20,<ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.OnViewSbaPreferences() )
				Tooltip				Translate( Translations, SbaPrefsTableTip );

	Define: EndOfOrderStatusLabel Using DDWinCtrlDef AsSymbol EndOfOrderStatusLabel Private
		Fields:	TypeName			StaticText
				Position			DRGBScaleLabel(GetLeft, Position), PreferenceStaticText(GetBottom, Position) + ($vGap * 2),
									130, 25
				Text				Translate( Translations, EOOrderStatus )

	Define: StatusComboBox Using DDWinCtrlDef AsSymbol StatusComboBox
		Fields: TypeName			SComboBox  
				Position			EndOfOrderStatusLabel(GetRight, Position)+5, EndOfOrderStatusLabel(GetTop, Position),
									170,500 
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConField			~OrderStatus~
				Tooltip				Translate( Translations, EOOrderStatusTooltip );

	Define: EnableCroppingCheckBox Using DDWinCtrlDef AsSymbol EnableCroppingCheckBox Private
		Fields:	TypeName			CheckBox
				Position			DRGBScaleLabel(GetLeft, Position), EndOfOrderStatusLabel(GetBottom, Position) + ($vGap * 2),
									190, 15
				GenConField			~EnableCropping~
				IActionsText		ACTIONS ( Get ) 
				DActionsText		ACTIONS ( Save "EXEC(<This>.OnEnableCropping())" )
				OActionsText		ACTIONS ( Save )
				Text				Translate( Translations, EnableCropping )
				Tooltip				Translate( Translations, EnableCroppingTip );

	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
		Fields:	TypeName			DefaultButton
				Position			<DP2> ? 45 : 60, EnableCroppingCheckBox(GetBottom, Position) + 5,
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <This>.OnOpenButton() )
				Text				Translate( Translations, Open )

	Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton Private
		Fields:	TypeName			Button
				Position			OpenButton(GetRight, Position) + 10, EnableCroppingCheckBox(GetBottom, Position) + 5,
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <This>.OnCancelButton() )
				Text				Translate( Translations, Cancel );
	
	DialogHeight = OpenButton(GetBottom,Position) + 40;

}

NUMERIC OptionsDialog::LoadComboBox()
{
	Query = ~Select * From WorkstationSettings Where Computer = '<$App.ComputerName>' AND Category = 'OrderStatus' AND Enabled <> 0 Order By Item~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Failed to query the WorkstationSettings table.\n\n<Query>\n\n<theErr>~ ) ); 
	}

	if ( List( NumEntries ) == 0 )
	{
		ForgetLocal( List );

		Query = ~Select * From SystemSettings Where Category = 'OrderStatus' AND Enabled <> 0 Order By Item~;

		if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
		{ 
			List( GetErrorDescription,0,theErr );
			return Warning( Translate( ~Failed to query the SystemSettings table.\n\n<Query>\n\n<theErr>~ ) ); 
		}
	}

	if ( List( NumEntries ) == 0 )
	{
		StringList( theStringList,New,Is,~<$[DATABASE FieldTypes].OrderStatus[ChoiceList]>~ );

		more = theStringList( GetFirstString,aString );

		while ( <more> )
		{
			dlg( ComboBox,StatusComboBox,AddString,~<aString>~ );
			more = theStringList( GetNextString,aString );
		}
	}
	else
	{
		while ( List( GetNext,Item ) )
		{
			dlg( ComboBox,StatusComboBox,AddString,~<$pcon.Item[SettingsText]>~ );
		}
	}

	return TRUE;
}

NUMERIC OptionsDialog::UpdateAutoBalList( firstEntry )
{
	PrefsQuery = ~Select Name From DSbaPrefsDef Order By Name~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<PrefsQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Query Failed:\n\n<PrefsQuery>.\n\n<theErr>.~ ) ); 
	}

	List( SetConnection,~~ );	// DISCONNECT LIST FROM THE DATABASE

	Count = List( NumEntries );

	if ( !<Count> )
	{
		return dlg( SetStatus,0, Translate( ~No Preferences defined.~) );
	}

	List( MakeStringList,PrefsList,Name );

	dlg( SetControlFromStringList,AutoBalComboBox,PrefsList );

	if ( IsNull( ~<ExtAutoBalPreference>~ ) )
	{
		GetWorkStationSettings( ~Analyzer~, ~DefaultAutoBalPref~, ExtAutoBalPreference, Enabled );
		if ( IsNull( ~<ExtAutoBalPreference>~ ) )
		{
			GetSystemSettings( ~Analyzer~, ~DefaultAutoBalPref~, ExtAutoBalPreference, Enabled );
		}
	}

	if ( !IsNull( ~<ExtAutoBalPreference>~ ) )
	{
		dlg( ComboBox,AutoBalComboBox,SelectString,~<ExtAutoBalPreference>~,-1 );
	}
	else if ( <firstEntry> )
	{
		dlg( ListBox,AutoBalComboBox,select,0 );
	}

	return TRUE;
}


NUMERIC OptionsDialog::OnViewSbaPreferences()
{
	Action = ACTION Doc ( ~DSbaPrefsDefDoc~ OpenOnce DSbaPrefsDefDoc "Init();" ); 
	return PerformActions( Action );

}

VOID OptionsDialog::SetPosition()
{
	DialogWidth = aDialog(GetMaxRight,Position) + $hGap * 2;

	aDialog( Set,Position,~<Left> <Top> <DialogWidth> <DialogHeight>~ );
}


VOID OptionsDialog::OnDialogEnd()
{
	// Release wheelman control
	DisableWheelman();

	// Re-enable menus
	if ( AnalyzerView.ValidateOrderID() )
	{
		EnableMenus( TRUE, FALSE );
	}
	else
	{
		EnableMenus( FALSE, TRUE );
	}

	// Re-enable correct view
	EnableCorrectWindow( TRUE );
}

/************************************************
 *************** Member functions ***************
 ************************************************/

NUMERIC	OptionsDialog::OnCancelButton()
{
	dlg( GetControlValue, AutoBalComboBox, AutoBalPreference );
	ExtAutoBalPreference = ~<AutoBalPreference>~;

	DoCancelButton();	// Do this last (destroys object)
	return TRUE;
}

NUMERIC	OptionsDialog::OnOpenButton()
{
	// Get settings
	dlg( GetControlTitle, RenderFolder, RenderPath );
	dlg( GetControlTitle, DRGBScale, DRGBValue );
	dlg( GetControlTitle, TextFolder, TextPath );
	dlg( GetControlValue, TextFolderCheck, TextCheck );
	dlg( GetControlValue, HoldCorrectionModeCheck, HoldCorrectionMode );
	dlg( GetControlValue, AllowResetOfNoPrintCheck, AllowResetOfNoPrint );
	dlg( GetControlValue, PreserveLumCheck, PreserveCheck );
	dlg( GetControlValue, ShowOnlyImagesToAdjustCheck, ShowOnlyImagesToAdjust );
	dlg( GetControlValue, DeleteOldCheck, DeleteCheck );
	dlg( GetControlValue, FileTypeComboBox, SaveFileType );
	dlg( GetControlValue, ThumbSizeEdit, ThumbnailSize );
	dlg( GetControlValue, RenderProfileComboBox, RenderProfile );
	dlg( GetControlValue, StatusComboBox, OrderStatus );
	dlg( GetControlValue, AutoBalComboBox, AutoBalPreference );
	dlg( GetControlValue, EnableCroppingCheckBox, EnableCropping );
	dlg( GetControlValue, AutoBalCheckBox, AutoBalFirst );

	if ( !IsNumeric( ~<ThumbnailSize>~ ) )
	{
		Warning( Translate( ~The longest size for thumbnails must be a whole number.~ ) );
		dlg( SetControlFocus, ThumbSizeEdit );
		return FALSE;
	}
	
	if ( <ThumbnailSize> < <MinThumbSize> )
	{
		Warning( Translate( ~The minimum allowed thumbnail size is <MinThumbSize>.~ ) );
		dlg( SetControlFocus, ThumbSizeEdit );
		return FALSE;
	}

	if ( <ThumbnailSize> > <MaxThumbSize> )
	{
		Warning( Translate( ~The maximum allowed thumbnail size is <MaxThumbSize>.~ ) );
		dlg( SetControlFocus, ThumbSizeEdit );
		return FALSE;
	}

	if ( ~<AutoBalPreference>~ == ~~ )
	{
		UpdateAutoBalList( TRUE );
		dlg( GetControlValue, AutoBalComboBox, AutoBalPreference );
	}

	ExtRenderOption = <RenderOption>;
	ExtFileOption = <FileOption>;
	ExtSaveFileType = ~<SaveFileType>~;
	ExtProfileOption = <ProfileOption>;
	ExtRenderProfile = ~<RenderProfile>~;
	ExtRenderPath = ~<RenderPath>~;
	ExtTextCheck = <TextCheck>;
	ExtTextPath = ~<TextPath>~;
	ExtHoldCorrectionMode = <HoldCorrectionMode>;
	ExtAllowResetOfNoPrint = <AllowResetOfNoPrint>;
	ExtPreserveCheck = <PreserveCheck>;
	ExtAutoBalPreference = ~<AutoBalPreference>~;
	ExtShowOnlyImagesToAdjust = <ShowOnlyImagesToAdjust>;
	ExtDeleteOld = <DeleteCheck>;
	ExtEnableCropping = <EnableCropping>;
	ExtAutoBalFirst	= <AutoBalFirst>;

	SysThumbnailSize = <ThumbnailSize>;

	if ( ~<ExtRenderProfile>~ == ~None~ )
	{
		ExtRenderProfile = ~~;
	}

	if ( <ExtRenderOption> )
	{
		KPDAWRender = TRUE;
	}

	// Save settings
	OldRenderOption = 0;
	GetWorkStationSettings( ~Analyzer~, ~RenderOption~, OldRenderOption, Enabled );
	
	SetWorkStationSettings( ~Analyzer~, ~RenderOption~, <RenderOption>, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~RenderFileOption~, <FileOption>, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~RenderFileType~, ~<SaveFileType>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~ProfileOption~, <ProfileOption>, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~RenderProfile~, ~<RenderProfile>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~RenderPath~, ~<RenderPath>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~UseInputPath~, <TextCheck>, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~InputPath~, ~<TextPath>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~HoldCorrectionMode~, ~<HoldCorrectionMode>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~AllowResetOfNoPrint~, ~<AllowResetOfNoPrint>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~PreserveLum~, ~<PreserveCheck>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~ShowOnlyImagesToAdjust~, ~<ShowOnlyImagesToAdjust>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~DeleteOld~, ~<DeleteCheck>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~DefaultEndOfOrderStatus~, ~<OrderStatus>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~DefaultAutoBalPref~, ~<AutoBalPreference>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~EnableCropping~, ~<EnableCropping>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~AutoBalFirst~, ~<AutoBalFirst>~, TRUE );
	SetSystemSettings( ~Thumbnail~, ~Size~, ~<ThumbnailSize>~, TRUE );

	SetSystemSettings( ~AdjustImages~, ~RGBToDensityScale~, <DRGBValue>, TRUE );

	if ( <RenderOption> )
	{
		if ( !<OldRenderOption> )
		{
			Warning( Translate( ~Program must be restarted to enable rendering to disk~ ) );
		}
//		CGCGCG Unable to bring window to top and re-maximize w/o frame around window
//		AddPrinter();
//		AddQueue();
//		if ( !<OldRenderOption> )
//		{
//			StartPrinter( TRUE );
//		}
//		AnalyzerView.BringToTop();
//
	}
//	else
//	{
//		if ( <OldRenderOption> )
//		{
//			StopPrinter();
//		}
//
//	}

	AnalyzerView.SetEnableCropping();

	AnalyzerView.SetToolbarState();
	
	DoCancelButton();
	return TRUE;
}

NUMERIC OptionsDialog::OnBrowseButton()
{
	if ( FileDialog( Title, Translate( Translations, SelectFolder ), PATH, Path, DefaultFile, ~Blank.txt~, DefaultExt, ~~, Save ) )
	{
		PathOnly = ~<$Str.$Path.Path>~;
		dlg( SetControlTitle, RenderFolder, ~<PathOnly>~ );
	}
	return TRUE;
}

NUMERIC OptionsDialog::OnTextBrowseButton()
{
	if ( FileDialog( Title, Translate( Translations, SelectInput ), PATH, Path, DefaultFile, ~Blank~, DefaultExt, ~~, Save ) )
	{
		PathOnly = ~<$Str.$Path.Path>~;
		dlg( SetControlTitle, TextFolder, ~<PathOnly>~ );
	}
	return TRUE;
}

VOID OptionsDialog::PopulateProfiles()
{

	Query = ~Select * From Profiles Where (Type = 'Output' OR Type = 'WorkingSpace') And Path IS NOT NULL~;

	if ( !PGenConList( ProfilesList, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{ 
		ProfilesList( GetErrorDescription, 0, theErr );
		Warning( Translate( ~Failed to query the Profiles table.  <theErr>~ ) ); 
		return;
	}

	ProfilesList( MakeStringList,RenderProfiles, Name );
	RenderProfiles( AddString, ~None~ );
	dlg( SetControlFromStringList, RenderProfileComboBox, RenderProfiles );
}

VOID OptionsDialog::PopulateOptions()
{
	LoadSbaTracking();

	DefaultAutoBalPref = ~~;
	GetWorkstationSettings( ~Analyzer~, ~DefaultAutoBalPref~, DefaultAutoBalPref, Enabled );
	if ( IsNull( ~<DefaultAutoBalPref>~ ) )
	{
		GetSystemSettings( ~Analyzer~, ~DefaultAutoBalPref~, DefaultAutoBalPref, Enabled );
	}

	if ( IsNULL( ~<DefaultAutoBalPref>~ ) )
	{
		UpdateAutoBalList( TRUE );
	}
	else
	{
		UpdateAutoBalList( FALSE );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderOption~, RenderImage, Enabled ) )
	{
		OnChangeRenderOption( <RenderImage> );
	}
	else
	{
		OnChangeRenderOption( 0 );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderFileOption~, FileOption, Enabled ) )
	{
		OnChangeFileOption( <FileOption> );
	}
	else
	{
		OnChangeFileOption( 0 );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderFileType~, SaveFileType, Enabled ) )
	{
		dlg( SetControlValue, FileTypeComboBox, ~<SaveFileType>~ );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~ProfileOption~, ProfileOption, Enabled ) )
	{
		OnChangeProfileOption( <ProfileOption> );
	}
	else
	{
		OnChangeProfileOption( 0 );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderProfile~, RenderProfile, Enabled ) )
	{
		if ( ~<RenderProfile>~ == ~~ )
		{
			RenderProfile = ~None~;
		}
		dlg( SetControlValue, RenderProfileComboBox, ~<RenderProfile>~ );
	}
	else
	{
		RenderProfile = GetWorkingSpaceProfile();
		dlg( SetControlValue, RenderProfileComboBox, ~<RenderProfile>~ );
	}
	

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderPath~, RenderPath, Enabled ) )
	{
		dlg( SetControlTitle, RenderFolder, ~<RenderPath>~ );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~UseInputPath~, TextCheck, Enabled ) )
	{
		dlg( SetCheck, <TextCheck>, TextFolderCheck );
	}
	OnTextSelected();
	 
	if ( GetWorkStationSettings( ~Analyzer~, ~InputPath~, TextPath, Enabled ) )
	{
		dlg( SetControlTitle, TextFolder, ~<TextPath>~ );
	}

	if ( GetSystemSettings( ~AdjustImages~, ~RGBToDensityScale~, DRGBValue, Enabled ) )
	{
		dlg( SetControlTitle, DRGBScale, ~<DRGBValue>~ );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~HoldCorrectionMode~, HoldCorrectionMode, Enabled ) )
	{
		dlg( SetCheck, (<HoldCorrectionMode> == 1) ? TRUE : FALSE, HoldCorrectionModeCheck );
	}

	AllowResetOfNoPrint = TRUE;
	GetWorkStationSettings( ~Analyzer~, ~AllowResetOfNoPrint~, AllowResetOfNoPrint, Enabled );
	dlg( SetCheck, (<AllowResetOfNoPrint> == 1) ? TRUE : FALSE, AllowResetOfNoPrintCheck );

	if ( GetWorkStationSettings( ~Analyzer~, ~PreserveLum~, PreserveCheck, Enabled ) )
	{
		dlg( SetCheck, (<PreserveCheck> == 1) ? TRUE : FALSE, PreserveLumCheck );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~ShowOnlyImagesToAdjust~, ShowOnlyImagesToAdjust, Enabled ) )
	{
		dlg( SetCheck, <ShowOnlyImagesToAdjust>, ShowOnlyImagesToAdjustCheck );
	}
	
	if ( GetWorkStationSettings( ~Analyzer~, ~DeleteOld~, DeleteCheck, Enabled ) )
	{
		dlg( SetCheck, <DeleteCheck>, DeleteOldCheck );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~EnableCropping~, EnableCropping, Enabled ) )
	{
		dlg( SetCheck, <EnableCropping>, EnableCroppingCheckBox );
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~AutoBalFirst~, AutoBalFirst, Enabled ) )
	{
		dlg( SetCheck, <AutoBalFirst>, AutoBalCheckBox );
	}

	ThumbnailSize = ~<DefaultThumbSize>~;
	GetSystemSettings( ~Thumbnail~, ~Size~, ThumbnailSize, Enabled );
	if ( IsNULL( ~<ThumbnailSize>~ ) )
	{
		ThumbnailSize = ~<DefaultThumbSize>~;
	}

	SysThumbnailSize = <ThumbnailSize>;
	dlg( SetControlTitle, ThumbSizeEdit, ~<ThumbnailSize>~ );

	DefaultOrderStatus = ~Ready~;
	GetWorkStationSettings( ~Analyzer~, ~DefaultEndOfOrderStatus~, DefaultOrderStatus, Enabled );
	if ( IsNULL( ~<DefaultOrderStatus>~ ) )
	{
		DefaultOrderStatus = ~Ready~;
	}

	dlg( ComboBox,StatusComboBox,SelectString,~<DefaultOrderStatus>~,-1 );

}

VOID OptionsDialog::OnChangeRenderOption( Option )
{
	RenderOption = <Option>;

	// Check appropriate apply type
	if ( <Option> == 0 )
	{
		dlg( SetCheck, TRUE, RenderOption0 );
		dlg( SetCheck, FALSE, RenderOption1 );
		dlg( SetCheck, FALSE, RenderOption2 );
		dlg( EnableControls, FALSE, RenderFolderLabel );
		dlg( EnableControls, FALSE, RenderFolder );
		dlg( EnableControls, FALSE, BrowseButton );
		dlg( EnableControls, FALSE, DeleteOldCheck );
		dlg( EnableControls, FALSE, FileOption0 );
		dlg( EnableControls, FALSE, FileOption1 );
		dlg( EnableControls, FALSE, FileTypeComboBox );
		dlg( EnableControls, FALSE, ProfileOption0 );
		dlg( EnableControls, FALSE, ProfileOption1 );
		dlg( EnableControls, FALSE, RenderProfileComboBox );
	}
	else if ( <Option> == 1 )
	{
		dlg( SetCheck, FALSE, RenderOption0 );
		dlg( SetCheck, TRUE, RenderOption1 );
		dlg( SetCheck, FALSE, RenderOption2 );
		dlg( EnableControls, FALSE, RenderFolderLabel );
		dlg( EnableControls, FALSE, RenderFolder );
		dlg( EnableControls, FALSE, BrowseButton );
		dlg( EnableControls, TRUE, DeleteOldCheck );
		dlg( EnableControls, TRUE, FileOption0 );
		dlg( EnableControls, TRUE, FileOption1 );
		dlg( EnableControls, TRUE, FileTypeComboBox );
		dlg( EnableControls, TRUE, ProfileOption0 );
		dlg( EnableControls, TRUE, ProfileOption1 );
		dlg( EnableControls, TRUE, RenderProfileComboBox );
	}
	else if ( <Option> == 2 )
	{
		dlg( SetCheck, FALSE, RenderOption0 );
		dlg( SetCheck, FALSE, RenderOption1 );
		dlg( SetCheck, TRUE, RenderOption2 );
		dlg( EnableControls, TRUE, RenderFolderLabel );
		dlg( EnableControls, TRUE, RenderFolder );
		dlg( EnableControls, TRUE, BrowseButton );
		dlg( EnableControls, TRUE, DeleteOldCheck );
		dlg( EnableControls, TRUE, FileOption0 );
		dlg( EnableControls, TRUE, FileOption1 );
		dlg( EnableControls, TRUE, FileTypeComboBox );
		dlg( EnableControls, TRUE, ProfileOption0 );
		dlg( EnableControls, TRUE, ProfileOption1 );
		dlg( EnableControls, TRUE, RenderProfileComboBox );
	}
}

VOID OptionsDialog::OnChangeFileOption( Option )
{
	FileOption = <Option>;

	// Check appropriate apply type
	if ( <Option> == 0 )
	{
		dlg( SetCheck, TRUE, FileOption0 );
		dlg( SetCheck, FALSE, FileOption1 );
		dlg( EnableControls, FALSE, FileTypeComboBox );
	}
	else if ( <Option> == 1 )
	{
		dlg( SetCheck, FALSE, FileOption0 );
		dlg( SetCheck, TRUE, FileOption1 );
		dlg( EnableControls, <RenderOption> ? TRUE : FALSE, FileTypeComboBox );
	}
}

VOID OptionsDialog::OnChangeProfileOption( Option )
{
	ProfileOption = <Option>;

	// Check appropriate apply type
	if ( <Option> == 0 )
	{
		dlg( SetCheck, TRUE, ProfileOption0 );
		dlg( SetCheck, FALSE, ProfileOption1 );
		dlg( EnableControls, FALSE, RenderProfileComboBox );
	}
	else if ( <Option> == 1 )
	{
		dlg( SetCheck, FALSE, ProfileOption0 );
		dlg( SetCheck, TRUE, ProfileOption1 );
		dlg( EnableControls, <RenderOption> ? TRUE : FALSE, RenderProfileComboBox );
	}
}

VOID OptionsDialog::OnTextSelected()
{
	dlg( GetControlValue, TextFolderCheck, TextCheck );
	dlg( EnableControls, <TextCheck>, TextFolderLabel );
	dlg( EnableControls, <TextCheck>, TextFolder );
	dlg( EnableControls, <TextCheck>, TextBrowseButton );
}

VOID OptionsDialog::OnHoldCorrectionMode()
{
	dlg( GetControlValue, HoldCorrectionModeCheck, HoldCorrectionMode );
}


VOID OptionsDialog::OnAutoAutoBal()
{
	dlg( GetControlValue, AutoBalCheckBox, AutoBalFirst );

	if ( <ExtKeepCorrection> && <AutoBalFirst> )
	{
		if ( MessageBox( Translate( Translations, AskKeepCorrectionsOff), YESNO ) != YES )
		{ 
			dlg( SetCheck,FALSE,AutoBalCheckBox );
		}
		else
		{
			SetKeepLastCorrection();
			if ( Defined(AnalyzerView) )
			{
				AnalyzerView.SetKeepLastCorrection();
			}
			if ( Defined(LightTableView) )
			{
				LightTableView.SetKeepLastCorrection();
			}
		}
	}
	ExtAutoBalFirst = <AutoBalFirst>;
}

VOID OptionsDialog::OnAllowResetOfNoPrint()
{
	dlg( GetControlValue, AllowResetOfNoPrintCheck, AllowResetOfNoPrint );
}

VOID OptionsDialog::OnPreserveSelected()
{
	dlg( GetControlValue, PreserveLumCheck, PreserveCheck );
}

VOID OptionsDialog::OnShowOnlyImagesToAdjustSelected()
{
	dlg( GetControlValue, ShowOnlyImagesToAdjustCheck, ShowOnlyImagesToAdjust );
}

VOID OptionsDialog::OnTrackAutoBalData()
{
	dlg( GetInput );

	dlg( GetControlValue,TrackAutoBalCheckBox,saveData );

	SetWorkstationSettings( ~Analyzer~, ~SaveAutoBalData~, ~<saveData>~, TRUE );
}

VOID OptionsDialog::OnDeleteSelected()
{
	dlg( GetControlValue, DeleteOldCheck, DeleteCheck );
}

VOID OptionsDialog::OnEnableCropping()
{
	dlg( GetControlValue, EnableCroppingCheckBox, EnableCropping );
}

VOID OptionsDialog::Activate()
{
	dlg( SetControlFocus, RenderOption0 );
}



/*********************************************************************************
 *********************************************************************************
 ***************************** Main Analyzer Window ******************************
 *********************************************************************************
 *********************************************************************************/

/************************************************************
 *************** Overridden virtual functions ***************
 ************************************************************/


VOID Analyzer::Analyzer()
{
	ImageWidth = $ScreenWidth / 2 - $hGap;
	ImageHeight = $ImageWidth;

//	Define: ImageEditData Using DDImageEdit Private
//		Fields:	orgD			64
//				orgGamma		1.0	;	// all other fields default to 0 or NULL
}

VOID Analyzer::DefineMessages()
{
	BaseForm::DefineMessages();

	Translations( AddText, NoOrder, ~You must select an Order~ );

	Define: TranslationsSpanish Using DDSymbol Private;

	TranslationsSpanish( AddText, NoOrder, ~An Order you must add~ );
}

VOID Analyzer::WindowDefinition()
{
	Fields: Title 				~Digital Analyzer~
			Position			0 0 100 100
			IsMaximized			<DP2> ? F : T
			NoSysMenu			<DP2> ? F : T				
			HActionsText		ACTION SHOWHELPPAGE( KPDAWHelpFile "Identifying_the_Screen_Features.htm" )
			EnableStatusBar		F
}

VOID Analyzer::ResizeToFitScreen()	// <DP2>
{
	if ( <DP2> )
	{
		DataWindow( GetWindowPosition,WindowLeft,WindowTop,WindowRight,WindowBottom );

		WindowWidth = <WindowRight> - <WindowLeft>;
		WindowHeight = <WindowBottom> - <WindowTop>;

		ImageGap = <hGap>;

		ImageWidth = (<WindowWidth> - <ImageGap>) / 2;
		ImageHeight = (<WindowHeight> - <TopOfImage> - $vGap - 60);

		ImageWidth = Min(<ImageWidth>,<ImageHeight> );
		ImageHeight = <ImageWidth>;
		Left = 0;
		Top = <InitialTopOfImage>;

		View( ControlRect,AnalyzedImage,SetPosition,<Left>,<Top>,<ImageWidth>,<ImageHeight> );
		View( ControlRect,AnalyzedImageText,SetPosition,<Left>,<Top>+<ImageHeight>+$vGap,<ImageWidth>,25 );

		View( ControlRect,GetPosition,NoPrintIndicator,x,y,w,l );
		View( ControlRect,SetPosition,NoPrintIndicator,<Left> + (<ImageWidth> / 2) - 65,<Top> - 30,<w>,<l> );

		View( ControlRect,GetPosition,InvalidText,x,y,w,l );
		InvalidBottom = (<Top> + <ImageHeight> + AnalyzedImage(GetTop,Position)) / 2 - 25;
		View( ControlRect,SetPosition,InvalidText,<Left>,<InvalidBottom>,<w>,<l> );


		Left += <ImageWidth> + <ImageGap>;
		View( ControlRect,ReferenceImage,SetPosition,<Left>,<Top>,<ImageWidth>,<ImageHeight> );
		View( ControlRect,ReferenceImageText,SetPosition,<Left>,<Top>+<ImageHeight>+$vGap,<ImageWidth>,25 );	

		View( RefreshView );
	}
}

VOID Analyzer::Maximize()
{
	DataWindow( Show, <DP2> ? ~Normal~ : ~Maximized~ );
}

NUMERIC Analyzer::OnKeyDown()
{
	Key = View<Viewname>( GetLastKey, KeyString );
	
//	Do nothing

	return TRUE;
}

VOID Analyzer::ViewDefinition()
{ 
	Fields:		BackgroundColor	~<BackRed> <BackGreen> <BackBlue>~
				KeyboardActionsText		ACTION EXEC ( <This>.OnKeyDown() )
//				IActionsText		ACTION EXEC ( <This>.Maximize() )
				NoScroll					T
				WindowPosChangedActionText	ACTION EXEC ( <This>.ResizeToFitScreen() )
				HActionsText		ACTION SHOWHELPPAGE( KPDAWHelpFile "Identifying_the_Screen_Features.htm" );
}

VOID Analyzer::AddControls()
{
	AddPromptControls();
	AddColorControls();
	AddImageControls();
	AddToolbar();

	// CGCGCG These will be deleted after testing
	AddWheelmanControls();
}

VOID Analyzer::OnCloseDataWindow()
{
	SetWorkStationSettings( ~Analyzer~, ~KeepCorrection~, ~<ExtKeepCorrection>~, TRUE );
	SetWorkstationSettings( ~Analyzer~, ~DefaultAutoBalLevel~, <ExtSbaLevel>, TRUE );

	ExitMe = TRUE;

	if ( Defined( DImageSba ) )
	{
		ForgetGlobal( DImageSba );
	}

	if ( DefinedAndNotNull( OrderID ) )
	{
		if ( !<PreDP2_42> )
		{
			if ( !<ModifiedFlag> )
			{
				CancelOrder();
			}
			else
			{
				AnalyzerExiting = TRUE;
				Global( AnalyzerExiting );
				EndOrder();
				ExitMe = FALSE;
			}
		}
		else
		{
			// Set status back to original only
			CancelOrder();
		}
	}

	if ( <ExitMe> && !<fWindowClosed> )
	{
		fWindowClosed = TRUE;
		if ( Defined(LightTableView) )	{ LightTableView.CloseWindow(); }	// <DP2>
		DataWindow( ForceCloseWindow );

		if ( <ExitScriptOnClose> )
		{
			Exit();
		}
	}
}

Define: ImageEditDataZero Using DDImageEdit ;


NUMERIC ViewChanges()
{
	ImageEditDataZero( UpdateCorrections );
	
	Action = ~ReApplyBalance();~;
	return QueueContentsAfter( Action,~500~ );
}

NUMERIC ReApplyBalance()		
{
	return UpdateAffectedImages();
}


NUMERIC UpdateAffectedImages()		// APPLIES THE MOST RECENT DIALOG CHANGE TO THE AFFECTED IMAGES
{
	KillTimer( 0 );

	return ImageEditData( UpdateCorrections );
}

/*************************************************
 *************** Mnemonic controls ***************
 *************************************************/

VOID Analyzer::AddPromptControls()
{
	AddPromptControl( ~<pNum0>~ );
	AddPromptControl( ~<pNum1>~ );
	AddPromptControl( ~<pNum2>~ );
	AddPromptControl( ~<pNum3>~ );
	AddPromptControl( ~<pNum4>~ );
	AddPromptControl( ~<pNum5>~ );
	AddPromptControl( ~<pNum6>~ );
	AddPromptControl( ~<pNum7>~ );
	AddPromptControl( ~<pNum8>~ );
	AddPromptControl( ~<pNum9>~ );
	AddPromptControl( ~<pNum0_2>~ );
	AddPromptControl( ~<pNum1_2>~ );
	AddPromptControl( ~<pNum2_2>~ );
	AddPromptControl( ~<pNum3_2>~ );
	AddPromptControl( ~<pNum4_2>~ );
	AddPromptControl( ~<pNum5_2>~ );
	AddPromptControl( ~<pNum6_2>~ );
	AddPromptControl( ~<pNum7_2>~ );
	AddPromptControl( ~<pNum8_2>~ );
	AddPromptControl( ~<pNum9_2>~ );
	AddPromptControl( ~<pDensity>~ );
	AddPromptControl( ~<pDensity2>~ );
	AddPromptControl( ~<pThumbUp>~ );
	AddPromptControl( ~<pThumbDown>~ );
	AddPromptControl( ~<pRed>~ );
	AddPromptControl( ~<pRed2>~ );
	AddPromptControl( ~<pGreen>~ );
	AddPromptControl( ~<pGreen2>~ );
	AddPromptControl( ~<pBlue>~ );
	AddPromptControl( ~<pBlue2>~ );
	AddPromptControl( ~<pPrint>~ );
	AddPromptControl( ~<pNoPrint>~ );
	AddPromptControl( ~<pNext>~ );
	AddPromptControl( ~<pPrev>~ );
	AddPromptControl( ~<pMode>~ );
	AddPromptControl( ~<pViewMode>~ );
	AddPromptControl( ~<pMakeRef>~ );
	AddPromptControl( ~<pRecallRef>~ );
	AddPromptControl( ~<pRotate90>~ );
	AddPromptControl( ~<pRotate180>~ );
	AddPromptControl( ~<pRotate270>~ );
	AddPromptControl( ~<pStore>~ );
	AddPromptControl( ~<pRecall>~ );
	AddPromptControl( ~<pRecallLast>~ );
	AddPromptControl( ~<pApplyAll>~ );
	AddPromptControl( ~<pOpen>~ );
	AddPromptControl( ~<pReset>~ );
	AddPromptControl( ~<pAutoBal>~ );
}

VOID Analyzer::AddPromptControl( Character )
{
	NewCharacter = ~<Character>~;
	if ( ~<Character>~ == ~<pDensity>~ )
	{
		NewCharacter = ~01~;
	}
	else if ( ~<Character>~ == ~<pDensity2>~ )
	{
		NewCharacter = ~02~;
	}
	else if ( ~<Character>~ == ~<pPrint>~ )
	{
		NewCharacter = ~03~;
	}
	else if ( ~<Character>~ == ~<pNoPrint>~ )
	{
		NewCharacter = ~04~;
	}
	else if ( ~<Character>~ == ~<pNext>~ )
	{
		NewCharacter = ~05~;
	}
	else if ( ~<Character>~ == ~<pPrev>~ )
	{
		NewCharacter = ~06~;
	}
	else if ( ~<Character>~ == ~<pMode>~ )
	{
		NewCharacter = ~07~;
	}
	else if ( ~<Character>~ == ~<pViewMode>~ )
	{
		NewCharacter = ~08~;
	}
	else if ( ~<Character>~ == ~<pNum0_2>~ )
	{
		NewCharacter = ~09~;
	}
	else if ( ~<Character>~ == ~<pNum1_2>~ )
	{
		NewCharacter = ~10~;
	}
	else if ( ~<Character>~ == ~<pNum2_2>~ )
	{
		NewCharacter = ~11~;
	}
	else if ( ~<Character>~ == ~<pNum3_2>~ )
	{
		NewCharacter = ~12~;
	}
	else if ( ~<Character>~ == ~<pNum4_2>~ )
	{
		NewCharacter = ~13~;
	}
	else if ( ~<Character>~ == ~<pNum5_2>~ )
	{
		NewCharacter = ~14~;
	}
	else if ( ~<Character>~ == ~<pNum6_2>~ )
	{
		NewCharacter = ~15~;
	}
	else if ( ~<Character>~ == ~<pNum7_2>~ )
	{
		NewCharacter = ~16~;
	}
	else if ( ~<Character>~ == ~<pNum8_2>~ )
	{
		NewCharacter = ~17~;
	}
	else if ( ~<Character>~ == ~<pNum9_2>~ )
	{
		NewCharacter = ~18~;
	}
	else if ( ~<Character>~ == ~<pThumbUp>~ )
	{
		NewCharacter = ~19~;
	}
	else if ( ~<Character>~ == ~<pThumbDown>~ )
	{
		NewCharacter = ~20~;
	}
	else if ( ~<Character>~ == ~<pAutoBal>~ )
	{
		NewCharacter = ~21~;
	}

	// Special handling for ( and ) because these characters embedded in an action will cause us
	// major problems in parsing the action.
	if ( ~<Character>~ == ~<pNum9_2>~ )
	{
		if ( <ShowButtonsForDebug> ) 
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							Position			<xAmountAnalyzer>,50,15,25
							DActionsText		ACTION EXEC ( <This>.OnLeftParenButton() )
							Text				Translate( ~&<Character>~ );
		}
		else
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							DActionsText		ACTION EXEC ( <This>.OnLeftParenButton() )
							Text				Translate( ~&<Character>~ );
		}
	}
	else if ( ~<Character>~ == ~<pNum0_2>~ )
	{
		if ( <ShowButtonsForDebug> )
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							Position			<xAmountAnalyzer>,50,15,25
							DActionsText		ACTION EXEC ( <This>.OnRightParenButton() )
							Text				Translate( ~&<Character>~ );
		}
		else
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							DActionsText		ACTION EXEC ( <This>.OnRightParenButton() )
							Text				Translate( ~&<Character>~ );
		}
	}
	else
	{
		if ( <ShowButtonsForDebug> )
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							Position			<xAmountAnalyzer>,50,15,25
							DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
							Text				Translate( ~&<Character>~ );
		}
		else
		{
			Define: Button<NewCharacter> Using DDWinCtrlDef AsSymbol Button<NewCharacter> Private
					Fields:	TypeName			Button
							DActionsText		ACTION EXEC ( <This>.OnButton( ~<Character>~ ) )
							Text				Translate( ~&<Character>~ );
		}
	}

	xAmountAnalyzer = <xAmountAnalyzer> + 20;
}

/************************************************
 *************** Toolbar controls ***************
 ************************************************/

VOID Analyzer::AddToolbar()
{
	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
			Fields:		TypeName				Button
						Position				<ToolbarGap>, 4, <ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWOpen.tif~
						DActionsText			ACTION EXEC ( OpenAnOrder() )
						ToolTip					~Open an order~;
	
		Define: Seperator0 Using DDWinCtrlDef AsSymbol Seperator0 Private
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: Seperator1 Using DDWinCtrlDef AsSymbol Seperator1 Private
			Fields:		TypeName				StaticText
						Position				OpenButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: PrevButton Using DDWinCtrlDef AsSymbol PrevButton Private
			Fields:		TypeName				Button
						Position				OpenButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWPrev.tif~
						DActionsText			ACTION EXEC ( <This>.OnPrevButton() )
						ToolTip					~Previous image~;

	Define: NextButton Using DDWinCtrlDef AsSymbol NextButton Private
			Fields:		TypeName				Button
						Position				PrevButton(GetRight, Position) , OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWNext.tif~
						DActionsText			ACTION EXEC ( <This>.OnNextButton() )
						ToolTip					~Next image~;

		Define: Seperator2 Using DDWinCtrlDef AsSymbol Seperator2 Private
			Fields:		TypeName				StaticText
						Position				NextButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: DensityUpButton Using DDWinCtrlDef AsSymbol DensityUpButton Private
			Fields:		TypeName				Button
						Position				NextButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWDensityU.tif~
						DActionsText			ACTION EXEC ( <This>.OnDensityButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add density/contrast~;

	Define: RedUpButton Using DDWinCtrlDef AsSymbol RedUpButton Private
			Fields:		TypeName				Button
						Position				DensityUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRedU.tif~
						DActionsText			ACTION EXEC ( <This>.OnRedButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add red/gamma~;

	Define: GreenUpButton Using DDWinCtrlDef AsSymbol GreenUpButton Private
			Fields:		TypeName				Button
						Position				RedUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWGreenU.tif~
						DActionsText			ACTION EXEC ( <This>.OnGreenButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add green/saturation~;

	Define: BlueUpButton Using DDWinCtrlDef AsSymbol BlueUpButton Private
			Fields:		TypeName				Button
						Position				GreenUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWBlueU.tif~
						DActionsText			ACTION EXEC ( <This>.OnBlueButton( <This>.GetChangeAmount( 1 ) ) )
						ToolTip					~Add blue~;

		Define: Seperator3 Using DDWinCtrlDef AsSymbol Seperator3 Private
			Fields:		TypeName				StaticText
						Position				BlueUpButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: DensityDownButton Using DDWinCtrlDef AsSymbol DensityDownButton Private
			Fields:		TypeName				Button
						Position				BlueUpButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWDensityD.tif~
						DActionsText			ACTION EXEC ( <This>.OnDensityButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract density/contrast~;

	Define: RedDownButton Using DDWinCtrlDef AsSymbol RedDownButton Private
			Fields:		TypeName				Button
						Position				DensityDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRedD.tif~
						DActionsText			ACTION EXEC ( <This>.OnRedButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract red/gamma~;

	Define: GreenDownButton Using DDWinCtrlDef AsSymbol GreenDownButton Private
			Fields:		TypeName				Button
						Position				RedDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWGreenD.tif~
						DActionsText			ACTION EXEC ( <This>.OnGreenButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract green/saturation~;

	Define: BlueDownButton Using DDWinCtrlDef AsSymbol BlueDownButton Private
			Fields:		TypeName				Button
						Position				GreenDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWBlueD.tif~
						DActionsText			ACTION EXEC ( <This>.OnBlueButton( <This>.GetChangeAmount( -1 ) ) )
						ToolTip					~Subtract blue~;

		Define: Seperator4 Using DDWinCtrlDef AsSymbol Seperator4 Private
			Fields:		TypeName				StaticText
						Position				BlueDownButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: StoreButton Using DDWinCtrlDef AsSymbol StoreButton Private
			Fields:		TypeName				Button
						Position				BlueDownButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWStore.tif~
						DActionsText			ACTION EXEC ( StoreCorrections() )
						ToolTip					~Store current corrections~;

	Define: RecallButton Using DDWinCtrlDef AsSymbol RecallButton Private
			Fields:		TypeName				Button
						Position				StoreButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRecall.tif~
						DActionsText			ACTION EXEC ( RecallCorrections() )
						ToolTip					~Recall corrections~;

	Define: RecallLastButton Using DDWinCtrlDef AsSymbol RecallLastButton Private
			Fields:		TypeName				Button
						Position				RecallButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRecallLast.tif~
						DActionsText			ACTION EXEC ( ApplyLastCorrection() )
						ToolTip					~Recall last saved correction~;

		Define: Seperator5 Using DDWinCtrlDef AsSymbol Seperator5
			Fields:		TypeName				StaticText
						Position				RecallLastButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: RecallRefButton Using DDWinCtrlDef AsSymbol RecallRefButton Private
			Fields:		TypeName				Button
						Position				RecallLastButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRecallRef.tif~
						DActionsText			ACTION EXEC ( RecallTheReference() )
						ToolTip					~Recall reference image~;

	Define: MakeRefButton Using DDWinCtrlDef AsSymbol MakeRefButton Private
			Fields:		TypeName				Button
						Position				RecallRefButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWMakeRef.tif~
						DActionsText			ACTION EXEC ( MakeTheReference() )
						ToolTip					~Make current image a reference image~;

		Define: Seperator6 Using DDWinCtrlDef AsSymbol Seperator6
			Fields:		TypeName				StaticText
						Position				MakeRefButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ResetButton Using DDWinCtrlDef AsSymbol ResetButton Private
			Fields:		TypeName				Button
						Position				MakeRefButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWReset.tif~
						DActionsText			ACTION EXEC ( <This>.ResetCorrections() )

						ToolTip					~Reset corrections~;

		Define: Seperator7 Using DDWinCtrlDef AsSymbol Seperator7
			Fields:		TypeName				StaticText
						Position				ResetButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ApplyToAllButton Using DDWinCtrlDef AsSymbol ApplyToAllButton Private
			Fields:		TypeName				Button
						Position				ResetButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWAll.tif~
						DActionsText			ACTION EXEC ( <This>.StartApplyAll() )
						ToolTip					~Apply current corrections to all images~;

		Define: Seperator8 Using DDWinCtrlDef AsSymbol Seperator8
			Fields:		TypeName				StaticText
						Position				ApplyToAllButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: AutoDRGBButton Using DDWinCtrlDef AsSymbol AutoDRGBButton Private
			Fields:		GENCONNAME				THIS
						DACTIONSTEXT			ACTION EXEC ( <THIS>.SetAutoBalMode(0,0,0,TRUE); <THIS>.OnAutoBalance(TRUE)  )
						POSITION				ApplyToAllButton(GetRight,Position) + <ToolbarGap>, OpenButton(GetTop,Position), <ToolbarW> + 7, <ToolbarH>
						TEXT					~DRGB~
						TOOLTIP					~Automatically calculate the DRGB balance~
						TYPENAME				BUTTON;

	Define: AutoDenButton Using DDWinCtrlDef AsSymbol AutoDenButton Private
			Fields:		GENCONNAME				THIS
						DACTIONSTEXT			ACTION EXEC ( <THIS>.SetAutoBalMode(16,0,0,TRUE); <THIS>.OnAutoBalance(TRUE)  )
						POSITION				AutoDRGBButton(GetRight,Position), OpenButton(GetTop,Position), <ToolbarW>, <ToolbarH>
						TEXT					~Den~
						TOOLTIP					~Automatically calculate the Density balance~
						TYPENAME				BUTTON;

	Define: AutoRGBButton Using DDWinCtrlDef AsSymbol AutoRGBButton Private
			Fields:		GENCONNAME				THIS
						DACTIONSTEXT			ACTION EXEC ( <THIS>.SetAutoBalMode(1,0,0,TRUE); <THIS>.OnAutoBalance(TRUE)  )
						POSITION				AutoDenButton(GetRight,Position), OpenButton(GetTop,Position), <ToolbarW>, <ToolbarH>
						TEXT					~RGB~
						TOOLTIP					~Automatically calculate the RGB balance~
						TYPENAME				BUTTON;

		Define: Seperator9 Using DDWinCtrlDef AsSymbol Seperator9
			Fields:		TypeName				StaticText
						Position				AutoRGBButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: FullViewButton Using DDWinCtrlDef AsSymbol FullViewButton
			Fields:		TypeName				Button
						Position				AutoRGBButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWFull.tif~
						DActionsText			ACTION EXEC ( <This>.SetToolbarState() )
						ToolTip					~Full view mode~
						IsTabStop				F;

	Define: LightTableButton Using DDWinCtrlDef AsSymbol LightTableButton Private
			Fields:		TypeName				Button
						Position				FullViewButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWLight.tif~
						DActionsText			ACTION EXEC ( ChangeView( 1 ) )
						ToolTip					~Display light table~;

		Define: Seperator10 Using DDWinCtrlDef AsSymbol Seperator10
			Fields:		TypeName				StaticText
						Position				LightTableButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ModeButton Using DDWinCtrlDef AsSymbol ModeButton Private
			Fields:		TypeName				Button
						Position				LightTableButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWMode.tif~
						DActionsText			ACTION EXEC ( <This>.ToggleWheelman() )
						ToolTip					~Change correction mode~;

		Define: Seperator11 Using DDWinCtrlDef AsSymbol Seperator11
			Fields:		TypeName				StaticText
						Position				ModeButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: RawButton Using DDWinCtrlDef AsSymbol RawButton
			Fields:		TypeName				Button
						Position				ModeButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												<ToolbarW>, <ToolbarH>
						ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRaw.tif~
						DActionsText			ACTION DOC ( DigitalCameraDoc OpenOnce "DigitalCameraDoc" )
						ToolTip					~Launch digital camera conversion tool~
						IsTabStop				F;

	if ( <DP2> )
	{
		Define: Seperator12 Using DDWinCtrlDef AsSymbol Seperator12
			Fields:		TypeName				StaticText
						Position				RawButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: OptionsButton Using DDWinCtrlDef AsSymbol OptionsButton
			Fields:		TypeName				Button
						Position				RawButton(GetRight, Position) + <ToolbarGap>, RawButton(GetTop, Position),
												<ToolbarW>+20, <ToolbarH>
						//ImageFile				~<$App.Directory>\ToolbarButtons\KPDAWRaw.tif~
						DActionsText			ACTION EXEC ( EditOptions() )
						ToolTip					~Change the analyzer options~
						Text					~Options~
						IsTabStop				F;

		Define: Seperator13 Using DDWinCtrlDef AsSymbol Seperator13
			Fields:		TypeName				StaticText
						Position				OptionsButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: KeepLastCorrectionsCheckBox Using DDWinCtrlDef AsSymbol KeepLastCorrectionsCheckBox
			Fields:		TypeName				CheckBox
						Position				OptionsButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												120, <ToolbarH>
						DActionsText			ACTION EXEC ( SetKeepLastCorrection() )
						Text					~Keep Last Correction~
						ToolTip					~When checked, retains the correction values when you press Print or No Print~
						IsTabStop				F;
	}
	else
	{

		Define: Seperator12 Using DDWinCtrlDef AsSymbol Seperator12
			Fields:		TypeName				StaticText
						Position				RawButton(GetRight, Position), OpenButton(GetTop, Position),
												<ToolbarGap>, <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

		Define: KeepLastCorrectionsCheckBox Using DDWinCtrlDef AsSymbol KeepLastCorrectionsCheckBox
			Fields:		TypeName				CheckBox
						Position				RawButton(GetRight, Position) + <ToolbarGap>, OpenButton(GetTop, Position),
												120, <ToolbarH>
						DActionsText			ACTION EXEC ( SetKeepLastCorrection() )
						Text					~Keep Last Correction~
						ToolTip					~When checked, retains the correction values when you press Print or No Print~
						IsTabStop				F;
	}

//	ScreenWidth = App( thisApp,MainWindow,GetClientWidth ) - 3;

	Define: Filler1 Using DDWinCtrlDef AsSymbol Filler1 Private
			Fields:		TypeName				StaticText
						Position				KeepLastCorrectionsCheckBox(GetRight, Position), OpenButton(GetTop, Position),
												$ScreenWidth - KeepLastCorrectionsCheckBox(GetRight, Position), <ToolbarH>
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ToolBarLine1 Using DDWinCtrlDef AsSymbol ToolBarLine1 Private
			Fields:		TypeName				StaticText
						Position				0, 0, $ScreenWidth, 1
						BGColorRed				255, BGColorBlue 255, BGColorGreen 255

	Define: ToolBarLine2 Using DDWinCtrlDef AsSymbol ToolBarLine2 Private
			Fields:		TypeName				StaticText
						Position				0, 1, $ScreenWidth, 3
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ToolBarLine3 Using DDWinCtrlDef AsSymbol ToolBarLine3 Private
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetBottom, Position), $ScreenWidth, 3
						BGColorRed				<ToolbarRed>, BGColorGreen <ToolbarGreen>, BGColorBlue <ToolbarBlue>;

	Define: ToolBarLine4 Using DDWinCtrlDef AsSymbol ToolBarLine4 Private
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetBottom, Position) + 3, $ScreenWidth, 1
						BGColorRed				128, BGColorBlue 128, BGColorGreen 128

	Define: ToolBarLine5 Using DDWinCtrlDef AsSymbol ToolBarLine5 Private
			Fields:		TypeName				StaticText
						Position				0, OpenButton(GetBottom, Position) + 4, $ScreenWidth, 1
						BGColorRed				0, BGColorBlue 0, BGColorGreen 0
}

NUMERIC Analyzer::GetChangeAmount( Amount )
{
	return <Amount> * <WheelChange>;
}

/**********************************************************
 *************** Color Corrections Controls ***************
 **********************************************************/
VOID Analyzer::AddColorControls()
{
	Define: DensityLabel Using DDWinCtrlDef AsSymbol DensityLabel Private
		Fields:	Typename		StaticText
				Position		20, 45, <LabelWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Density correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~D~

	Define: DensityText Using DDWinCtrlDef AsSymbol DensityText Private
		Fields:	TypeName		StaticText
				Position		DensityLabel(GetRight, Position), DensityLabel(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Density correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: RedLabel Using DDWinCtrlDef AsSymbol RedLabel Private
		Fields:	Typename		StaticText
				Position		DensityLabel(GetLeft, Position), DensityLabel(GetBottom, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Red correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~R~

	Define: RedText Using DDWinCtrlDef AsSymbol RedText Private
		Fields:	TypeName		StaticText
				Position		DensityText(GetLeft, Position), DensityText(GetBottom, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Red correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: GreenLabel Using DDWinCtrlDef AsSymbol GreenLabel Private
		Fields:	Typename		StaticText
				Position		DensityLabel(GetLeft, Position), RedLabel(GetBottom, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 255,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Green correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~G~

	Define: GreenText Using DDWinCtrlDef AsSymbol GreenText Private
		Fields:	TypeName		StaticText
				Position		DensityText(GetLeft, Position), RedText(GetBottom, Position),
								<ColorWidth>, <ColorHeight>,
				TextColorRed	0,			TextColorGreen 255,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Green correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: BlueLabel Using DDWinCtrlDef AsSymbol BlueLabel Private
		Fields:	Typename		StaticText
				Position		DensityLabel(GetLeft, Position), GreenLabel(GetBottom, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Blue correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~B~

	Define: BlueText Using DDWinCtrlDef AsSymbol BlueText Private
		Fields:	TypeName		StaticText
				Position		DensityText(GetLeft, Position), GreenText(GetBottom, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Blue correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: ColorGroupBox Using DDWinCtrlDef AsSymbol ColorGroupBox Private
		Fields:	TypeName		GroupBox
				Position		DensityLabel(GetLeft, Position) - 10,
								DensityText(GetTop, Position) - 10,
								DensityText(GetRight, Position) - DensityLabel(GetLeft, Position) + 20,
								BlueText(GetBottom, Position) - DensityText(GetTop, Position) + 15
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>;

	TopOfImage = ColorGroupBox(GetBottom, Position) + $vGap;
	InitialTopOfImage = <TopOfImage>;

	Define: ContrastLabel Using DDWinCtrlDef AsSymbol ContrastLabel Private
		Fields:	Typename		StaticText
				Position		DensityText(GetRight, Position) + $vGap*4, DensityLabel(GetTop, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Contrast correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~C~

	Define: ContrastText Using DDWinCtrlDef AsSymbol ContrastText Private
		Fields:	TypeName		StaticText
				Position		ContrastLabel(GetRight, Position), DensityText(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Contrast correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE
	Define: GammaLabel Using DDWinCtrlDef AsSymbol GammaLabel Private
		Fields:	Typename		StaticText
				Position		ContrastLabel(GetLeft, Position), RedLabel(GetTop, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Gamma correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~G~

	Define: GammaText Using DDWinCtrlDef AsSymbol GammaText Private
		Fields:	TypeName		StaticText
				Position		GammaLabel(GetRight, Position), RedText(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Gamma correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: SaturationLabel Using DDWinCtrlDef AsSymbol SaturationLabel Private
		Fields:	Typename		StaticText
				Position		ContrastLabel(GetLeft, Position), GreenLabel(GetTop, Position),
								<LabelWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Saturation correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~S~

	Define: SaturationText Using DDWinCtrlDef AsSymbol SaturationText Private
		Fields:	TypeName		StaticText
				Position		SaturationLabel(GetRight, Position), GreenText(GetTop, Position),
								<ColorWidth>, <ColorHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Saturation correction for current image~
				Font			~<ColorFont>~
				FontSize		<ColorFontSize>
				Text			~0~
				RightJustified	TRUE

	Define: StepIndicator Using DDWinCtrlDef AsSymbol StepIndicator Private
		Fields:	TypeName		StaticText
				Position		ContrastText(GetRight, Position) - 20, SaturationText(GetBottom, Position) + ($vGap * 2),
								20, 15
				TextColorRed	0,			TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			~Change size indicator~
				Text			~+1~
				RightJustified	TRUE
				IsHidden		T

	Define: ColorGroupBox2 Using DDWinCtrlDef AsSymbol ColorGroupBox2 Private
		Fields:	TypeName		GroupBox
				Position		ContrastLabel(GetLeft, Position) - 10,
								ContrastText(GetTop, Position) - 10,
								ContrastText(GetRight, Position) - ContrastLabel(GetLeft, Position) + 20,
								SaturationText(GetBottom, Position) - ContrastText(GetTop, Position) + 15
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				IsHidden		T
}

VOID Analyzer::SetNewColor()
{
	View( SetControlColor, DensityLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, RedLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, GreenLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, BlueLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, ContrastLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, SaturationLabel, BGColor, 144, 144, 144 );
	View( SetControlColor, GammaLabel, BGColor, 144, 144, 144 );

	View( SetControlColor, DensityText, BGColor, 144, 144, 144 );
	View( SetControlColor, RedText, BGColor, 144, 144, 144 );
	View( SetControlColor, GreenText, BGColor, 144, 144, 144 );
	View( SetControlColor, BlueText, BGColor, 144, 144, 144 );
	View( SetControlColor, ContrastText, BGColor, 144, 144, 144 );
	View( SetControlColor, SaturationText, BGColor, 144, 144, 144 );
	View( SetControlColor, GammaText, BGColor, 144, 144, 144 );

	View( SetControlTitle, StepIndicator, ~+<WheelChange>~);
	View( ShowControls, TRUE, StepIndicator );
}

VOID Analyzer::SetOldColor()
{
	View( SetControlColor, DensityLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, RedLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GreenLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, BlueLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, ContrastLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, SaturationLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GammaLabel, BGColor, <BackRed>, <BackGreen>, <BackBlue> );

	View( SetControlColor, DensityText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, RedText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GreenText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, BlueText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, ContrastText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, SaturationText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );
	View( SetControlColor, GammaText, BGColor, <BackRed>, <BackGreen>, <BackBlue> );

	View( ShowControls, FALSE, StepIndicator );
}


/**********************************************************
 *************** Image & Reference Controls ***************
 **********************************************************/
 VOID Analyzer::AddImageControls()
 {
	// Hidden frame box for frame storage
	Define: FramesListBox Using DDWinCtrlDef AsSymbol FramesListBox Private
		Fields:	TypeName		ListBox
				Position		$hGap, 300,
								90, 200 
				GenConField		~Frame~
				IActionsText	ACTIONS ( GetList(FramesToRetouchList) Get )
				DActionsText	ACTIONS ( Save "Exec(<THIS>.OnFrameSelected(TRUE);)" )
				OActionsText	ACTIONS ( Save )
				IsHidden		T;

	AnalyzeHeight = <ScreenHeight> - <TopOfImage> - 25 - ($vGap * 2);
	ReferenceHeight = <ScreenHeight> - <TopOfImage> - 25 - ($vGap * 2);
	AnalyzeWidth = <ImageWidth>;
	ReferenceWidth = <ImageWidth>;

	if ( DefinedAndNotNull( WantStaticToolbars ) )
	{
		AnalyzeHeight -= 25;
		ReferenceHeight -= 25;
	}

	Define: AnalyzedImage Using DDWinCtrlDef AsSymbol AnalyzedImage Private 
		Fields:	TypeName		StaticText
				Position		0, <TopOfImage>,
								<ImageWidth>, <AnalyzeHeight>
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			Translate( ~Image To Analyze~ )
				RClickDnActionsText	ACTION EXEC ( <This>.ImageContextMenu() )
				DoubleClickActionsText ACTION EXEC ( ChangeView( 1 ) )
				Font			~Arial~
				FontSize		24
				FontWeight		600
				CenterText		TRUE
				AllowCropping	FALSE
				DisplayCropBox	TRUE;

	InvalidBottom = (AnalyzedImage(GetBottom,Position) + AnalyzedImage(GetTop,Position)) / 2 - 25;

	Define: InvalidText Using DDWinCtrlDef AsSymbol InvalidText Private
		Fields:	TypeName		StaticText
				Position		AnalyzedImage(GetLeft, Position), <InvalidBottom>,
								<AnalyzeWidth>, 50
				TextColorRed	255,		TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			Translate( ~Invalid Image Path~ )
				Font			~Arial~
				FontSize		48
				FontWeight		600
				CenterText		TRUE
				IsHidden		T
				Text			Translate( ~Invalid Image Path~ )

	Define: AnalyzedImageText Using DDWinCtrlDef AsSymbol AnalyzedImageText Private
		Fields:	TypeName		StaticText
				Position		AnalyzedImage(GetLeft,Position), AnalyzedImage(GetBottom,Position)+$vGap,
								<AnalyzeWidth>, 25
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			Translate( ~Order\Roll\Frame~ )
				Font			~Arial~
				FontSize		20
				FontWeight		600
				CenterText		TRUE

	Define: NoPrintIndicator Using DDWinCtrlDef AsSymbol NoPrintIndicator Private 
		Fields:	TypeName		StaticText
				Position		AnalyzedImage(GetLeft,Position) + (AnalyzedImage(GetWidth,Position) / 2) - 65, AnalyzedImage(GetTop,Position) - 30, 
								130, 30
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			Translate( ~Image is Not Printable~ )
				ImageFile		~<$App.Directory>\ToolbarButtons\KPDAWNoPrint.tif~
				IsHidden		T

	Define: ReferenceImage Using DDWinCtrlDef AsSymbol ReferenceImage Private 
		Fields:	TypeName		StaticText
				Position		AnalyzedImage(GetRight,Position) + $hGap, AnalyzedImage(GetTop,Position),
								<ReferenceWidth>, <ReferenceHeight>
				Tooltip			Translate( ~Reference Image~ )
				RClickDnActionsText	ACTION EXEC ( <This>.RefContextMenu() )
				DoubleClickActionsText	ACTION EXEC ( RecallTheReference() )
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>;

	Define: ReferenceImageText Using DDWinCtrlDef AsSymbol ReferenceImageText Private
		Fields:	TypeName		StaticText
				Position		ReferenceImage(GetLeft,Position), ReferenceImage(GetBottom,Position)+$vGap,
								<ReferenceWidth>, 25
				TextColorRed	255,		TextColorGreen 255,			TextColorBlue 255
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Tooltip			Translate( ~Reference Image~ )
				Font			~Arial~
				FontSize		20
				FontWeight		600
				CenterText		TRUE;

//	ScreenWidth = App( thisApp,MainWindow,GetClientWidth ) - 3;

	Define: DebugText Using DDWinCtrlDef AsSymbol DebugText Private
		Fields:	TypeName		StaticText
				Position		$ScreenWidth - 70, 50,
								70, 30
				TextColorRed	255,		TextColorGreen 0,			TextColorBlue 0
				BGColorRed		<BackRed>,	BGColorGreen <BackGreen>,	BGColorBlue <BackBlue>
				Text			Translate( ~Debug~ )
				Tooltip			Translate( ~Debug mode indicator~ )
				Font			~Arial~
				FontSize		24
				IsHidden		<DebugModeChar>
				RClickDnActionsText	ACTION EXEC ( <This>.ShowDebugMenu() )
//				DActionsText	ACTION EXEC ( <This>.SetNewColor() ) ;
}


/****************************************************
 *************** Open Order Functions ***************
 ****************************************************/

NUMERIC StopForAEImages( Order )
{
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate(DBMessages,ConnectionFailed,~<theErr>~) );
	}

	Cmd = ~Select Count(1) from Images Where OrderID='<Order>' AND ApplyShasta=1~;
	dbase( GetValuesFor, ~<Cmd>~, numRecs);
	
	if ( <numRecs> == 0 )
	{
		return FALSE;
	}
	
	ShastaWarning = ~The order you selected contains images that have been auto enhanced.\n\nIf you make adjustments in the Digital Analyzer to these images, the auto enhancements will be lost.\n\nTo preserve auto enhancements, use Adjust Images.\n\nIf you wish to open this order in the Digitalizer Analyzer, select Yes.~;
	
	if ( MessageBox( ~<ShastaWarning>~,YESNO,DEFBUTTON2 ) != YES )
	{
		return TRUE;
	}	
	
	return FALSE;
}

VOID OpenAnOrder(NewOrderID)
{
	if ( <ModifiedFlag> )
	{
		EndOrder();
	}
	else
	{
		EnableMenus( FALSE, FALSE );

		// DP2
		if ( DefinedAndNotNull( NewOrderID ) )
		{
			AnalyzerView.NewOrder(~<NewOrderID>~);
		}
		else
		{
			AnalyzerView.OpenOrder();
		}
	}
}

VOID Analyzer::OpenOrder()
{
	// Disable window while open order dialog is active
	EnableCorrectWindow( FALSE );

	// Pass wheelman control to open order dialog
	OpenOrderWheel( New, Wheelman );
	Global( Wheelman );
	EnableWheelman();
	
	// execute open order dialog
	ForgetGlobal( OpenDlg );
	OpenDialog( New, OpenDlg );
	Global( OpenDlg );
	OpenDlg.DefineDialog();
	OpenDlg.SetupList();
	OpenDlg.PopulateOrderListBox();// Only do this when they press the button DF removed comment 28/6/06
	OpenDlg.OnOrderSelected();
        OpenDlg.StartTimerRefresh();
}


/**********************************************************
 *************** Store Correction functions ***************
 **********************************************************/

VOID StoreCorrections()
{
	if ( !<ImageLoaded> )
	{
		return;
	}

	ResetChangeFactor();
	
	EnableMenus( FALSE, FALSE );
	if (<WhichAnalyzerView> == 0)
	{
		AnalyzerView.StoreCorrection();
	}
	else
	{
		LightTableView.StoreCorrection();
	}
}

VOID Analyzer::StoreCorrection()
{
	ResetChangeFactor();

	// Disable window while store correction dialog is active
	EnableCorrectWindow( FALSE );

	GetCurrentCorrections();

	// execute store correction dialog
	ForgetGlobal( StoreDlg );
	StoreDialog( New,StoreDlg );
	Global( StoreDlg );
	StoreDlg.DefineDialog();
	StoreDlg.PopulateCorrectionListBox();
	StoreDlg.OnCorrectionSelected();
}

VOID Analyzer::GetCurrentCorrections()
{
	if ( !Defined( CurDensity ) )
	{
		View( GetControlTitle, DensityText, CurDensity );
		Global( CurDensity );
	}

	if ( !Defined( CurRed ) )
	{
		View( GetControlTitle, RedText, CurRed );
		Global( CurRed );
	}

	if ( !Defined( CurGreen ) )
	{
		View( GetControlTitle, GreenText, CurGreen );
		Global( CurGreen );
	}

	if ( !Defined( CurBlue ) )
	{
		View( GetControlTitle, BlueText, CurBlue );
		Global( CurBlue );
	}

	if ( !Defined( CurContrast ) )
	{
		View( GetControlTitle, ContrastText, CurContrast );
		Global( CurContrast );
	}

	if ( !Defined( CurSaturation ) )
	{
		View( GetControlTitle, SaturationText, CurSaturation );
		Global( CurSaturation );
	}

	if ( !Defined( CurGamma ) )
	{
		View( GetControlTitle, GammaText, CurGamma );
		Global( CurGamma );
	}
}

VOID Analyzer::ForgetCurrentCorrections()
{
	ForgetGlobal( CurDensity );
	ForgetGlobal( CurRed );
	ForgetGlobal( CurGreen );
	ForgetGlobal( CurBlue );
	ForgetGlobal( CurContrast );
	ForgetGlobal( CurSaturation );
	ForgetGlobal( CurGamma );
}


/***********************************************************
 *************** Recall Correction functions ***************
 ***********************************************************/

VOID RecallCorrections()
{
	if ( !<ImageLoaded> )
	{
		return;
	}

	ResetChangeFactor();

	EnableMenus( FALSE, FALSE );

	AnalyzerView.RecallCorrection();
}

VOID Analyzer::RecallCorrection()
{
	// Disable window while recall correction dialog is active
	EnableCorrectWindow( FALSE );

	// Pass wheelman support to recall correction window
	RecallWheel( New, Wheelman );
	Global( Wheelman );
	EnableWheelman();

	// Declare and execute recall correction dialog
	ForgetGlobal( RecallDlg );
	RecallDialog( New,RecallDlg );
	Global( RecallDlg );
	RecallDlg.DefineDialog();
	RecallDlg.PopulateCorrectionListBox();

}

VOID ApplyLastCorrection()
{
	if ( !<ImageLoaded> )
	{
		return;
	}
	ResetChangeFactor();
	if ( <gCorrectionMade> )
	{
		Density = <gLastDensity>;
		Red = <gLastRed>;
		Green = <gLastGreen>;
		Blue = <gLastBlue>;
		Contrast = <gLastContrast>;
		Saturation = <gLastSaturation>;
		Gamma = <gLastGamma>;

		if (<WhichAnalyzerView> == 0)
		{
			AnalyzerView.ApplyCorrection( <Density>, <Red>, <Green>, <Blue>, <Contrast>, <Saturation>, <Gamma> );
		}
		else
		{
			LightTableView.ApplyCorrections( <Density>, <Red>, <Green>, <Blue>, <Contrast>, <Saturation>, <Gamma> );
		}
	}
	else
	{
		Warning( Translate( ~No correction has been saved previously.~ ) );
	}
}

VOID ApplyCorrections( CorrectionNum, Description )
{
	Found = FALSE;

	// Try by number first
	if ( <CorrectionNum> >= 0 )
	{
		CorrectionList( Filter, ~Number = <CorrectionNum>~ );
		Found = CorrectionList( GetFirst, Item );
	}

	// Then try by description
	if (!<Found>)
	{
		CorrectionList( Filter, ~Description = '<Description>'~ );
		Found = CorrectionList( GetFirst, Item );
	}

	if (<Found>)
	{
		LastUsed += 1;
		Item( Set, LastUsed, <LastUsed> );
		CorrectionList( Update );

		Density = MakeNumber( ~<$pcon.Item[Density]>~ );
		Red = MakeNumber( ~<$pcon.Item[Red]>~ );
		Green = MakeNumber( ~<$pcon.Item[Green]>~ );
		Blue = MakeNumber( ~<$pcon.Item[Blue]>~ );
		Contrast = MakeNumber( ~<$pcon.Item[Contrast]>~ );
		Saturation = MakeNumber( ~<$pcon.Item[Saturation]>~ );
		Gamma = MakeNumber( ~<$pcon.Item[Gamma]>~ );

		if (<WhichAnalyzerView> == 0)
		{
			AnalyzerView.ApplyCorrection( <Density>, <Red>, <Green>, <Blue>, <Contrast>, <Saturation>, <Gamma> );
		}
		else
		{
			LightTableView.ApplyCorrections( <Density>, <Red>, <Green>, <Blue>, <Contrast>, <Saturation>, <Gamma> );
		}
	}
	else
	{
		if ( <CorrectionNum> > 0 )
		{
			Error = Translate( ~Correction <CorrectionNum> does not exist.~ );
		}
		else
		{
			Error = Translate( ~Correction <Description> does not exist.~ );
		}
		Warning( ~<Error>~ );
	}
}

VOID Analyzer::ApplyCorrection( Density, Red, Green, Blue, Contrast, Saturation, Gamma )
{
	Found = FALSE;

	InitCorrections();
		
	NewDensity = <Density> - <gOldDensity>;
	NewRed = <Red> - <gOldRed>;
	NewGreen = <Green> - <gOldGreen>;
	NewBlue = <Blue> - <gOldBlue>;
	NewContrast = <Contrast> - <gOldContrast>;
	NewSaturation = <Saturation> - <gOldSaturation>;
	NewGamma = <Gamma> - <gOldGamma>;

	ImageEditData( SetValue, cDensity, <NewDensity> );
	ImageEditData( SetValue, cRed, <NewRed> );
	ImageEditData( SetValue, cGreen, <NewGreen> );
	ImageEditData( SetValue, cBlue, <NewBlue> );
	ImageEditData( SetValue, cContrast, <NewContrast> );
	ImageEditData( SetValue, cSaturation, <NewSaturation> );
	ImageEditData( SetValue, cGamma, <NewGamma> );

	ImageEditData( UpdateCorrections, ~<LastImagePath>~ );

	UpdateColorValues();
}

VOID Analyzer::ApplySingleDRGBCorrection( Density, Red, Green, Blue )
{
	Found = FALSE;

	InitCorrections();

	NewDensity = <Density> - <gOldDensity>;
	NewRed = <Red> - <gOldRed>;
	NewGreen = <Green> - <gOldGreen>;
	NewBlue = <Blue> - <gOldBlue>;

	ImageEditData( SetValue, cDensity, <NewDensity> );
	ImageEditData( SetValue, cRed, <NewRed> );
	ImageEditData( SetValue, cGreen, <NewGreen> );
	ImageEditData( SetValue, cBlue, <NewBlue> );
	ImageEditData( SetValue, AutoBalanceDone, TRUE );

	ImageEditData( UpdateCorrections, ~<LastImagePath>~ );

	UpdateColorValues();
}


VOID Analyzer::StartApplyAll()
{
	if ( !<ImageLoaded> )
	{
		return;
	}
	EnableMenus( FALSE, FALSE );

	// Disable window while recall correction dialog is active
	EnableCorrectWindow( FALSE );

	// Pass wheelman support to recall correction window
	ApplyAllWheel( New, Wheelman );
	Global( Wheelman );
	EnableWheelman();

	ForgetGlobal( ApplyAllDlg );
	ApplyAllDialog( New, ApplyAllDlg );
	Global( ApplyAllDlg );
	ApplyAllDlg.DefineDialog();
	ApplyAllDlg.OnChangeApplyType( 0 );
}

VOID ApplyToAll( Value )
{
	if (<WhichAnalyzerView> == 0)
	{
		AnalyzerView.ApplyAll( <Value> );
	}
	else
	{
		LightTableView.ApplyAll( <Value> );
	}
}

VOID Analyzer::CheckCorrection( OldValue, &NewValue, ValueRange )
{
	TempValue = 0;
	if ( <OldValue> + <NewValue> > <ValueRange> )
	{
		TempValue = <ValueRange> - <OldValue> - <NewValue>;
	}
	else
	{
		if ( <ValueRange> == <GammaRange> )
		{
			ValueRange = 0.0;
		}

		if ( <OldValue> + <NewValue> < -<ValueRange> )
		{
			TempValue = 0 - <ValueRange> - <OldValue> - <NewValue>;
		}
	}

	NewValue += <TempValue>;
}

VOID Analyzer::SetAutoBalMode( level, shiftState, altState, FromButton )
{
	if ( <FromButton> )
	{
		ImageEditData( SetValues,SBALevel,~<level>~ );
	}
	else
	{
		if ( <shiftState> )	// Density
		{
			ImageEditData( SetValues,SBALevel,16 );
		}
		else if ( <altState> ) // RGB
		{
			ImageEditData( SetValues,SBALevel,1 );
		}
		else		// DRGB
		{
			ImageEditData( SetValues,SBALevel,0 );
		}
	}

	ExtSbaLevel = ImageEditData( GetNumeric, SBALevel );
}


NUMERIC Analyzer::OnAutoBalance( FromButton )		// Vectors here when the Auto Bal button is pressed  HOLLY
{
	if ( !<ImageLoaded> )
	{
		return FALSE;
	}

	Path = ~<LastImagePath>~;

	query = ~Select * from Images Where Path = '<Path>'~;
	if ( !PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{
		return Warning( Translate (~Image not available~ ) );
	}

	List( SetConnection,~~ );	// DISCONNECT LIST FROM THE DATABASE

	count = List( ChildCount );

	if ( <count> == 0 || <count> > 1 )
	{
		return Warning( Translate(~You should select the one image you wish to auto balance~ ) );
	}

	if ( ~<ExtAutoBalPreference>~ == ~~ )
	{
		msg = ~An Auto Balance Preference file must be selected from the Options.~;
		return Warning( Translate( ~<msg>~ ) );
	}

	WaitCursor( Begin );
	moreImages = List( GetNext, Item );

	if ( !<FromButton> )
	{
		if ( ~<$pcon.Item[AutoBalance]>~ != ~1~ )
		{
			return FALSE;
		}
	}

	SbaInit();

	if ( <moreImages> )
	{
		result = FALSE;

		Order = ~<$pcon.Item[OrderID]>~;
		Roll  = ~<$pcon.Item[Roll]>~;
		Frame = ~<$pcon.Item[Frame]>~;
		ICCProfile = ~<$pcon.Item[ICCProfile]>~;


		thumbnailImage = ~~;
		embeddedProfile = ~~;
		embeddedProfileChecked = FALSE;

		den		= 0;
		red		= 0;
		green	= 0;
		blue	= 0;

		if ( Defined( View ) )
		{
			View( GetThumbnailImage, AnalyzedImage, ~<Path>~, thumbnailImage, embeddedProfile );
			if ( !isNull( ~<thumbnailImage>~ ) )
			{
				embeddedProfileChecked = TRUE;
			}

		}

		result = DImageSba.BalanceImage( thumbnailImage,~<ExtAutoBalPreference>~,<ExtSbaLevel>,
										~<Order>~,~<Roll>~,~<Frame>~,~<Path>~,~<ICCProfile>~,
										~<embeddedProfile>~,~<embeddedProfileChecked>~ );

		if ( <result> )
		{
			DImageSba.GetSbaSliders( den,red,green,blue );
			ApplySingleDRGBCorrection( ~<den>~,~<red>~,~<green>~,~<blue>~ );
		}

		moreImages = FALSE;
	}
	WaitCursor( End );

	return TRUE;
}


VOID Analyzer::ChangeImageSize( Direction, NoChange )
{
	Changed = FALSE;
	if ( !DefinedAndNotNull( NoChange ) )
	{
		if ( <Direction> > 0 )
		{
			if ( <TopOfImage> > <ToolbarH> + 10 )
			{
				TopOfImage -= 3;
				AnalyzeWidth += 4;
				AnalyzeHeight += 3;

				ReferenceWidth -=4;
				Changed = TRUE;
			}
		}
		else
		{
			if ( <TopOfImage> < <InitialTopOfImage> )
			{
				TopOfImage += 3;
				AnalyzeWidth -= 4;
				AnalyzeHeight -= 3;

				ReferenceWidth += 4;
				Changed = TRUE;
			}
		}
	}
	else
	{
//		if (<TopOfImage> != <InitialTopOfImage> )
//		{
			Changed = TRUE;
//		}
	}

	if ( <Changed> )
	{
		KillTimer( 1 );
		
		PositionControl( ~AnalyzedImage~, 0, <TopOfImage>, <AnalyzeWidth>, <AnalyzeHeight> );
		PositionControl( ~AnalyzedImageText~, 0, <TopOfImage> + <AnalyzeHeight> + $vGap, <AnalyzeWidth>, 25 );
		PositionControl( ~ReferenceImage~, <AnalyzeWidth> + $hGap, <InitialTopOfImage>, <ReferenceWidth>, <ReferenceHeight> );
		PositionControl( ~ReferenceImageText~, <AnalyzeWidth> + $hGap, <InitialTopOfImage> + <ReferenceHeight> + $vGap, <ReferenceWidth>, 25 );
		if ( <TopOfImage> == <InitialTopOfImage> )
		{
			ChangeDRGBPosition( 20 );
		}
		else
		{
			ChangeDRGBPosition( <AnalyzeWidth> + 20);
		}
		ChangeNoPrintPosition();
		ChangeNoPrintPosition();
		SetTimer( 1, 30, ~OnMainResizeTimer()~ );
	}
}

VOID Analyzer::ChangeNoPrintPosition()
{
	CGSLeft = <AnalyzeWidth> + 20 + <LabelWidth> + <ColorWidth> + ($vGap * 4);
	if ( <TopOfImage> > <ToolbarH> + 40 )
	{
		PositionControl( ~NoPrintIndicator~, (<AnalyzeWidth> / 2) - 65, <TopOfImage> - 30, 130, 30, FALSE);
	}
	else
	{
		PositionControl( ~NoPrintIndicator~, <CGSLeft> - 10, 60 + (<ColorHeight> * 3), 130, 30, FALSE);
	}
}

VOID OnMainResizeTimer()
{
	KillTimer( 1 );
	AnalyzerView.OnResizeTimer();
}

VOID Analyzer::OnResizeTimer()
{
	View( RefreshView );
	SetWorkStationSettings( ~Analyzer~, ~TopOfImage~, <TopOfImage>, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~AnalyzeWidth~, <AnalyzeWidth>, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~AnalyzeHeight~, <AnalyzeHeight>, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~ReferenceWidth~, <ReferenceWidth>, TRUE );
}

VOID Analyzer::ChangeSingleDRGBPos( LeftEdge, Color, Mult )
{
	PositionControl( ~<Color>Label~, <LeftEdge>, 45 + (<ColorHeight> * <Mult>), <LabelWidth>, <ColorHeight>, FALSE );
	PositionControl( ~<Color>Text~, <LeftEdge> + <LabelWidth>, 45 + (<ColorHeight> * <Mult>), <ColorWidth>, <ColorHeight>, FALSE );
}

VOID Analyzer::ChangeDRGBPosition( LeftEdge )
{
	CGSLeft = <LeftEdge> + <LabelWidth> + <ColorWidth> + ($vGap * 4);
	ChangeSingleDRGBPos( <LeftEdge>, ~Density~, 0 );
	ChangeSingleDRGBPos( <LeftEdge>, ~Red~, 1 );
	ChangeSingleDRGBPos( <LeftEdge>, ~Green~, 2 );
	ChangeSingleDRGBPos( <LeftEdge>, ~Blue~, 3 );
	ChangeSingleDRGBPos( <CGSLeft>, ~Contrast~, 0 );
	ChangeSingleDRGBPos( <CGSLeft>, ~Gamma~, 1 );
	ChangeSingleDRGBPos( <CGSLeft>, ~Saturation~, 2 );
	PositionControl( ~ColorGroupBox~, <LeftEdge> - 10, 35, <LabelWidth> + <ColorWidth> + 20, (<ColorHeight> * 4) + 15, FALSE );
	PositionControl( ~StepIndicator~, <CGSLeft> + <LabelWidth> + <ColorWidth> - 20, 45 + (<ColorHeight> * 3) + ($vGap * 2), 20, 15, FALSE );
	PositionControl( ~ColorGroupBox2~, <CGSLeft> - 10, 35, <LabelWidth> + <ColorWidth> + 20, (<ColorHeight> * 3) + 15, FALSE );
}

// True on end of ControlRect call refreshed automatically
VOID Analyzer::PositionControl( ControlName, X, Y, Width, Height )
{
	View( ControlRect, <ControlName>, SetPosition, <X>, <Y>, <Width>, <Height>, FALSE);
}

VOID Analyzer::ApplyAll( Value )
{
	if ( !<ImageLoaded> )
	{
		return;
	}

	GetCurrentCorrections();

	Query = ~Select * From Images where OrderID = '<OrderID>' Order By Roll, Frame~;	
	InitCorrections();
	
	if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{
		while ( List( GetNext, Record ) )
		{
			StatusBarText( ~Updating <$pcon.Record[OrderID]>/<$pcon.Record[Roll]>/<$pcon.Record[Frame]>~ );

			if ( ImageCorrections( GetCurrentCorrections, ~<$pcon.Record[Path]>~, Corrections ) )
			{
				if ( <Value> == 0 )
				{
					NewDensity = <CurDensity> - Corrections(GetNumeric, orgDensity);
					NewRed = <CurRed> - Corrections(GetNumeric, orgRed);
					NewGreen = <CurGreen> - Corrections(GetNumeric, orgGreen);
					NewBlue = <CurBlue> - Corrections(GetNumeric, orgBlue);
					NewContrast = <CurContrast> - Corrections(GetNumeric, orgContrast);
					NewSaturation = <CurSaturation> - Corrections(GetNumeric, orgSaturation);
					NewGamma = <CurGamma> - Corrections(GetNumeric, orgGamma);
				}
				else if ( <Value> == 1 )
				{
					NewDensity = <CurDensity>;
					CheckCorrection( Corrections( GetNumeric, orgDensity ), NewDensity, <CorrRange> );
					NewRed = <CurRed>;
					CheckCorrection( Corrections( GetNumeric, orgRed ), NewRed, <CorrRange> );
					NewGreen = <CurGreen>;
					CheckCorrection( Corrections( GetNumeric, orgGreen ), NewGreen, <CorrRange> );
					NewBlue = <CurBlue>;
					CheckCorrection( Corrections( GetNumeric, orgBlue ), NewBlue, <CorrRange> );
					NewContrast = <CurContrast>;
					CheckCorrection( Corrections( GetNumeric, orgContrast ), NewContrast, <AltCorrRange> );
					NewSaturation = <CurSaturation>;
					CheckCorrection( Corrections( GetNumeric, orgSaturation ), NewSaturation, <AltCorrRange> );
					NewGamma = <CurGamma>;
					NewGamma -= 1.0;
					CheckCorrection( Corrections( GetNumeric, orgGamma ), NewGamma, <GammaRange> );
				}
				else
				{
					Warning( Translate( ~Error applying to all~ ) );
				}

				OldDensity = Corrections( GetNumeric, orgDensity ) + <NewDensity>;
				OldRed = Corrections( GetNumeric, orgRed ) + <NewRed>;
				OldGreen = Corrections( GetNumeric, orgGreen ) + <NewGreen>;
				OldBlue = Corrections( GetNumeric, orgBlue ) + <NewBlue>;
				OldContrast = Corrections( GetNumeric, orgContrast ) + <NewContrast>;
				OldSaturation = Corrections( GetNumeric, orgSaturation ) + <NewSaturation>;
				OldGamma = Corrections( GetNumeric, orgGamma ) + <NewGamma>;

				if ( ~<LastImagePath>~ == ~<$pcon.Record[Path]>~ )
				{
					gOldDensity = <OldDensity>;
					gOldRed = <OldRed>;
					gOldGreen = <OldGreen>;
					gOldBlue = <OldBlue>;
					gOldContrast = <OldContrast>;
					gOldSaturation = <OldSaturation>;
					gOldGamma = <OldGamma>;
				}

				ImageEditData( SetValue, cDensity, <NewDensity> );
				ImageEditData( SetValue, cRed, <NewRed> );
				ImageEditData( SetValue, cGreen, <NewGreen> );
				ImageEditData( SetValue, cBlue, <NewBlue> );
				ImageEditData( SetValue, cContrast, <NewContrast> );
				ImageEditData( SetValue, cSaturation, <NewSaturation> );
				ImageEditData( SetValue, cGamma, <NewGamma> );

				ImageEditData( UpdateCorrections, ~<$pcon.Record[Path]>~ );
				ImageEditData( SaveCorrections, ~<$pcon.Record[Path]>~ );

				// Log image accept
				Line = ~<$pcon.Record[OrderID]>,<$pcon.Record[Roll]>,<$pcon.Record[Frame]>,<OldDensity>,<OldRed>~;
				Line = ~<Line>,<OldGreen>,<OldBlue>,<OldContrast>,<OldSaturation>,<OldGamma>~;
				Line = ~<Line>,<$pcon.Record[RotateFromDisk]>,<$pcon.Record[Rejected]>,<$Date.%Y%m%d%H%M%S>~;
				++TotalImageEdits;
				LogImageEdit( ~<Line>~ );
			}
		}
	}

	StatusBarText( ~Complete~);


	ResetImageEditData( FALSE );
	ForgetCurrentCorrections();
}

VOID Analyzer::StartFinishOrder()
{
	DisableWheelman();

	EnableMenus( FALSE, FALSE );

	// Pass wheelman support to recall correction window
	FinishWheel( New, Wheelman );
	Global( Wheelman );
	EnableWheelman();

	ForgetGlobal( FinishDlg );
	FinishDialog( New, FinishDlg );
	Global( FinishDlg );
	FinishDlg.DefineDialog();
	FinishDlg.OnChangeFinishType( 0 );
	FinishDlg.Activate();
}

NUMERIC Analyzer::MarkedForProofing( OrderID )
{
    Query = ~SELECT Path FROM Conversion where OrderID='<OrderID>'~;
    ADO( dBase,Connect,GetValuesFor,~<Query>~, Path );

    if (Files( FileExists,~<Path>\Proof.txt~ ))
    {
        return true;
    }
    else
    {
        return false;
    }
}

VOID Analyzer::CancelOrder()
{
	TempOrderID = ~<OrderID>~;
	MakeSQLSafe( TempOrderID );
	Query = ~Select * From Orders Where ID = '<TempOrderID>'~;
	if ( !PGenConList( List, Connect, GetRecordFor, ~<Query>~, Order ) )
	{
		Warning(~Unable to get order record for <OrderID>~);
		return;
	}

	if ( ~<OrigStatus>~ != ~~ )
	{
		if ( Order( Set, Status, ~<OrigStatus>~ ) )
		{
			List( Update );
		}
		else
		{
			List( GetErrorMessage,0, ErrorMsg );
			Warning( Translate( ~Unable to set status of order <OrderID>: <ErrorMsg>~ ) );
		}
	}
}

VOID Analyzer::FinishOrder( Value, SelectedStatus, ShutdownApp )
{
	// CG Disabling average analyzation feature
/*
	Query = ~Select * From Images where OrderID = '<OrderID>' Order By Roll, Frame~;	
	InitCorrections();
	TotalDensity = 0;
	TotalRed = 0;
	TotalGreen = 0;
	TotalBlue = 0;
	TotalContrast = 0;
	TotalSaturation = 0;
	TotalGamma = 0;
	Count = 0;

	
	
	if ( <Value> )
	{
		if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
		{
			while ( List( GetNext, Record ) )
			{
				if ( ImageCorrections(GetCurrentCorrections, ~<$pcon.Record[Path]>~, Corrections ) )
				{
					TotalDensity += Corrections( GetNumeric, orgDensity );
					TotalRed += Corrections( GetNumeric, orgRed );
					TotalGreen += Corrections( GetNumeric, orgGreen );
					TotalBlue += Corrections( GetNumeric, orgBlue );
					TotalContrast += Corrections( GetNumeric, orgContrast );
					TotalSaturation += Corrections( GetNumeric, orgSaturation );
					TotalGamma += Corrections( GetNumeric, orgGamma );
					Count += 1;
				}	
			}

			gOldDensity = round( <TotalDensity> / <Count> );
			gOldRed = round( <TotalRed> / <Count> );
			gOldGreen = round( <TotalGreen> / <Count> );
			gOldBlue = round( <TotalBlue> / <Count> );
			gOldContrast = round( <TotalContrast> / <Count> );
			gOldSaturation = round( <TotalSaturation> / <Count> );
			gOldGamma = round( <TotalSaturation> / <Count> * 100 );
			gOldGamma = <gOldGamma> / 100;
			UpdateColorValues();

			ApplyToAll( 0 );
		}
		else
		{
			Warning(~Unable to get image records for <OrderID>~);
			return;
		}
	}
*/

	fSeq = 0;

	// Get order record
    if (DefinedAndNotNULL( OrderToRelease ))
    {
      	TempOrderID = ~<OrderToRelease>~;
        ForgetGlobal( OrderToRelease );
    }
    else
    {
    	TempOrderID = ~<OrderID>~;
    }
    Log(Session, ~****** Analyzer FinishOrder called for <TempOrderID> Value <Value>~);

	MakeSQLSafe( TempOrderID );
	Query = ~Select * From Orders Where ID = '<TempOrderID>'~;
	if ( !PGenConList( List, Connect, GetRecordFor, ~<Query>~, Order ) )
	{
		Warning(~Unable to get order record for <TempOrderID>~);
		return;
	}

	NewStatus = ~<SelectedStatus>~;
	if ( <Value> )
	{
		NewStatus = ~<OrigStatus>~;
	}
	else
	{
		// Start rendering if checked
		if ( <ExtRenderOption> )
		{
			ExternalValid = FALSE;
			InternalValid = TRUE;
			if ( DefinedAndNotNull( ExtRenderPath ) )
			{
				RenderPath = ~<ExtRenderPath>~;
				len = strlen( ~<RenderPath>~ );
				substr( ~<RenderPath>~, <len> - 1, 1, LastChar );
				if ( ~<LastChar>~ != ~\~ )
				{
					RenderPath = ~<ExtRenderPath>\~;
				}
				ExternalValid = TRUE;
			}

			if ( <ExtRenderOption> == 1 )
			{
				ExternalValid = TRUE;
				InternalValid = FALSE;
				// Retrieve render folder from order
				Description = ~<$pcon.Order[Description]>~;
				len = strlen( ~<RenderFlag>~ );
				lenD = strlen( ~<Description>~ );
				substr( ~<Description>~, 0, 5, TestComp );
				substr( ~<Description>~, 0, 1, SingleComp );
				substr( ~<Description>~, 0, 20, LongComp );
				if ( substr( ~<Description>~, 0, <len>, RenderCompare ) )
				{
					if ( ~<RenderFlag>~ == ~<RenderCompare>~ )
					{
						if ( substr( ~<Description>~, <len>, <lenD>, RenderPath ) )
						{
							RenderPath = String( TrimLeft, ~<RenderPath>~ );
							RenderPath = String( TrimRight, ~<RenderPath>~ );
							if ( DefinedAndNotNull( RenderPath ) )
							{
								InternalValid = TRUE;
							}
						}
					}
				}
			}

			if ( !<InternalValid> || !<ExternalValid> )
			{
				Warning( Translate( ~Unable to render images.  Render path is blank.~ ) );
				return;
			}

			Query = ~Select * From Images where OrderID = '<TempOrderID>' Order By Roll, Frame~;	
			
			if ( PGenConList( List2, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
			{
				BatchID = UniquePrintBatchID();
				List2( GetConnection, dBase );

				while ( List2( GetNext, Record ) )
				{
					if ( !MakeNumber( ~<$pcon.Record[Rejected]>~ ) )
					{
						ImagePath = ~<$pcon.Record[Path]>~;
						RelativePath = ~<$pcon.Record[Description]>~;
						ImageName = ~<$Str.$ImagePath.Filename.WithExt>~;
						NewPath = ~<RenderPath><TempOrderID>\<RelativePath><ImageName>~;
//						Directory( Create, ~<RenderPath><RelativePath>~ );
						RenderImage( ~<ImagePath>~, ~<NewPath>~, ~<BatchID>~, dBase );
					}
				}

				Cmd = ~Update JobQueue Set PrintStatus = 1 Where BatchID = '<BatchID>' AND PrintStatus = 8~;

				if ( !dBase( Cmd,~<Cmd>~ ) )
				{
					dBase( GetErrorDescription,theErr );

					Invoke( ShowWarning, ~Job Queue Update Failed.  <theErr>.  <Cmd>~ );
					return FALSE;
				}
			}
		}
	}

	// Get order record
	Query = ~Select * From Orders Where ID = '<TempOrderID>'~;
	if ( !PGenConList( List3, Connect, GetRecordFor, ~<Query>~, Order ) )
	{
		Warning(~Unable to get order record for <TempOrderID>~);
		return;
	}

    Log(Session, ~****** Analyzer FinishOrder set Status <NewStatus>~);

    // If this is an order marked to proof then New Status will be Pending Approval.
    if (MarkedForProofing(~<TempOrderID>~))
    {
       NewStatus = ~Pending Approval~;
       BatchID = ~00001~;
       CreateProofReleaseScript(~<TempOrderID>~, ~<BatchID>~);

       Log(Session, ~****** Analyzer FinishOrder marked to proof set Status <NewStatus>~);
    }

	if ( Order( Set, Status, ~<NewStatus>~ ) )
	{
		List3( Update );
		View( ListBox, FramesListBox, ResetContent );
		OrderID = ~~;
		DeleteContents();
		LightTableView.DeleteContents();
		if ( <WhichAnalyzerView> == 1 )
		{
			InitLightTable( ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<ExtRefImage>~, ~<LastRefPath>~, TRUE );
		}

		if ( DefinedAndNotNull( AnalyzerExiting ) )
		{
			LightTableView.CloseWindow();
			DataWindow( ForceCloseWindow );

			if ( Defined( DImageSba ) )
			{
				ForgetGlobal( DImageSba );
			}

			if ( <ShutdownApp> )
			{
				abort();
			}
			else
			{
				ExitAnalyzerProgram = TRUE;
				PermanentSymbol( ExitAnalyzerProgram );
				Exit();
			}
		}
		else
		{
			OpenAnOrder();
		}
	}
	else
	{
		ErrorMsg = GetLastErrorMsg();
		Warning( Translate( ~Unable to set status of order <OrderID>: <ErrorMsg>~ ) );
	}

    if (<ReleaseScript>)
    {
        RecordAction( ~<TempOrderID>~, ~Finished <SelectedStatus>~);	
    }
}


/***************************************************
 *************** Reference functions ***************
 ***************************************************/

VOID RecallTheReference()
{
	EnableMenus( FALSE, FALSE );
	AnalyzerView.RecallReference();
}

VOID Analyzer::RecallReference()
{
	// Disable window while recall reference dialog is active
	EnableCorrectWindow( FALSE );

	// Pass wheelman support to recall reference window
	RecallRefWheel( New, Wheelman );
	Global( Wheelman );
	EnableWheelman();

	// execute recall reference dialog

	ForgetGlobal( RecallRefDlg );
	RecallRefDialog( New, RecallRefDlg );
	Global( RecallRefDlg );
	RecallRefDlg.DefineDialog();
	RecallRefDlg.PopulateTypeCombo();
	RecallRefDlg.PopulateRefListBox();
	RecallRefDlg.OnChangeRef( 0 );
	RecallRefDlg.OnRefSelected();
}

VOID MakeTheReference()
{
	if ( <WhichAnalyzerView> == 0 )
	{
		AnalyzerView.MakeReference();
	}
	else
	{
		LightTableView.MakeReference();
	}
}

VOID AddReference( RefImage, RefPath )
{
	OrderRefList( Filter, ~Frame = '<RefImage>'~ );

	if ( OrderRefList( GetFirst, Item ) )
	{
		Warning( ~The reference image name <RefImage> already exists in the database~ );
		return;
	}
			
	OrderRefList( AddNew, Position );
	Position( Set, Frame, ~<RefImage>~, Path, ~<RefPath>~ );

	ShowTheReferenceImage( ~<RefImage>~, ~<RefPath>~ );
}



VOID Analyzer::MakeReference()
{
	FileName = ~<$Str.$LastImagePath.Filename.WithoutExt>~;

	AddReference( ~<FileName>~, ~<LastImagePath>~ );
}

NUMERIC Analyzer::AddThumbnail()
{
	size = ~<$SystemSettings.Thumbnail[Size]>~;
	compressionQuality = ~<$SystemSettings.Thumbnail[Quality]>~;

	size = IsNULL( ~<size>~ ) ? ~500~ : ~<size>~;
	compressionQuality = IsNULL( ~<compressionQuality>~ ) ? ~100~ : ~<compressionQuality>~;

	if ( MessageBox( Translate(~Are you sure you want to add a thumbnail to the image? ~),YESNO ) == NO )
	{
		return TRUE;
	}

	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate(~Could not connect to the database. <theErr>~) );
	}

	WaitCursor( Begin );

	BroadcastMessageToAllViews( ReleaseImageChain,~<LastImagePath>~ );
	CloseWindowOfPath( ~<LastImagePath>~ );

	FileType = ~~; Width = Length = PreviewWidth = PreviewLength = 0;

	if ( AddThumbNailToImage( ~<LastImagePath>~,<size>,<compressionQuality>,FileType,Width,Length,PreviewWidth,PreviewLength ) > 0 )
	{ 
		Key = STR ( OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>' );

		SizeFields	= ~Width=<Width>,PreviewWidth=<PreviewWidth>,Length=<Length>,PreviewLength=<PreviewLength>~;
		InsertCmd	= ~Update Images Set Filetype='<Filetype>',<SizeFields> Where <Key>~;

		if ( !dbase( CMD,~<InsertCmd>~ ) )
		{
			dbase( GetErrorDescription,theErr );
			WaitCursor( End );
			return Warning( Translate( ~Database update failed. <InsertCmd>. <theErr>~ ) );
		}

		View( RedrawThumbNailByPath,~<LastImagePath>~,TRUE );
	}
	else
	{
		WaitCursor( End );
		return Warning( Translate( ~Stopping.  Failed to add a thumbnail to <OrderID>/<Roll>/<Frame>\n\n<LastImagePath>~ ) );
	}

	WaitCursor( End );

	return TRUE;
}

NUMERIC Analyzer::SetInputProfileForImage()
{
	ImageCorrections( GetInputProfileName,~<LastImagePath>~,ProfileName );

	Query = ~Select Device,Name,Path From Profiles Where (Type = 'Input' OR Type = 'WorkingSpace') Order By Device,Name~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Profiles table: <Query>. <theErr>~ );
	}

	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	Count = 0;

	while ( List( GetNext,Item ) )
	{
		GenCon( Profile<++Count>,New,DDMenuItemDef,SetValues,
				Text,		~&<Count>)  <$pcon.Item[Name]>~,
				IDText,		~ID~,
				IsChecked,	(SimilarStr(~<$pcon.Item[Name]>~,~<ProfileName>~)) ? T : F );

		theAction = ACTION EXEC ( <This>.WantProfile(~<$pcon.Item[Name]>~) );

		Profile<Count>( SetValuesFrom,ActionsText,theAction );

		ListMenu( InsertBack,Profile<Count> );
	}

	GenCon( Profile<++Count>,New,DDMenuItemDef,SetValues,
			Text,		~&<Count>)  Use Embedded Input Profile if Available or Default Input Profile if not Available~,
			IDText,		~ID~,
			IsChecked,	(~~ == ~<ProfileName>~) ? T : F );

	theAction = ACTION EXEC ( <This>.WantProfile(~~); );

	Profile<Count>( SetValuesFrom,ActionsText,theAction );
		
	ListMenu( InsertBack,Profile<Count> );

	View( DisplayMenu,ListMenu );

	return TRUE;
}


NUMERIC Analyzer::WantProfile( ProfileName)
{
	SetInputProfile( ~<ProfileName>~,~~,~<OrderID>~,~<Roll>~,~<Frame>~,~<LastImagePath>~ );

	return TRUE;
}


NUMERIC Analyzer::OpenAnImageExternal()
{
	if ( !IsNull(~<LastImagePath>~) )
	{
		BroadcastMessageToAllViews( ReleaseImageChain,~<LastImagePath>~ );

		if ( !MakeImageWritable( ~<LastImagePath>~ ) )
		{
			WaitCursor( End );
			return FALSE;
		}

		if ( !FindExecutable( ~<LastImagePath>~,Program ) )
		{
			GetLastError( ErrorString,theErr );
			WaitCursor( End );
			return Warning( ~You must go to View/Options/FileTypes of the Windows Explorer to define the program that can open\n\n  <LastImagePath>.\n\n<theErr>~ );
		}

		if ( !ShellExecute( Open,~<LastImagePath>~ ) )
		{
			GetLastError( ErrorString,theErr );
			Log( Session,~Could not open <LastImagePath>. <theErr>~ );
		}
	}

	WaitCursor( End );

	return TRUE;
}


VOID ShowTheReferenceImage(RefImage, RefPath, WhichView)
{
	TheView = <WhichAnalyzerView>;
	if ( DefinedAndNotNull( WhichView ) )
	{
		TheView = <WhichView>;
	}

	ExtRefImage = ~<RefImage>~;
	if (<TheView> == 0 )
	{
		AnalyzerView.ShowReferenceImage( ~<RefImage>~, ~<RefPath>~ );
	}
	else
	{
		LightTableView.ShowReferenceImage( ~<RefImage>~, ~<RefPath>~ );
	}
}

VOID Analyzer::ShowReferenceImage(RefImage, RefPath)
{
	View( SetControlTitle, ReferenceImageText, ~<RefImage>~ );

	ShowImage(~<RefPath>~, 2);
	LastRefPath = ~<RefPath>~;
}


/*********************************************************
 *************** Program options functions ***************
 *********************************************************/

VOID EditOptions()
{
	EnableMenus( FALSE, FALSE );
	AnalyzerView.ChangeOptions();
}

VOID Analyzer::ChangeOptions()
{
	// Disable window while options dialog is active
	EnableCorrectWindow( FALSE );

	// Disable wheelman support
//	RecallRefWheel( New, Wheelman );
//	Global( Wheelman );
//	EnableWheelman();

	ForgetGlobal( OptionsDlg );

	// Declare and/or execute options dialog
	ForgetGlobal( OptionsDlg );
	OptionsDialog( New, OptionsDlg );
	Global( OptionsDlg );
	OptionsDlg.DefineDialog();
	OptionsDlg.PopulateProfiles();
	OptionsDlg.PopulateOptions();
}


/*************************************************
 *************** Wheelman functions **************
 *************************************************/

VOID Analyzer::OnLeftParenButton()
{
	OnButton( ~(~ );
}

VOID Analyzer::OnRightParenButton()
{
	OnButton( ~)~ );
}

VOID Analyzer::OnButton( Value )	// This function controls all mnemonic buttons
{
	Amount = KeyState( Shift );
	shiftState = KeyState( Shift );
	altState   = KeyState( Alt );

	if ( !ValidateOrderID())
	{
		OnSimilarStr( ~<Value>~, 
			~<pMode>~,		<Amount> ? ~ChangeView( 1 )~ : ~<This>.ToggleWheelman()~ ,
			~<pViewMode>~,	~ChangeView( 1 )~ ,
			~<pRecallRef>~,	~RecallTheReference()~,
			~<pOpen>~,		~OpenAnOrder()~ );
		return;
	}

	OnSimilarStr( ~<Value>~, 
		~<pNum0>~,		~SaveChangeFactor( 0 )~,
		~<pNum1>~,		~SaveChangeFactor( 1 )~,
		~<pNum2>~,		~SaveChangeFactor( 2 )~,
		~<pNum3>~,		~SaveChangeFactor( 3 )~,
		~<pNum4>~,		~SaveChangeFactor( 4 )~,
		~<pNum5>~,		~SaveChangeFactor( 5 )~,
		~<pNum6>~,		~SaveChangeFactor( 6 )~,
		~<pNum7>~,		~SaveChangeFactor( 7 )~,
		~<pNum8>~,		~SaveChangeFactor( 8 )~,
		~<pNum9>~,		~SaveChangeFactor( 9 )~,
		~<pNum0_2>~,	~SaveChangeFactor( 0 )~,
		~<pNum1_2>~,	~SaveChangeFactor( 1 )~,
		~<pNum2_2>~,	~SaveChangeFactor( 2 )~,
		~<pNum3_2>~,	~SaveChangeFactor( 3 )~,
		~<pNum4_2>~,	~SaveChangeFactor( 4 )~,
		~<pNum5_2>~,	~SaveChangeFactor( 5 )~,
		~<pNum6_2>~,	~SaveChangeFactor( 6 )~,
		~<pNum7_2>~,	~SaveChangeFactor( 7 )~,
		~<pNum8_2>~,	~SaveChangeFactor( 8 )~,
		~<pNum9_2>~,	~SaveChangeFactor( 9 )~,
		~<pDensity>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( 1 ) )~,
		~<pDensity2>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( -1 ) )~,
		~<pThumbUp>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( 1 ) )~,
		~<pThumbDown>~,	~<This>.OnDensityButton( <This>.GetChangeAmount( -1 ) )~,
		~<pRed>~,		~<This>.OnRedButton( <This>.GetChangeAmount( 1 ) )~,
		~<pRed2>~,		~<This>.OnRedButton( <This>.GetChangeAmount( -1 ) )~,
		~<pGreen>~,		~<This>.OnGreenButton( <This>.GetChangeAmount( 1 ) )~,
		~<pGreen2>~,	~<This>.OnGreenButton( <This>.GetChangeAmount( -1 ) )~,
		~<pBlue>~,		~<This>.OnBlueButton( <This>.GetChangeAmount( 1 ) )~,
		~<pBlue2>~,		~<This>.OnBlueButton( <This>.GetChangeAmount( -1 ) )~,
		~<pPrint>~,		~<This>.AcceptImageEdits( 0 )~,
		~<pNoPrint>~,	~<This>.AcceptImageEdits( 1 )~,
		~<pNext>~,		~<This>.OnNextButton()~,
		~<pPrev>~,		~<This>.OnPrevButton()~,
		~<pMode>~,		<Amount> ? ~ChangeView( 1 )~ : ~<This>.ToggleWheelman()~ ,
		~<pViewMode>~,	~ChangeView( 1 )~ ,
		~<pMakeRef>~,	~MakeTheReference()~,
		~<pRecallRef>~,	~RecallTheReference()~,
		~<pRotate90>~,	~<This>.RotateImage( 90 )~,
		~<pRotate180>~,	~<This>.RotateImage( 180 )~,
		~<pRotate270>~,	~<This>.RotateImage( 270 )~,
		~<pStore>~,		~StoreCorrections()~,
		~<pRecall>~,	~RecallCorrections()~,
		~<pRecallLast>~,~ApplyLastCorrection()~,
		~<pApplyAll>~,	~<This>.StartApplyAll()~,
		~<pOpen>~,		~OpenAnOrder()~,
		~<pReset>~,		~<This>.ResetCorrections()~,
		~<pAutoBal>~,	~<This>.SetAutoBalMode(0,<shiftState>, <altState>, FALSE); <THIS>.OnAutoBalance(TRUE)~ );
}

VOID OnTimer()
{
	KillTimer( 0 );
	AnalyzerView.UpdateTheColor();
}

NUMERIC Analyzer::GetSingleColor( CurValue, &TempValue, OldValue, ValueRange )
{
	NewValue = <CurValue> + <TempValue>;
	SumValue = <NewValue> + <OldValue>;
	if ( <SumValue> > <ValueRange> )
	{
		NewValue = <ValueRange> - <OldValue>;
	}
	else
	{
		if ( <ValueRange> == <GammaRange> )
		{
			ValueRange = 0.0;
		}

		if ( <SumValue> < -<ValueRange> )
		{
			NewValue = -<ValueRange> - <OldValue>;
		}
	}
	TempValue = 0;

	return <NewValue>;
}

VOID Analyzer::UpdateTheColor()
{
	NewDensity = GetSingleColor( ImageEditData( GetNumeric, cDensity ), tDensity, <gOldDensity>, <CorrRange> );
	ImageEditData( SetValue, cDensity, <NewDensity> );

	NewRed = GetSingleColor( ImageEditData( GetNumeric, cRed ), tRed, <gOldRed>, <CorrRange> );
	ImageEditData( SetValue, cRed, <NewRed> );

	NewGreen = GetSingleColor( ImageEditData( GetNumeric, cGreen ), tGreen, <gOldGreen>, <CorrRange> );
	ImageEditData( SetValue, cGreen, <NewGreen> );

	NewBlue = GetSingleColor( ImageEditData( GetNumeric, cBlue ), tBlue, <gOldBlue>, <CorrRange> );
	ImageEditData( SetValue, cBlue, <NewBlue> );

	NewContrast = GetSingleColor( ImageEditData( GetNumeric, cContrast ), tContrast, <gOldContrast>, <AltCorrRange> );
	ImageEditData( SetValue, cContrast, <NewContrast> );

	NewSaturation = GetSingleColor( ImageEditData( GetNumeric, cSaturation ), tSaturation, <gOldSaturation>, <AltCorrRange> );
	ImageEditData( SetValue, cSaturation, <NewSaturation> );

	NewGamma = GetSingleColor( ImageEditData( GetNumeric, cGamma ), tGamma, <gOldGamma>, <GammaRange> );
	ImageEditData( SetValue, cGamma, <NewGamma> );

	InitCorrections();
	ImageEditData( UpdateCorrections, ~<LastImagePath>~ );
	
	UpdateColorValues();
}

VOID Analyzer::ResetCorrections()
{
	if ( !<ImageLoaded> )
	{
		return;
	}

	ResetChangeFactor();

	if ( ImageCorrections(GetCurrentCorrections, ~<LastImagePath>~, Corrections ) )
	{
		if ( !Numeric(~<$SystemSettings.Analyzer[IgnoreResetPrompt].boolean>~) )
		{
			if ( MessageBox( ~Are you sure you want to reset all color corrections (crop and rotation will not be affected)?  These corrections will be saved in the database.~,YESNO ) != YES )
			{ 
				return; 
			}
		}

		ImageEditData( ResetCorrections, ~<LastImagePath>~, FALSE );
		ImageEditData( RefreshCorrections, ~<LastImagePath>~ );

		ImageEditData( SetValue, cDensity, 0 );
		ImageEditData( SetValue, cRed, 0 );
		ImageEditData( SetValue, cGreen, 0 );
		ImageEditData( SetValue, cBlue, 0 );
		ImageEditData( SetValue, cContrast, 0 );
		ImageEditData( SetValue, cSaturation, 0 );
		ImageEditData( SetValue, cGamma, 0.0 );

		ImageEditData( SetValue, AutoBalanceDone, 0 );

		gOldDensity = 0;
		gOldRed = 0;
		gOldGreen = 0;
		gOldBlue = 0;
		gOldContrast = 0;
		gOldSaturation = 0;
		gOldGamma = 1.0;
		gOldRotation = 0;

		UpdateColorValues();
	}
}

VOID Analyzer::UpdateColorValues()
{
	nDensity = ImageEditData( GetNumeric, cDensity ) + <gOldDensity>;
	nRed = ImageEditData( GetNumeric, cRed ) + <gOldRed>;
	nGreen = ImageEditData( GetNumeric, cGreen ) + <gOldGreen>;
	nBlue = ImageEditData( GetNumeric, cBlue ) + <gOldBlue>;
	nContrast = ImageEditData( GetNumeric, cContrast ) + <gOldContrast>;
	nSaturation = ImageEditData( GetNumeric, cSaturation ) + <gOldSaturation>;
	dGamma = ImageEditData( GetNumeric, cGamma ) + <gOldGamma>;

	if ( !<PreDP2_42> )
	{
		nRed = Truncate( <nRed> );
		nGreen = Truncate( <nGreen> );
		nBlue = Truncate( <nBlue> );
	}
	View( SetControlTitle, DensityText, ~<nDensity>~ );
	View( SetControlTitle, RedText, ~<nRed>~ );
	View( SetControlTitle, GreenText, ~<nGreen>~ );
	View( SetControlTitle, BlueText, ~<nBlue>~ );
	View( SetControlTitle, ContrastText, ~<nContrast>~ );
	View( SetControlTitle, SaturationText, ~<nSaturation>~ );
	View( SetControlTitle, GammaText, Format(~<dGamma>~,~%1.2lf~) );

	ShowOpticalDRGB(TRUE);
}

VOID Analyzer::OnDensityButton(amount)
{
	KillTimer( 0 );

	if ( !ValidateOrderID() )
	{
		return;
	}

	if ( !<ImageLoaded> )
	{
		return;
	}
	
	if ( KeyState( Shift ) )
	{
		ChangeImageSize( <Amount> );
		return;
	}

	if ( DefinedAndNotNull( UserChange ) )
	{
		if ( <Amount> < 0 )
		{
			Amount = 0 - MakeNumber( ~<UserChange>~ );
		}
		else
		{
			Amount = MakeNumber( ~<UserChange>~ );
		}

		ResetChangeFactor();
	}

	if ( <WheelManMode> > 0 )
	{
		tContrast += <amount>;
	}
	else
	{
		tDensity += <amount>;
	}

	SetTimer( 0, <TimerMils>, ~OnTimer()~ );
}

VOID Analyzer::OnRedButton(amount)
{
	KillTimer(0);

	if ( !ValidateOrderID() )
	{
		return;
	}

	if ( !<ImageLoaded> )
	{
		return;
	}

	if ( DefinedAndNotNull( UserChange ) )
	{
		if ( <Amount> < 0 )
		{
			Amount = 0 - MakeNumber( ~<UserChange>~ );
		}
		else
		{
			Amount = MakeNumber( ~<UserChange>~ );
		}
		ResetChangeFactor();
	}

	if ( <WheelManMode> > 0 )
	{
		amount = <amount> / 20;
		tGamma += <amount>;
	}
	else
	{
		tRed += <amount>;
		if ( <ExtPreserveCheck> )
		{
			tGreen -= (<amount> / 2);
			tBlue -= (<amount> / 2);
		}
	}

	SetTimer( 0, <TimerMils>, ~OnTimer()~ );
}

VOID Analyzer::OnGreenButton(amount)
{
	KillTimer( 0 );

	if ( !ValidateOrderID() )
	{
		return;
	}

	if ( !<ImageLoaded> )
	{
		return;
	}

	if ( DefinedAndNotNull( UserChange ) )
	{
		if ( <Amount> < 0 )
		{
			Amount = 0 - MakeNumber( ~<UserChange>~ );
		}
		else
		{
			Amount = MakeNumber( ~<UserChange>~ );
		}
		ResetChangeFactor();
	}

	if (<WheelManMode> > 0)
	{
		tSaturation += <amount>;
	}
	else
	{
		tGreen += <amount>;
		if ( <ExtPreserveCheck> )
		{
			tRed -= (<amount> / 2);
			tBlue -= (<amount> / 2);
		}
	}

	SetTimer( 0, <TimerMils>, ~OnTimer()~ );
}

VOID Analyzer::OnBlueButton(amount)
{
	if (<WheelManMode> == 0)
	{
		KillTimer( 0 );

		if ( !ValidateOrderID() )
		{
			return;
		}

		if ( !<ImageLoaded> )
		{
			return;
		}

		if ( DefinedAndNotNull( UserChange ) )
		{
			if ( <Amount> < 0 )
			{
				Amount = 0 - MakeNumber( ~<UserChange>~ );
			}
			else
			{
				Amount = MakeNumber( ~<UserChange>~ );
			}
			ResetChangeFactor();
		}

		if ( <ExtPreserveCheck> )
		{
			tRed -= (<amount> / 2);
			tGreen -= (<amount> / 2);
		}
		tBlue += <amount>;
		SetTimer( 0, <TimerMils>, ~OnTimer()~ );
	}
}

VOID Analyzer::RotateTheImage(Rotation)
{
	AnalyzerView.RotateImage(Rotation);
}

VOID Analyzer::RotateImage(Rotation)
{
	if ( !<ImageLoaded> )
	{
		return;
	}
	if ( ImageCorrections(GetCurrentCorrections, ~<LastImagePath>~, Corrections ) )
	{
		NewValue = ImageEditData(GetNumeric, cRotateFromDisk) + <Rotation>;
		while (<NewValue> + Corrections(GetNumeric, orgRotateFromDisk) > 360)
		{
			NewValue -= 360;
		}

		ImageEditData( SetValue, cRotateFromDisk, <NewValue> );
		ImageEditData( UpdateCorrections, ~<LastImagePath>~ );
	}
	ResetChangeFactor();
}

VOID Analyzer::AcceptImageEdits( NoPrint )
{
	if ( !<ImageLoaded> )
	{
		OnNextButton();
		return;
	}
	ResetChangeFactor();

	// Save corrections
	ImageEditData( SaveCorrections, ~<LastImagePath>~ );

	// Reset reject flag
	Query = ~Select * From Images Where OrderID = '<OrderID>' And Roll = '<Roll>' and Frame = '<Frame>'~;

	if ( !PGenConList( List, Connect, GetRecordFor, ~<Query>~, Image ) )
	{
		return;
	}

	IsRejected = Numeric(~<$pcon.Image[Rejected]>~) != 0;
	okToUpdate = TRUE;
	if ( !<ExtAllowResetOfNoPrint> && <IsRejected> && !<NoPrint> )
	{
		okToUpdate = FALSE;
	}

	if ( <okToUpdate> )
	{
		if ( Image(Set, Rejected, <NoPrint> ) )
		{
			List( Update );
			LightTableView.UpdateRejectedFlag( ~<OrderID>~,~<Roll>~,~<Frame>~,<NoPrint> );
		}
		else
		{
			Warning(~Unable to update the image~);
			return;
		}
	}

	ModifiedFlag = TRUE;
	gCorrectionMade = TRUE;

	// Save last correction
	gLastDensity = MakeNumber( ~<$pcon.Image[Brt]>~ );
	gLastRed = MakeNumber( ~<$pcon.Image[Red]>~ );
	gLastGreen = MakeNumber( ~<$pcon.Image[Grn]>~ );
	gLastBlue = MakeNumber( ~<$pcon.Image[Blu]>~ );
	gLastContrast = MakeNumber( ~<$pcon.Image[Con]>~ );
	gLastSaturation = MakeNumber( ~<$pcon.Image[Saturation]>~ );
	gLastGamma = MakeNumber( ~<$pcon.Image[Gamma]>~ );

	// Log image accept
	Line = ~<$pcon.Image[OrderID]>,<$pcon.Image[Roll]>,<$pcon.Image[Frame]>,<$pcon.Image[Brt]>,<$pcon.Image[Red]>~;
	Line = ~<Line>,<$pcon.Image[Grn]>,<$pcon.Image[Blu]>,<$pcon.Image[Con]>,<$pcon.Image[Saturation]>,<$pcon.Image[Gamma]>~;
	Line = ~<Line>,<$pcon.Image[RotateFromDisk]>,<$pcon.Image[Rejected]>,<$Date.%Y%m%d%H%M%S>~;
	++TotalImageEdits;
	LogImageEdit( ~<Line>~ );

	// Select next frame or end order if no more frames
	if ( View( ListBox, FramesListBox, SelectNext ) )
	{
		InitCorrections();
		ImageAccepted = TRUE;
		OnFrameSelected(TRUE);
	}
	else
	{
		// End order
		EndOrder();
	}

	if ( !<ExtHoldCorrectionMode> )
	{
		ResetWheelMode();
	}
}

VOID Analyzer::ResetWheelMode()
{
	// Set WheelMan mode back to RGB
	if ( <WheelManMode> == 1 )
	{
		ToggleWheelMan();
	}
}

VOID EndOrder()
{
	if ( <WhichAnalyzerView> == 0)
	{
		AnalyzerView.ResetWheelMode();
	}
	else if ( <WhichAnalyzerView> == 1 )
	{
		LightTableView.ResetWheelMode();
	}
	EnableCorrectWindow( FALSE );
	
	AnalyzerView.ResetImageEditData( TRUE );
	AnalyzerView.StartFinishOrder();
}

VOID Analyzer::InitCorrections()
{
	tDensity = 0;
	tRed = 0;
	tGreen = 0;
	tBlue = 0;
	tContrast = 0;
	tSaturation = 0;
}

VOID Analyzer::ResetImageEditData( ResetRotate, CheckReset )
{
	if ( !DefinedAndNotNull( CheckReset ) || !<ExtKeepCorrection> || !<ImageAccepted> )
	{
		ImageEditData( SetValues, cDensity, 0, cRed, 0, cGreen, 0, cBlue, 0, cContrast, 0, cSaturation, 0, cGamma, 0.0 );
	}
	ImageAccepted = FALSE;

	if ( <ResetRotate> )
	{
		ImageEditData( SetValues, cRotateFromDisk, 0 );
	}
	UpdateColorValues();
}

VOID Analyzer::OnNextButton()
{
	if ( View( ListBox,FramesListBox,SelectNext ) )
	{
		InitCorrections();
		OnFrameSelected(TRUE);
	}
}

VOID Analyzer::OnPrevButton()
{
	if ( View( ListBox,FramesListBox,SelectPrev ) )
	{
		InitCorrections();
		OnFrameSelected(TRUE);
	}
}

VOID NotifyLightTableToggleWheelMan()
{
	LightTableView.ToggleFromOtherView();
}

VOID Analyzer::ToggleWheelMan()
{
	WheelManMode = !<WheelManMode>;
	Wheelman.ToggleWheelmanMode();
	View( ShowControls,!<WheelManMode>,ColorGroupBox);
	View( ShowControls,<WheelManMode>,ColorGroupBox2);

	NotifyLightTableToggleWheelMan();
}


VOID Analyzer::ToggleFromOtherView()
{
	WheelManMode = !<WheelManMode>;

	if ( Defined( View ) )
	{
		View( ShowControls,!<WheelManMode>,ColorGroupBox);
		View( ShowControls,<WheelManMode>,ColorGroupBox2);
	}
}


/********************************************************
 *************** Image Selection functions **************
 ********************************************************/

NUMERIC Analyzer::GetSelectedFrame()
{
	ReturnOnFailure( ValidateOrderID() );

	View( GetControlValue, FramesListBox, RollFrame );

	GetTokens( ~<RollFrame>~, ~<Tab>~, tmpRoll, tmpFrame );
	Roll = ~<tmpRoll>~;
	Frame = ~<tmpFrame>~;

	return TRUE;
}
NUMERIC	Analyzer::ImageIndex( OrderID , Roll, Frame )
{
	Query = ~Select Roll, Frame From Images Where OrderID = '<OrderID>'  Order By Roll, Frame~;

//      Log(Session, ~ImageIndex Roll = <Roll>, Frame = <Frame> OrderID = <OrderID>~);
	if ( !PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{
		return FALSE;
	}

    Index = 1;
    while ( List( GetNext, Record ) )
    {
        if ((~<$pcon.Record[Roll]>~ == ~<Roll>~) &&  (~<$pcon.Record[Frame]>~ == ~<Frame>~))
        {
//          Log(Session, ~ImageIndex Index Found at <Index>~);
            return $Index;
        }
        ++Index;
    }
//  Log(Session, ~ImageIndex Index NOT Found~);
    return 0;
}

STR Analyzer::GetIndexStr()
{
	ReturnOnFailure( ValidateOrderID() );

	View( GetControlValue, FramesListBox, RollFrame );

    Count = NewImages(~<OrderID>~);

    Index = ImageIndex(~<OrderID>~, ~<Roll>~, ~<Frame>~);

	return ~<Index> of <Count>~;
}

NUMERIC Analyzer::OnFrameSelected( resetData )
{
	if ( <resetData> )
	{
		ResetImageEditData( TRUE, TRUE );
		ImageEditData( UpdateCorrections, ~<LastImagePath>~ );
	}

	ReturnOnFailure( GetSelectedFrame() );

	Query = ~Select Path,Rejected From Images Where OrderID = '<OrderID>' And Roll = '<Roll>' and Frame = '<Frame>'~;

	if ( !PGenConList( List, Connect, GetRecordFor, ~<Query>~, Image ) )
	{
		return FALSE;
	}

	if ( ShowImage(~<$pcon.Image[Path]>~, 1) )
	{
		if ( <ExtAutoBalFirst> )
		{
			gOldDensity = 0;
			gOldRed		= 0;
			gOldGreen	= 0;
			gOldBlue	= 0;

			OnAutoBalance(FALSE);
		}
		else if ( <ExtKeepCorrection> )
		{
			ImageEditData( UpdateCorrections, ~<$pcon.Image[Path]>~ );
		}

		if ( ImageCorrections( GetCurrentCorrections, ~<LastImagePath>~, Corrections ) )
		{
			gOldDensity = Corrections( GetNumeric, orgDensity );
			gOldRed = Corrections( GetNumeric, orgRed );
			gOldGreen = Corrections( GetNumeric, orgGreen );
			gOldBlue = Corrections( GetNumeric, orgBlue );
			gOldContrast = Corrections( GetNumeric, orgContrast );
			gOldSaturation = Corrections( GetNumeric, orgSaturation );
			gOldGamma = Corrections( GetNumeric, orgGamma );
		}

        IndexStr = GetIndexStr();
		View( SetControlTitle, AnalyzedImageText, ~<OrderID>\<Roll>\<Frame> (<IndexStr>)~ );
        UpdateColorValues();

		View( ShowControls, MakeNumber(~<$pcon.Image[Rejected]>~), NoPrintIndicator );
	}
	else
	{
		if ( <ExtAutoBalFirst> )
		{
			gOldDensity = 0;
			gOldRed		= 0;
			gOldGreen	= 0;
			gOldBlue	= 0;

			OnAutoBalance(FALSE);
		}
		else if ( <ExtKeepCorrection> )
		{
			ImageEditData( UpdateCorrections, ~<$pcon.Image[Path]>~ );
		}

		gOldDensity = 0;
		gOldRed = 0;
		gOldGreen = 0;
		gOldBlue = 0;
		gOldContrast = 0;
		gOldSaturation = 0;
		UpdateColorValues();
                IndexStr = GetIndexStr();
		View( SetControlTitle, AnalyzedImageText, ~<OrderID>\<Roll>\<Frame> (<IndexStr>)~ );
	}

	return TRUE;	
}

VOID SelectTheFrame( Roll, Frame )
{
	AnalyzerView.SelectFrame( ~<Roll>~, ~<Frame>~ );
}

VOID Analyzer::SelectFrame( Roll, Frame )
{
	View( ListBox, FramesListBox, SelectString, 0, ~<Roll><Tab><Frame>~ );
	OnFrameSelected(FALSE);
}

NUMERIC Analyzer::PopulateFramesListBox()
{
	if ( IsNull( ~<OrderID>~ ) )
	{
		return Warning( Translate( Translations,NoOrder ) );
	}

	StringList( FramesList,New );

	adjustCount = ADO( dbase,Connect,RecordCountFor,~Select Frame from Images Where OrderID = '<OrderID>' AND Inspect <> 0~ );
	totalCount = ADO( dbase,Connect,RecordCountFor,~Select Frame from Images Where OrderID = '<OrderID>'~ );

	ExtIgnoreAdjustImagesFlag = FALSE;
	if ( <ExtShowOnlyImagesToAdjust> && <adjustCount> > 0 )
	{
		Query = ~Select * From Images where OrderID = '<OrderID>' AND Inspect <> 0 Order By Roll, Frame~;
	}
	else
	{
		if ( <ExtShowOnlyImagesToAdjust> && <adjustCount> == 0 && <totalCount> != 0 )
		{
			PromptForAllImages = TRUE;
			GetUserSettings(~Analyzer~, ~PromptForAllImages~, PromptForAllImages, Enabled);
			if ( <PromptForAllImages> )
			{
				GenCon( MbInfo,New,DDCustomMessageBox );
				MbInfo( SetValues,Title,~Import Images~,
							Message,~There are no images that are marked as needing adjusting in order:\n\n<OrderID>\n\nDo you want to open all images for the order instead?~,
							Button1,~OK~,
							Button2,~Cancel~,
							CheckBox,~Don't show this message again (open all images when none are marked needing adjusting)~,
							SetWindowPos,1,X,-1,Y,-1,Width,480,Height,215 );
				CustomMessageBox(MbInfo);
				result = MbInfo(GetNumeric, ButtonPressed);
				dontShowMessageAgain = MbInfo(GetNumeric, CheckBoxChecked);
				if ( <dontShowMessageAgain> && <result> == 1 )
				{
					SetUserSettings( ~Analyzer~,~PromptForAllImages~,~0~,TRUE );
				}

				if ( <result> == 0 || <result> == 2 )
				{
					return FALSE;
				}
			}

			ExtIgnoreAdjustImagesFlag = TRUE;
		}
		else if ( <totalCount> == 0 )
		{
			return Warning( ~There are no images in order <OrderID>.~ );
		}

		Query = ~Select * From Images where OrderID = '<OrderID>' Order By Roll, Frame~;
	}

	if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{
		while ( List( GetNext,Record ) )
		{
			FramesList( AddString, ~<$pcon.Record[Roll]><Tab><$pcon.Record[Frame]>~ );
			++count;
		}
	}
	
	View( SetControlFromStringList, FramesListBox, FramesList );
	View( ListBox, FramesListBox, Select, 0 );

	OnFrameSelected(TRUE);

	return TRUE;
}

NUMERIC AddConversionRow( OrderID )
{
    connected = ADO( database,Connect );

    if ( !<connected> ) 
    {
        Log( Session, ~AddConversionRow: ********* Could not connect to database !!!!!~ );
        return FALSE;
    }

    cmd = ~INSERT INTO Conversion (OrderID, ConversionStatus, Priority, ImportWorkStation, ImportUser, IndexCards, ROESProxies ) VALUES ('<OrderID>', '10', '50', '<$App.ComputerName>','<$App.UserName>','1','0')~;

    database( BeginTransaction );
    if ( !database(CMD, ~<cmd>~ ) )
    {
        Log( Session, ~AddConversionRow::********* Could not Add Conversion Table Entry !!!!!~ );
        database( RollBackTransaction );
        return FALSE;
    }
    database( CommitTransaction );
    return TRUE;
}

NUMERIC Analyzer::ValidateOrderID()
{
	if ( IsNull( ~<OrderID>~ ) )
	{
		EnableToolbar( FALSE );
		EnableMenus( FALSE, TRUE );

		return FALSE;
	}

    // Check that this order Exists
    if (!OrderExists(~<OrderID>~))
    {
        OpenDialog::StopTimerRefresh();
        Warning( Translate( ~Order ID '<OrderID>' does not exist in the DP2 orders table~ ) );
		EnableToolbar( FALSE );
		EnableMenus( FALSE, TRUE );
        OrderID = ~~;
		return FALSE;
    }

    // Check that this order has an entry in the conversion Table
    if (!OrderInConversionTable(~<OrderID>~))
    {
        OpenDialog::StopTimerRefresh();
        Msg = Translate( ~Order ID '<OrderID>' does not exist in the conversion table and may not be sRGB! Do you want to bypass the normal sequence and
add this order to the conversion table and force it state to converted?.~ ) ;

        if ( MessageBox( ~<Msg>~, YESNO ) != YES )
        {
    		EnableToolbar( FALSE );
	    	EnableMenus( FALSE, TRUE );
            OrderID = ~~;

            return FALSE;
        }
        Msg = Translate( ~This is a FINAL warning, Are you really 100% Sure about bypassing the usual workflow?~ );

        if ( MessageBox( ~<Msg>~, YESNO ) != YES )
        {
    		EnableToolbar( FALSE );
	    	EnableMenus( FALSE, TRUE );
            OrderID = ~~;

            return FALSE;
        }
        AddConversionRow( ~<OrderID>~ );
    }

    // Check that this order has been converted
    if (!OrderConverted(~<OrderID>~))
    {
        OpenDialog::StopTimerRefresh();
        Warning( Translate( ~Order ID '<OrderID>' has not been converted to sRGB! This means that the images may not even exist with the correct extension.
Therefore you cannot analyse this order yet. Give it 10 minutes until it appears on the list. ~ ) );
		EnableToolbar( FALSE );
		EnableMenus( FALSE, TRUE );
        OrderID = ~~;
		return FALSE;
    }

    if (ProofOrder(~<OrderID>~))
    {
        OpenDialog::StopTimerRefresh();
        Warning( Translate( ~The customer has selected they require NO colour corrections. Please only check this order for consistency.
If the colour quality is poor, please advise customer services as a matter or urgency~ ) );
    }
    OpenDialog::StopTimerRefresh();
	return TRUE;
}

NUMERIC Analyzer::ShowImage( ImagePath, Position )
{
//	ReturnOnSuccess( IsNull( ~<ImagePath>~ ) );
	Status = FALSE;
	if ( IsNull( ~<ImagePath>~ ) || !Files( FileExists, ~<ImagePath>~ ) )
	{
		ImagePath = ~~;
		if ( <Position> == 1 )
		{
			if ( DefinedAndNotNull( OrderID ) )
			{
				View( ShowControls, TRUE, InvalidText );
				View( ShowControls, FALSE, AnalyzedImage );
			}
			else
			{
				View( ShowControls, FALSE, InvalidText );
				View( ShowControls, TRUE, AnalyzedImage );
			}
			View( SetControlImageFilePath, AnalyzedImage, ~<ImagePath>~ );
			ImageLoaded = FALSE;
			LastImagePath = ~~;
			return FALSE;
		}
	}

	if ( <Position> == 1 )
	{
		View( ShowControls, FALSE, InvalidText );
		View( ShowControls, TRUE, AnalyzedImage );
		ImageLoaded = TRUE;
		if ( ~<LastImagePath>~ != ~<ImagePath>~ )
		{
			View( SetControlTitle, AnalyzedImage, ~~ );
			Status = View( SetControlImageFilePath, AnalyzedImage, ~<ImagePath>~ );
			LastImagePath = ~<ImagePath>~;
		}
	}
	else
	{
		Status = View( SetControlImageFilePath, ReferenceImage, ~<ImagePath>~ );
	}

	return TRUE;
}


/***************************************************
 *************** Load Order functions **************
 ***************************************************/

VOID Analyzer::ClearCorrections()
{
	CorrectionList( ClearFilter );

	More = CorrectionList( GetFirst, Item );
	while ( <More> )
	{
		CorrectionList( Remove );
		More = CorrectionList( GetNext, Item );
	}

	CorrectionList( AddNew, Position );
	Position( Set, Description, ~[ Zero corrections ]~, Number, ~0~, Density, ~0~, Red, ~0~,
			  Green, ~0~, Blue, ~0~, Contrast, ~0~, Saturation, ~0~, Gamma, ~1.0~ );
}

VOID Analyzer::ClearReferences()
{
	OrderRefList( ClearFilter );
	
	More = OrderRefList( GetFirst, Item );
	while ( <More> )
	{
		OrderRefList( Remove );
		More = OrderRefList( GetNext, Item );
	}
}

VOID Analyzer::ClearImage()
{
	ShowImage( ~~, 1 );
	View( SetControlTitle, AnalyzedImageText, ~ ~ );
	gOldDensity = 0;
	gOldRed = 0;
	gOldGreen = 0;
	gOldBlue = 0;
	gOldContrast = 0;
	gOldSaturation = 0;
	gOldGamma = 0.0;
	ResetImageEditData( TRUE );
	UpdateColorValues();
}

VOID Analyzer::DeleteContents()
{
	ModifiedFlag = FALSE;
	InitCorrections();
	ClearCorrections();
	ClearReferences();
	ClearImage();
}

VOID Analyzer::EnableToolbar( Enable )
{
	View( EnableViewControls, <Enable>, NextButton );
	View( EnableViewControls, <Enable>, PrevButton );
	View( EnableViewControls, <Enable>, DensityUpButton );
	View( EnableViewControls, <Enable>, DensityDownButton );
	View( EnableViewControls, <Enable>, RedUpButton );
	View( EnableViewControls, <Enable>, RedDownButton );
	View( EnableViewControls, <Enable>, GreenUpButton );
	View( EnableViewControls, <Enable>, GreenDownButton );
	View( EnableViewControls, <Enable>, BlueUpButton );
	View( EnableViewControls, <Enable>, BlueDownButton );
	View( EnableViewControls, <Enable>, ResetButton );
	View( EnableViewControls, <Enable>, ApplyToAllButton );
	View( EnableViewControls, <Enable>, ModeButton);
	//View( EnableViewControls, <Enable>, LightTableButton );
	View( EnableViewControls, <Enable>, MakeRefButton );
	View( EnableViewControls, <Enable>, RecallRefButton );
	View( EnableViewControls, <Enable>, StoreButton );
	View( EnableViewControls, <Enable>, RecallButton );
	View( EnableViewControls, <Enable>, RecallLastButton );
}
NUMERIC GetItemHeight( OrderID )
{
    Query = ~Select DISTINCT ProductID from OrderItems where OrderID='<OrderID>'~;

    ItemCount =  ADO( dBase,Connect,RecordCountFor,~<Query>~ );

    if (!DefinedAndNotNULL( ItemCount ))
    {
        Log(Session, ~DEFAULTING to Height 30~);
        return 30;
    }
    Height = ($ItemCount * 2) + 25;
    Log(Session, ~Height <Height>~);
    return ( $Height );
}

NUMERIC Analyzer::LoadOrder(OrderNum)
{
	OrderID = ~<OrderNum>~;
	TempOrderID = ~<OrderID>~;
	MakeSQLSafe( TempOrderID );

	DeleteContents();

	ForgetGlobal( LightTableOpen );	// Force light table to re-load

	ReturnOnFailure( ValidateOrderID() );

	EnableToolbar( TRUE );
	EnableMenus( TRUE, FALSE );

	if ( !PGenConList( List, Connect, Cursor, Forward, Query, ~Select * from Orders where ID = '<TempOrderID>'~ ) )
	{
		dBase( GetErrorDescription, theErr );
		return Warning( ~Failed to insert Order <OrderID>. <theErr>~ );
	}

	if ( !List( GetNext,Record ) )
	{
		Warning( Translate( ~Order ID '<OrderID>' does not exist~ ) );
		OrderID = ~~;
		ReturnOnFailure( ValidateOrderID() );
	}
	else
	{
        if (DefinedAndNotNULL( OrderToRelease ))
        {
//            Query = ~Select Status From Orders Where ID = '<OrderToRelease>'~;
//            if ( !PGenConList( OldList, Connect, GetRecordFor, ~<Query>~, Status ) )
//        	{
//        		Warning(~Unable to get order record for <OrderToRelease>~);
//	        }
//            Status( Get, Status, ~<OldStatus>~);
//    		OrigStatus = ~<OldStatus>~;
//            Log(Session, ~Storing status of <OrderToRelease> to OrigStatus <OldStatus>~);
    		OrigStatus = ~Adjust~;
        }
        else
        {
    		OrigStatus = ~<$pcon.Record[Status]>~;
        }
		if ( Record( Set, Status, ~Adjusting~ ) )
		{
			List( Update );

            // Only mark the order adjusting if this is not for a reorder
            if (!DefinedAndNotNULL( OrderToRelease ))
            {
                RecordAction( ~<OrderID>~, ~Adjusting~);
            }
		}
		else
		{
			Warning(~Unable to set status of order <OrderID>~);
		}
	}
	CustomerID = ~<$pcon.Record[CustomerID]>~;
	MakeSQLSafe( CustomerID );

	// Set reference image
	Query = ~Select * from Images where OrderID = 'Reference' AND SubjectID = '<CustomerID>' Order By Roll, Frame~;
	if ( !PGenConList( List2, Connect, Cursor, Forward, Query, ~<Query>~ ) )
	{
		List2( GetErrorDescription,0, theErr );
		return Warning( ~Failed to load reference image for studio <CustomerID>. <theErr>~ );
	}
	if ( List2( GetFirst, Record ) )
	{
		RefPath = ~<$pcon.Record[Path]>~;
		RefImage = ~<$Str.$RefPath.Filename.WithoutExt>~;
		ShowTheReferenceImage( ~<$pcon.Record[Frame]>~, ~<RefPath>~ );
	}
	else
	{
		SelectFirstReference();
	}

	if ( !PopulateFramesListBox() )
	{
		return FALSE;
	}

	if (<WhichAnalyzerView> == 1)
	{
		InitLightTable( ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<ExtRefImage>~, ~<LastRefPath>~ );
	}

    // Open a summary
    if (DefinedAndNotNULL( OrderToRelease ))
    {
        ItemHeight = GetItemHeight(~<OrderToRelease>~);
        Actions = ACTION Doc ( BrowserDoc Open BrowserDoc "Init(~<$App.HTTPServer>/Reports/MiniOrderSummary.kpl?OrderID=<OrderToRelease>~,~<OrderToRelease> Summary Report~,30,0,30,<ItemHeight>,0,0,0);" );
    }
    else
    {
        ItemHeight = GetItemHeight(~<OrderID>~);
        Actions = ACTION Doc ( BrowserDoc Open BrowserDoc "Init(~<$App.HTTPServer>/Reports/MiniOrderSummary.kpl?OrderID=<OrderID>~,~<OrderID> Summary Report~,30,0,30,<ItemHeight>,0,0,0);" );
    }
    PerformActions( Actions );

	return TRUE;
}


VOID Analyzer::LogImageEdit( Line )
{
	Folder = ~<$App.Directory>\SessionLogs\ImageEdits~;
	Directory( Create, ~<Folder>~ );
	if ( !DefinedAndNotNull( KPDAWLogFileName ) )
	{
		KPDAWLogFileName = ~<Folder>\<$Date.%Y%m%d_%H%M%S>.txt~;
		PermanentSymbol( KPDAWLogFileName );
	}
	Type = ~Open~;
	if ( !Files( FileExists, ~<KPDAWLogFileName>~ ) )
	{
		Type = ~Create~;
	}
	if ( File( LogFile, Open, ~<KPDAWLogFileName>~, <Type>, Write ) )
	{
		LogFile( Seek, 0, End );
		LogFile( Translate( ~<Line>~ ) );
		LogFile( Close );
	}
	if ( <TotalImageEdits> >= 1000000000 )
	{
		++BillionEdits;
		TotalImageEdits = 0;
	}

	Path = ~<$App.Directory>\ImageEdits.dat~;
	if (File( TotalEdits, Open, ~<Path>~, Create, Write ) )
	{
		TotalEdits( ~Billions=<BillionEdits>;~ );
		TotalEdits( ~Counter=<TotalImageEdits>;~ );
		TotalEdits( Close );
	}
}

VOID Analyzer::LoadTotalImageEdits()
{
	Path = ~<$App.Directory>\ImageEdits.dat~;
	if ( Files( FileExists,~<Path>~ ) )
	{
		if (File( TotalEdits, Open, ~<Path>~, Read, Open ) )
		{
			TotalEdits( ReadTextFile, TotalEditsData );
			TotalEdits( Close );

			Billions = String( GetParameter, TotalEditsData, ~Billions=~,~;~ );
			Counter = String( GetParameter, TotalEditsData, ~Counter=~,~;~ );

			TotalImageEdits = MakeNumber( ~<Counter>~ );
			BillionEdits = MakeNumber( ~<Billions>~ );
		}
	}
}

// Not used yet
VOID Analyzer::LogOperation()
{
	if (!Accunet(Acc, Log, OrderID, ~<OrderID>~, OperationNumber, ~<LoggingOp>~))
	{
		return Warning(Translate(~Unable to log operation <LoggingOp> to ACCUNET.~));
	}
	Message = Translate(~Logging operation <LoggingOp> written to ACCUNET.~);
}
/****************************************************
 *************** View Change functions **************
 ****************************************************/

VOID Analyzer::ShowWindow( Show )
{
	if ( !<Show> )
	{
		DataWindow( Show, Hide );
	}
	else
	{
		DataWindow( Show, <DP2> ? ~Normal~ : ~Maximized~ );
		DataWindow( Activate );
	}
}

NUMERIC ChangeView( WhichView )
{
	app( Application );

	RefImage = ~~;
	ResetChangeFactor();
	NewRoll = ~~;
	NewFrame = ~~;
	NewRefImage = ~~;
	NewRefPath = ~~;

	app( Application );

	if ( <WhichView> != <WhichAnalyzerView> )
	{
		if ( !<DP2> )
		{
			Application( MainMenu, Enable, TRUE, ViewMainView );
			Application( MainMenu, Check, FALSE, ViewMainView );
			Application( MainMenu, Enable, TRUE, ViewLightTable );
			Application( MainMenu, Check, FALSE, ViewLightTable );
		}

		DisableWheelman();
		if ( <WhichAnalyzerView> == 0 )
		{
			AnalyzerView.GetReferenceImage( NewRefImage );
		}
		else if ( <WhichAnalyzerView> == 1 )
		{
			if ( ThumbView( GetSelected, ImageList ) )	// GetAll gets all records
			{
				if ( ImageList( GetFirst,Image ) )
				{
					NewRoll = ~<$con.Image[Roll]>~;
					NewFrame = ~<$con.Image[Frame]>~;
				}
			}
			LightTableView.SaveThumbnailSize();
		}
	}

	if ( <WhichView> == 0 )
	{
		if ( !<DP2> )
		{
			Application( MainMenu, Enable, FALSE, ViewMainView );
			Application( MainMenu, Check, TRUE, ViewMainView );
			EnableCorrectWindow( TRUE, 0 );
		}
		else
		{
			HandleWheelman( New, Wheelman );
			Global( Wheelman );
			AnalyzerView.EnableWheelman();
		}
		LightTableView.CancelCorrections( ~<NewRoll>~, ~<NewFrame>~ );
		SelectTheFrame( ~<NewRoll>~, ~<NewFrame>~ );
		ShowTheReferenceImage( ~<ExtRefImage>~, ~<LastRefPath>~, <WhichView> );
		DisplayStepIndicator( <WhichView> );
		AnalyzerView.ShowWindow( TRUE );
		AnalyzerView.SetKeepLastCorrectionCheckBox();
	}
	else if ( <WhichView> == 1 )
	{
		if ( !<DP2> )
		{
			Application( MainMenu, Enable, FALSE, ViewLightTable );
			Application( MainMenu, Check, TRUE, ViewLightTable );
		}
		AnalyzerView.ShowWindow( FALSE );
		InitLightTable( ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<ExtRefImage>~, ~<LastRefPath>~ );
		DisplayStepIndicator( <WhichView> );
		LightTableView.ShowWindow( TRUE );
		LightTableView.SetKeepLastCorrectionCheckBox();
	}
	else
	{
		// Something bad
	}

	if ( <WhichView> != <WhichAnalyzerView> )
	{
		if ( <WhichAnalyzerView> == 0 )
		{
			AnalyzerView.ShowWindow( FALSE );
		}
		else if ( <WhichAnalyzerView> == 1 )
		{
			LightTableView.ShowWindow( FALSE );
		}
	}

	WhichAnalyzerView = <WhichView>;

	return TRUE;
}

VOID Analyzer::GetReferenceImage( &RefImage )
{
	View( GetControlValue, ReferenceImageText, TheRefImage );

	RefImage = ~<TheRefImage>~;
}

NUMERIC Analyzer::OpenLightTable( Disable )
{
	//return TRUE;  // <DP2>		// LightTable
	// Check light table menu item
	app( Application );

	if ( !Defined( Disable ) )
	{
		Disable = ~~;
	}

	// Release control of wheelman
	DisableWheelman();

	View( GetControlValue, ReferenceImageText, RefImage );

	InitLightTable( ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<RefImage>~, ~<LastRefPath>~, ~<Disable>~ );
	LightTableView.ShowWindow( TRUE );

	return PerformActions( Actions );
}

VOID EnableMenus( Enable, EnableOpen )
{
	if ( <DP2> )	{ return; }
	app( Application );

	Application( MainMenu, Enable, <Enable> + <EnableOpen>, FileOpen );
	Application( MainMenu, Enable, <Enable>, FileClose );
	Application( MainMenu, Enable, <Enable>, MenuStoreCorrections );
	Application( MainMenu, Enable, <Enable>, MenuRecallCorrections );
	Application( MainMenu, Enable, <Enable>, MenuRecallLast );
	Application( MainMenu, Enable, <Enable> + <EnableOpen>, ViewingParameters );
	Application( MainMenu, Enable, <Enable> + <EnableOpen>, ProgramOptions );
}


/************************************************
/*************** Render functions ***************
 ************************************************/

NUMERIC Analyzer::CreateImageJob( JobPath, ImagePath, NewPath, Flatten )
{
	if ( !File( Job,Open,~<JobPath>~,Create,Write ) )	// CREATE AND OPEN THE JOB
	{
		Invoke( ShowWarning,~Could not create the job file <JobPath>~  );
		return FALSE;
	}

	Job( ~FileType: Job ;~ );

	Job( CRLF,WRITELINE,~Macros:   |Macros.txt|~ );

	Job( CRLF,WRITELINE,~UnitOfMeasure: Pixels;~ );

	Job( CRLF,WRITELINE,~BeginInclude();~ );

	Job( CRLF,WRITELINE,~FileNameSequence = 0;~ );

	Job( CRLF,WRITELINE,~ImageWidth1 = |0|; ImageHeight1 = |0|; FileType = ||;~ );

	Job( CRLF,WRITELINE,~NUMERIC GetDimensions( Image )~ );	
	Job( ~{~ );
	Job( ~	if ( !GetImageInfo( |<Image>|,MaxWidth,Width,MaxHeight,Height,FileType,LocalType ) ) ~ );
	Job( ~	{~ );	
	Job( ~		Warning( |Could not open <Image>| );~ );
	Job( ~		Exit();~ );
	Job( ~	}~ );
	Job( CRLF,WRITELINE,~	ImageWidth1 = <Width>;  ImageHeight1 = <Height>; FileType = |<LocalType>|;~ );
	Job( CRLF );
	Job( ~	substr( |<LocalType>|, 0, 4, ImageType );~ );

	if ( !<ExtFileOption> )
	{
		Job( ~	if ( |<ImageType>| == |JPEG| ) ~ );
		Job( ~	{~ );
		Job( ~		FileType = |JPEG Max|;~ );
		Job( ~	}~ );
		Job( ~	else if ( |<ImageType>| == |EXIF| ) ~ );
		Job( ~	{~ );
		Job( ~		FileType = |JPEG Max|;~ );
		Job( ~	}~ );
	}
	else
	{
		Job( ~	FileType = |<ExtSaveFileType>|;~ );

		if (String(BeginsWith, ~TIFF~ , Upper(~<ExtSaveFileType>~) ) != ~~)
		{
			if (String(EndsWith, Upper(~.jpg~), Upper(~<NewPath>~) ) != ~~)
			{
				substr(~<NewPath>~, 0, strlen(~<NewPath>~) - 4, NewPath);
				NewPath = ~<NewPath>.tif~;
			}
		}
		else if (String(BeginsWith, ~JPEG~, Upper(~<ExtSaveFileType>~) ) != ~~)
		{
			if (String(EndsWith, Upper(~.tif~), Upper(~<NewPath>~) ) != ~~)
			{
				substr(~<NewPath>~, 0, strlen(~<NewPath>~) - 4, NewPath);
				NewPath = ~<NewPath>.jpg~;
			}
		}
		else if (String(BeginsWith, ~EXIF~, Upper(~<ExtSaveFileType>~) ) != ~~)
		{
			if (String(EndsWith , Upper(~.tif~), Upper(~<NewPath>~)) != ~~)
			{
				substr(~<NewPath>~, 0, strlen(~<NewPath>~) - 4, NewPath);
				NewPath = ~<NewPath>.jpg~;
			}
		}
	}

//	Job( ~	ImageCorrections( PasteCrop,|<ImagePath>|,50,50,100,100,0 );~ );
//	Job( ~	if ( ImageCorrections( GetCrop,|<Image>|,cropX,cropY,cropW,cropH,Rotation ) ) ~ );
//	Job( ~	{~ );
//	Job( ~	   if ( SimilarStr(|<Rotation>|,|90|,|270| ) )~ );	
//	Job( ~	   {~ );
//	Job( ~	     Temp = <ImageWidth1>;~ );
//	Job( ~	     ImageWidth = <ImageHeight1>;~ );	
//	Job( ~	     ImageHeight = <Temp>;~ );	
//	Job( ~	   }~ );
//	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	Job( CRLF,WRITELINE,~NUMERIC FinishFlatten()~ );	
	Job( ~{~ );
	Job( ~	tries = 0;~ );
	Job( ~	Files( Delete,|<NewPath>| );~ );
	Job( ~	while ( TRUE )~ );
	Job( ~	{~ );
	Job( ~		if ( Files( Rename,|<NewPath>_ZZZ|,|<NewPath>| ) )~ );	
	Job( ~			break;~ );
	Job( ~		if ( GetLastError() != 32 )~ );	
	Job( ~		{~ );
	Job( ~			errMsg = GetLastErrorMsg();~ );
	Job( ~			err = GetLastError();~ );
	Job( ~			Files( Delete,|<NewPath>_ZZZ| );~ );
	Job( ~			return Warning( Translate( |FlattenImage: Could not rename <NewPath>_ZZZ to <NewPath>.  <errMsg>| ) );~ );
	Job( ~		}~ );
	Job( ~		++tries;~ );
	Job( ~		if ( <tries> > 10 )~ );	
	Job( ~		{~ );
	Job( ~			err = GetLastError();~ );
	Job( ~			errMsg = GetLastErrorMsg();~ );
	Job( ~			Files( Delete,|<NewPath>_ZZZ| );~ );
	Job( ~			Log( Session,|FlattenImage: Failed to rename <NewPath>_ZZZ to <NewPath>. Error=<err>. <errMsg>.| );~ );
	Job( ~			return FALSE;~ );
	Job( ~		}~ );
	Job( ~		Sleep( 1000 );~ );
	Job( ~	}~ );
//	Job( ~	Log( Session,|FlattenImage: Removing Image Corrections for <ImagePath>| );~ );	CGCG No session log
	Job( ~	ImageCorrections( Reset,|<ImagePath>| );~ );
	Job( ~	ImageCorrections( UpdateCrop,|<ImagePath>|,50,50,100,100 );~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	Job( CRLF,WRITELINE,~NUMERIC DeleteOld()~ );
	Job( ~{~ );
	Job( ~	tries = 0;~ );
	Job( ~	while ( TRUE )~ );
	Job( ~	{~ );
	Job( ~		if (Files( Delete,|<ImagePath>| ) )~ );
	Job( ~			break;~ );
	Job( ~		if ( GetLastError() != 32 )~ );	
	Job( ~		{~ );
	Job( ~			errMsg = GetLastErrorMsg();~ );
	Job( ~			err = GetLastError();~ );
	Job( ~			Files( Delete,|<ImagePath>| );~ );
	Job( ~			return Warning( Translate( |FlattenImage: Could not delete <ImagePath>.  <errMsg>| ) );~ );
	Job( ~		}~ );
	Job( ~		++tries;~ );
	Job( ~		if ( <tries> > 10 )~ );	
	Job( ~		{~ );
	Job( ~			err = GetLastError();~ );
	Job( ~			errMsg = GetLastErrorMsg();~ );
	Job( ~			Files( Delete,|<ImagePath>| );~ );
	Job( ~			Log( Session,|FlattenImage: Failed to delete <ImagePath>. Error=<err>. <errMsg>.| );~ );
	Job( ~			return FALSE;~ );
	Job( ~		}~ );
	Job( ~		Sleep( 1000 );~ );
	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	Job( ~GetDimensions(|<ImagePath>|);~ );

	Job( CRLF,WRITELINE,~EndInclude();~ );

	Job( CRLF,WRITELINE,~Main:~ );
	Job( ~	IWidth: <ImageWidth1>;~ );
	Job( ~	IHeight: <ImageHeight1>;~ );
	Job( ~	IColor: 0 255 255 255;~ );

	Job( CRLF,WRITELINE,~IL: 1~ );
	Job( ~	IFile: |<ImagePath>|;~ );

	Job( ~	ILocation: 0 0 <ImageWidth1> <ImageHeight1>;~ );
	Job( ~	AutoCrop: 50 50 50 50 100 100; ~ );

	Job( ~	Density: 0;~ );
	Job( ~	RGB: 0, 0, 0, 0;~ );
	Job( ~	Contrast: 0;~ );
	Job( ~	Saturation: 0;~ );
	Job( ~	XGamma: 1;~ );
	Job( ~	OverrideImageRotation: 0~ );

	Job( CRLF,WRITELINE,~Saveimage:~ );
	Job( ~	QueueName:		|KPDAW|;~ );
	if ( <ExtProfileOption> == 1 )
	{
		RenderProfile = ~<ExtRenderProfile>~;
		if ( ~<ExtRenderProfile>~ == ~~ )
		{
			RenderProfile = ~None~;
		}
	}
	else
	{
		RenderProfile = GetWorkingSpaceProfile();
	}

	if ( DefinedAndNotNull( RenderProfile ) )
	{
		Job( ~	ImageOutputProfile: |<RenderProfile>|;~ );
	}

	Job( ~	Copies:			1;~ );
	Job( ~	Enabled:		1;~ );
	Job( ~	Savefiletype:	|<FileType>|;~ );
	Job( ~	Previewsize:	<SysThumbnailSize>;~ );

	if ( !DefinedAndNotNull( NewPath ) )
	{
		NewName = ~ZZZ_<$Str.$ImagePath.FileName.WithExt>~;
		NewPath = ~<$Str.$ImagePath.Path>\<NewName>~;
	}
	if ( !<Flatten> )
	{
		Job( ~	Savename:		|<NewPath>|;~ );
		if ( <ExtDeleteOld> )
		{
			Job( ~	ProcessAfter:	|DeleteOld();|;~ );
		}
	}
	else
	{
		Job( ~	Savename:		|<NewPath>_ZZZ|;~ );
		Job( ~	ProcessAfter:	|FinishFlatten();|;~ );
	}

	Job( Close );

	return TRUE;
}

NUMERIC Analyzer::AddJobToDatabase( &dBase, JobPath, JobID, BatchID)
{
	while ( TRUE )
	{
		Now = Time();

		Fields = ~JobPath,QueueName,SubmitDate,BatchID,OrderID,OrderSequence,OrderItemID,OrderItemQty,OrderItemSequence,JobID,PrintStatus,Priority,Owner~;
	
		++fSeq;

		Values = ~'<JobPath>','KPDAW',<Now>,'<BatchID>','<OrderID>',1,
					<fSeq>,1,<fSeq>,'<JobID>',8,50,'<$App.UserName>'~;

		Cmd = ~Insert Into JobQueue(<Fields>) Values(<Values>)~;

		if ( dBase( Cmd, ~<cmd>~ ) )
			break;

		dBase( GetErrorNumber, err, GetErrorDescription, theErr );

		if ( !dbase( ErrorIs, <err>, ~Duplicate~) )
		{	
			Warning( Translate( ~Failed to add job to the JobQueue.  <Cmd>.  <theErr>~ ) );
			return FALSE;
		}
	}

	return TRUE;
}

STR Analyzer::CreateJobPath(&JobID)
{
	JobPath = ~<$App.ShareDirectory>\ExportImages~;

	Directory( Create, ~<JobPath>~ );

	while ( TRUE )
	{

		JobID = UniqueJobID();

		JobName = ~Job_<JobID>~;

		if ( !Files( FileExists,~<JobPath>\<JobName>~ ) )
			break;
	}

	return ~<JobPath>\<JobName>~;
}

NUMERIC Analyzer::RenderImage( ImagePath, NewPath, BatchID, &dBase )
{
	if ( IsNull( ~<Image>~ ) )
	{
		//Invoke( ShowWarning,~No image to export~ );
		Warning( Translate( ~No image to export~ ) );
		return FALSE;
	}

	JobID = 0;

	JobPath = CreateJobPath(JobID);

	if ( IsNull( ~<JobPath>~ ) )
	{
		Warning( Translate( ~Couldn't create a unique job path~ ) );
		return FALSE;
	}

	Flatten = FALSE;
	if ( ~<ImagePath>~ == ~<NewPath>~ )
	{
		Flatten = TRUE;
	}

	if ( !CreateImageJob( ~<JobPath>~, ~<ImagePath>~, ~<NewPath>~, <Flatten> ) )
	{
		return FALSE;
	}

	if ( !AddJobToDatabase( dBase, ~<JobPath>~, ~<JobID>~, ~<BatchID>~ ) )
	{
		return FALSE;
	}

	return TRUE;
}

NUMERIC StartPrinter()
{
	ComputerName = ~<$app.ComputerName>~;
	if ( strlen( ~<ComputerName>~ ) > 24 )
	{
		substr( ~<ComputerName>~, 0, 24, ComputerName );
	}
	Query = ~Select * From Printers WHERE PrinterName = 'KPDAW_<ComputerName>'~;

	if ( !PGenConList( List, Connect, Cursor, Forward, Query, ~<Query>~ ) )
	{
		List( GetErrorDescription, 0, theErr );
		return Warning( ~Query Failed: <Query>. <theErr>~ );
	}

	if ( List( GetFirst, Printer ) )
	{
		CFunc( CRenderEngineMain, CRenderEngineMain, Printer(GetObject), 1 );
	}

	return TRUE ;
}

NUMERIC StopPrinter()
{
	ComputerName = ~<$app.ComputerName>~;
	if ( strlen( ~<ComputerName>~ ) > 24 )
	{
		substr( ~<ComputerName>~, 0, 24, ComputerName );
	}
	Query = ~Select * From Printers WHERE PrinterName = 'KPDAW_<ComputerName>'~;

	if ( !PGenConList( List, Connect, Cursor, Forward, Query, ~<Query>~ ) )
	{
		List( GetErrorDescription, 0, theErr );
		return Warning( ~Query Failed: <Query>. <theErr>~ );
	}

	if ( List( GetFirst, Printer ) )
	{
		Printer( ResetChanged, Set, Status, 3 );
		List( Update );
	}

	return TRUE;
}

VOID AddPrinter()
{
	ComputerName = ~<$app.ComputerName>~;
	if ( strlen( ~<ComputerName>~ ) > 24 )
	{
		substr( ~<ComputerName>~, 0, 24, ComputerName );
	}
	Query = ~Select * FROM Printers WHERE PrinterName = 'KPDAW_<ComputerName>'~;
	//if ( !PGenConList( List,Connection,database,Cursor,Keyset,Query,~<Query>~ ) )
	if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{
		if ( !List( GetFirst, Record ) )
		{
			// Add printer
			List( AddNew, Printer );

			Printer( Set, PrinterName, ~KPDAW_<ComputerName>~, PrinterModel, ~Disk~, QueueName, ~KPDAW~, ComputerName, ~<$app.ComputerName>~, OnOrderComplete, ~KPDAWOrderComplete.txt~ );
			List( Update );
		}
	}
}

VOID AddQueue()
{
	Query = ~Select * FROM QueueDefinition WHERE QueueName = 'KPDAW'~;
	//if ( !PGenConList( List,Connection,database,Cursor,Keyset,Query,~<Query>~ ) )
	if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{
		if ( !List( GetFirst, Record ) )
		{
			// Add printer
			List( AddNew, Printer );

//			Printer( Set, QueueName, ~KPDAW~, PrinterModel, ~Disk~, ICCProfile, GetWorkingSpaceProfile() );
			Printer( Set, QueueName, ~KPDAW~, PrinterModel, ~Disk~ );
			List( Update );
		}
//		else
//		{
//			Record( Set, QueueName, ~KPDAW~, PrinterModel, ~Disk~, ICCProfile, GetWorkingSpaceProfile() );
//			List( Update );
//		}
	}
}

STR GetWorkingSpaceProfile( void )
{
	WorkingSpaceProfile = ~~;
	if (!ADO(dBase, Connect))
	{
		dbase( GetErrorDescription, theErr);
		Warning( Translate( ~Could not connect to the database. <theErr>~ ) );
		return ~<WorkingSpaceProfile>~;
	}

	// Use the current DP2 working space profile if it's set
	Query = ~SELECT WorkingSpaceProfile FROM ViewProfiles WHERE ComputerName = '<$app.ComputerName>' AND UserName = '<$app.UserName>'~;

	if (!dBase(GetValuesFor, ~<Query>~, WorkingSpaceProfile) )
	{
		Warning(~Unable to set the working space profile!~ );
		Exit();
	} else
	{
		WorkingSpaceProfileName = ~<WorkingSpaceProfile>~;
	}

	// If DP2 didn't have a default working space profile setting, then we use SRGB 
	// for processing.
	if ( (~<WorkingSpaceProfile>~ == ~None~) || (~<WorkingSpaceProfile>~ == ~~) )
	{
		WorkingSpaceProfile = ~srgb~;
	}

	return ~<WorkingSpaceProfile>~;
}

/*******************************************************
 *************** Initialization functions **************
 *******************************************************/

VOID CreateData()
{
	// Create list of corrections
	PGenConList( CorrectionList, Create );
	Global( CorrectionList );

	CorrectionList( AppendField, Description,	Char,		<CorrectionLength> + 1,	FldUpdatable );
	CorrectionList( AppendField, Number,		Integer,	4,	FldUpdatable );
	CorrectionList( AppendField, Density,		Integer,	4,	FldUpdatable );
	CorrectionList( AppendField, Red,			Integer,	4,	FldUpdatable );
	CorrectionList( AppendField, Green,			Integer,	4,	FldUpdatable );
	CorrectionList( AppendField, Blue,			Integer,	4,	FldUpdatable );
	CorrectionList( AppendField, Contrast,		Integer,	4,	FldUpdatable );
	CorrectionList( AppendField, Saturation,	Integer,	4,	FldUpdatable );
	CorrectionList( AppendField, Gamma,			Double,		8,	FldUpdatable );
	CorrectionList( AppendField, LastUsed,		Integer,	4,	FldUpdatable );

	CorrectionList( Open );

	// Create list of order-level reference images
	PGenConList( OrderRefList, Create );
	Global( OrderRefList );
	OrderRefList( AppendField, Frame,			Char,		<FrameLength> + 1, FldUpdatable );
	OrderRefList( AppendField, Path,			Char,		255,FldUpdatable );

	OrderRefList( Open );
}

VOID Analyzer::SelectFirstReference()
{
	if ( GetWorkStationSettings( ~Analyzer~, ~DefaultImagePath~, ImagePath, Enabled ) )
	{
		FileName = ~<$Str.$ImagePath.Filename.WithoutExt>~;
		ShowTheReferenceImage( ~<FileName>~, ~<ImagePath>~ );
	}
	else
	{
		Query = ~Select * From Images where OrderID = 'Reference' AND SubjectID Is Null Order By Frame~;
		if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
		{
			if ( List( GetFirst, Record ) )
			{
				FilePath = ~<$pcon.Record[Path]>~;
				FileName = ~<$Str.$FilePath.Filename.WithoutExt>~;
				ShowTheReferenceImage( ~<FileName>~, ~<FilePath>~ );
			}
		}
	}
}

VOID LoadOptions()
{
	RenderOption = 0;

	if ( !<DP2> )
	{
		if ( GetWorkStationSettings( ~Analyzer~, ~RenderOption~, RenderOption, Enabled ) )
		{
			ExtRenderOption = <RenderOption>;
			if ( <ExtRenderOption> )
			{
				KPDAWRender = TRUE;
			}
		}
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderFileOption~, FileOption, Enabled ) )
	{
		ExtFileOption = <FileOption>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderFileType~, FileType, Enabled ) )
	{
		ExtSaveFileType = ~<FileType>~;
	}
	else
	{
		ExtSaveFileType = ~TIFF~;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~ProfileOption~, ProfileOption, Enabled ) )
	{
		ExtProfileOption = <ProfileOption>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderProfile~, RenderProfile, Enabled ) )
	{
		if ( ~<RenderProfile>~ == ~~ )
		{
			RenderProfile = ~None~;
		}
		ExtRenderProfile = ~<RenderProfile>~;
	}
	else
	{
		ExtRenderProfile = GetWorkingSpaceProfile();
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~RenderPath~, RenderPath, Enabled ) )
	{
		ExtRenderPath = ~<RenderPath>~;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~UseInputPath~, TextCheck, Enabled ) )
	{
		ExtTextCheck = <TextCheck>;
	}
	 
	if ( GetWorkStationSettings( ~Analyzer~, ~InputPath~, TextPath, Enabled ) )
	{
		ExtTextPath = ~<TextPath>~;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~HoldCorrectionMode~, HoldCorrectionMode, Enabled ) )
	{
		ExtHoldCorrectionMode = <HoldCorrectionMode>;
	}

	AllowResetOfNoPrint = TRUE;
	GetWorkStationSettings( ~Analyzer~, ~AllowResetOfNoPrint~, AllowResetOfNoPrint, Enabled );
	ExtAllowResetOfNoPrint = <AllowResetOfNoPrint>;

	if ( GetWorkStationSettings( ~Analyzer~, ~PreserveLum~, PreserveCheck, Enabled ) )
	{
		ExtPreserveCheck = <PreserveCheck>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~KeepCorrection~, KeepCorrection, Enabled ) )
	{
		ExtKeepCorrection = <KeepCorrection>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~ShowOnlyImagesToAdjust~, ShowOnlyImagesToAdjust, Enabled ) )
	{
		ExtShowOnlyImagesToAdjust = <ShowOnlyImagesToAdjust>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~DeleteOld~, DeleteOld, Enabled ) )
	{
		ExtDeleteOld = <DeleteOld>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~EnableCropping~, EnableCropping, Enabled ) )
	{
		ExtEnableCropping = <EnableCropping>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~AutoBalFirst~, AutoBalFirst, Enabled ) )
	{
		ExtAutoBalFirst = <AutoBalFirst>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~DefaultAutoBalLevel~, SbaLevel, Enabled ) )
	{
		ExtSbaLevel = <SbaLevel>;
	}

	if ( !<DP2> )
	{
		if ( DefinedAndNotNull( RenderOption ) )
		{
			if ( <RenderOption> )
			{
				AddPrinter();
				AddQueue();
				StartPrinter();
			}
		}
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~PreDP2_4.2~, Pre42, Enabled ) )
	{
		PreDP2_42 = <Pre42>;
	}

	if ( GetWorkStationSettings( ~Analyzer~, ~WheelStep~, TheWheelStep, Enabled ) )
	{
		WheelChange = MakeNumber( ~<TheWheelStep>~ );
	}

	ThumbnailSize = MakeNumber( ~<$SystemSettings.Thumbnail[Size]>~ );
	if ( <ThumbnailSize> > 0 )
	{
		SysThumbnailSize = <ThumbnailSize>;
	}

	ThumbnailQuality = MakeNumber( ~<$SystemSettings.Thumbnail[Quality]>~ );
	if ( <ThumbnailQuality> > 0 )
	{
		SysThumbnailQuality = <ThumbnailQuality>;
	}

	DefaultAutoBalPref = ~~;
	GetWorkStationSettings( ~Analyzer~, ~DefaultAutoBalPref~, DefaultAutoBalPref, Enabled );
	if ( IsNull( ~<DefaultAutoBalPref>~ ) )
	{
		GetSystemSettings( ~Analyzer~, ~DefaultAutoBalPref~, DefaultAutoBalPref, Enabled );
	}

	if ( !IsNULL( ~<DefaultAutoBalPref>~ ) )
	{
		ExtAutoBalPreference = ~<DefaultAutoBalPref>~;
	}
	else
	{
		PrefsQuery = ~Select Name From DSbaPrefsDef Order By Name~;

		if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<PrefsQuery>~ ) )
		{
			List( GetErrorDescription,0,theErr );
			return Warning( Translate( Translations, QueryFailed, ~<PrefsQuery>~, ~<theErr>~ ) ); 
		}

		Count = List( NumEntries );

		if ( !<Count> )
		{
			return;
		}

		if ( List( GetFirst, Record ) )
		{
			ExtAutoBalPreference = ~<$pcon.Record[Name]>~;
		}
	}
}

VOID LoadMainSize()
{
	if ( GetWorkStationSettings( ~Analyzer~, ~TopOfImage~, TopTemp, Enabled ) )
	{
		if ( GetWorkStationSettings( ~Analyzer~, ~AnalyzeWidth~, WidthTemp, Enabled ) )
		{
			if ( GetWorkStationSettings( ~Analyzer~, ~AnalyzeHeight~, HeightTemp, Enabled ) )
			{
				if ( GetWorkStationSettings( ~Analyzer~, ~ReferenceWidth~, RWidthTemp, Enabled ) )
				{
					TopOfImage = <TopTemp>;
					AnalyzeWidth = <WidthTemp>;
					AnalyzeHeight = <HeightTemp>;
					ReferenceWidth = <RWidthTemp>;
				}	
			}
		}
	}
}

VOID ToggleJobToolBar()
{
	Action = ~[ToggleToolbar(JobToolbar)]~;
	PerformActions( Action ); 
}

VOID Analyzer::NewOrder(NewOrderID)  // DP2
{
	if ( DefinedAndNotNull(NewOrderID) )
	{
		// Cancel previous order if necessary

		if ( !<ModifiedFlag> )
		{
			AnalyzerView.CancelOrder();
		}
		
		if ( StopForAEImages( ~<NewOrderID>~ ) )
		{
			return;
		}

		AnalyzerView.LoadOrder( ~<NewOrderID>~ );
	}
}


VOID Analyzer::DefineLastCorrections()
{
	gLastDensity = 0;
	gLastRed = 0;
	gLastGreen = 0;
	gLastBlue = 0;
	gLastContrast = 0;
	gLastSaturation = 0;
	gLastGamma = 0.0;
	gCorrectionMade = FALSE;

	PermanentSymbol( gLastDensity );
	PermanentSymbol( gLastRed );
	PermanentSymbol( gLastGreen );
	PermanentSymbol( gLastBlue );
	PermanentSymbol( gLastContrast );
	PermanentSymbol( gLastSaturation );
	PermanentSymbol( gLastGamma );
	PermanentSymbol( gCorrectionMade );
}

VOID Analyzer::SetToolbarState()
{
	View( SetState, TRUE, FullViewButton );
	ShowButton = !<KPDAWRender> || DefinedAndNotNull( WantStaticToolbars );
}

VOID Analyzer::SetEnableCropping()
{
	View( SetAllowCropping, AnalyzedImage, <ExtEnableCropping> );
	ShowButton = !<KPDAWRender> || DefinedAndNotNull( WantStaticToolbars );
}

VOID SetKeepLastCorrection()
{
	if ( !<ExtKeepCorrection> && <ExtAutoBalFirst> )
	{
		if ( MessageBox( Translate( ~<AskAutoBalOff>~ ), YESNO ) != YES )
		{ 
			if ( Defined( AnalyzerView ) )
			{
				AnalyzerView.SetKeepLastCorrectionCheckBox();
			}
			if ( Defined( LightTableView ) )
			{
				LightTableView.SetKeepLastCorrectionCheckBox();
			}
		}
		else
		{
			ExtKeepCorrection = !<ExtKeepCorrection>;
			ExtAutoBalFirst = FALSE;
		}
	}
	else
	{
		ExtKeepCorrection = !<ExtKeepCorrection>;
	}
}

VOID Analyzer::SetKeepLastCorrectionCheckBox()
{
	if ( Defined( View ) )
	{
		View( SetCheck, <ExtKeepCorrection>, KeepLastCorrectionsCheckBox );
	}
}

VOID ChangeResolution()
{
	AnalyzerView.ChangeRes();
}

VOID SetEnableCropping()
{
	AnalyzerView.SetEnableCropping();
}

VOID Analyzer::ChangeRes()
{
	if ( GetUserSettings(~PreviewOptions~, ~HighestResolution~, UseHighestResolution, Enabled) )
	{
		UseHighest = (~<UseHighestResolution>~ == "T") ? TRUE : FALSE;
		View( SetUseHighestRes, ReferenceImage, <UseHighest>);
		View( SetUseHighestRes, AnalyzedImage, <UseHighest>);
	}
}

VOID ResetChangeFactor()
{
	UserChange = ~~;
	UpdateStatusText();
}

VOID SaveChangeFactor( NewChar )
{
	if ( KeyState( Shift ) )
	{
		WheelChange = MakeNumber( ~<NewChar>~ );
		if ( <WheelChange> == 0 )
		{
			WheelChange = 10;
		}
		SetWorkStationSettings( ~Analyzer~, ~WheelStep~, <WheelChange>, TRUE );
		DisplayStepIndicator();
	}
	else
	{
		UserChange = ~<UserChange><NewChar>~;

		UpdateStatusText();
	}
}

VOID DisplayStepIndicator( TheView )
{
	WhichView = <WhichAnalyzerView>;

	if ( DefinedAndNotNull( TheView ) )
	{
		WhichView = <TheView>;
	}

	if ( <WheelChange> == 1 )
	{
		BigStep = FALSE;
		if ( <WhichView> == 0 )
		{
			AnalyzerView.SetOldColor();
		}
		else
		{
			LightTableView.SetOldColor();
		}
	}
	else
	{
		BigStep = TRUE;
		if ( <WhichView> == 0 )
		{
			AnalyzerView.SetNewColor();
		}
		else
		{
			LightTableView.SetNewColor();
		}
	}
}

VOID ShowOpticalDRGB(ImageIsSelected)
{
	if ( !<PreDP2_42> )
	{
		if ( <ImageIsSelected> )
		{
			if ( DRGBFromAdjustments( OrderRollFrame, ~<OrderID>~, ~<Roll>~, ~<Frame>~, D, R, G, B ) )
			{
				DeltaDRGB = ~dDRGB(<D>,<R>,<G>,<B>)~;
			}

			UpdateStatusText();
		}
		else
		{
			DeltaDRGB = ~dDRGB(64,0,0,0)~;
			StatusBarText( ~<DeltaDRGB>~ );
		}
	}
	else
	{
		UpdateStatusText();
	}
}

VOID UpdateStatusText()
{
	LocalChange = ~~;
	if ( DefinedAndNotNull( UserChange ) )
	{
		LocalChange = ~User Change: <UserChange>~;
	}
	StatusBarText( ~<DeltaDRGB>          <LocalChange>~ );
}


VOID EnableCorrectWindow( Enable, WhichView )
{
	//if ( <DP2> )	{	return; }	// LightTable
	TheView = <WhichAnalyzerView>;
	if ( DefinedAndNotNull( WhichView ) )
	{
		TheView = <WhichView>;
	}

	if ( <TheView> == 0 )
	{
		if ( !<Enable> )
		{
			DisableWheelman();
			AnalyzerView.EnableTheWindow( FALSE );
		}
		else
		{
			AnalyzerView.EnableTheWindow( TRUE );
//			AnalyzerView.ChangeImageSize( 0, 1 );
			HandleWheelman( New, Wheelman );
			Global( Wheelman );
			AnalyzerView.EnableWheelman();
		}
	}
	else if ( <TheView> == 1 )
	{
		if ( !<Enable> )
		{
			LightTableView.DisableView();
		}
		else
		{
			LightTableView.EnableViews();
		}
	}
}


/***************************************************************************
/************************* Serial Wheelman Support *************************
 ***************************************************************************/

NUMERIC Analyzer::EnableWheelman()
{
	Wheelman.CloseInputDevice();
	Sleep( 50 );

	if ( !GetWorkStationSettings( ~Analyzer~, ~WheelmanInputPort~, Port, Enabled ) )
	{
		return FALSE;
	}

	if ( IsNull( ~<Port>~ ) )
	{
		SetWheelmanPort( <Port> );
		return FALSE;
	}

	if ( MakeNumber( ~<Port>~ ) <= 0 )	{ return FALSE; };

	if ( !Wheelman.OpenInputDevice( <Port> ) )
	{
		// Error is already reported
	}
	else
	{
		SetWheelmanPort( <Port> );
	}

	View( ShowControls, !<WheelManMode>, ColorGroupBox);
	View( ShowControls, <WheelManMode>, ColorGroupBox2);

	return TRUE;
}

VOID DisableWheelman()
{
	if ( Defined( Wheelman ) )
	{
		Wheelman.CloseInputDevice();
		Sleep( 50 );
		ForgetGlobal( Wheelman );
		Sleep( 25 );
	}
}

VOID Analyzer::SetWheelmanPort( Port )
{
	SetWorkStationSettings( ~Analyzer~, ~WheelmanInputPort~, <port>, TRUE );
}

//VOID Analyzer::GetWheelmanPort()
//{
//	if ( GetWorkStationSettings( ~Analyzer~, ~WheelmanInputPort~, port, Enabled ) )
//	{
//		View( SetControlValue, SerialPortCombo, ~<port>~);
//		EnableWheelman();
//	}
//}

VOID Analyzer::AddWheelmanControls()
{	
	Define: SerialPrompt Using DDWinCtrlDef AsSymbol SerialPrompt Private
		Fields:	TYPENAME		StaticText
				POSITION		700, 100,
								120,$ButtonHeight
				TEXT			~Serial Port~
				TextColorRed	255,TextColorBlue 255,TextColorGreen 255
				BGColorRed		0, BGColorBlue 0, BGColorGreen 0
				RightJustified	TRUE
				FontSize		<FontSize>
				IsHidden		T					
								
	Define: SerialPortCombo Using DDWinCtrlDef AsSymbol SerialPortCombo 
		Fields: TypeName		SComboBox  
				POSITION		SerialPrompt(GetRight,Position) + $hGap, SerialPrompt(GetTop,Position)-2, 70, $ButtonHeight * 4
				IActionsText    ~[GetList(PortList) Get]~
				DActionsText	ACTION EXEC ( <THIS>.EnableWheelman() )
				OActionsText    ~[Save]~
				GenConName       THIS
				Tooltip          ~Select the serial port connected to your DRGB input device~
				IsHidden		T
}


Class( HandleWheelman, Extends, BaseWheelman );	// Main analyzer window handler
Class( OpenOrderWheel, Extends, BaseWheelman );	// Open order dialog handler
Class( RecallWheel, Extends, BaseWheelman );	// Recall corrections dialog handler
Class( RecallRefWheel, Extends, BaseWheelman );	// Recall reference dialog handler
Class( ApplyAllWheel, Extends, BaseWheelman );	// Apply all dialog handler
Class( FinishWheel, Extends, BaseWheelman );	// Finish order dialog handler
Class( DeleteOrderWheel, Extends, BaseWheelman );	// Delete order dialog handler

HandleWheelman( New, Wheelman );

VOID HandleWheelman::OnWheel1(amount)		{ AnalyzerView.OnDensityButton( AnalyzerView.GetChangeAmount( <amount> ) ); }
VOID HandleWheelman::OnWheel2(amount)		{ AnalyzerView.OnRedButton( AnalyzerView.GetChangeAmount( <amount> ) ); }
VOID HandleWheelman::OnWheel3(amount)		{ AnalyzerView.OnGreenButton( AnalyzerView.GetChangeAmount( <amount> ) ); }
VOID HandleWheelman::OnWheel4(amount)		{ AnalyzerView.OnBlueButton( AnalyzerView.GetChangeAmount( <amount> ) ); }
VOID HandleWheelman::OnButton1()			{ AnalyzerView.AcceptImageEdits( 0 ); }
VOID HandleWheelman::OnButton2()			{ AnalyzerView.OnNextButton(); }
VOID HandleWheelman::OnButton3()			{ AnalyzerView.OnPrevButton(); }
VOID HandleWheelman::OnButton4()			{ AnalyzerView.ToggleWheelMan(); }
VOID HandleWheelman::ToggleWheelmanMode()
{
	if ( <Port> > 0 )
	{
		WheelManMode = !<WheelManMode>;
		InputDevice( WriteString,0,<WheelManMode> ? ~M~ : ~m~ );
	}
}

VOID OpenOrderWheel::OnWheel1(amount)		{ OpenDlg.OnChangeOrder( 0 - <amount> ); }
VOID OpenOrderWheel::OnButton1()			{ OpenDlg.OnOpenButton(); }
VOID OpenOrderWheel::OnButton2()			{ OpenDlg.OnChangeOrder( 1 ); }
VOID OpenOrderWheel::OnButton3()			{ OpenDlg.OnChangeOrder( -1 ); }

VOID RecallWheel::OnWheel1(amount)			{ RecallDlg.OnChangeCorrection( 0 - <amount> ); }
VOID RecallWheel::OnButton1()				{ RecallDlg.OnOpenButton(); }
VOID RecallWheel::OnButton2()				{ RecallDlg.OnChangeCorrection( 1 ); }
VOID RecallWheel::OnButton3()				{ RecallDlg.OnChangeCorrection( -1 ); }

VOID RecallRefWheel::OnWheel1(amount)		{ RecallRefDlg.OnChangeRef( 0 - <amount> ); }
VOID RecallRefWheel::OnButton1()			{ RecallRefDlg.OnOpenButton(); }
VOID RecallRefWheel::OnButton2()			{ RecallRefDlg.OnChangeRef( 1 ); }
VOID RecallRefWheel::OnButton3()			{ RecallRefDlg.OnChangeRef( -1 ); }
VOID RecallRefWheel::OnButton4()			{ RecallRefDlg.SelectNextType(); }

VOID ApplyAllWheel::OnButton1()				{ ApplyAllDlg.OnOpenButton(); }
VOID ApplyAllWheel::OnButton2()				{ ApplyAllDlg.OnChangeApplyType( 1 ); }
VOID ApplyAllWheel::OnButton3()				{ ApplyAllDlg.OnChangeApplyType( 0 ); }

VOID FinishWheel::OnButton1()				{ FinishDlg.OnOpenButton(); }
VOID FinishWheel::OnButton2()				{ FinishDlg.OnChangeFinishType( 1 ); }
VOID FinishWheel::OnButton3()				{ FinishDlg.OnChangeFinishType( 0 ); }

VOID DeleteOrderWheel::OnWheel1(amount)		{ DeleteDlg.OnChangeOrder( 0 - <amount> ); }
VOID DeleteOrderWheel::OnButton1()			{ DeleteDlg.OnCloseButton(); }
VOID DeleteOrderWheel::OnButton2()			{ DeleteDlg.OnChangeOrder( 1 ); }
VOID DeleteOrderWheel::OnButton3()			{ DeleteDlg.OnChangeOrder( -1 ); }

/****************************************************
 *************** Context menu support ***************
 ****************************************************/

Class( AnalyzerMenu, Extends, BaseMenu );

VOID AnalyzerMenu::AddMenuItems()
{
	// Add items to image context menu
	Action = ACTION EXEC ( AnalyzerView.RotateImage(90) );
	AddMenuItem( TRUE, FALSE, Translate( ~Rotate Clockwise~ ), Action );

	Action = ACTION EXEC ( AnalyzerView.RotateImage(180) );
	AddMenuItem( TRUE, FALSE, Translate( ~Rotate 180~ ), Action );

	Action = ACTION EXEC ( AnalyzerView.RotateImage(270) );
	AddMenuItem( TRUE, FALSE, Translate( ~Rotate Counter-Clockwise~ ), Action );

	AddMenuSeparator( View );

	//Action = ACTION EXEC ( AnalyzerView.ExternalCrop() );		// V5.1
	//AddMenuItem( TRUE, FALSE, Translate( ~Crop~ ), Action );	// V5.1

	Action = ACTION EXEC ( AnalyzerView.MakeReference() );
	AddMenuItem( TRUE, FALSE, Translate( ~Make Reference Image~ ), Action );

	Action = ACTION EXEC ( AnalyzerView.AddThumbnail() );
	AddMenuItem( TRUE, FALSE, Translate(~Add Thumbnail~), Action );

	Action = ACTION EXEC ( AnalyzerView.SetInputProfileForImage() );
	AddMenuItem( TRUE, FALSE, Translate(~Set ICC Input Profile~), Action );

	Action = ACTION EXEC ( AnalyzerView.OpenAnImageExternal() );
	AddMenuItem( TRUE, FALSE, Translate(~Retouch~), Action );
}

VOID Analyzer::ImageContextMenu()
{
	if ( ValidateOrderID() )
	{
		AnalyzerMenu( New, theMenu );
		DataWindow( GetViewOfWindow, View, View1 );	
		theMenu.DisplayInView( View1 );
	}
}


Class( ReferenceMenu, Extends, BaseMenu );

VOID ReferenceMenu::AddMenuItems()
{
	// Add items to reference context menu
	Action = ACTION EXEC ( AnalyzerView.RecallReference() );
	AddMenuItem( TRUE, FALSE, Translate( ~Recall Reference Image~ ), Action );
}

VOID Analyzer::RefContextMenu()
{
	if ( KeyState( Shift ) && KeyState( Control ) && KeyState( Alt ) )
	{
		EnableDebug();
	}
	else
	{
		ReferenceMenu( New, theMenu );
		DataWindow( GetViewOfWindow, View, View1 );	
		theMenu.DisplayInView( View1 );
	}
}


Class( DebugMenu, Extends, BaseMenu );

VOID SetSerialPort( Port )
{
	AnalyzerView.SetWheelmanPort( <Port> );
	AnalyzerView.EnableWheelman();
}

VOID DebugMenu::AddMenuItems()
{
	ReturnOnFailure( DefinedAndNotNull( AnalyzerDebug ) );

	// Add items to debug menu
	Action = ACTION EXEC ( StopPrinter() );
	AddMenuItem( TRUE, FALSE, Translate( ~Stop Printer~ ), Action );

	Action = ACTION EXEC ( StartPrinter() );
	AddMenuItem( TRUE, FALSE, Translate( ~Start Printer~ ), Action );

	AddMenuSeparator( View );

	Action = ACTION DOC ( AllOrders Open SearchDoc "Search(Orders);" );
	AddMenuItem( TRUE, FALSE, Translate( ~Search Orders~ ), Action );

	Action = ACTION DOC ( AllOrders Open SearchDoc "Search(JobQueue);" );
	AddMenuItem( TRUE, FALSE, Translate( ~Search Job Queue~ ), Action );

	ComputerName = ~<$app.ComputerName>~;
	if ( strlen( ~<ComputerName>~ ) > 24 )
	{
		substr( ~<ComputerName>~, 0, 24, ComputerName );
	}
	Action = ACTION DOC ( Printers Open PrintersDoc "Init( ~~,~Select * From Printers WHERE PrinterName = 'KPDAW_<ComputerName>' Order By PrinterName~);" );
	AddMenuItem( TRUE, FALSE, Translate( ~KPDAW Renderer~ ), Action );

	Action = ACTION DOC ( AllWorkstationSettings OpenOnce WorkstationSettingsDoc "Init( ~~,~Select * From WorkstationSettings Order By Computer,Category,Item~);" );
	AddMenuItem( TRUE, FALSE, Translate( ~Workstation Settings~ ), Action );

	AddMenuSeparator( View );
	Action = ACTION EXEC ( SetSerialPort( 1 ) );
	AddMenuItem( TRUE, FALSE, Translate( ~Serial Wheelman Port 1~ ), Action );

	Action = ACTION EXEC ( SetSerialPort( 2 ) );
	AddMenuItem( TRUE, FALSE, Translate( ~Serial Wheelman Port 2~ ), Action );

	Action = ACTION EXEC ( SetSerialPort( 3 ) );
	AddMenuItem( TRUE, FALSE, Translate( ~Serial Wheelman Port 3~ ), Action );

	Action = ACTION EXEC ( SetSerialPort( 4 ) );
	AddMenuItem( TRUE, FALSE, Translate( ~Serial Wheelman Port 4~ ), Action );

	AddMenuSeparator( View );

	Action = ACTION DOC ( TraceDoc OpenOnce TraceDoc );
	AddMenuItem( TRUE, FALSE, Translate( ~Trace...~ ), Action );

	if ( AnalyzerView.ValidateOrderID() )
	{
		AddMenuSeparator( View );

		Action = ACTION EXEC ( AnalyzerView.RenderImage( ~<LastImagePath>~, ~~ ) );
		AddMenuItem( TRUE, FALSE, Translate( ~Render Image~ ), Action );
	}
}

VOID Analyzer::ShowDebugMenu()
{
	DebugMenu( New, theMenu );
	DataWindow( GetViewOfWindow, View, VIew1 );
	theMenu.DisplayInView( View1 );
}


VOID Analyzer::EnableDebug()
{
	if ( Defined( AnalyzerDebug ) )
	{
		AnalyzerDebug = !<AnalyzerDebug>;
	}
	else
	{
		AnalyzerDebug = TRUE;
		Global( AnalyzerDebug );
	}
	View( ShowControls, <AnalyzerDebug>, DebugText);
}


/**********************************************
 *************** Thread support ***************
 **********************************************/

NUMERIC ThumbThread::HandleMsg( Msg, lparam, wparam )
{
	Path = ImageThread.Dequeue();
	while ( !IsNULL( ~<Path>~ ) )
	{
		Result = AddThumbNailToImage( ~<Path>~, <SysThumbnailSize>, <SysThumbnailQuality>, FileType, Width, Length, PreviewWidth, PreviewLength );
		if ( !<Result> )
		{
			GetLastError( ErrorString, err );
		}
		Path = ImageThread.Dequeue();
	}
//	Warning( ~Adding thumbnails to images is finished.~ );
	Abort();

	return TRUE;
}


Include: ~AnalyzerCrop~;

VOID Analyzer::ExternalCrop()
{ 
	Open( Any, ~<LastImagePath>~ );
	Queue( ~<THIS>.SetCrop();~ );
}		// V5.1

NUMERIC RecordAction( OrderID, ActionToRecord )
{
    // Check we have a valid Order ID
    if (!DefinedAndNotNULL( OrderID ))
    {
        Log( Session, ~RecordAction:********* NULL OrderID passed to RecordAction !!!!!~ );
        return FALSE;
    }

    connected = ADO( database,Connect );
    if ( !<connected> ) 
    {
        Log( Session, ~RecordAction:********* Could not connect to database !!!!!~ );
        return FALSE;
    }

    Cmd = ~Insert into AnalyzerTrack (OrderID, ActionTime, Action, UserID) values ('<OrderID>', getdate(), '<ActionToRecord>', '<$App.UserName>')~;

    Log( Session, ~RecordAction:********* Updating AnalyzerTrack for <OrderID> to <ActionToRecord> for "<$App.UserName>"~ );
    database( BeginTransaction );
    if ( !database( CMD, ~<cmd>~ ) )
    {
        Log( Session, ~RecordAction:********* FAILED to Change AnalyzerTrack for OrderID <OrderID> !!!!!~ );
        database( RollBackTransaction );
        return FALSE;
    }
    database( CommitTransaction );
    return TRUE;
}




/******************************************************
 *************** Start analyzer script ****************
 ******************************************************/

// Define and initialize global variables
Tab = chr(9);
EnterChr = chr(13);
LineChr = chr(10);
Tilda = chr(126);
OrderID = ~~;
Roll = ~~;
Frame = ~~;
CustomerID = ~~;
WhichAnalyzerView = 0;
PermanentSymbol( WhichAnalyzerView );
LastRefPath = ~~;
LastUsed = 0;
ModifiedFlag = FALSE;
OrigStatus = ~~;
ExtRenderOption = 0;
ExtRenderPath = ~~;
ExtTextPath = ~~;
ExtTextCheck = FALSE;
ExtDeleteOld = FALSE;
ExtEnableCropping = FALSE;
ExtFileOption = 0;
ExtSaveFileType = "TIFF";
ExtProfileOption = 0;
ExtRenderProfile = ~~;
SysThumbnailSize = 500;
SysThumbnailQuality = 100;
RenderFlag = ~Imported by KPDAW, Render Folder:~;
BigStep = 0;
MESSAGE_THUMB_START = 1000;
WheelChange = 1;
ImageLoaded = FALSE;
ImageAccepted = FALSE;
TopOfImage = 250;
InitialTopOfImage = 250;
AnalyzeHeight = 0;
AnalyzeWidth = 0;
ReferenceHeight = 0;
ReferenceWidth = 0;

KPDAWRender = FALSE;
ExtHoldCorrectionMode = FALSE;
ExtAutoBalFirst = FALSE;
ExtSbaLevel = 0;		// DRGB
ExtAllowResetOfNoPrint = TRUE;
ExtPreserveCheck = FALSE;
ExtKeepCorrection = FALSE;
ExtShowOnlyImagesToAdjust = FALSE;
ExtIgnoreAdjustImagesFlag = FALSE;
ExtAutoBalPreference = ~~;
UserChange = ~~;
DeltaDRGB = ~~;
PreDP2_42 = FALSE;
TotalImageEdits = 0;
BillionEdits = 0;

MESSAGE_START_THUMBS = 1000;
MESSAGE_ABORT_THUMBS = 1001;

// Light Table global variables
LastImageSel = ~~;
ExtRefImage = ~~;

// Temporary values for color changes
tDensity = 0;
gOldDensity = 0;
tRed = 0;
gOldRed = 0;
tGreen = 0;
gOldGreen = 0;
tBlue = 0;
gOldBlue = 0;
tContrast = 0;
gOldContrast = 0;
tSaturation = 0;
gOldSaturation = 0;
tGamma = 0.1;
tGamma = 0.0;
gOldGamma = 0.1;
gOldGamma = 0.0;
gOldRotation = 0;

// Prompt values
pNum0		= ~0~;
pNum1		= ~1~;
pNum2		= ~2~;
pNum3		= ~3~;
pNum4		= ~4~;
pNum5		= ~5~;
pNum6		= ~6~;
pNum7		= ~7~;
pNum8		= ~8~;
pNum9		= ~9~;
pNum0_2		= ~)~;
pNum1_2		= ~!~;
pNum2_2		= ~@~;
pNum3_2		= ~#~;
pNum4_2		= ~$~;
pNum5_2		= ~%~;
pNum6_2		= ~^~;
pNum7_2		= ~&~;
pNum8_2		= ~*~;
pNum9_2		= ~(~;
pDensity	= ~.~;
pDensity2	= ~,~;
pThumbUp	= ~>~;
pThumbDown	= ~<~;
pRed		= ~R~;
pRed2		= ~I~;
pGreen		= ~G~;
pGreen2		= ~J~;
pBlue		= ~B~;
pBlue2		= ~K~;
pPrint		= ~`~;
pNoPrint	= ~;~;
pNext		= ~\~;
pNext2		= ~|~;
pPrev		= ~/~;
pPrev2		= ~?~;
pMode		= ~]~;
pViewMode	= ~}~;
pMakeRef	= ~E~;
pRecallRef	= ~F~;
pRotate90	= ~W~;
pRotate180	= ~V~;
pRotate270	= ~U~;
pStore		= ~S~;
pRecall		= ~C~;
pRecallLast	= ~L~;
pApplyAll	= ~A~;
pOpen		= ~O~;
pReset		= ~Z~;
pPlus		= ~+~;
pMinus		= ~-~;
pAutoBal	= ~X~;
pViewChanges = ~Q~;

AskAutoBalOff = ~Are you sure you want to turn off automatic auto balance?~;



// Maximum field size values
OrderIDLength = strlen(~<$[DATABASE FieldTypes].OrderID[Mask]>~);
FrameLength = strlen(~<$[DATABASE FieldTypes].Frame[Mask]>~);
CorrectionLength = 50;

ThisView = ~AnalyzerView~;
DebugModeChar = ~T~;
if ( KeyState( Shift ) && KeyState( Control ) && KeyState( Alt ) )
{
	AnalyzerDebug = TRUE;
	DebugModeChar = ~F~;
}

// Define image edit data structure
Define: ImageEditData Using DDImageEdit Private
		Fields:	orgD			64
				orgGamma		1.0
				orgGammaRed		1.0	
				orgGammaGreen	1.0	
				orgGammaBlue	1.0 ;	// all other fields default to 0 or NULL

Define: ImageEditTemp Using DDImageEdit Private
		Fields:	orgD			64
				orgGamma		1.0
				orgGammaRed		1.0	
				orgGammaGreen	1.0	
				orgGammaBlue	1.0 ;	// all other fields default to 0 or NULL

// Load Options and start rendering engine if selected
LoadOptions();

ScreenWidth = App( Application, MainWindow, GetClientWidth ) - 4;
ScreenHeight = Application( MainWindow, GetClientHeight ) - 39;

LightTable( New, LightTableView );

VOID StartLightTable()
{
	ThisView = ~LightTableView~;

	InitLightTable( ~~, ~~, ~~, RefImage, RefPath, FALSE );
	LightTableView( ShowWindow,FALSE );	
	CreateData();

	LightTableView.DefineLastCorrections();
}

Analyzer( New, AnalyzerView );

VOID StartAnalyzer(NewOrderID)
{
    Log(Session, ~***********************************************************************~);
    Log(Session, ~          Analyzer Dialog Opened (<AnalyzerVersion>)~);
    Log(Session, ~***********************************************************************~);

	ThisView = ~AnalyzerView~;

	AnalyzerView.DefineWindow();
	AnalyzerView.Init();
	//AnalyzerView.GetWheelmanPort();
	CreateData();
	AnalyzerView.DefineLastCorrections();

	AnalyzerView.SelectFirstReference();
	AnalyzerView.SetToolbarState();
	AnalyzerView.SetKeepLastCorrectionCheckBox();

	AnalyzerView.LoadTotalImageEdits();

	AnalyzerView.ResizeToFitScreen();
}

FirstTime = TRUE;

VOID Initialize(WhichView,OrderID)
{
	ImageEditData( InitCorrectionsLUT, ~cLut~ );
	ImageEditTemp( InitCorrectionsLUT, ~cLut~ );

	if ( !<FirstTime> )
	{
		OpenAnOrder(~<OrderID>~);
		return;
	}

	FirstTime = FALSE;

	if ( SimilarStr( ~<WhichView>~,~Analyzer~ ) )
	{
		StartAnalyzer();

		OpenAnOrder(~<OrderID>~);
	}
	else
	{
		StartLightTable();
	}

	SetEnableCropping();
}


if ( !<DP2> )
{
	app( Application );

	ImageEditData( InitCorrectionsLUT, ~cLut~ );
	ImageEditTemp( InitCorrectionsLUT, ~cLut~ );

	Application( MainMenu, Enable, FALSE, ViewMainView );
	Application( MainMenu, Check, TRUE, ViewMainView );

	Application( MainMenu, Enable, TRUE, ViewLightTable );
	Application( MainMenu, Check, FALSE, ViewLightTable );

	EnableCorrectWindow( FALSE, 1 );

	StartAnalyzer();

	ChangeResolution();

	AnalyzerView.SetEnableCropping();

	DisplayStepIndicator();

	LoadMainSize();
	AnalyzerView.ChangeImageSize( 0, 1 );

	OpenAnOrder();

	SetEnableCropping();
}
else	// Running in and MDI environment
{
	if ((~<$App.Name>~ !=~DP1.exe~) && (!GetUserPermissions( ImageEditing ) ))
	{
		Warning( Translate( ~You don't have permission to edit images.  See your administrator.~ ) );
		Exit();
	}

	FirstTime = TRUE;
	//Action = ACTIONS ( CloseAllWindows );
	//PerformActions( Action );
	//HideAppToolBar();
}
