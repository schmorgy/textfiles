

Include: ~UtilityRoutines~;

IncludeClass( BaseForm );
IncludeClass( BaseDialog );
IncludeClass( BasePattern );

Class( PatternEditor,Extends,BaseForm,
		Member,ButtonX,Numeric,5,
		Member,ButtonY,Numeric,5,
		Member,ButtonLeft,Numeric,5,
		Member,ButtonRight,Numeric,0,
		Member,ButtonFarRight,Numeric,0,
		Member,ControlButtonWidth,Numeric,80,
		Member,ControlButtonHeight,Numeric,22,
		Member,CntrlColorR,Numeric,190,Member,CntrlColorG,Numeric,190,Member,CntrlColorB,Numeric,190,
		Member,Rows,Numeric,10,
		Member,Cols,Numeric,10,
		Member,NodeWidth,Numeric,40,
		Member,LastRow,Numeric,5,
		Member,LastCol,Numeric,5,Member,CountableColorR,Numeric,200,
		Member,CountableColorG,Numeric,230,Member,CountableColorB,Numeric,230,
		Member,TTColorR,Numeric,190,Member,TTColorG,Numeric,170,Member,TTColorB,Numeric,230,
		Member,BTColorR,Numeric,190,Member,BTColorG,Numeric,170,Member,BTColorB,Numeric,230,
		Member,TBColorR,Numeric,190,Member,TBColorG,Numeric,170,Member,TBColorB,Numeric,230,
		Member,T1ColorR,Numeric,130,Member,T1ColorG,Numeric,150,Member,T1ColorB,Numeric,230,
		Member,BBColorR,Numeric,230,Member,BBColorG,Numeric,230,Member,BBColorB,Numeric,230,
		Member,I1ColorR,Numeric,30,Member,I1ColorG,Numeric,200,Member,I1ColorB,Numeric,230,
		Member,Z1ColorR,Numeric,70,Member,Z1ColorG,Numeric,140,Member,Z1ColorB,Numeric,230,
		Member,F1ColorR,Numeric,200,Member,F1ColorR,Numeric,230,Member,F1ColorR,Numeric,230,
		Member,SelectedColorR,Numeric,255,Member,SelectedColorG,Numeric,255,Member,SelectedColorB,Numeric,0,
		Member,BGColorR,Numeric,230,Member,BGColorG,Numeric,230,Member,BGColorB,Numeric,230,
		Member,NewMouseOver,Numeric,TRUE,
		Member,CountableNodes,Numeric,0 ,
		Member,RowList,Object,StringList,
		Member,fDirectory,Str,~~,
		Member,fPatternPath,Str,~~,
		Member,fPatternFile,Str,~~,
		Member,fPattern,Object,BasePattern,
		Member,fMaxNode,Numeric,0,
		Member,fMidPoint,Numeric,0,
		Member,fDirty,Numeric,0,
		Member,fUndo,Numeric,0,
		Member,fMaxUndo,Numeric,0,
		Member,fLastSelected,Numeric,0,
		Member,fUndoDirectory,Str,~<$App.Directory>\PatternUndo\<$Doc.This>~,
		Member,fCleanupUndo,Numeric,TRUE,
		Member,fAvailableControls,Object,StringList,Constructor,New,
		Member,fFeaturedNodeName,Str,~Featured~
	 );

VOID PatternEditor::PatternEditor()
{ 
	HelpPage = ~PatternEditor.htm~;
	SystemParametersInfo( SetMouseHoverTime,100 );

	ButtonRight = $ButtonX + $ControlButtonWidth + $hGap;
	ButtonFarRight = $ButtonRight + $ControlButtonWidth + $hGap;
	InitUndo();
	if ( GetSystemSettings( ~GridLayouts~,~FeaturedNodeName~,Featured,Enabled ) )
	{
		if (!IsNull(~<Featured>~))
		{
			fFeaturedNodeName = ~<Featured>~;
		}
	}
	InitNodeColors();
}

VOID PatternEditor::InitNodeColors()
{
	DefineNodeDict();
	if (!Defined(fNodeTypeColors))
	{
		GenCon(fNodeTypeColors,New,DDNodeColorDict);
		Private(fNodeTypeColors);
	}
	
	fNodeTypeColors(Set,CountableColorR,200);
	fNodeTypeColors(Set,CountableColorG,230);
	fNodeTypeColors(Set,CountableColorB,230);

	fNodeTypeColors(Set,TTColorR,190);
	fNodeTypeColors(Set,TTColorG,170);
	fNodeTypeColors(Set,TTColorB,230);
	
	fNodeTypeColors(Set,BTColorR,190);
	fNodeTypeColors(Set,BTColorG,170);
	fNodeTypeColors(Set,BTColorB,230);
	
	fNodeTypeColors(Set,TBColorR,190);
	fNodeTypeColors(Set,TBColorG,170);
	fNodeTypeColors(Set,TBColorB,230);
	
	fNodeTypeColors(Set,T1ColorR,130);
	fNodeTypeColors(Set,T1ColorG,150);
	fNodeTypeColors(Set,T1ColorB,230);
	
	fNodeTypeColors(Set,BBColorR,230);
	fNodeTypeColors(Set,BBColorG,230);
	fNodeTypeColors(Set,BBColorB,230);
	
	fNodeTypeColors(Set,I1ColorR,30);
	fNodeTypeColors(Set,I1ColorG,200);
	fNodeTypeColors(Set,I1ColorB,230);
	
	fNodeTypeColors(Set,Z1ColorR,70);
	fNodeTypeColors(Set,Z1ColorG,140);
	fNodeTypeColors(Set,Z1ColorB,230);
		
	fNodeTypeColors(Set,F1ColorR,200);
	fNodeTypeColors(Set,F1ColorG,230);
	fNodeTypeColors(Set,F1ColorB,230);

}

NUMERIC PatternEditor::IsDirty() 
{
	return <fDirty>;
}

VOID PatternEditor::WindowDefinition()		
{

	ScreenWidth = App( thisApp,MainWindow,GetClientWidth );
	ScreenHeight = thisApp( MainWindow,GetClientHeight );
	Private(ScreenWidth,ScreenHeight);

	if (<ScreenWidth> >= 1280)
	{

	Fields:	Title 					~Pattern Editor~
			TypeName				SplitterWnd
			SplitterRows			1
			SplitterColumns			~2 33 67~
			EnableStatusBar			T
			Position				5 5 65 82
			NoWindowPositionAdjust	!Keystate( Control )
			DropActionsText			ACTION EXEC ( <THIS>.HandleDrop() )	
	}
	else
	{
	Fields:	Title 					~Pattern Editor~
			TypeName				SplitterWnd
			SplitterRows			1
			SplitterColumns			~2 33 67~
			EnableStatusBar			T
			Position				5 0 87 99
			NoWindowPositionAdjust	!Keystate( Control )
			DropActionsText			ACTION EXEC ( <THIS>.HandleDrop() )	
	}
}

VOID PatternEditor::ViewDefinitionData()		
{ 
	Fields:	BackgroundColor		~<BGColorR>,<BGColorG>,<BGColorB>~
			//CloseActionsText	ACTION CALL ( <THIS>.OnCloseDataWindow() )			
}

VOID PatternEditor::ViewDefinitionControl()		
{ 
	Fields:	BackgroundColor		~230,230,230~			
}

TotalAllowed = 1500;
// To allow more than 1500 nodes to be generated,
// open job.txt and change MaxGridNodes gencon value
// to 1500.

VOID PatternEditor::DefineMessages()		
{ 
	BaseForm::DefineMessages();	

	// Error Messages
	
	Translations( AddText,NodeNameNull,~You must enter a node name~ );	
	Translations( AddText,NothingSelected,~Nothing was selected~ );

	Translations( AddText,NodeNameInUse,~Node name is already in use~ );
	Translations( AddText,SelectTwoNodes,~You must select two countable nodes.  Countable nodes have a number in them.~ );
	Translations( AddText,DeltaSizeNull,~You must enter a delta size in percent~ );	
	Translations( AddText,NoMoreControls,~You cannot add any more nodes. If you close the pattern and re-open it, you may add more nodes up to a maximum limit of <TotalAllowed>.~ );		

	// Controls

	Translations( AddText,Open,~&Open~ );
	Translations( AddText,OpenToolTip,~Open a new pattern~ );

	Translations( AddText,Save,~&Save~ );	
	Translations( AddText,SaveToolTip,~Save your changes to disk~ );
	
	Translations( AddText,SaveAs,~Save As~ );	
	Translations( AddText,SaveAsToolTip,~Save your changes to a disk file~ );

	Translations( AddText,Revert,~Revert~ );	
	Translations( AddText,RevertToolTip,~Load the last saved copy of the pattern from disk~ );

	Translations( AddText,ViewAsText,~&View As Text~ );		
	Translations( AddText,ViewAsTextToolTip,~Open the last saved copy of the pattern in NotePad~ );
	
	Translations( AddText,Undo,~Undo    &Z~ );		
	Translations( AddText,UndoToolTip,~Undo the last change you made~ );

	Translations( AddText,Redo,~Redo    &Y~ );		
	Translations( AddText,RedoToolTip,~Redo the next change that you un-did~ );

	Translations( AddText,Next,~&Next~ );	
	Translations( AddText,NextToolTip,~Open the pattern with one more countable node~ );
		
	Translations( AddText,Previous,~&Previous~ );
	Translations( AddText,PreviousToolTip,~Open the pattern with one less countable node~ );
	
	Translations( AddText,Goto,~&Goto~ );
	Translations( AddText,GotoToolTip,~Open the pattern with the number of countable nodes you have specified~ );
	
	Translations( AddText,SelectRow,~Select Row~ );
	Translations( AddText,SelectRowToolTip,~Select all nodes in the row that you have selected~ );

	Translations( AddText,SelectColumn,~Select Column~ );
	Translations( AddText,SelectColumnToolTip,~Select all nodes in the column that you have selected~ );

	Translations( AddText,SelectNone,~Select None~ );
	Translations( AddText,SelectNoneToolTip,~Deselect everything~ );

	Translations( AddText,Countable,~Countab&le~ );
	Translations( AddText,CountableToolTip,~Make the selected nodes countable~ );

	Translations( AddText,Blank,~&Blank~ );
	Translations( AddText,BlankToolTip,~Make the selected nodes blank.  Blank nodes occupy space, but do not contain an image or text.~ );

	Translations( AddText,Title,~&Title~ );
	Translations( AddText,TitleToolTip,~Make the selected nodes a title.  Title is the same as TT in KPIS layouts.~ );

	Translations( AddText,LeftHalfTitle,~Left Half Title~ );
	Translations( AddText,LeftHalfTitleToolTip,~Make the selected node a title node that is blank on the left half.  Title is the same as BT in KPIS layouts.~ );

	Translations( AddText,RightHalfTitle,~Right Half Title~ );
	Translations( AddText,RightHalfTitleToolTip,~Make the selected node a title node that is blank on the right half.  Title is the same as TB in KPIS layouts.~ );

	Translations( AddText,Text,~Te&xt~ );
	Translations( AddText,TextToolTip,~Make the selected nodes fixed text.  Text is the same as T1, T2, etc in KPIS layouts.~ );

	Translations( AddText,Image,~Ima&ge~ );
	Translations( AddText,ImageToolTip,~Make the selected nodes fixed image.  Text is the same as I1, I2, etc in KPIS layouts.~ );

	Translations( AddText,ImageText,~Image+Text~ );
	Translations( AddText,ImageTextToolTip,~Make the selected nodes fixed image and text.  These are not countable nodes, but they have the same dimensions as countable nodes.~ );

	Translations( AddText,Featured,~Featured~ );
	Translations( AddText,FeaturedToolTip,~Make the selected node a featured node.  There can be at most one featured node in a pattern.~ );

	Translations( AddText,AddColumn,~&Add~ );
	Translations( AddText,AddColumnToolTip,~Add a new node at the end of the currently selected row.~ );

	Translations( AddText,AddRow,~A&dd Bottom~ );
	Translations( AddText,AddRowToolTip,~Add a new node on a new row.~ );

	Translations( AddText,Remove,~&Remove~ );
	Translations( AddText,RemoveToolTip,~Remove the selected nodes from the layout.~ );

	Translations( AddText,RemoveSave,~Remove/Save~ );
	Translations( AddText,RemoveSaveToolTip,~Remove the selected nodes from the pattern and save.~ );

	Translations( AddText,AddNewRow,~Add Row~ );
	Translations( AddText,AddnewRowToolTip,~Add a new row of nodes.~ );

	Translations( AddText,AddNewCol,~Add Column~ );
	Translations( AddText,AddNewColToolTip,~Add a new column of nodes.~ );

	Translations( AddText,Swap,~S&wap~ );
	Translations( AddText,SwapToolTip,~Swap the node numbers of two countable images~ );

	Translations( AddText,Shuffle,~S&huffle~ );
	Translations( AddText,ShuffleToolTip,~Swap the node numbers of two countable images and shift the intermediate images up by one node number~ );

	Translations( AddText,Resequence,~Resequence~ );
	Translations( AddText,ResequenceToolTip,~Sequence the countable node numbers starting from 1 in the upper left corner.~ );

	Translations( AddText,NodeName,~Node Name~ );
	Translations( AddText,NodeNameToolTip,~Assign a name to one or more nodes~ );

	Translations( AddText,DeltaXY,~Delta XY~ );
	Translations( AddText,DeltaXYToolTip,~Change the position (x,y) of a node by a fixed percentage.~ );

	Translations( AddText,DeltaWL,~Delta WL~ );
	Translations( AddText,DeltaWLToolTip,~Change the size (width,length) of a node by a fixed percentage.~ );

	Translations( AddText,ImportKPISPattern,~Import KPIS Pattern~ );
	Translations( AddText,ImportKPISPatternToolTip,~Invoke a dialog that allows you to convert KPIS pattern files to DP2 Patterns.~ );

	Translations( AddText,CreateGridLayouts,~Create Grid Layouts~ );
	Translations( AddText,CreateGridLayoutsToolTip,~Invoke a dialog that allows you to create grid layouts from patterns.~ );

	Translations( AddText,GotoFieldToolTip,~Enter the number of variable positions in the grid layout you wish to go to.~ );

	Translations( AddText,GotoFieldToolTip,~Enter the number of variable positions in the grid layout you wish to go to.~ );
	Translations( AddText,TextNFieldToolTip,~An incrementing number that identifies a text node~ );
	Translations( AddText,ImageNFieldToolTip,~An incrementing number that identifies a image node~ );
	Translations( AddText,ImageTextNFieldToolTip,~An incrementing number that identifies a image and text node~ );

	Translations( AddText,NodeNameFieldToolTip,~Enter the name for the node~ );
	Translations( AddText,xDeltaSizeFieldToolTip,~Enter the percentage (of a single node + gap) to move the node in the horizontal direction.  100 percent would overlap the node to the right.~ );
	Translations( AddText,yDeltaSizeFieldToolTip,~Enter the percentage (of a single node + gap) to move the node in the vertical direction.  100 percent would overlap the node to the bottom.~ );

	Translations( AddText,wDeltaSizeFieldToolTip,~Enter a percentage of the node width to change the width of the node.~ );
	Translations( AddText,lDeltaSizeFieldToolTip,~Enter a percentage of the node height to change the length of the node~ );
}

VOID PatternEditor::AddControlButton( XPos,BumpY,Name,theText )
{
	Define: <Name> Using DDWinCtrlDef AsSymbol <Name> Private
		Fields:	TYPENAME		Button
				POSITION		<XPos>, $ButtonY, $ControlButtonWidth, $ControlButtonHeight
				TEXT			Translate( Translations,<theText> )
				TOOLTIP			Translate( Translations,<theText>ToolTip )
				BGColorRed		<CntrlColorR> BGColorGreen <CntrlColorG> BgColorBlue <CntrlColorB>
				TextBGColorRed	<CntrlColorR> TextBGColorGreen <CntrlColorG> TextBgColorBlue <CntrlColorB>
				IsTabStop		0
				DACTIONSTEXT	ACTION EXEC ( <THIS>.On<Name>() )	;
				
	if ( <BumpY> )
	{
		ButtonY = $ButtonY + 22 + 2;
	}					
}

VOID PatternEditor::AddMaskedEditField( Name,Xpos,Ypos,Width,Mask,AllowedChars )
{
	Define: <Name> Using DDWinCtrlDef AsSymbol <Name> Private
		Fields:	TYPENAME		MaskedEditText
				POSITION		<Xpos> <Ypos> <Width> 20
				TEXT			~~
				MASK			~<Mask>~
				ALLOWEDCHARS	~<AllowedChars>~
				TOOLTIP			Translate( Translations,<Name>ToolTip )
				IsTabStop		1

}


// Paul Forleo 6/3/02  attempt to turn node name field into combo box
// This works.  Next improvement:  Save the node names in the database
// by pattern name so that the combo box can be refreshed
// across shutdowns.  I disabled the code for combo boxes today and will get back
// to it later.
// AddComboEditField is only called when node name
// control is a combo box
VOID PatternEditor::AddComboEditField( Name,Xpos,Ypos,Width,Mask,AllowedChars )
{
	Define: <Name> Using DDWinCtrlDef AsSymbol <Name> Private
		Fields:	TYPENAME		ComboBox
				POSITION		<Xpos> <Ypos> <Width> 100
				TEXT			~~
				MASK			~<Mask>~
				ALLOWEDCHARS	~<AllowedChars>~
				GenConField		~NodeName~
				TOOLTIP			Translate( Translations,<Name>ToolTip )
				IsTabStop		1
				IActionsText	ACTION EXEC ( <THIS>.Init<Name>() )
				DActionsText	~[Save]~
				DropDownActionsText	ACTION EXEC ( <THIS>.Display<Name>() )	;

}

VOID PatternEditor::NewSection()		{ ButtonY += $vGap * 2; }

VOID PatternEditor::AddControlsControl()
{
	AddControlButton( $ButtonLeft,FALSE,CreateButton,Open );
	AddControlButton( $ButtonRight,TRUE,SaveButton,Save );
	AddControlButton( $ButtonLeft,FALSE,RevertButton,Revert );
	AddControlButton( $ButtonRight,TRUE,SaveAsButton,SaveAs );
	AddControlButton( $ButtonLeft,FALSE,UndoButton,Undo );
	AddControlButton( $ButtonRight,TRUE,RedoButton,Redo );
	AddControlButton( $ButtonLeft,TRUE,ViewAsTextButton,ViewAsText );	
		
	NewSection();

	CntrlColorR = 220;	CntrlColorG = 220;	CntrlColorB = 190;
	AddControlButton( $ButtonLeft,FALSE,NextButton,Next );		
	AddControlButton( $ButtonRight,TRUE,PrevButton,Previous );	
	AddControlButton( $ButtonLeft,TRUE,GotoButton,GoTo );
	AddMaskedEditField( GotoField,GotoButton(GetRight,Position)+$hGap,GotoButton(GetTop,Position)+2,30,~####~,~~ );

	NewSection();

	CntrlColorR = <SelectedColorR>;	CntrlColorG = <SelectedColorG>;	CntrlColorB = <SelectedColorB>;
	AddControlButton( $ButtonLeft,FALSE,SelectRowButton,SelectRow );
	AddControlButton( $ButtonRight,TRUE,SelectColumnButton,SelectColumn );
	AddControlButton( $ButtonLeft,TRUE,ClearSelectionButton,SelectNone );

	NewSection();

	CntrlColorR = <CountableColorR>;	CntrlColorG = <CountableColorG>;	CntrlColorB = <CountableColorB>;
	AddControlButton( $ButtonLeft,FALSE,CountableImage,Countable );

	CntrlColorR = <BBColorR>;	CntrlColorG = <BBColorG>;	CntrlColorB = <BBColorB>;
	AddControlButton( $ButtonRight,FALSE,BlankButton,Blank );

	CntrlColorR = <CountableColorR>;	CntrlColorG = <CountableColorG>;	CntrlColorB = <CountableColorB>;
	AddControlButton( $ButtonFarRight,TRUE,FeaturedButton,Featured );

	CntrlColorR = <TTColorR>;	CntrlColorG = <TTColorG>;	CntrlColorB = <TTColorB>;
	AddControlButton( $ButtonLeft,TRUE,TitleButton,Title );
	AddControlButton( $ButtonLeft,FALSE,LeftHalfTitleButton,LeftHalfTitle );
	AddControlButton( $ButtonRight,TRUE,RightHalfTitleButton,RightHalfTitle );

	CntrlColorR = <T1ColorR>;	CntrlColorG = <T1ColorG>;	CntrlColorB = <T1ColorB>;
	AddControlButton( $ButtonLeft,TRUE,TextButton,Text );
	AddMaskedEditField( TextNField,TextButton(GetRight,Position)+$hGap,TextButton(GetTop,Position)+2,30,~##~,~~ );

	CntrlColorR = <I1ColorR>;	CntrlColorG = <I1ColorG>;	CntrlColorB = <I1ColorB>;

	AddControlButton( $ButtonLeft,TRUE,ImageButton,Image );
	AddMaskedEditField( ImageNField,ImageButton(GetRight,Position)+$hGap,ImageButton(GetTop,Position)+2,30,~##~,~~ );
	
	CntrlColorR = <Z1ColorR>;	CntrlColorG = <Z1ColorG>;	CntrlColorB = <Z1ColorB>;

	AddControlButton( $ButtonLeft,TRUE,ImageTextButton,ImageText );
	AddMaskedEditField( ImageTextNField,ImageTextButton(GetRight,Position)+$hGap,ImageTextButton(GetTop,Position)+2,30,~##~,~~ );

//	CntrlColorR = <CountableColorR>;	CntrlColorG = <CountableColorG>;	CntrlColorB = <CountableColorB>;
//	AddControlButton( $ButtonLeft,TRUE,FeaturedButton,Featured );

	CntrlColorR = 190;	CntrlColorG = 190;	CntrlColorB = 190;

	NewSection();

	CntrlColorR = 190;	CntrlColorG = 220;	CntrlColorB = 190;

	AddControlButton( $ButtonLeft,FALSE,AddColumnButton,AddColumn );
	AddControlButton( $ButtonRight,TRUE,AddRowButton,AddRow );
	AddControlButton( $ButtonLeft,FALSE,RemoveButton,Remove );
	AddControlButton( $ButtonRight,TRUE,RemoveSaveButton,~RemoveSave~ );

	NewSection();

	AddControlButton( $ButtonLeft,FALSE,AddNewRowButton,AddNewRow );
	AddControlButton( $ButtonRight,TRUE,AddNewColButton,AddNewCol );

	NewSection();

	CntrlColorR = 220;	CntrlColorG = 190;	CntrlColorB = 190;
	AddControlButton( $ButtonLeft,FALSE,SwapButton,Swap );
	AddControlButton( $ButtonRight,TRUE,ShuffleButton,Shuffle );
	AddControlButton( $ButtonLeft,TRUE,ResequenceButton,Resequence );

	CntrlColorR = 190;	CntrlColorG = 190;	CntrlColorB = 190;

	NewSection();

	AddControlButton( $ButtonLeft,TRUE,SetNodeNameButton,NodeName );
	// Paul Forleo 6/3/02  attempt to turn node name field into combo box
	// This works.  Next improvement:  Save the node names in the database
	// by pattern name so that the combo box can be refreshed
	// across shutdowns.  I disabled the code for combo boxes today and will get back
	// to it later
	
	AddComboEditField( NodeNameField,SetNodeNameButton(GetRight,Position)+$hGap,SetNodeNameButton(GetTop,Position)+2,$ControlButtonWidth,RepeatStr(20,~A~),~~ );

	AddControlButton( $ButtonLeft,TRUE,SetDeltaXYButton,DeltaXY );
	AddMaskedEditField( xDeltaSizeField,SetDeltaXYButton(GetRight,Position)+$hGap,SetDeltaXYButton(GetTop,Position)+2,40,~####~,~-.~ );
	AddMaskedEditField( yDeltaSizeField,xDeltaSizeField(GetRight,Position),xDeltaSizeField(GetTop,Position),40,~####~,~-.~ );

	AddControlButton( $ButtonLeft,TRUE,SetDeltaWLButton,DeltaWL );
	AddMaskedEditField( wDeltaSizeField,SetDeltaWLButton(GetRight,Position)+$hGap,SetDeltaWLButton(GetTop,Position)+2,40,~####~,~-.~ );
	AddMaskedEditField( lDeltaSizeField,wDeltaSizeField(GetRight,Position),wDeltaSizeField(GetTop,Position),40,~####~,~-.~ );

	NewSection();

	CntrlColorR = 190;	CntrlColorG = 190;	CntrlColorB = 190;
	
	ControlButtonHeight = 35;

	AddControlButton( $ButtonLeft,FALSE,ImportKPISPatternButton,ImportKPISPattern );
	AddControlButton( $ButtonRight,TRUE,CreateGridLayoutsButton,CreateGridLayouts );
}


VOID PatternEditor::UpdateStatistics()
{
	fPattern.RecalcMaxColumns();

	fPattern.UpdateMaxColumns();

	MaxColumms = fPattern.GetMaxColumns();

	fMidPoint = (<MaxColumms> / 2) * (<NodeWidth> + <hGap>);

	i = 0;

	Rows = fPattern.NumRows();

	while ( <++i> <= <Rows> )
	{
		ColumnsInRow = fPattern.NumColumns(<i>);

		fRowStart<i> = <fMidPoint> - (( <ColumnsInRow> * (<NodeWidth> + $hGap) ) / 2);
		Private( fRowStart<i> );
	}
}

VOID PatternEditor::RepositionControls()
{
	Editor.UpdateStatistics();

	more = fPattern.PositionToFirst();

	while ( <more> )
	{
		ControlNumber = fPattern.GetControlNumber();

		Row = Col = 0;

		fPattern.GetRowCol( Row,Col );

		CalcPosition( <Row>,<Col>,X,Y );

		ViewData( ControlRect,Node<ControlNumber>,SetPosition,<X>,<Y>,<NodeWidth>,<NodeWidth>,FALSE );

		ViewData( ShowControls,TRUE,Node<ControlNumber> );

		more = fPattern.PositionToNext();
	}

	ViewData( RefreshView );
}

VOID PatternEditor::CalcPosition( Row,Col,&X,&Y )
{
	X = <fRowStart<Row>> + (<Col> * (<NodeWidth> + $hGap)) - <NodeWidth>;

	Y = (<Row> - 1) * (<NodeWidth> + $vGap) + $vGap;	
}

VOID PatternEditor::GetNodeColor( &Red,&Green,&Blue )
{
	theType = fPattern.GetPositionType();

	if ( SimilarStr( ~<TheType>~,~TT~,~BB~,~TB~,~BT~,~Countable~,~I1~,~T1~,F ) )
	{
		PosType = fPattern.GetPositionType();
		if (SimilarStr(~<PosType>~,F) )
		{
			Red = ~<CountableColorR>~;
			Green = ~<CountableColorG>~;
			Blue = ~<CountableColorB>~;
		}
		else
		{
			Red = ~<<TheType>ColorR>~;
			Green = ~<<TheType>ColorG>~;
			Blue = ~<<TheType>ColorB>~;
		}
		return;
	}
	else if ( !IsNull(String( BeginsWith,~I~,~<TheType>~ )) )
	{
		Red = ~<I1ColorR>~;
		Green = ~<I1ColorG>~;
		Blue = ~<I1ColorB>~;
		return;
	}
	else if ( !IsNull(String( BeginsWith,~T~,~<TheType>~ )) )
	{
		Red = ~<T1ColorR>~;
		Green = ~<T1ColorG>~;
		Blue = ~<T1ColorB>~;
		return;
	}
	else if ( !IsNull(String( BeginsWith,~Z~,~<TheType>~ )) )
	{
		Red = ~<Z1ColorR>~;
		Green = ~<Z1ColorG>~;
		Blue = ~<Z1ColorB>~;
		return;
	}
}

VOID PatternEditor::AddControlsData()
{
	X = Y = 0;  Row = Col = 0;

	more = fPattern.PositionToControlNumber(<++fMaxNode>);

	while ( <more> )
	{
		fPattern.GetRowCol( Row,Col );

		CalcPosition( <Row>,<Col>,X,Y );

		theText = fPattern.GetNodeText();

		GetNodeColor( R,G,B );

		Define: Node<fMaxNode> Using DDWinCtrlDef AsSymbol Node<fMaxNode> Private
			Fields:	TYPENAME				StaticText
					POSITION				$X,$Y,$NodeWidth,$NodeWidth
					TEXT					~<theText>~
					Sunken					TRUE
					CenterText				TRUE
					FontWeight				600
					MouseOverActionsText	ACTION EXEC ( <THIS>.MouseOver(<fMaxNode>) )
					MouseLeaveActionsText	ACTION EXEC ( <THIS>.MouseLeave(<fMaxNode>) )
					DACTIONSTEXT			ACTION EXEC ( <THIS>.OnNodePressed(<fMaxNode>) )	
					BGColorRed				<R> BGColorGreen <G> BgColorBlue <B>
					TextBGColorRed			<R> TextBGColorGreen <G> TextBgColorBlue <B>;

		more = fPattern.PositionToControlNumber(~<++fMaxNode>~);
	}
	--fMaxNode;
	AddExtraControls();
}

VOID PatternEditor::AddExtraControls()
{
	Last = Min( <TotalAllowed>,<fMaxNode>+100 );

	i = <fMaxNode>;  // fMaxNode is number we have

	while ( <++i> <= <Last> )
	{
		fMaxNode = <i>;

		fAvailableControls( Push,~<fMaxNode>~ );

		Define: Node<fMaxNode> Using DDWinCtrlDef AsSymbol Node<fMaxNode> Private
			Fields:	TYPENAME				StaticText
					POSITION				0-<NodeWidth>,0-<NodeWidth>,$NodeWidth,$NodeWidth
					TEXT					~~
					Sunken					TRUE
					CenterText				TRUE
					IsHidden				T
					FontWeight				600
					MouseOverActionsText	ACTION EXEC ( <This>.MouseOver(<fMaxNode>) )
					MouseLeaveActionsText	ACTION EXEC ( <This>.MouseLeave(<fMaxNode>) )
					DACTIONSTEXT			ACTION EXEC ( <THIS>.OnNodePressed(<fMaxNode>) )	
					BGColorRed				<CountableColorR> BGColorGreen <CountableColorG> BgColorBlue <CountableColorB>
					TextBGColorRed			<CountableColorR> TextBGColorGreen <CountableColorG> TextBgColorBlue <CountableColorB>;
	}
}

VOID PatternEditor::ControlIsAvailable( ControlNumber )
{
	ViewData( ShowControls,FALSE,Node<ControlNumber> );
	fAvailableControls( Push,~<ControlNumber>~ );
}

NUMERIC PatternEditor::GetAvailableControl()
{
	if ( !fAvailableControls( Pop,ControlNumber ) )
	{
		return Warning( Translate( Translations,NoMoreControls ) );
	}

	return <ControlNumber>;
}

VOID PatternEditor::FreeAllControls()
{
	more = fPattern.PositionToFirst();

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		ViewData( ShowControls,FALSE,Node<ControlNumber> );

		fAvailableControls( Push,~<ControlNumber>~ );

		more = fPattern.PositionToNext();
	}
}


VOID PatternEditor::ReloadAllControls()
{
	more = fPattern.PositionToFirst();

	while ( <More> )
	{
		X = Y = Row = Col = 0;

		fPattern.GetRowCol( Row,Col );

		R = G = B = 0;

		GetNodeColor( R,G,B );

		ControlNumber = GetAvailableControl();

		ViewData( SetControlValue,Node<ControlNumber>,fPattern.GetNodeText() );

		ViewData( SetControlColor,Node<ControlNumber>,BgColor,<R>,<G>,<B> );

		ViewData( ControlSelected,Set,FALSE,Node<ControlNumber> );

		CalcPosition( <Row>,<Col>,X,Y );

		ViewData( ControlRect,Node<ControlNumber>,SetPosition,<X>,<Y>,<NodeWidth>,<NodeWidth>,FALSE );

		ViewData( ShowControls,TRUE,Node<ControlNumber> );

		fPattern.SetControlNumber( <ControlNumber> );

		more = fPattern.PositionToNext();
	}
}


VOID PatternEditor::MouseOver(Num)
{
	if ( KeyState( Control ) && <NewMouseOver> )
	{
		NewMouseOver = FALSE;
	}
	else
	{
		fPattern.PositionToControlNumber( <num> );

		Row = 0; col = 0;
		fPattern.GetRowCol( Row,col );

		fPattern.PositionToControlNumber( <num> );

		theType = fPattern.GetPositionType();
		theNodeName = fPattern.GetNodeName();

		if ( !IsNull( ~<theNodeName>~ ) )
		{
			theNodeName = ~The NodeName is '<theNodeName>'~;
		}

		Other = ~~;

		if ( Keystate( Control ) )
		{
			ViewData( ControlRect,Node<num>,GetPosition,X,Y,W,L );
			Other = ~<X>,<Y>,<W>,<L>~;
		}

		X = Y = W = L = 0;
		
		theDeltaSize = ~~;
		
		if ( fPattern.GetDeltaSize( X,Y,W,L ) )
		{
			theDeltaSize = ~Size is altered <X>,<Y>,<W>,<L>~;
		}
		
		if ( fPattern.IsCountable() )
		{
			NodeNumber = fPattern.GetNodeNumber();
			DataWindow( StatusBar,Text,~<Row>,<Col> [<num>]) Countable Image Node <NodeNumber>.  <theNodeName>   <theDeltaSize>   <Other>~ );
		}
		else if ( SimilarStr( ~<TheType>~,~TT~ ) )
		{
			DataWindow( StatusBar,Text,~<Row>,<Col> [<num>]) Main Text Node.   <theNodeName>   <theDeltaSize>   <Other>~ );
		}
		else if ( SimilarStr( ~<TheType>~,~BB~ ) )
		{
			DataWindow( StatusBar,Text,~<Row>,<Col> [<num>]) Blank Node.   <theNodeName>   <theDeltaSize>   <Other>~ );
		}
		else if ( !IsNull( String( BeginsWith,~I~,~<TheType>~) ) )
		{
			DataWindow( StatusBar,Text,~<Row>,<Col> [<num>]) Fixed Image Node <TheType>.   <theNodeName>   <theDeltaSize>   <Other>~ );
		}
		else if ( !IsNull( String( BeginsWith,~F~,~<TheType>~) ) )
		{
			DataWindow( StatusBar,Text,~<Row>,<Col> [<num>]) Featured Node <TheType>.   <theNodeName>   <theDeltaSize>   <Other>~ );
		}
		else if ( !IsNull( String( BeginsWith,~T~,~<TheType>~) ) )
		{
			DataWindow( StatusBar,Text,~<Row>,<Col> [<num>]) Fixed Text Node <TheType>.   <theNodeName>   <theDeltaSize>   <Other>~ );
		}
		else if ( !IsNull( String( BeginsWith,~Z~,~<TheType>~) ) )
		{
			DataWindow( StatusBar,Text,~<Row>,<Col> [<num>]) Fixed Image and Text Node <TheType>.   <theNodeName>   <theDeltaSize>   <Other>~ );
		}
	}
}

VOID PatternEditor::MouseLeave(Num)	
{ 
	NewMouseOver = TRUE;

	Num = fPattern.NumCountableNodes();

	DataWindow( StatusBar,Text,~<Num> Countable Image Nodes~ );
}

VOID PatternEditor::ClearSelection()
{
	ControlNumber = fPattern.GetControlNumber();
	if ( ViewData( ControlSelected,Get,Node<ControlNumber> ) )
	{
		GetNodeColor( R,G,B );
		ViewData( SetControlColor,Node<ControlNumber>,BgColor,<R>,<G>,<B> );
		ViewData( ControlSelected,Set,FALSE,Node<ControlNumber> );
	}
}

VOID PatternEditor::SetSelection(Num)
{
	ViewData( SetControlColor,Node<Num>,BgColor,<SelectedColorR>,<SelectedColorG>,<SelectedColorB> );
	ViewData( ControlSelected,Set,TRUE,Node<Num> );
	fLastSelected = <Num>;
}

VOID PatternEditor::HandleShiftClick(Num)
{
	if ( !<fLastSelected> )				// ONLY ONE CELL EVER SELECTED?
	{
		ToggleSelection( <Num> );
		return;
	}

	if ( <Num> == <fLastSelected> )		// JUST ONE CELL SELECTED?
	{
		ToggleSelection( <Num> );
		return;
	}

	if ( !fPattern.PositionToControlNumber(<fLastSelected>) )	{ return; }

	FirstRow = FirstCol = 0;
	if ( !fPattern.GetRowCol( FirstRow,FirstCol )  )			{ return; }

	if ( !fPattern.PositionToControlNumber(<Num>) )				{ return; }

	ThisRow = ThisCol = 0;
	if ( !fPattern.GetRowCol( ThisRow,ThisCol ) )				{ return; }

	if ( <ThisRow> > <FirstRow> )			// OBVIOUS FORWARD SELECTION?
	{
		LastControl = <Num>; FirstControl = <fLastSelected>;
	}
	else if ( <ThisRow> < <FirstRow> )		// OBVIOUS BACKWARD SELECTION?
	{
		LastControl = <fLastSelected>; FirstControl = <Num>;
	}
	else	if ( <ThisCol> >= <FirstCol> )	// SAME ROW, BUT STILL FORWARD SELECTION
	{
		LastControl = <Num>; FirstControl = <fLastSelected>;
	}
	else									// ONLY THING LEFT IS A BACKWARDS SELECTION
	{
		LastControl = <fLastSelected>; FirstControl = <Num>;
	}

	if ( !fPattern.PositionToControlNumber(<LastControl>) )	{ return; }
	i = fPattern.GetControlNumber();

	ViewData( ControlRect,Node<i>,GetPosition,X,Y,W,L );

	RightMost = truncate(<X> + <W> - 1);
	BottomMost = truncate(<Y> + <L> - 1);

	if ( !fPattern.PositionToControlNumber(<FirstControl>) )	{ return; }
	i = fPattern.GetControlNumber();

	ViewData( ControlRect,Node<i>,GetPosition,LeftMost,TopMost,W,L );

	fPattern.AllNodes();	

	if ( !fPattern.PositionToControlNumber(<FirstControl>) )	{ return; }

	ToggleSelection(<FirstControl>);
	ToggleSelection(<LastControl>);

	while ( <i> != <LastControl> )	
	{ 
		ViewData( ControlRect,Node<i>,GetPosition,X,Y,W,L );

		Right = truncate(<X> + <W> - 1);
		Bottom = truncate(<Y> + <L> - 1);

		if ( (<X> >= <LeftMost>) && (<Right> <= <RightMost>) && (<Y> >= <TopMost>) && (<Bottom> <= <BottomMost>) )
		{
			ToggleSelection(<i>);
		}
		
		if ( !fPattern.PositionToNext() )
			break;

		i = fPattern.GetControlNumber();
	}
}

VOID PatternEditor::ToggleSelection(Num)
{
	if ( ViewData( ControlSelected,Get,Node<Num> ) )	{ ClearSelection(); }
	else												{ SetSelection(<Num>); }
}

VOID PatternEditor::OnNodePressed(Num)
{
	fPattern.PositionToControlNumber(<Num>);

	if ( Keystate( Control ) )							{ ToggleSelection(<Num>); }
	else if ( Keystate( Shift ) && <fLastSelected> )	{ HandleShiftClick( <Num> ); }
	else
	{
		OnClearSelectionButton();
		SetSelection( <Num> );
	}
}

NUMERIC PatternEditor::RemoveNodes( &RemoveList )
{
	DataWindow( StatusBar,Text,~Removing .....~ );
	ReturnOnFailure( fPattern.Remove( RemoveList ) );

	ReturnOnFailure( ResequenceEverything() );

	Count = RemoveList( NumEntries );
	return DataWindow( StatusBar,Text,~Removed <count> nodes~ );		
}

NUMERIC PatternEditor::ResequenceEverything()
{
	DataWindow( StatusBar,Text,~Resequencing Rows And Columns.....~ );
	ReturnOnFailure( fPattern.ResequenceRowCols() );

	DataWindow( StatusBar,Text,~Repositioning .....~ );
	RepositionControls();

	DataWindow( StatusBar,Text,~Resequencing Node Numbers .....~ );	
	OnResequence();

	return TRUE;
}

NUMERIC PatternEditor::OnRemoveSaveButton()
{
	OnRemoveButton();
	return OnSaveButton();
	
}

NUMERIC PatternEditor::OnRemoveButton()
{
	WaitCursor( Begin );

	Count = 0;

	StringList( RemoveList,New );

	More = fPattern.PositionToLast();

	while ( <More> )
	{
		if ( IsSelectedControl( fPattern.GetControlNumber() ) )
		{
			ControlNumber = fPattern.GetControlNumber();
			ControlIsAvailable( ~<ControlNumber>~ );

			CurrentRow = CurrentCol = 0;
			fPattern.GetRowCol( CurrentRow,CurrentCol );

			RemoveList( AddString,~<CurrentRow>,<CurrentCol>~ );
			++Count;
		}

		More = fPattern.PositionToPrev();
	}

	if ( ChangedOccured(Count) )
	{
		RemoveNodes(RemoveList);
		SetupForUndo();
		ViewData( RefreshView );
	}

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::Insert( Qty,R,C )
{
	ReturnOnFailure( ControlNumber = GetAvailableControl() );

	ReturnOnFailure( fPattern.Insert( <Qty>,<R>,<C>,<ControlNumber> ) );

	SetSelection( <ControlNumber> );

	ReturnOnFailure( fPattern.ResequenceRowCols() );

	ViewData( ShowControls,TRUE,Node<ControlNumber> );

	UpdateStatistics();

	return TRUE;
}

NUMERIC PatternEditor::OnAddNewRowButton()
{
	WaitCursor( Begin );

	UpdateStatistics();

	OnClearSelectionButton();

	fPattern.PositionToLast();

	fPattern.GetRowCol( LastRow,LastCol );

	if (Insert( 1,<++LastRow>,1 ))
	{

		MaxColumms = fPattern.GetMaxColumns();

		i = 1;

		 while ( <++i> <= <MaxColumms> )
		 {
	 		if (!Insert( 1,<LastRow>,2 ))
				break;
		 }
	}

	RepositionControls();	

	OnResequence();	

	fDirty = TRUE;

	MaintainWindowTitle();

	SetupForUndo();

	OnClearSelectionButton();

	fDirty = TRUE;

	MaintainWindowTitle();

	WaitCursor( End );

	return TRUE;
}


NUMERIC PatternEditor::OnAddNewColButton()
{
	WaitCursor( Begin );

	UpdateStatistics();

	Rows = fPattern.NumRows();

	R = 0;

	while ( <++R> <= <Rows> )
	{
		if (!Insert( 1,<R>,1 ))
			break;
	}

	RepositionControls();	
	OnResequence();	
	SetupForUndo();

	fDirty = TRUE;

	MaintainWindowTitle();

	OnClearSelectionButton();

	WaitCursor( End );

	return TRUE;
}


NUMERIC PatternEditor::OnAddColumnButton()	
{
	WaitCursor( Begin );

	R = C = Count = 0;

	More = fPattern.PositionToFirst();

	while ( <More> )
	{
		if ( IsSelectedControl( fPattern.GetControlNumber() ) )
		{
			ClearSelection();

			if ( fPattern.GetRowCol( R,C ) )
			{
				if ( Insert( 1,<R>,<C> ) )
				{
					++Count;
					break;
				}
			}
		}

		More = fPattern.PositionToNext();
	}

	if ( !<Count> )
	{
		if (Insert( 1,1,1 ))
		{
			++Count;
		}
	}

	if ( ChangedOccured(Count) )
	{
		RepositionControls();	
		OnResequence();	
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}


NUMERIC PatternEditor::OnAddRowButton()
{
	WaitCursor( Begin );

	OnClearSelectionButton();

	fPattern.PositionToLast();

	fPattern.GetRowCol( LastRow,LastCol );

	Insert( 1,<++LastRow>,1 );

	RepositionControls();	

	OnResequence();	

	fDirty = TRUE;

	MaintainWindowTitle();

	SetupForUndo();

	WaitCursor( End );

	return TRUE;
}


NUMERIC PatternEditor::OnSelectRowButton()
{
	FirstControlNumber = 0;

	Count = GetSelectedCount( FirstControlNumber );

	if ( <Count> != 1 )
	{
		return Warning( ~Select a single node in the row you wish to select~ );
	}

	fPattern.PositionToControlNumber( <FirstControlNumber> );

	Row = Col = 0;

	fPattern.GetRowCol( Row,Col );

	more = fPattern.PositionToRow( <Row> );

	while ( <more> )
	{
		SetSelection( fPattern.GetControlNumber() );

		more = fPattern.PositionToNext();
	}

	return TRUE;
}


NUMERIC PatternEditor::OnSelectColumnButton()
{
	FirstControlNumber = 0;

	Count = GetSelectedCount( FirstControlNumber );

	if ( <Count> != 1 )
	{
		return Warning( ~Select a single node in the column you wish to select~ );
	}

	fPattern.PositionToControlNumber( <FirstControlNumber> );

	Row = Col = 0;

	fPattern.GetRowCol( Row,Col );

	more = fPattern.PositionToCol( <Col> );

	while ( <more> )
	{
		SetSelection( fPattern.GetControlNumber() );

		more = fPattern.PositionToNext();
	}

	return TRUE;
}


NUMERIC PatternEditor::IsSelectedControl( num )
{
	return ViewData( ControlSelected,Get,Node<Num> ) && ViewData( IsControlVisible,Node<Num> );
}

NUMERIC PatternEditor::GetSelectedCount( &FirstControlNumber )
{
	count = 0;

	more = fPattern.PositionToFirst();

	while ( <more> )
	{
		if ( IsSelectedControl( fPattern.GetControlNumber() ) )
		{
			++count;

			if ( <Count> == 1 )
			{
				FirstControlNumber = fPattern.GetControlNumber();
			}
		}

		more = fPattern.PositionToNext();
	}

	return <count>;
}

NUMERIC PatternEditor::NotContiguous()
{
	WaitCursor( END );
	return Warning( ~Item is not contiguous~ );
}


NUMERIC PatternEditor::IsContiguousSelection()
{
	more = fPattern.PositionToFirst();

	R = C = LastR = LastC = UpperLeftR = UpperLeftC = RightEdge = ColCount = FirstColCount = 0;

	First = TRUE;

	while ( <More> )
	{
		if ( IsSelectedControl( fPattern.GetControlNumber() ) )
		{
			fPattern.GetRowCol( R,C );

			if ( <first> )
			{
				UpperLeftR = <R>; UpperLeftC = <C>;	First = FALSE;
			}
			else
			{
				if ( <R> == <LastR> )		// Same Row?
				{
					if ( <C> != ( <LastC> + 1 ) )				{ return NotContiguous(); }
				}
				else	// New row
				{
					if ( <RightEdge> )
					{
						if ( <LastC> != <RightEdge> )			{ return NotContiguous(); } 
					}
					else
					{ 
						RightEdge = <LastC>;
					}

					if ( <R> != <LastR> + 1 )					{ return NotContiguous(); }
				
					if ( <C> != <UpperLeftC> )					{ return NotContiguous(); }
				}
			}

			LastR = <R>; LastC = <C>;
		}

		more = fPattern.PositionToNext();
	}

	if ( <RightEdge> )
	{
		if ( <LastC> != <RightEdge> )	{ return NotContiguous(); } 
	}

	return TRUE;
}

NUMERIC PatternEditor::Get2SelectedCountableNodes( &First,&Second )
{
	First = Second = 0;

	more = fPattern.PositionToFirstCountableNode();

	while ( <More> )
	{
		if ( IsSelectedControl( fPattern.GetControlNumber()  ) )
		{
			theType = fPattern.GetPositionType();

			if ( !SimilarStr( ~<theType>~,~Countable~ ) )
				continue;

			if ( <First> )
			{ 
				Second = fPattern.GetControlNumber();
				break;
			}
			else 
			{
				First = fPattern.GetControlNumber();
			}
		}

		more = fPattern.PositionToNext();
	}

	return <First> != 0 && <Second> != 0;
}

NUMERIC PatternEditor::OnSwapButton()
{
	First = Second = 0;

	if ( Get2SelectedCountableNodes( First,Second ) )
	{
		fPattern.PositionToControlNumber( <First> );
		TheFirst = fPattern.GetNodeNumber();

		fPattern.PositionToControlNumber( <Second> );
		TheSecond = fPattern.GetNodeNumber();
		fPattern.SetNodeNumber( <TheFirst> );
		ClearSelection();

		ViewData( SetControlValue,Node<Second>,fPattern.GetNodeText() );

		fPattern.PositionToControlNumber( <First> );
		fPattern.SetNodeNumber( <TheSecond> );
		ClearSelection();

		ViewData( SetControlValue,Node<First>,fPattern.GetNodeText() );

		fDirty = TRUE;
		MaintainWindowTitle();

		SetupForUndo();

		return TRUE;
	}

	return Warning( Translate( Translations,SelectTwoNodes ) );	
}

NUMERIC PatternEditor::OnShuffleButton()
{
	First = Second = 0;

	if ( !Get2SelectedCountableNodes( First,Second ) )
	{
		return Warning( Translate( Translations,SelectTwoNodes ) );
	}

	WaitCursor( Begin );

	fPattern.PositionToControlNumber( <Second> );
	TheSecondNodeNumber = fPattern.GetNodeNumber();
	ClearSelection();

	fPattern.PositionToControlNumber( <First> );
	TheFirstNodeNumber = fPattern.GetNodeNumber();
	ClearSelection();

	index = <TheFirstNodeNumber>;
	Num = <TheSecondNodeNumber>;

	more = fPattern.PositionToFirstShuffleNode(<First>,<Second>);

	while ( <more> )
	{
		ControlNumber = fPattern.GetControlNumber();

		ThisNodeNumber = fPattern.GetNodeNumber();

		fPattern.SetNodeNumber( <Num> );

		ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );

		Num = <ThisNodeNumber>;

		more = fPattern.PositionToNext() && <ControlNumber> != <Second>;

	}

	fDirty = TRUE;
	MaintainWindowTitle();

	SetupForUndo();

	WaitCursor( End );

	return TRUE;
}

NUMERIC PatternEditor::OnSetDeltaXYButton()
{
	ViewControl( GetControlValue,xDeltaSizeField,x );
	ViewControl( GetControlValue,yDeltaSizeField,y );

	WaitCursor( Begin );

	Count = 0;

	More = fPattern.PositionToFirst();

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetDeltaXY( ~<x>~,~<y>~ );

			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );

			++Count;
		}

		More = fPattern.PositionToNext();
	}


	if ( ChangedOccured(Count) )
	{
		ViewControl( SetControlValue,xDeltaSizeField,0 );
		ViewControl( SetControlValue,yDeltaSizeField,0 );

		SetupForUndo();
	}

	WaitCursor( End );

	return TRUE;
}

NUMERIC PatternEditor::OnSetDeltaWLButton()
{
	ViewControl( GetControlValue,wDeltaSizeField,w );
	ViewControl( GetControlValue,lDeltaSizeField,l );

	WaitCursor( Begin );

	Count = 0;

	More = fPattern.PositionToFirst();

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetDeltaWL( ~<w>~,~<l>~ );

			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );

			++Count;
		}

		More = fPattern.PositionToNext();
	}


	if ( ChangedOccured(Count) )
	{
		ViewControl( SetControlValue,wDeltaSizeField,0 );
		ViewControl( SetControlValue,lDeltaSizeField,0 );

		SetupForUndo();
	}

	WaitCursor( End );

	return TRUE;
}

// Paul Forleo 6/3/02  attempt to turn node name field into combo box
// This works.  Next improvement:  Save the node names in the database
// by pattern name so that the combo box can be refreshed
// across shutdowns.I disabled the code for combo boxes today and will get back
// to it later
// InitNodeNameField and DisplayNodeNameField only called when node name
// control is a combo box

NUMERIC PatternEditor::InitNodeNameField()
{
	if ( !DefinedPermanent( NodeNameChoices ) )
	{
		StringList( NodeNameChoices,New,NoDuplicateValues,InAlphaOrder );
		PermanentSymbol( NodeNameChoices);
	}
	DisplayNodeNameField();
	return 1;
}

NUMERIC PatternEditor::DisplayNodeNameField()
{
	result = ViewControl( SetControlFromStringList,NodeNameField,NodeNameChoices,~NoSelection~ );
	ViewControl( GetEditBoxValue,NodeNameField,aNodeName );
	
	if (DefinedPermanent(PermanentNodeName))
	{
		ViewControl( SetControlValue,NodeNameField,~<PermanentNodeName>~);
	}
	

	return  <result>;
}

NUMERIC PatternEditor::OnSetNodeNameButton()
{
	// Paul Forleo 6/3/02  attempt to turn node name field into combo box
	// This works.  Next improvement:  Save the node names in the database
	// by pattern name so that the combo box can be refreshed
	// across shutdowns.  I disabled the code for combo boxes today and will get back
	// to it later

	
	ViewControl( GetEditBoxValue,NodeNameField,aNodeName );
	NodeNameChoices( AddString, ~<aNodeName>~);

	ReturnOnFailure( IsContiguousSelection() );

	WaitCursor( Begin );

	// MIGHT WANNA ADD LOGIC TO ENSURE THE SELECTION IS CONTIGOUS AND ALL OF THE SAME TYPE

	More = fPattern.PositionToFirst();

	while ( <More> && !IsNull(~<aNodeName>~))
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( !IsSelectedControl( <ControlNumber> ) )
		{
			if ( SimilarStr( fPattern.GetNodeName(), ~<aNodeName>~ ) )
			{
				WaitCursor( End );
				return Warning( Translate( Translations,NodeNameInUse ) );	
			}
		}

		More = fPattern.PositionToNext();
	}

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetNodeName( ~<aNodeName>~ );

			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );

			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		//ViewControl( SetControlValue,NodeNameField,~~ );

		SetupForUndo();
	}

	PermanentNodeName=~<aNodeName>~;
	PermanentSymbol(PermanentNodeName);

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::ChangedOccured( &Count )
{
	if ( !<Count> )
	{
		return Warning( Translate( Translations,NothingSelected ) );
	}

	fDirty = TRUE;

	MaintainWindowTitle();

	return TRUE;
}

VOID PatternEditor::OnClearSelectionButton()
{
	More = fPattern.PositionToFirst();

	num = 0;
	
	fPattern( GetReferenceTo,fList,List );
		
	ViewData(ClearSelectedPatternNodes,fNodeTypeColors,List);
	
}

NUMERIC PatternEditor::OnCountableImageButton()
{
	WaitCursor( Begin );

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( ~Countable~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			//ViewData( SetValueInCtrlDef,Node<ControlNumber>,ToolTip,~Countable Node~ );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::OnTitleButton()
{
	ReturnOnFailure( IsContiguousSelection() );

	WaitCursor( Begin );

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( ~TT~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}

VOID PatternEditor::SetToolTip(ControlNumber,Tip)	{ ViewData( SetValueInCtrlDef,Node<ControlNumber>,ToolTip,~<Tip>~ ); }

VOID PatternEditor::OnLeftHalfTitleButton()		{ OnHalfTitleButton(TRUE); }
VOID PatternEditor::OnRightHalfTitleButton()	{ OnHalfTitleButton(FALSE); }

NUMERIC PatternEditor::OnHalfTitleButton( Left )
{
	WaitCursor( Begin );

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( <Left> ? ~BT~ : ~TB~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::OnTextButton()
{
	ReturnOnFailure( IsContiguousSelection() );

	WaitCursor( Begin );

	ViewControl( GetControlValue,TextNField,N );

	if ( IsNull( ~<N>~ ) )
	{
		N = 1;
		ViewControl( SetControlValue,TextNField,<N> );
	}

	WaitCursor( Begin );

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( ~T<N>~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		ViewControl( SetControlValue,TextNField,<++N> );
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::OnFeaturedButton()
{	
	ReturnOnFailure( IsContiguousSelection() );

	WaitCursor( Begin );

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( ~F~ );
			fPattern.SetNodeName( ~<fFeaturedNodeName>~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::OnImageTextButton()
{
	FirstControlNumber = 0;

	NumSelected = GetSelectedCount( &FirstControlNumber );

	if ( <NumSelected> > 1 )
	{
		return Warning( ~You must select one and only one node for this feature~ );
	}

	ReturnOnFailure( IsContiguousSelection() );

	WaitCursor( Begin );

	ViewControl( GetControlValue,ImageTextNField,N );

	if ( IsNull( ~<N>~ ) )
	{
		N = 1;
		ViewControl( SetControlValue,ImageTextNField,<N> );
	}

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( ~Z<N>~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		ViewControl( SetControlValue,ImageTextNField,<++N> );
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::OnImageButton()
{
	ReturnOnFailure( IsContiguousSelection() );

	WaitCursor( Begin );

	ViewControl( GetControlValue,ImageNField,N );

	if ( IsNull( ~<N>~ ) )
	{
		N = 1;
		ViewControl( SetControlValue,ImageNField,<N> );
	}

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( ~I<N>~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		ViewControl( SetControlValue,ImageNField,<++N> );
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}

NUMERIC PatternEditor::OnBlankButton()
{
	WaitCursor( Begin );

	More = fPattern.PositionToFirst();

	Count = 0;

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		if ( IsSelectedControl( <ControlNumber> ) )
		{
			fPattern.SetPositionType( ~BB~ );
			ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
			ClearSelection();
			++Count;
		}

		More = fPattern.PositionToNext();
	}

	if ( ChangedOccured(Count) )
	{
		OnResequence();
		SetupForUndo();
	}

	WaitCursor( End );

	return <Count>;
}


VOID PatternEditor::SetToolTip( ControlNumber,ToolTip )		// NOT USED.  HERE FOR AN EXAMPLE
{
	ViewData( SetValueInCtrlDef,Node<ControlNumber>,ToolTip,~<ToolTip>~ );
}


VOID PatternEditor::OnResequenceButton()
{
	OnResequence();
	SetupForUndo();
	fDirty = TRUE;
	MaintainWindowTitle();
}


VOID PatternEditor::OnResequence()
{
	DataWindow( StatusBar,Text,~Resequencing .....~ );

	WaitCursor( Begin );

	UpdateStatistics();

	Num = 0;

	More = fPattern.PositionToFirstCountableNode();

	while ( <More> )
	{
		ControlNumber = fPattern.GetControlNumber();

		fPattern.SetNodeNumber( <++Num> );

		ViewData( SetControlTitle,Node<ControlNumber>,fPattern.GetNodeText() );
		
		More = fPattern.PositionToNext();	
	}

	DataWindow( StatusBar,Text,~<Num> Countable Image Nodes~ );

	WaitCursor( End );
}


NUMERIC PatternEditor::BrowseForOutputDirectory()	
{
	NumNodes = fPattern.NumCountableNodes();

	DefaultFileName = ~Pattern.<$str.$NumNodes.%03ld>~;

	Title = Translate( ~Find the directory for the patterns~ );

	if ( FileDialog( Title,~<title>~,PATH,Path,DefaultFile,~<DefaultFileName>~,Save ) )
	{
		fDirectory = ~<$Str.$Path.Path>~;
		fFileName = ~<$Str.$Path.Filename>~;
		return TRUE;
	}

	return FALSE;
}

NUMERIC PatternEditor::BrowseForInputDirectory()	
{
	Title = Translate( ~Find a pattern file~ );

	if ( FileDialog( Title,~<title>~,PATH,Path,Open ) )
	{
		fDirectory = ~<$Str.$Path.Path>~;
		fPatternFile = ~<$Str.$Path.FileName>~;
		return TRUE;
	}

	return FALSE;
}


NUMERIC PatternEditor::OnSaveAsButton()
{
	PrevSaveDirectory = ~<fDirectory>~;

	NumNodes = fPattern.NumCountableNodes();

	TheFileName = ~Pattern.<$str.$NumNodes.%03ld>~;

	if ( !BrowseForOutputDirectory() )
	{
		return FALSE;
	}

	thePath = ~<fDirectory>\Pattern.<$str.$NumNodes.%03ld>~;

	if ( Files( FileExists,~<thePath>~ ) )
	{
		if ( MessageBox( Translate( ~<thePath> has changed.  Do you want to save your changes? ~),YESNO ) != YES ) 
		{
			fDirectory = ~<PrevSaveDirectory>~;
			return TRUE;
		}
		
		if ( !Files( Access,~<thePath>~,ReadWrite ) )
		{
			fDirectory = ~<PrevSaveDirectory>~;
			if (MessageBox( Translate( ~<thePath> is write protected.  Do you want to remove the write protection and overwrite it? ~),YESNO ) != YES)
			{
				return FALSE;
			}
			Files( ChMod,~<thePath>~,ReadWrite );	 
		}
	}

	fPattern.SetPath( ~<thePath>~ );

	WaitCursor( Begin );
	success = fPattern.Write();
	WaitCursor( End );

	if ( MessageBox( Translate( ~Change the working directory to <fDirectory>? ~),YESNO ) != YES ) 
	{
		fDirectory = ~<PrevSaveDirectory>~;
		return TRUE;
	}

	fDirty = FALSE;

	MaintainWindowTitle();

	InformCompositeGenerator( ~<fDirectory>~,<NumNodes> );

	return <Success>;
}


NUMERIC PatternEditor::OnSaveButton()
{
	return OnSaveRoutine(FALSE);
}


NUMERIC PatternEditor::OnSaveRoutine(NeedOverWritePermission)
{
	NumNodes = fPattern.NumCountableNodes();

	TheFileName = ~Pattern.<$str.$NumNodes.%03ld>~;

	if ( IsNull( ~<fDirectory>~ ) )
	{
		if ( !BrowseForOutputDirectory() )
		{
			return FALSE;
		}
	}

	thePath = ~<fDirectory>\Pattern.<$str.$NumNodes.%03ld>~;

	if ( Files( FileExists,~<thePath>~ ) )
	{
		if ( <NeedOverWritePermission> )
		{
			if ( MessageBox( Translate( ~<thePath> has changed.  Do you want to save your changes? ~),YESNO ) != YES ) 
			{
				return TRUE;
			}
		}

		if ( !Files( Access,~<thePath>~,ReadWrite ) )
		{
			if (MessageBox( Translate( ~<thePath> is write protected.  Do you want to remove the write protection and overwrite it? ~),YESNO ) != YES)
			{
				return FALSE;
			}
			Files( ChMod,~<thePath>~,ReadWrite );	 
		}
	}

	fPattern.SetPath( ~<thePath>~ );

	WaitCursor( Begin );
	success = fPattern.Write();
	WaitCursor( End );

	fDirty = FALSE;

	MaintainWindowTitle();

	InformCompositeGenerator( ~<fDirectory>~,<NumNodes> );

	return <Success>;
}

VOID PatternEditor::InformCompositeGenerator( Path,Num )
{
	Actions = ACTION Doc (  GridGeneratorDialog "SelectSize(~<Path>~,~<Num>~);" );
	PerformActions( Actions );
}


VOID PatternEditor::MaintainWindowTitle()
{
	Path = fPattern.GetPath();

	Path = IsNULL(~<Path>~) ? ~No path specified~ : ~<Path>~;

	Dirty = <fDirty> ? ~*~ : ~~;

	Editor.SetWindowTitle( ~Pattern Editor    <Path><Dirty>~ );
}

VOID PatternEditor::SetPath( Path )
{
	fPattern.SetPath( ~<Path>~ );
}

NUMERIC PatternEditor::OnUndoButton()
{
	if ( <fUndo> <= 1 )   { return Warning( ~Nothing to undo~ ); }

	thePath = ~<fUndoDirectory>\Undo.<--fUndo>~;
	
	return UndoOrRedo( ~<thePath>~ );
}

NUMERIC PatternEditor::OnRedoButton()
{
	//Highest = Findfile( aFile,FindHighestExtension,~<fUndoDirectory>\*.*~ );

	if ( <fUndo> >= <fMaxUndo> )		{ return Warning( ~Nothing to redo~ ); }

	thePath = ~<fUndoDirectory>\Undo.<++fUndo>~;

	return UndoOrRedo( ~<thePath>~ );
}

NUMERIC PatternEditor::UndoOrRedo( thePath )
{
	WaitCursor( Begin );

	Directory( Create,~<fUndoDirectory>~ );

	FreeAllControls();

	fPattern.LoadData( ~<thePath>~ );

	UpdateStatistics();

	ReloadAllControls();

	UpdateUndoControls();

	WaitCursor( End );

	return TRUE;
}


VOID PatternEditor::UpdateUndoControls()
{

	ViewControl( EnableViewControls,(<fUndo> <= 1) ? FALSE : TRUE ,UndoButton );
	ViewControl( EnableViewControls,(<fUndo> < <fMaxUndo> && <fMaxUndo>) ? TRUE : FALSE ,RedoButton );

	ViewControl( SetControlTitle,UndoButton,~Undo <fUndo>   &Z~ );
	ViewControl( SetControlTitle,RedoButton,~Redo   &Y~ );
}

NUMERIC PatternEditor::SetupForUndo()
{
	WaitCursor( Begin );

	Directory( Create,~<fUndoDirectory>~ );

	thePath = ~<fUndoDirectory>\Undo.<++fUndo>~;

	fMaxUndo = <fUndo>;

	success = fPattern.SaveData(~<thePath>~);

	UpdateUndoControls();

	return <Success>;
}


NUMERIC PatternEditor::InitUndo()	{ return Directory( Create,~<fUndoDirectory>~ ); }

VOID PatternEditor::ReloadUndo(Path,UndoDirectory)	
{ 
	fUndoDirectory = ~<UndoDirectory>~;

	InitUndo();

	fUndo = ~<$Str.$Path.Ext>~;

	UpdateUndoControls();
}


VOID PatternEditor::CleanupUndo()
{
	fUndo = 0; 
	FindFile( aFindFile,DeleteFiles,~<fUndoDirectory>\*.*~ );
	ForgetLocal( aFindFile );
	Directory( Remove,~<fUndoDirectory>~ ); 
}

VOID PatternEditor::ForgetUndo()	
{ 
	CleanupUndo();
	SetupForUndo();
	UpdateUndoControls();
}	


NUMERIC PatternEditor::OnViewAsTextButton()
{
	if ( IsNull( fPattern.GetPath() ) )
	{
		return Warning( ~You must save the pattern first~ );
	}

	ViewFileInNotepad( fPattern.GetPath() ); 

	return TRUE;
}

// ******************* Dialog to Prompt For Rows and Columns ***********************

VOID CreatePatternDialog::CreatePatternDialog()
{
	Title = ~Open Pattern Editor~;
	Left = 200;
	Dictionary = ~DDCreatePatternDialog~;
	ExitScriptOnClose = FALSE;
	HelpPage = ~PatternEditorOpen.htm~;
}


VOID CreatePatternDialog::DefineDictionary()
{
	Dictionary: ~<Dictionary>~ 
		Fields: Name Rows		type long;
		Fields:	Name Cols		type long;
}

VOID PatternEditor::DefineNodeDict()
{
	if ( !DictionaryExists( DDNodeColorDict ) )
	{
	Dictionary: ~DDNodeColorDict~ 
		Fields: Name CountableColorR		type long;
		Fields:	Name CountableColorG		type long;
		Fields:	Name CountableColorB		type long;
		
		Fields:	Name TTColorR		type long;
		Fields:	Name TTColorG		type long;
		Fields:	Name TTColorB		type long;
		
		Fields:	Name BTColorR		type long;
		Fields:	Name BTColorG		type long;
		Fields:	Name BTColorB		type long;

		Fields:	Name TBColorR		type long;
		Fields:	Name TBColorG		type long;
		Fields:	Name TBColorB		type long;
		
		Fields:	Name T1ColorR		type long;
		Fields:	Name T1ColorG		type long;
		Fields:	Name T1ColorB		type long;

		Fields:	Name BBColorR		type long;
		Fields:	Name BBColorG		type long;
		Fields:	Name BBColorB		type long;
		
		Fields:	Name I1ColorR		type long;
		Fields:	Name I1ColorG		type long;
		Fields:	Name I1ColorB		type long;

		Fields:	Name Z1ColorR		type long;
		Fields:	Name Z1ColorG		type long;
		Fields:	Name Z1ColorB		type long;
		
		Fields:	Name F1ColorR		type long;
		Fields:	Name F1ColorG		type long;
		Fields:	Name F1ColorB		type long;	
		}	
}

VOID CreatePatternDialog::DefineMessages()		
{ 
	BaseDialog::DefineMessages();	
	
	Translations( AddText,RowsZero,~You must enter the number of rows~ );
	Translations( AddText,ColsZero,~You must enter the number of columns~ );
	Translations( AddText,TooMany,~%1 * %2 = %3 which is too many.  You are limited to %4.~ );
	Translations( AddText,FindPatternFile,~Find a pattern file~ );

	Translations( AddText,Rows,~Rows~ );
	Translations( AddText,Cols,~Cols~ );
	Translations( AddText,Create,~Create~ );
	Translations( AddText,Open,~Open~ );
}

NUMERIC	CreatePatternDialog::OnCreateButton()
{
	nRows = ~<$con.DlgData[Rows]>~;
	nCols = ~<$con.DlgData[Cols]>~;

	if ( IsNULLOrZero( ~<nRows>~ ) )
	{
		return Warning( Translate( Translations,RowsZero ) );
	}

	if ( IsNULLOrZero( ~<nCols>~ ) )
	{
		return Warning( Translate( Translations,ColsZero )  );
	}

	Total = <nRows> * <nCols>;

	if ( <Total> > <TotalAllowed> )
	{
		return Warning( Translate( Translations,TooMany,<nRows>,<nCols>,<Total>,<TotalAllowed> ) );
	}

	if ( Defined( Editor ) )
	{
		Editor.EnableTheWindow( TRUE );
		Action = ACTION DOC ( PatternEditorDoc Open PatternEditorDoc3 "Init(~<$con.DlgData[Rows]>~,~<$con.DlgData[cols]>~);" );
		PerformActions( Action );
	}
	else
	{
		Init( ~<$con.DlgData[Rows]>~,~<$con.DlgData[cols]>~ );
	}

	DoCancelButton();

	return TRUE;
}

NUMERIC	CreatePatternDialog::OnOpenButton()
{

	Title = Translate( Translate( Translations,FindPatternFile ) );

	if ( FileDialog( Title,~<title>~,PATH,Path,Open ) )
	{
		Action = ACTION DOC ( PatternEditorDoc Open PatternEditorDoc3 "OpenPattern(~<Path>~);" );
		PerformActions( Action );

		if ( Defined( Editor ) )	{ Editor.EnableTheWindow( TRUE ); }

		DoCancelButton();
	
		return TRUE;
	}

	return TRUE;
}


VOID CreatePatternDialog::OnDialogEnd()
{
	if ( Defined( Editor ) )
	{
		Editor.EnableTheWindow( TRUE );
		Editor.MaintainWindowTitle();
	}
	else
	{
		ExitScriptOnClose = TRUE;
	}
}

VOID CreatePatternDialog::DefineControls()
{
	Define: RowsPrompt Using DDWinCtrlDef AsSymbol RowsPrompt Private
			Fields:	TYPENAME			STATICTEXT
					GENCONNAME			THIS
					POSITION			<hgap> <vGap> 40 <ButtonHeight>
					TEXT				Translate( Translations,Rows);

	Define: RowsField Using DDWinCtrlDef AsSymbol RowsField Private
			Fields:	TYPENAME			EDITTEXT
					GENCONNAME			THIS
					GENCONFIELD			Rows
					IACTIONSTEXT		ACTIONS ( Get )
					DACTIONSTEXT		ACTIONS ( Save )
					OACTIONSTEXT		ACTIONS ( Save )
					POSITION			RowsPrompt(GetRight,Position)+$hGap RowsPrompt(GetTop,Position) 
										50 <ButtonHeight>

	Define: ColsPrompt Using DDWinCtrlDef AsSymbol ColsPrompt Private
			Fields:	TYPENAME			STATICTEXT
					GENCONNAME			THIS
					POSITION			RowsPrompt(GetLeft,Position) RowsPrompt(GetBottom,Position) +$vGap
										RowsPrompt(GetWidth,Position) <ButtonHeight>
					TEXT				Translate( Translations,Cols);

	Define: ColsField Using DDWinCtrlDef AsSymbol ColsField Private
			Fields:	TYPENAME			EDITTEXT
					GENCONNAME			THIS
					GENCONFIELD			Cols
					IACTIONSTEXT		ACTIONS ( Get )
					DACTIONSTEXT		ACTIONS ( Save )
					OACTIONSTEXT		ACTIONS ( Save )
					POSITION			ColsPrompt(GetRight,Position)+$hGap ColsPrompt(GetTop,Position) 
										RowsField(GetWidth,Position) <ButtonHeight>
					TEXT				~~;

	Define: CreateButton Using DDWinCtrlDef AsSymbol CreateButton Private
			Fields:	TYPENAME			DEFAULTBUTTON
					GENCONNAME			THIS
					POSITION			$hGap ColsPrompt(GetBottom,Position)+$vGap,
										<ButtonWidth> <ButtonHeight>
					DACTIONSTEXT		ACTION EXEC ( <THIS>.OnCreateButton() )
					TEXT				Translate( Translations,Create);

	Define: OpenButton Using DDWinCtrlDef AsSymbol OpenButton Private
			Fields:	TYPENAME			BUTTON
					GENCONNAME			THIS
					POSITION			CreateButton(GetRight,Position)+$hGap CreateButton(GetTop,Position),
										<ButtonWidth> <ButtonHeight>
					DACTIONSTEXT		ACTION EXEC ( <THIS>.OnOpenButton() )
					TEXT				Translate( Translations,Open);
}

// ******************* End Dialog to Prompt For Rows and Columns ***********************



NUMERIC PatternEditor::OnCreateButton() 
{
	if ( Keystate( Control ) )
	{
		return OpenUndo();
	}

	EnableTheWindow( FALSE );

	Class( CreatePatternDialog,Extends,BaseDialog );
	CreatePatternDialog( New,CreateDlg );

	CreateDlg.DefineDialog();

	return Global( CreateDlg );
}

VOID PatternEditor::OnOpenButton() 
{
	if ( !BrowseForInputDirectory() )
	{
		return FALSE;
	}

	return TRUE;
}

VOID PatternEditor::OnImportKPISPatternButton() 
{
	Action = ACTION DOC ( ImportKPISPatternDoc OpenOnce ImportKPISPatternDoc );
	PerformActions( Action );
}

VOID PatternEditor::OnCreateGridLayoutsButton() 
{
	thePatternPath = fPattern.GetPath();

	if ( !IsNull( ~<thePatternPath>~ ) )
	{
		thePatternPath = ~<$Str.$thePatternPath.Path>~;
	}

	action = ACTION DOC ( GridGeneratorDialog OpenOnce GridGeneratorDialog "Init(~<thePatternPath>~);" );
	PerformActions( action );
}

VOID PatternEditor::DefineViews()	
{
	DefineView(Control);
	DefineView(Data);		
}	


VOID PatternEditor::SetRowsCols( nRows,nCols )
{ 
	Rows = ~<nRows>~;
	Cols = ~<nCols>~;
}


NUMERIC PatternEditor::OpenUndo()
{
	Title = Translate( ~Select an undo file~ );

	if ( FileDialog( Title,~<title>~,DefaultDirectory,~<fUndoDirectory>~,PATH,thePath,Open ) )
	{
		return UndoOrRedo( ~<thePath>~ );
	}

	return FALSE;
}

NUMERIC PatternEditor::Open( Path )	// OPEN AN EXISTING PATTERN
{ 
	fPattern.SetPath( ~<Path>~ );

	ReturnOnFailure( fPattern.Read() );
	ReturnOnFailure( fPattern.ParsePattern() );
	ReturnOnFailure( fPattern.ParseOtherData() );

	Rows = fPattern.NumRows();
	Cols = fPattern.NumColumns(1);

	Editor.UpdateStatistics();

	fDirectory = ~<$Str.$Path.Path>~;
//	fPattern.Dump( ~After Open: Row, col, NodeNumber, ControlNumber, NodeName,PositionType,DeltaSizeX,DeltaSizeY,DeltaSizeW,DeltaSizeL~ );

	return TRUE;
}

NUMERIC PatternEditor::TryToOpen( PartialPath,Num )
{
	extension = ~<$Str.$Num.%03ld>~;

	FullPath = ~<PartialPath>.<extension>~;

	if ( !Files( FileExists,~<FullPath>~ ) )	
	{ 
		return FALSE;
	}

	Action = ACTION DOC ( PatternEditorDoc Open PatternEditorDoc3 "OpenPattern( ~<FullPath>~ );" );
	PerformActions( Action );
	
	return TRUE;
}

NUMERIC PatternEditor::OnNextSetup( &Num,&PartialPath )
{
	Num = fPattern.NumCountableNodes();

	ThePath = fPattern.GetPath( ~<Path>~ );

	if ( IsNull( ~<ThePath>~ ) )
	{
		if ( !BrowseForOutputDirectory() )
		{
			return FALSE;
		}

		PartialPath = ~<fDirectory>\Pattern~;
	}
	else
	{
		PartialPath = ~<$Str.$ThePath.WithoutExt>~;
	}

	return TRUE;
}

NUMERIC PatternEditor::SaveIfDirty()
{
	if ( !<fDirty> )	{ return TRUE; }

	if ( MessageBox( Translate( ~Would you like to save your changes? ~),YESNO ) != YES ) 
	{
		fDirty = FALSE;
		return TRUE;
	}
 
	if ( OnSaveButton() )
	{
		fDirty = FALSE;
		return TRUE;
	}
	
	return FALSE;	
}

NUMERIC PatternEditor::OnNextButton()
{ 
	ReturnOnFailure( SaveIfDirty() );

	Num = 0;	PartialPath = ~~;

	ReturnOnFailure( OnNextSetup( Num,PartialPath ) );

	MaxNum = <num> + 1000;

	while ( ++num < <MaxNum> )
	{
		if ( TryToOpen( ~<PartialPath>~,<num> ) )
		{
			CloseWindow();
			return TRUE;
		}
	}

	return Warning( ~No more patterns~ );
}

NUMERIC PatternEditor::OnPrevButton()
{ 
	ReturnOnFailure( SaveIfDirty() );

	Num = 0;	PartialPath = ~~;

	ReturnOnFailure( OnNextSetup( Num,PartialPath ) );

	while ( --num > 0 )
	{
		if ( TryToOpen( ~<PartialPath>~,<num> ) )
		{
			CloseWindow();
			return TRUE;
		}
	}

	return Warning( ~No more patterns~ );
}

NUMERIC PatternEditor::OnGotoButton()
{ 
	ReturnOnFailure( SaveIfDirty() );

	ViewControl( GetControlValue,GotoField,GotoNum );

	if ( IsNull( ~<GotoNum>~ ) )
	{
		return Warning( ~You must enter the number of countable nodes~ );
	}

	PartialPath = ~~;

	ReturnOnFailure( OnNextSetup( Num,PartialPath ) );

	if ( TryToOpen( ~<PartialPath>~,<GotoNum> ) )
	{
		CloseWindow();
		return TRUE;
	}

	return Warning( ~Pattern for size <GotoNum> does not exist~ );
}

NUMERIC	PatternEditor::OnRevertButton()
{
	thePatternPath = fPattern.GetPath();

	if ( IsNull( ~<thePatternPath>~ ) )
	{
		return Warning( ~Nothing to revert to~ );
	}

	if (<fMaxNode> > <TotalAllowed>)
	{
		return Warning( Translate( ~Cannot revert because there are too many nodes~));
	}

	if ( MessageBox( Translate( ~Are you sure you want to revert to the last saved version of <thePatternPath>? ~),YESNO ) != YES ) 
	{
		return FALSE;
	}

	Action = ACTION DOC ( PatternEditorDoc Open PatternEditorDoc3 "OpenPattern(~<thePatternPath>~);" );
	PerformActions( Action );

	if ( Defined( Editor ) )	{ Editor.EnableTheWindow( TRUE ); }

	BaseForm::OnCloseDataWindow();
	
	return TRUE;
}


VOID PatternEditor::CloseWindow()
{
	CleanupUndo();

	if ( !Keystate( Control ) )
	{
		<THIS>.OnCloseDataWindow();
	}
}

VOID PatternEditor::OnCloseDataWindow( Name )
{
	RemoveView();

	if ( RemoveView() )
	{
		return;
	}

	if ( !SaveIfDirty() )
	{
		return;
	}

	if ( <fCleanupUndo> )
	{
		CleanupUndo();
	}

	BaseForm::OnCloseDataWindow( ~<Name>~ );
}

NUMERIC PatternEditor::ProcessDraggedFile( Path )	// HANDLE DRAGS OF PATTERN FILES ON TO THE WINDOW
{
	Action = ACTION DOC ( PatternEditorDoc3 Open PatternEditorDoc3 "OpenPattern(~<Path>~);" );
	return PerformActions( Action );
}


NUMERIC PatternEditor::CreateNew()	{ fDirty = TRUE; return fPattern.CreateNew( <Rows>,<Cols> ); }



// --------------------------------- Script Entry Points -------------------------------------- //


NUMERIC Init( nRows,nCols )	// CREATE A NEW PATTERN
{
	WaitCursor( Begin );

	if ( IsNull(~<nRows>~) || IsNull(~<nCols>~) )	// PROMPT USER FOR # ROWS AND COLS?
	{
		Class( CreatePatternDialog,Extends,BaseDialog );
		CreatePatternDialog( New,CreateDlg );
		Global( CreateDlg );
		CreateDlg.DefineDialog();
	}
	else	// CREATE NEW PATTERN WITH SELECTED ROWS AND COLS
	{
		PatternEditor( New,Editor );
		Editor( Global );
		Editor.SetRowsCols(~<nRows>~,~<nCols>~);
		Editor.CreateNew();
		Editor.UpdateStatistics();
		Editor.DefineWindow();
		Editor.Init();
		Editor.ForgetUndo();
		Editor.MaintainWindowTitle();
		Editor.InitNodeNameField();
	}

	WaitCursor( End );

	return TRUE;
}


NUMERIC OpenPattern( Path )	// OPEN A PREVIOUSLY SAVED PATTERN
{
	WaitCursor( Begin );

	PatternEditor( New,Editor );
	Editor( Global );
	
	ReturnOnFailure( Editor.Open( ~<Path>~ ) );
	ReturnOnFailure( Editor.DefineWindow() );
	ReturnOnFailure( Editor.Init() );	
	Editor.MaintainWindowTitle();
	Editor.ForgetUndo();

	return WaitCursor( End );
}


VOID AskToSave( NeedPermission )
{
	if ( Defined( Editor ) )
	{
		if (Editor.IsDirty())
		{
			Editor.OnSaveRoutine(<NeedPermission>);
		}
	}
}