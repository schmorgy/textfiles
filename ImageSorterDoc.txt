ScannerDocHR500 = FALSE;

Include: ~ScannerHR500CommonDoc.txt~;
Include: ~ImageTypeSorterDefaults.txt~;
Include: ~DeleteOrder.txt~;
Include: ~Utilities2.txt~;

Include: ~ImageSorterJobCreation.txt~;


VOID SetupSizzleControl()
{
	Define:	SizzleControl Using DDHR500FTControlDict
		Fields:	xPos				 50.
				yPos				 50.
				ScanWidth			 100.
				ScanLength			 100.
				OpticalZoom			 0
				ScanSize			 0
				NextInfoAdjusted	 0
				NextPunch			 (-9)
				NextXOffset			 0
				NextXPos			 0.
				NextYPos			 0.
				NextScanWidth		 0.
				NextScanLength		 0.
				ScanAreaInPercent	 1
				ScannerSharpenAmount 0
				SharpenDelta		 0
				Rotation			 0
				Focus				 0
				FocusRange			 300
				Size				 1000
				redOverride			 0
				greenOverride		 0
				blueOverride		 0
				contrastOverride	 0
				brightnessOverride	 0
				DeleteScanObj		 0
				ScanObj				 0
				ScanObjIndex		 0
				SaveObjIndex		 0
				ImageBuffer			 0
				ImageBufferWidth	 0
				ImageBufferHeight	 0
				ImageBufferDepth	 0
				ImageBufferLayout	 ~~
				DisplayLastImage	 1
				FirstValidPixel		 0
				LastValidPixel		 0
				UseAnalyzerDRGBValues 0
				DirtyFlag			 0
				AutoSaveToDisk		 1
				ICCProfile			~~
				ICCOutputProfile	~rgbMaster~
				EmbedProfile		 0
				MaxThumbNailSize	 500
				Path				 ~~ 
				FetchTimeout		(1000 * 60)
				FetchCompleteNotification	~ImageFetchComplete();~
				FetchErrorNotification		~FetchErrorNotification();~
				FlushCompleteNotification	~ImageFlushComplete(%ld);~
				FlushErrorNotification		~FlushErrorNotification(%ld);~
				FocusProgressNotification	~FocusProgress(%ld);~
				FocusCompleteNotification	~FocusComplete();~
				FocusErrorNotification		~FocusErrorNotification();~
				FocusWarningNotification	~FocusWarningNotification();~
				FocusCancelNotification		~FocusCancelNotification();~
				PreScanNotification			~~
				ScanCompleteNotification	~~
				ScanErrorNotification		~ScanErrorNotification(%ld);~
				RenderOverScanError			~RenderOverScanError(%ld);~
				RenderOverScanComplete		~RenderOverScanComplete(%ld);~
				LoadCompleteNotification	~LoadFilmComplete();~
				UnloadCompleteNotification	~UnloadFilmComplete(%ld,%ld);~
				FrameDetectErrorNotification ~~
				SpliceDetectedNotification	 ~~
				AutoSkipFDABlankFrame		0
				OverScan					0
				OverScanYPos				50.
				OverScanXPos				50.
				OverScanWidth				100.
				OverScanHeight				100.
				WaitingForOverScan			0
				WaitingForDisplay			0
				AdjustingNextFrame			0
				FDAErrorOnPrevious			0
				FDAErrorOnCurrent			0
				AutoFDAErrorHandlingEnabled	0
				SavedAutoScanState			0
				FileResolution				250
				AdaptiveSharpen				0
				SharpenAmount				0.0
				SharpenFaster				1
				SharpenLimit				150
				SharpenThreshold			90
				SharpenBlurAmount			0
				NoiseReductionAmount		0.0
				ExposureTime				0.
				FrameDetectStartTime		0
				FrameDetectCompleteTime		0
				EdgeCollectStartTime		0
				EdgeCollectCompleteTime		0
				FrameStatus					0
				UseImageOverrides			0
				UseDigitalIce				0
				DigitalIceType				<kDICELevelLow>
				UseSBAPlus					0
				SBALevel					0
				CMM							100
				PreferenceClass				0
				PCWF						700
				IgnoreSFS					0
				OverscanFilmType			0
				EdgeSensitivity				40
				MinGap						0
				FilmEdge					FALSE
				FilmPosition				0.0
				FilmStatus					0
				SkippingBlankFilm			FALSE
				IgnoreFdaErrors				FALSE
				DisableFrameDetect			FALSE
				LastMoveDirection			0
				ImageSizeInMM				0
				NewStrip					0
				FuzzyPositioningFactor		0
				AlignmentFlag				0
				FilmType					~~
				RescanningFrame				FALSE
				CropX						50
				CropY						50
				CropWidth					100
				CropLength					100
				SaveFileType				~TIFF~
				FileExtension				~.tif~
				JPEGQuality					100

				saDensity					0
				saRed						0
				saGreen						0
				saBlue						0

				dDensity					0
				dRed						0
				dGreen						0
				dBlue						0

				DRGBRef						~~
				TotalMatching				0
				RangeMatch					0

				FilmDriveType				0
				DumpRawIRData				0
	;

	Global( SizzleControl );
}

OldSettingsMatch = 1;
OldSettingsDontMatch = 2;
NoDBSettings = 3;

NUMERIC LoadScannerRoutines()
{
	dlg( GetInput );

	SimulateTheScanner = DlgData( GetNumeric,Simulating );

	WaitCursor( Begin );

	dlg( SetStatus,0,~Connecting to and initializing scanner~ );

	if ( Defined( Scanner ) )
	{
		Scanner( CleanupLastScan, SizzleControl );
	}
	ForgetGlobal( Scanner );

	if (  !HR500( Scanner,Simulating,<SimulateTheScanner> ) )
	{
		dlg( SetStatus,0,~Error starting the scanning software.~ );
		return Warning( Translate( ~Error starting the scanning software.~ ) );
	}

	if ( !Scanner( Initialize ) )
	{
		dlg( SetStatus,0,~Unable to connect to the scanner~ );
		ErrMsg = Translate( ~Unable to connect to and initialize the scanner.~ );
		return HandleHR500Error( ~<ErrMsg>~ );
	}

	Global( Scanner );

	if ( !Scanner( Version,FirmwareVersion ) )
	{
		ErrMsg = Translate( ~Error getting firmware version information.~ );
		return HandleHR500Error( ~<ErrMsg>~ );
	}

	Log( Session,~HR500 Firmware Version <FirmwareVersion>~ );

	if ( !Scanner( GetSerialNumber,ScannerSerialNumber ) )
	{
		Warning( Translate( ~Could not get serial number of scanner.~ ) );
	}

	Log( Session,~HR500 Serial Number <ScannerSerialNumber>~ );

	UpdateLampOnTime( TRUE,TRUE );

	UpdateLampState( );

	FWNum = Numeric( ~<FirmwareVersion>~ );
	CFWNum = Numeric( ~<CurrentHR500FirmwareVersion>~ );
	if ( !<SimulateTheScanner> && ( <FWNum> < <CFWNum> ) )
	{
		fwFile= String( Replace, ~<CurrentHR500FirmwareVersion>~, ~.~, ~_~ );
		Warning( ~The firmware version reported by the scanner (<FirmwareVersion>) does\nnot match the firmware version expected by this version of\nDP2 (<CurrentHR500FirmwareVersion>).\n\nNOTE:  While this doesn't prevent you from continuing to use\nthe scanner, you should load the latest version of the firmware\nonto the scanner to avoid unexpected results while using the\nscanner.\n\nThe latest firmware is located in <$App.Directory>\HR500\Px<fwFile>.zip.~ );
	}
	
	if ( !Scanner( Is4x5Capable ) )
	{
		UniversalScanner = FALSE;
		GetFilmDriveVendor();
		if ( ~<FDVendor>~ == ~None~ )
		{
			HR500_NoFilmDriveSelected();
		}
	}
	else
	{
		UniversalScanner = TRUE;

		filmFormat = ~<$con.DlgData[Format]>~;
		if ( !Scanner( SetFilmSize,~<filmFormat>~ ) )
		{
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && DlgData(GetNumeric,FilmDriveEnabled) )
			{ SetTransportControlsStopped(); }
			ErrMsg = Translate( ~Incompatible film format.~ );
			HandleHR500Error( ~<ErrMsg>~ );
			return FALSE;
		}
	}
	WaitCursor( End );

	LastFilmType = ~<$con.DlgData[FilmType]>~;

	FilmType = ~<$con.DlgData[FilmType]>~;
	LastFilmType = ~<FilmType>~;

	DlgData( Get,SFSFile,SFSFile );

	FilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<FilmType>.flt~;

	if ( ~<SFSFile>~ == ~~ )
	{
		SFSFile = ~<$App.ShareDirectory>\Scan\HR500\kcdfs.satdef~;
	}

	if ( !Scanner( LoadFilmTermsFromFile,~<FilmTermsFile>~,~<FilmType>~,~<SFSFile>~ ) )
	{
		ErrMsg = Translate( ~Could not find or load <FilmTermsFile>.~ );
		HandleHR500Error( ~<ErrMsg>~ );
		return FALSE;
	}

	CheckStoredCalibration( TRUE,FALSE,FALSE );

	SetTimeCallsFlag();

	SetTraceCallsFlag();

	return TRUE; 
}


NUMERIC OnFormatChange(reason, statusText, UpdateCrop, UpdateYCorrection, DoCalibration)
{
	// Reason values:
	// 1 = Settings loaded
	// 2 = Film type changed (positive/negative)
	// 3 = Film format changed (35mm, etc)
	// 4 = Scan sized changed
	// 5 = Optical zoom changed
	// 6 = Crop loaded

	dlg( SetStatus,0,~<statusText>~ );

	loadingSettings = FALSE;
	if ( <reason> == 1 ) 
	{
		loadingSettings = TRUE;
	}

	filmTypeChanged = FALSE;
	if ( <reason> == 2 ) 
	{
		filmTypeChanged = TRUE;
	}

	filmFormatChanged = FALSE;
	if ( <reason> == 3 )
	{
		filmFormatChanged = TRUE;
	}

	if ( <filmFormatChanged> || <loadingSettings> )
	{
		IgnorePredefinedFrameWidths = DlgData( GetNumeric, IgnorePredefinedFrameWidths );
	}

	CheckOverScanAdjustment( 0 );

	scanSizeChanged = FALSE;
	if ( <reason> == 4 ) 
	{
		scanSizeChanged = TRUE;
	}

	opticalZoomChanged = FALSE;
	if ( <reason> == 5 ) 
	{
		opticalZoomChanged = TRUE;
	}
	lowVal = dlgData(GetAttrInfo, OpticalZoom, LowValue);
	highVal = dlgData(GetAttrInfo, OpticalZoom, HighValue);

	if ( !CheckZoom() )
	{
		return FALSE;
	}

	OpticalZoom = ~<$Con.DlgData[OpticalZoom]>~;
	if ( <OpticalZoom> == <LastOpticalZoomSetting> )
	{	
		opticalZoomChanged = FALSE;
	}

//	Add scan area settings for Halse Drive
	FilmDriveEnabled = DlgData( GetNumeric,FilmDriveEnabled );
	GetFilmDriveVendor();

	Filmformat = ~<$Con.DlgData[Format]>~;
	if ( <loadingSettings> || (~<Filmformat>~ != ~<gCurrentFilmFormat>~) )
	{
		if ( <FilmDriveEnabled> && FunctionDefined( ~<FDVendor>_RefreshScanAreaSettings~ ) )
		{
			<FDVendor>_RefreshScanAreaSettings( <reason>,<loadingSettings>,~FTScanSetups~ );
		}
	}

	if ( <UpdateCrop> && <reason> != 6 )
	{
		RefreshCropsComboBox(TRUE);
	}

	if ( <UpdateYCorrection> )
	{
		UpdateEditorXYOffsetSetting();
	}

	gCurrentFilmFormat = ~<$con.DlgData[Format]>~;
	if ( Defined(Scanner) && <UniversalScanner> && ( <filmFormatChanged> || <loadingSettings> ) )
	{
		if ( !Scanner( SetFilmSize,~<FilmFormat>~ ) )
		{
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> )
			{ SetTransportControlsStopped(); }
			ErrMsg = Translate( ~Incompatible film format.~ );
			HandleHR500Error( ~<ErrMsg>~ );
			return FALSE;
		}
	}

	if ( !<filmTypeChanged> && !<loadingSettings> )
	{
		filmTypeChanged = FilmTypeChange();
	}

	CurrentScanSizePos = ~<$Con.DlgData[SpeedQuality]>~;
	NeedToCalibrate = FALSE;
	if ( Defined(Scanner) ) // && !<loadingSettings> )
	{
		SetMagnification( False );
		if ( Scanner(MagChanged) )
		{
			MagNeeded = TRUE;
		}
		else
		{
			MagNeeded = FALSE;
		}
	}
	showMessage = TRUE;

//	if ( <scanSizeChanged> || <opticalZoomChanged> || <filmFormatChanged> )
	if ( !<loadingSettings> ) 
	{
		if ( ( <LastScanSizePos> != <CurrentScanSizePos> ) || 
			 ( <OpticalZoom> != <LastOpticalZoomSetting> ) || 
			   <filmFormatChanged> || <MagNeeded>		 )
		{
			if (!UpdateScanSize(FALSE,TRUE,TRUE))
			{
				EnableScanningControls( TRUE );
				if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
				return FALSE;
			}

			if ( Defined(Scanner) )
			{
				if ( !CheckStoredCalibration( TRUE,<DoCalibration>,IsDriveTensioned( FALSE ) ) )
				{
					NeedToCalibrate = TRUE;
				}
				showMessage = FALSE;
			}
			LastScanSizePos = <CurrentScanSizePos>;
			LastOpticalZoomSetting = <OpticalZoom>;
		}
	}
	if ( <filmTypeChanged> )
	{
		if (!UpdateScanSize(FALSE,FALSE,TRUE))
		{
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return FALSE;
		}

		if ( Defined(Scanner) )
		{
			if ( CheckStoredCalibration( TRUE,<showMessage>,IsDriveTensioned( FALSE ) ) ) //film drive enabled?
			{
				if ( !<MagNeeded> )
				{
					if ( !LoadStoredCalibration( TRUE,FALSE,IsDriveTensioned( FALSE ) ) )
					{
						NeedToCalibrate = TRUE;
					}
				}
			}
			else
			{
				NeedToCalibrate = TRUE;
			}
		}

		DlgData( Get,FilmType,FilmType );
		DlgData( Get,SFSFile,SFSFile );

		if ( ~<SFSFile>~ == ~~ )
		{
			SFSFile = ~<$App.ShareDirectory>\Scan\HR500\kcdfs.satdef~;
		}
		FilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<FilmType>.flt~;
		result = Scanner( IsColorFilterPositionCorrect,~<FilmTermsFile>~,~<FilmType>~,~<SFSFile>~ );
		if ( <result> == -1 )
		{
			ErrMsg = Translate( ~Could not check color filter position for <FilmTermsFile>.~ );
			HandleHR500Error( ~<ErrMsg>~ );
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return FALSE;
		}
		if ( <result> == FALSE )
		{
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return Warning( Translate( ~The color filter is not in the correct position for this film type.\nMake sure the filter is in the correct position and then\nselect OK to continue.~ ) );
		}
	}

	if ( <NeedToCalibrate> && !<loadingSettings> && <DoCalibration> )
	{
		if ( !OnHR500CalibrateButton( FALSE,FALSE,TRUE ) )
		{
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			ClearCalibrationHandlers();
			dlg( SetStatus,0,Translate( ~Calibration did not complete.~ ) );
			return FALSE;
		}
	}

	return TRUE;
}



NUMERIC CalibrationOK( DisplayStatus,DisplayMessage,IgnoreCalibrationTimeOut,UpdateLastMag )
{
	FilmType = ~<$con.DlgData[FilmType]>~;
	Result = 0.0;
	retval = FALSE;

	dlg( GetInput );
	DlgData( GetValues,CalibrationTimeout,calTimeout,IgnoreCalTimeout,ignoreTimeout );
	if ( <ignoreTimeout> || <IgnoreCalibrationTimeOut> == 1 )
	{	calTimeout = -1;	}
	
	userCalTimeout = DlgData( GetNumeric,CalibrationTimeout );
	calStatus = 0;

	if ( !Scanner( NeedCalibration,<calTimeout>,calStatus,<UpdateLastMag> ) )
	{	
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~You will have to calibrate the scanner.~ ) );
		}
		return FALSE;
	}

	if ( <calStatus> == 1 ) // not needed
	{
		retval = TRUE;
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~Calibration is not needed.~ ) );
		}
	}
	else if ( <calStatus> == 2  || (<calStatus> == 3 && <userCalTimeout> == 0) ||
			  <calStatus> == 4  || <calStatus> == 5 ) // cal needed
	{
		retval = FALSE;
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~You will have to calibrate the scanner.~ ) );
		}
	}
	else if ( <calStatus> == 3 ) // cal restored
	{
		retval = TRUE;
		if ( <DisplayStatus> || <DisplayMessage> )
		{	
			dlg( SetStatus,0,Translate( ~Stored calibration values have been loaded.~ ) );
		}
	}
	else if ( <calStatus> == 6 || <calStatus> == 7 ) // mismatched filter position
	{
		retval = FALSE;
		if ( <calStatus> == 7 ) // incorrect color filter position
		{
			if ( <DisplayStatus> )
			{
				dlg( SetStatus,0,Translate(~Incorrect color filter position.~ ) );
			}
			if ( <DisplayMessage> )
			{
				Msg = ~The color filter is not in the correct position for this film type.\nMake sure the filter is in the correct position and then\ntry the operation again.~; 
				Warning( Translate( ~<Msg>~ ) );
			}
		}
		if ( CheckStoredCalibration( <DisplayStatus>,FALSE,<IgnoreCalibrationTimeOut> ) )
		{
			if ( LoadStoredCalibration( <DisplayStatus>,FALSE,<IgnoreCalibrationTimeOut> ) )
			{
				if ( <calStatus> == 6 )
				{
					retval = TRUE;
				}
				if ( <DisplayStatus> || <DisplayMessage> )
				{	
					dlg( SetStatus,0,Translate( ~Stored calibration values have been loaded.~ ) );
				}
			}
			else if ( <DisplayMessage> )
			{
				Warning( Translate( ~The stored calibration failed to load. Please calibrate the scanner.~ ) );
			}
		}
	}
	else
	{	
		retval = FALSE;	
	}

	return <retval>;
}


NUMERIC CheckStoredCalibration( DisplayStatus,DisplayMessage,IgnoreCalibrationTimeOut )
{
	FilmType = ~<$con.DlgData[FilmType]>~;
	Result = 0.0;

	dlg( GetInput );
	DlgData( GetValues,CalibrationTimeout,calTimeout,IgnoreCalTimeout,ignoreTimeout );
	if ( <ignoreTimeout> || <IgnoreCalibrationTimeOut> == 1 )
	{	calTimeout = -1;	}
	
	userCalTimeout = DlgData( GetNumeric,CalibrationTimeout );
	calStatus = 0;

	RealMag = CalculateMagnification( FALSE );

	if ( !Scanner( CheckForStoredCalibration,<RealMag>,<calTimeout>,calStatus ) )
	{	
		return Warning( Translate( ~Unable to check for stored calibration for <RealMag>.~ ) );
	}

	SetMagnification( False );
	if ( Scanner(MagChanged) )
	{
		MagNeeded = TRUE;
	}
	else
	{
		MagNeeded = FALSE;
	}

	if ( <calStatus> == 1 ) // not needed
	{
		retval = TRUE;
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~Stored calibration values exists.~ ) );
		}
	}
	else if ( <calStatus> == 2  || (<calStatus> == 3 && <userCalTimeout> == 0) ||
			  <calStatus> == 4  || <calStatus> == 5 ) // cal needed
	{
		retval = FALSE;
		if (<DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~You will have to calibrate the scanner.~ ) );
		}
	}
	else if ( <calStatus> == 3 ) // stored cal exists
	{
		retval = TRUE;
		if ( <DisplayMessage> || <DisplayStatus> )
			{	dlg( SetStatus,0,Translate( ~Stored calibration values exist.~ ) );	}
	}
	else
	{	
		retval = FALSE;	
	}
	return <retval>;
}


NUMERIC LoadStoredCalibration( DisplayStatus,DisplayMessage,IgnoreCalibrationTimeOut )
{
	FilmType = ~<$con.DlgData[FilmType]>~;
	Result = 0.0;

	dlg( GetInput );
	DlgData( GetValues,CalibrationTimeout,calTimeout,IgnoreCalTimeout,ignoreTimeout );
	if ( <ignoreTimeout> || <IgnoreCalibrationTimeOut> == 1 )
	{	calTimeout = -1;	}
	
	userCalTimeout = DlgData( GetNumeric,CalibrationTimeout );
	calStatus = 0;

	RealMag = CalculateMagnification( FALSE );

	if ( !Scanner( LoadStoredCalibration,<RealMag>,<calTimeout>,calStatus ) )
	{	
		return Warning( Translate( ~Unable to load stored calibration for <RealMag>.~ ) );
	}

	if ( <calStatus> == 1 ) // not needed
	{
		retval = TRUE;
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~Stored calibration values have been loaded.~ ) );
		}
	}
	else if ( <calStatus> == 2  || (<calStatus> == 3 && <userCalTimeout> == 0) ||
			  <calStatus> == 4  || <calStatus> == 5 ) // cal needed
	{
		retval = FALSE;
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~You will have to calibrate the scanner.~ ) );
		}
		if ( <DisplayMessage> )
		{
			if ( <IgnoreCalibrationTimeOut> )
			{
				Msg = ~You will have to calibrate before performing this operation.~;
			}
			else
			{
				Msg = ~You will have to calibrate before scanning or focusing.~;
			}
			Warning( Translate( ~<Msg>~ ) );
		}
	}
	else if ( <calStatus> == 3 ) // cal restored
	{
		if ( <DisplayStatus> || <DisplayMessage> )
		{	
			dlg( SetStatus,0,Translate( ~Stored calibration values have been loaded.~ ) );
		}
		retval = TRUE;
	}
	else
	{	
		retval = FALSE;	
	}
	return <retval>;
}

VOID SetupTheScanner( TestScan,FullScanArea )
{
	MagIndex = MagNames( IndexOf,~<$Con.DlgData[Format]>~ );

	ResIndex = ResolutionNames( IndexOf,~<$Con.DlgData[ScanResolution]>~ );
	Size	 = atof(Resolutions( ValueOf,$ResIndex ));
	Depth	 = 3;
	Rotation = DlgData( GetNumeric,ScanRotation );

	SizzleControl( SetValues,DEPTH,<Depth>,SIZE,<Size>,Rotation,<Rotation> );

	if ( <FullScanArea> )
	{
		SizzleControl( SetValues,xPos,50,yPos,50,ScanWidth,100,ScanLength,100 );
	}
	else
	{
		SizzleControl( SetValues,xPos,DlgData(GetNumeric,xPos),yPos,DlgData(GetNumeric,yPos),
							ScanWidth,DlgData(GetNumeric,ScanWidth),ScanLength,DlgData(GetNumeric,ScanLength) );

		if ( FunctionDefined( ~<FDVendor>_GetScanHeightPercent~ ) && SizzleControl( GetNumeric,overscan ) )
		{
			scanLength = <FDVendor>_GetScanHeightPercent() * 100.;
			SizzleControl( SetValues,ScanLength,<scanLength> );
		}
	}
	SizzleControl( SetValues,OverScanXPos,DlgData(GetNumeric,OverScanXPos),OverScanYPos,DlgData(GetNumeric,OverScanYPos),
							OverScanWidth,DlgData(GetNumeric,OverScanWidth),OverScanHeight,DlgData(GetNumeric,OverScanLength) );

	SizzleControl( SetValues,SaveFileType,~<$con.DlgData[SaveFileType]>~,
							 FileExtension,~<$con.DlgData[FileExtension]>~,
							 JPEGQuality,DlgData(GetNumeric,JPEGQuality) );

	SizzleControl( SetValues,DumpRawData,DlgData(GetNumeric,DumpRawData) );
	SizzleControl( SetValues,LogActivity,DlgData(GetNumeric,LogActivity) );
	SizzleControl( SetValues,TraceCalls,DlgData(GetNumeric,TraceCalls) );
	SizzleControl( SetValues,TimeCalls,DlgData(GetNumeric,TimeCalls) );
	SizzleControl( SetValues,ScannerProfileEnabled,DlgData(GetNumeric,ScannerProfileEnabled),OutputProfileEnabled,DlgData(GetNumeric,OutputProfileEnabled) );
	SizzleControl( SetValues,ICCProfile,~<$con.DlgData[ICCProfile]>~,ICCOutputProfile,~<$con.DlgData[ICCOutputProfile]>~ );
	SizzleControl( SetValues,EmbedProfile,DlgData(GetNumeric,EmbedProfile));
	SizzleControl( SetValues,TestScan,<TestScan> );

	SizzleControl( SetValues,DisplayLastImage,DlgData( GetNumeric,DisplayLastImage ) );
	SizzleControl( SetValues,FocusRange,DlgData(GetNumeric,FocusRange) );

	DlgData( Get,LutFile,LutFile );	
	SizzleControl( Set,LutFile,~<LutFile>~ );
}

NUMERIC CheckRangeSettings()
{
	NumScans = DlgData( GetNumeric,ScansToSave );
	if ( <NumScans> < 10 )
	{
		msg = ~The number of scans to save must be greater than or equal to 10.\nPlease enter a valid number.~;
		return Warning( Translate( ~<msg>~ ) );
	}

	DlgData( GetValues,FilmType,newFilmType,SFSFile,newSFSFile );

	if ( !VerifySFSFile() )
	{
		return Warning( Translate( ~The Subject Failure Suppression Boundary Set File (<newSFSFile>) does not exist.\nPlease go to the Scan tab and select a valid file.~ ) );
	}

	SizzleControl( GetValues,FilmTermFile,FilmType,SFSFile,SFSFile );

	if ( ~<SFSFile>~ == ~~ )
	{
		SFSFile = ~<newSFSFile>~;
	}

	if ( ~<FilmType>~ == ~~ )
	{
		FilmType = ~<newFilmType>~;
	}

	Files( FilenamePlusExt,~<newSFSFile>~,newSFSName );
	Files( FilenamePlusExt,~<SFSFile>~,SFSName );

	DlgData( Get,ScanSetup,ScanSetup );
	SizzleControl( Set,FTScanSetup,~<ScanSetup>~ );

	newAvgDenNKey = DlgData( GetNumeric,AvgDenNKey );
	newAvgDenNMin = DlgData( GetNumeric,AvgDenNMin );
	newAvgDenNMax = DlgData( GetNumeric,AvgDenNMax );

	newAvgDenRGBKey = DlgData( GetNumeric,AvgDenRGBKey );
	newAvgDenRMin = DlgData( GetNumeric,AvgDenRMin );
	newAvgDenRMax = DlgData( GetNumeric,AvgDenRMax );
	newAvgDenGMin = DlgData( GetNumeric,AvgDenGMin );
	newAvgDenGMax = DlgData( GetNumeric,AvgDenGMax );
	newAvgDenBMin = DlgData( GetNumeric,AvgDenBMin );
	newAvgDenBMax = DlgData( GetNumeric,AvgDenBMax );

	newHueSatKey = DlgData( GetNumeric,HueSatKey );
	newAvgHueMin = DlgData( GetNumeric,AvgHueMin );
	newAvgHueMax = DlgData( GetNumeric,AvgHueMax );
	newAvgSatMin = DlgData( GetNumeric,AvgSatMin );
	newAvgSatMax = DlgData( GetNumeric,AvgSatMax );

	newSBAFleshKey = DlgData(GetNumeric,SBAFleshKey);
	newSBAFleshMin = DlgData( GetNumeric,SBAFleshMin );
	newSBAFleshMax = DlgData( GetNumeric,SBAFleshMax );

	SizzleControl( Set,UseSBAPlus,<newSBAFleshKey> );
	
	DlgData( GetValues,Order,Order,Frame,Frame );

	if (~<Frame>~ == ~<lastFrameScanned>~ )
	{
		SizzleControl( Set,RescanningFrame,TRUE );
	}
	else
	{
		SizzleControl( Set,RescanningFrame,FALSE );
	}

	if ( ~<newSFSName>~	 != ~<SFSName>~							   || 
		 ~<newFilmType>~ != ~<FilmType>~						   || 
		 <newAvgDenNKey> != SizzleControl( GetNumeric,AvgDenNKey ) ||
		 <newAvgDenNMin> != SizzleControl( GetNumeric,AvgDenNMin ) ||
		 <newAvgDenNMax> != SizzleControl( GetNumeric,AvgDenNMax ) ||
		 <newAvgDenRGBKey> != SizzleControl( GetNumeric,AvgDenRGBKey ) ||
		 <newAvgDenRMin> != SizzleControl( GetNumeric,AvgDenRMin ) ||
		 <newAvgDenRMax> != SizzleControl( GetNumeric,AvgDenRMax ) ||
		 <newAvgDenGMin> != SizzleControl( GetNumeric,AvgDenGMin ) ||
		 <newAvgDenGMax> != SizzleControl( GetNumeric,AvgDenGMax ) ||
		 <newAvgDenBMin> != SizzleControl( GetNumeric,AvgDenBMin ) ||
		 <newAvgDenBMax> != SizzleControl( GetNumeric,AvgDenBMax ) ||
		 <newHueSatKey> != SizzleControl( GetNumeric,HueSatKey ) ||
		 <newAvgHueMin> != SizzleControl( GetNumeric,AvgHueMin ) ||
		 <newAvgHueMax> != SizzleControl( GetNumeric,AvgHueMax ) ||
		 <newAvgSatMin> != SizzleControl( GetNumeric,AvgSatMin ) ||
		 <newAvgSatMax> != SizzleControl( GetNumeric,AvgSatMax ) ||
		 <newSBAFleshKey> != SizzleControl( GetNumeric,SBAFleshKey ) ||
		 <newSBAFleshMin> != SizzleControl( GetNumeric,SBAFleshMin ) ||
		 <newSBAFleshMax> != SizzleControl( GetNumeric,SBAFleshMax ) )
	{
		if ( !ValidateRanges() )
		{
			return FALSE;
		}

		SizzleControl( Get,Order,OldOrderID );

		if ( ~<OldOrderID>~ != ~~ )
		{
			if ( !AskToDeleteOrder( ~<Order>~,<OldSettingsDontMatch> ) )
			{
				return FALSE;
			}
		}
		else
		{
			result = CheckForOrderInSummaryTable( ~<Order>~,~<newFilmType>~,~<newSFSName>~ );
			if ( <result> != <NoDBSettings> )
			{
				if ( !AskToDeleteOrder( ~<Order>~,<result> ) )
				{
					return FALSE;
				}
			}
		}

		Scanner( ZeroScanCount );
		Scanner( ClearLastMatchingFrame );

		SizzleControl( SetValues,SFSFile,~<newSFSFile>~ );
		SizzleControl( Set,FilmTermFile,~<newFilmType>~ );

		SizzleControl( SetValues,AvgDenNKey,<newAvgDenNKey>,
								 AvgDenNMin,<newAvgDenNMin>,
								 AvgDenNMax,<newAvgDenNMax> );

		SizzleControl( SetValues,AvgDenRGBKey,<newAvgDenRGBKey>,
								 AvgDenRMin,<newAvgDenRMin>,
								 AvgDenRMax,<newAvgDenRMax>,
								 AvgDenGMin,<newAvgDenGMin>,
								 AvgDenGMax,<newAvgDenGMax>,
								 AvgDenBMin,<newAvgDenBMin>,
								 AvgDenBMax,<newAvgDenBMax> );

		SizzleControl( SetValues,HueSatKey,<newHueSatKey>,
								 AvgHueMin,<newAvgHueMin>,
								 AvgHueMax,<newAvgHueMax> );

		SizzleControl( SetValues,AvgSatMin,<newAvgSatMin>,AvgSatMax,<newAvgSatMax> );

		SizzleControl( SetValues,SBAFleshKey,<newSBAFleshKey>,
								 SBAFleshMin,<newSBAFleshMin>,
								 SBAFleshMax,<newSBAFleshMax> );

	}
	return TRUE;
}

NUMERIC CheckForOrderInSummaryTable( Order,FilmType,SFSFilename )
{
	Query = ~SELECT * from ImageSorterSummary WHERE OrderID = '<Order>'~;
	
	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		Warning( Translate( ~Failed to query the ImageSorterSummary table.\n\n<Query>\n\n<theErr>~ ) ); 
		return TRUE;
	}

	if ( !List( GetFirst,Item ) )
	{
		return <NoDBSettings>;
	}

	newSFSFile = ~<$pcon.Item[SFSFile]>~;
	newFilmType = ~<$pcon.Item[FilmTerm]>~;
	newAvgDenNKey = atof( ~<$pcon.Item[AvgDenNKey]>~ );
	newAvgDenNMin = atof( ~<$pcon.Item[AvgDenNMin]>~ );
	newAvgDenNMax = atof( ~<$pcon.Item[AvgDenNMax]>~ );

	newAvgDenRGBKey = atof( ~<$pcon.Item[AvgDenRGBKey]>~ );
	newAvgDenRMin = atof( ~<$pcon.Item[AvgDenRMin]>~ );
	newAvgDenRMax = atof( ~<$pcon.Item[AvgDenRMax]>~ );
	newAvgDenGMin = atof( ~<$pcon.Item[AvgDenGMin]>~ );
	newAvgDenGMax = atof( ~<$pcon.Item[AvgDenGMax]>~ );
	newAvgDenBMin = atof( ~<$pcon.Item[AvgDenBMin]>~ );
	newAvgDenBMax = atof( ~<$pcon.Item[AvgDenBMax]>~ );

	newHueSatKey = atof( ~<$pcon.Item[HueSatKey]>~ );
	newAvgHueMin = atof( ~<$pcon.Item[AvgHueMin]>~ );
	newAvgHueMax = atof( ~<$pcon.Item[AvgHueMax]>~ );
	newAvgSatMin = atof( ~<$pcon.Item[AvgSatMin]>~ );
	newAvgSatMax = atof( ~<$pcon.Item[AvgSatMax]>~ );

	newSBAFleshKey = atof( ~<$pcon.Item[SBAFleshKey]>~ );
	newSBAFleshMin = atof( ~<$pcon.Item[SBAFleshMin]>~ );
	newSBAFleshMax = atof( ~<$pcon.Item[SBAFleshMax]>~ );

	if ( ~<newSFSFile>~	 != ~<SFSFilename>~					 || 
		 ~<newFilmType>~ != ~<FilmType>~					 || 
		 <newAvgDenNKey> != DlgData( GetNumeric,AvgDenNKey ) ||
		 <newAvgDenNMin> != DlgData( GetNumeric,AvgDenNMin ) ||
		 <newAvgDenNMax> != DlgData( GetNumeric,AvgDenNMax ) ||
		 <newAvgDenRGBKey> != DlgData( GetNumeric,AvgDenRGBKey ) ||
		 <newAvgDenRMin> != DlgData( GetNumeric,AvgDenRMin ) ||
		 <newAvgDenRMax> != DlgData( GetNumeric,AvgDenRMax ) ||
		 <newAvgDenGMin> != DlgData( GetNumeric,AvgDenGMin ) ||
		 <newAvgDenGMax> != DlgData( GetNumeric,AvgDenGMax ) ||
		 <newAvgDenBMin> != DlgData( GetNumeric,AvgDenBMin ) ||
		 <newAvgDenBMax> != DlgData( GetNumeric,AvgDenBMax ) ||
		 <newHueSatKey> != DlgData( GetNumeric,HueSatKey )	 ||
		 <newAvgHueMin> != DlgData( GetNumeric,AvgHueMin )	 ||
		 <newAvgHueMax> != DlgData( GetNumeric,AvgHueMax )	 ||
		 <newAvgSatMin> != DlgData( GetNumeric,AvgSatMin )	 ||
		 <newAvgSatMax> != DlgData( GetNumeric,AvgSatMax )	 ||
		 <newSBAFleshKey> != DlgData( GetNumeric,SBAFleshKey ) ||
		 <newSBAFleshMin> != DlgData( GetNumeric,SBAFleshMin ) ||
		 <newSBAFleshMax> != DlgData( GetNumeric,SBAFleshMax ) )
	{
		return <OldSettingsDontMatch>;
	}

	SizzleControl( Set,TotalMatching,~<$pcon.Item[MatchingScans]>~ );

	return <OldSettingsMatch>;
}


NUMERIC AskToDeleteOrder( Order,OldSettingsState )
{
	if ( <OldSettingsState> == <OldSettingsDontMatch> )
	{
		msg = ~The current Range Values do not match the settings from the last <Order> session.~;
		msg = ~<msg>\n\nIn order to continue, the existing data for the <Order> must be deleted.\n~;
	}
	else
	{
		msg = ~There is data in the database for the last <Order> session with the current range settings.~;
		msg = ~<msg>\n\nIf you want to start a fresh session with new images, the existing data for the <Order> must be deleted.\n~; 
	}

	msg = ~<msg>\n\nDo you want to delete the existing data for the <Order> now?~;

	if ( MessageBox( Translate( ~<msg>~ ),YESNO ) == NO )
	{
		if ( <OldSettingsState> == <OldSettingsMatch> )
		{
			return TRUE;
		}
		dlg( SetStatus,0,Translate( ~Scanning cancelled.~ ) );
		if ( Defined( Scanner ) )
		{
			Scanner( UpdateSummaryScanCount,~<Order>~ );
		}
		EnableScanningControls( TRUE );
		SetTransportControlsStopped();
		Warning( Translate( ~Scanning cancelled.~ ) );
		return FALSE;
	}
	else
	{
		dlg( SetStatus,0,Translate( ~Deleting Order <Order>.~ ) );
		if ( !DeleteOrderInfo( ~<Order>~ ) )
		{
			dlg( SetStatus,0,Translate( ~Scanning cancelled.~ ) );
			EnableScanningControls( TRUE );
			SetTransportControlsStopped();
			return FALSE;
		}
		if ( !AddOrder() )
		{
			return FALSE;
		}
		lastFrameScanned = ~~;
		SizzleControl( Set,RescanningFrame,FALSE );
		SizzleControl( Set,TotalMatching,0 );
	}
	return TRUE;
}

NUMERIC DeleteOrderInfo( OrderID )
{
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate(DBMessages,ConnectionFailed,~<Orders>~,~<theErr>~) );
	}

	result = CanDeleteOrder(dBase,~<OrderID>~);  // returns: TRUE, -1, -2

	if (<result> == TRUE)
	{
		result = DeleteOrdersItemsAndImages( dBase,~<OrderID>~,TRUE,TRUE,TRUE );
	}
	else
	{
		MessageBox( Translate(OrdersMessages,CantDeleteOrder2,~<$con.Order[ID]>~),OK );
		result = FALSE;
	}

	return <result>;
}


VOID CheckImageSorterCount()
{
	if ( !Defined( Scanner ) )
	{
		return;
	}

	DlgData( Get,Order,Order );
	Scanner( UpdateSummaryScanCount,~<Order>~ );
	matching = SizzleControl( GetNumeric,TotalMatching );
	if ( <matching> < DlgData( GetNumeric,ScansToSave ) )
	{
		msg = ~The requested Number of Scans to Save has not yet been saved for Order ID <Order>.\n\n~;
		msg = ~<msg>Please do one of the following:\n~;
		msg = ~<msg>  Load more film and continue scanning\n~;
		msg = ~<msg>  Use the data from the <matching> scans\n~;
		msg = ~<msg>  Change the range values and restart the data collection.~;

		Warning( Translate( ~<msg>~ ) );
	}
}


NUMERIC ScanOne( Focusing,TestScan,FocusBeforeScan )
{
	if ( !FindScanner(FALSE) )	{ return FALSE; }

	SizzleControl( SetValues,Focus,<Focusing> || <FocusBeforeScan> );

	SetupTheScanner( <TestScan>,FALSE );

	DlgData( Get,FilmType,FilmType );
	DlgData( Get,SFSFile,SFSFile );
	if ( ~<SFSFile>~ == ~~ )
	{
		SFSFile = ~<$App.ShareDirectory>\Scan\HR500\kcdfs.satdef~;
	}
	FilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<FilmType>.flt~;
	result = Scanner( IsColorFilterPositionCorrect,~<FilmTermsFile>~,~<FilmType>~,~<SFSFile>~ );
	if ( <result> == -1 )
	{
		ErrMsg = Translate( ~Could not find or load <FilmTermsFile>.~ );
		HandleHR500Error( ~<ErrMsg>~ );
		return FALSE;
	}
	if ( <result> == FALSE )
	{
		return Warning( Translate( ~The color filter is not in the correct position for this film type.\nMake sure the filter is in the correct position and then\nselect OK to continue.~ ) );
	}

	if ( !SetScanWindow() )
	{
		return FALSE;
	}

	dlg( SetString,~10~,Progress,0 );

	//if ( DlgData( GetNumeric,AdjustFramePosition ) )
	//{
		Actions = ACTION Doc ( OverScanImage "DoCancelButton();" );
		PerformActions( Actions );
	//}

	SizzleControl( Get, PreScanNotification, PreScanNotification );
	if ( DefinedAndNotNull( PreScanNotification ) )
	{
		<PreScanNotification>;
	}

	ScannerDlgDefinition( GetWindowPosition,xPos,yPos );
	xPos = <xPos> + ($DialogWidth / 2.0);
	focusRange = SizzleControl( GetNumeric,FocusRange );
	dlg( GetInput,GetStrings,Frame,Frame );

	if ( !<Focusing> )
	{
		if (~<Frame>~ == ~<lastFrameScanned>~ )
		{
			SizzleControl( Set,RescanningFrame,TRUE );
		}
		else
		{
			SizzleControl( Set,RescanningFrame,FALSE );
		}

		if ( !<TestScan> )
		{
			lastFrameScanned = ~<Frame>~;
		}
	}

	if ( $Focusing )
	{
		Actions = ACTION Doc ( FocusProgressDialog OpenOnce FocusProgressDialog "OpenFocusProgressWindow( ~Focusing...~,<focusRange>,<xPos>,<yPos>,~ImageSorter~ );" );
		PerformActions( Actions );
		Scanner( FocusAsync, SizzleControl );
		dlg( SetStatus,0,~Focusing~ );
	}
	else if ( <FocusBeforeScan> )
	{
		Actions = ACTION Doc ( FocusProgressDialog OpenOnce FocusProgressDialog "OpenFocusProgressWindow( ~Focusing...~,<focusRange>,<xPos>,<yPos>,~ImageSorter~ );" );
		PerformActions( Actions );
		SizzleControl( SetValues,SBARedAdjust,0,SBAGreenAdjust,0,SBABlueAdjust,0,SBAFleshAdjust,0,ForceSBA,0 );
		SizzleControl( SetValues,SbaR,0,SbaG,0,SbaB,0,SbaFlesh,0,UsedSBA,0);
		SizzleControl( SetValues,xferDenN,0,xferDenGM,0,xferDenI,0);
		SizzleControl( SetValues,AvgDenR,0,AvgDenG,0,AvgDenB,0,AvgDenN,0);
		SizzleControl( SetValues,unwtDenGM,0,unwtDenI,0,AvgHue,0,AvgSat,0);

		Scanner( FocusAndScanAsync, SizzleControl );
		dlg( SetStatus,0,~Focusing and scanning~ );
	}
	else
	{
		// DPT 07/10/01
		// Reset the SBA values since we are doing another scan.
		SizzleControl( SetValues,SBARedAdjust,0,SBAGreenAdjust,0,SBABlueAdjust,0,SBAFleshAdjust,0,ForceSBA,0 );
		SizzleControl( SetValues,SbaR,0,SbaG,0,SbaB,0,SbaFlesh,0,UsedSBA,0);
		SizzleControl( SetValues,xferDenN,0,xferDenGM,0,xferDenI,0);
		SizzleControl( SetValues,AvgDenR,0,AvgDenG,0,AvgDenB,0,AvgDenN,0);
		SizzleControl( SetValues,unwtDenGM,0,unwtDenI,0,AvgHue,0,AvgSat,0);

		Scanner( ScanAsync, SizzleControl );
		dlg( SetStatus,0,~Scanning~ );
	}

	UpdateFreeDiskSpace();

	return TRUE;
}

NUMERIC DefineFileTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	Helpfile = ~ITS_Output.htm~;
    Define: Tab<tab> Using DDWinCtrlDef AsSymbol TheFileTab 
        Fields: Text            ~Output~
                TypeName        Tab
                Tooltip         ~Setup Parameters for image files saved to disk~
				HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "<Helpfile>" )

    Contains: InListOrder
    {
		TextWidth = 90;

        Define: FileTypeStaticText Using DDWinCtrlDef AsSymbol FileTypeStaticText 
                Fields: TypeName        StaticText
                        Text            ~File Type~
						RightJustified	TRUE
                        Position        <x> , <y>,  <TextWidth> , <StaticTextHeight>

        Define: FileTypeComboBox Using DDWinCtrlDef AsSymbol FileTypeComboBox 
                Fields: TypeName		SComboBox  
                        Position		FileTypeStaticText(GetRight,Position) + $hGap, FileTypeStaticText(Gettop,Position),<ComboBoxWidth> ,<ComboBoxHeight> 
                        IActionsText    ~[GetList(OutputFileTypes) Get]~
						DActionsText	~[Save Exec("OnFileTypeChange(FALSE)")]~
                        OActionsText    ~[Save]~
                        GenConName       THIS
						IsEnabled		T
                        GenConField      ~SaveFileType~
                        Tooltip          ~Select a file type~

		Define: JPEGQualityPrompt Using DDWinCtrlDef AsSymbol JPEGQualityPrompt
				Fields:	POSITION		FileTypeComboBox(GetRight,Position) + $hGap + 10,FileTypeComboBox(GetTop,Position),40,$StaticTextHeight
						TEXT			Translate( ~Quality~ )
						TYPENAME		StaticText

		Define: JPEGQualityField Using DDWinCtrlDef AsSymbol JPEGQualityField
				Fields:	DACTIONSTEXT	ACTIONS ( Save Update(JPEGQualitySlider) "Exec(AuditField(JPEGQualityField,0,100,100);)" )
						GENCONFIELD		~JPEGQuality~
						GENCONNAME		THIS
						IACTIONSTEXT	ACTIONS ( Get )
						OACTIONSTEXT	ACTIONS ( Save )
						POSITION		JPEGQualityPrompt(GetRight,Position) + $hGap,JPEGQualityPrompt(GetTop,Position),30,$StaticTextHeight
						TEXT			~~
						TOOLTIP			~Adjust the quality of the EXIF or JPEG file for the scanned images~
						TYPENAME		MaskedEditText
						Mask			~###~
						PromptChar		~ ~ 
						IsTabStop		T;


		Define: JPEGQualitySlider Using DDWinCtrlDef AsSymbol JPEGQualitySlider
				Fields:	DACTIONSTEXT	ACTIONS ( Save Update(JPEGQualityField) )
						GENCONFIELD		~JPEGQuality~
						GENCONNAME		THIS
						IACTIONSTEXT	ACTIONS ( Get )
						OACTIONSTEXT	ACTIONS ( Save )
						POSITION		JPEGQualityField(GetRight,Position) + $hGap,JPEGQualityField(GetTop,Position),80 $StaticTextHeight
						TOOLTIP			~Adjust the quality of the EXIF or JPEG file for the scanned images~
						TYPENAME		~SLIDER~ 
						UNITS			1 ;

       Define: ExtensionPrompt Using DDWinCtrlDef AsSymbol ExtensionPrompt 
                Fields: TypeName		StaticText
                        Text			~Extension~
						RightJustified	TRUE
                        Position		$x,FileTypeStaticText(GetBottom,Position) + $vGap,<TextWidth>,<StaticTextHeight>
 		
		Define: ExtensionField Using DDWinCtrlDef AsSymbol ExtensionField 
				Fields: TypeName		MaskedEditText  
						//Position		ExtensionPrompt(GetRight,Position) + $hGap,ExtensionPrompt(Gettop,Position),<ComboBoxWidth> ,<ComboBoxHeight> 
						//IActionsText  ~[GetList(OutputFileExtensions) Get]~
						Position		ExtensionPrompt(GetRight,Position) + $hGap,ExtensionPrompt(Gettop,Position),<ComboBoxWidth> ,20 
						IActionsText    ~[Get]~
						OActionsText    ~[Save]~
						GenConName       THIS
						GenConField      ~FileExtension~
						Mask			~%%%%%%~
						PromptChar		~ ~		
						IsEnabled		T
						Tooltip			~Extension to concatenate to the file name (ex.  .jpg  .tif)~

       Define: ScannerProfileStaticText Using DDWinCtrlDef AsSymbol ScannerProfileStaticText 
                Fields: TypeName        StaticText
                        Text            ~Scanner Profile~
						RightJustified	TRUE
                        Position		$x,ExtensionPrompt(GetBottom,Position) + $vGap*5,
										<TextWidth>,<StaticTextHeight>

        Define: ScannerProfileComboBox Using DDWinCtrlDef AsSymbol ScannerProfileComboBox 
                Fields: TypeName		SComboBox  
                        Position		ScannerProfileStaticText(GetRight,Position) + $hGap,ScannerProfileStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                        IActionsText	ACTION EXEC ( RefreshScannerProfilesComboBox(TRUE) )
						DropDownActionsText ACTION CALL ( RefreshScannerProfilesComboBox(FALSE) )
						DActionsText		~[Save Exec("OnProfileChange(TRUE)")]~
                        OActionsText    ~[Save]~
                        GenConName       THIS
                        GenConField      ~ICCProfile~
                        Tooltip          ~Select the profile that characterizes the scanner~

		Define: ScannerProfileEnabledBox Using DDWinCtrlDef AsSymbol ScannerProfileEnabledBox 
				Fields: TypeName		CheckBox
						Text			Translate( ~Enabled~ )
						Position		ScannerProfileComboBox(GetRight,Position) + ($hGap * 1),ScannerProfileComboBox(GetTop,Position), <StaticTextWidth>+10,  <StaticTextHeight>
						GenConName		THIS
                        GenConField		~ScannerProfileEnabled~	
						IActionsText    ACTIONS ( Get )
						DActionsText	ACTION EXEC ( OnChangeProfilesEnabled() )
						OActionsText	ACTIONS ( Save )
						Tooltip         ~Enable or disable the use of the selected scanner profile~

      Define: OutputProfileStaticText Using DDWinCtrlDef AsSymbol OutputProfileStaticText 
                Fields: TypeName        StaticText
                        Text            ~Storage Profile~
						RightJustified	TRUE
                        Position		<x>,ScannerProfileStaticText(GetBottom,Position) + $vGap,<TextWidth>,<StaticTextHeight>

        Define: OutputProfileComboBox Using DDWinCtrlDef AsSymbol OutputProfileComboBox 
                Fields: TypeName			SComboBox  
                        Position			OutputProfileStaticText(GetRight,Position) + $hGap,OutputProfileStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                        IActionsText		ACTION EXEC ( RefreshOuputProfilesComboBox(TRUE) )
                        OActionsText		~[Save]~
                        GenConName			THIS
                        GenConField			~ICCOutputProfile~
						DropDownActionsText ACTION CALL ( RefreshOuputProfilesComboBox(FALSE) )
						DActionsText		~[Save Exec("OnProfileChange(FALSE)")]~
                        Tooltip				~Select the profile that describes the color space to store the image in~
 
 		Define: OutputProfileEnabledBox Using DDWinCtrlDef AsSymbol OutputProfileEnabledBox 
				Fields: TypeName		CheckBox
						Text			Translate( ~Enabled~ )
						Position		OutputProfileComboBox(GetRight,Position) + ($hGap * 1),OutputProfileComboBox(GetTop,Position), <StaticTextWidth>+10,  <StaticTextHeight>
						GenConName		THIS
                        GenConField		~OutputProfileEnabled~	
						IActionsText    ACTIONS ( Get )
						DActionsText	ACTION EXEC ( OnChangeProfilesEnabled() )
						OActionsText	ACTIONS ( Save )
						Tooltip         ~Enable or disable the use of the selected storage profile~

		Define: LutFileStaticText Using DDWinCtrlDef AsSymbol LutFileStaticText 
                Fields: TypeName		StaticText
                        Text			~Scanner Lut~
						RightJustified	TRUE
						IsHidden		T
                        Position		<x>,OutputProfileStaticText(GetBottom,Position) + $vGap*5,<TextWidth>,<StaticTextHeight>

        Define: LutFileEditText Using DDWinCtrlDef AsSymbol LutFileEditText 
                Fields: TypeName		EditText
                        Position		LutFileStaticText(GetRight,Position) + $hGap,LutFileStaticText(Gettop,Position),250, <EditTextHeight>
                        GenConName		THIS
                        GenConField		~LutFile~
                        IActionsText	~[Get]~
                        OActionsText    ~[Save]~
						IsEnabled		F
						IsHidden		T
						IsTabStop		T
                        Tooltip			~Select a linearization lut to apply to the image~

		Define: LutFileBrowseButton Using DDWinCtrlDef AsSymbol LutFileBrowseButton 
				Fields: TypeName		Button
						Text			Translate(~?~)
						Position		LutFileEditText(GetRight,Position) + $hGap,LutFileEditText(GetTop,Position), <StaticTextHeight>,  <StaticTextHeight>
						IsEnabled		F
						IsHidden		T
						DActionsText	ACTION EXEC ( BrowseForLutFilePath() )
						TOOLTIP			~Find a Lut to apply to the scanned image~

		Define: ProductStaticText Using DDWinCtrlDef AsSymbol ProductStaticText 
                Fields: TypeName        StaticText
                        Text            ~Proof Product~
						RightJustified	TRUE
                        Position		<x>,LutFileStaticText(GetBottom,Position) + $vGap,<TextWidth>,<StaticTextHeight>

        Define: ProductComboBox Using DDWinCtrlDef AsSymbol ProductComboBox 
                Fields: TypeName			SComboBox  
                        Position			ProductStaticText(GetRight,Position) + $hGap,ProductStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                        IActionsText		ACTION EXEC ( RefreshProductComboBox(TRUE) )
                        OActionsText		~[Save Exec("RefreshPrinterQueueComboBox(TRUE)") ]~
                        GenConName			THIS
                        GenConField			~ProductID~
						DropDownActionsText ACTION CALL ( RefreshProductComboBox(FALSE) )
						DActionsText		~[Save Exec("RefreshPrinterQueueComboBox(TRUE)") ]~
                        Tooltip				~Select the proof product for the images that match the range criteria~;
 
		Define: PrinterQueueStaticText Using DDWinCtrlDef AsSymbol PrinterQueueStaticText 
                Fields: TypeName        StaticText
                        Text            ~Printer Queue~
						RightJustified	TRUE
                        Position		<x>,ProductStaticText(GetBottom,Position) + $vGap,<TextWidth>,<StaticTextHeight>;

        Define: PrinterQueueComboBox Using DDWinCtrlDef AsSymbol PrinterQueueComboBox 
                Fields: TypeName			SComboBox  
                        Position			PrinterQueueStaticText(GetRight,Position) + $hGap,PrinterQueueStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                        IActionsText		ACTION EXEC ( RefreshPrinterQueueComboBox(TRUE) )
                        OActionsText		~[Save]~
                        GenConName			THIS
                        GenConField			~QueueName~
						DropDownActionsText ACTION CALL ( RefreshPrinterQueueComboBox(FALSE) )
						DActionsText		~[Save]~
                        Tooltip				~Select the printer queue for printing the images that match the range criteria~;
 
    }

    return ProductStaticText(GetBottom,Position);
}


NUMERIC ColorRangeControl( Prompt,KeyName,Prompt2,Type,x,CurrentY,hGap,vGap,MinValue,MaxValue,Wrap )
{
	if ( ~<Prompt>~ != ~~ )
	{
		CurrentY = $CurrentY + 2;
		Define: <Type>KeyPrompt Using DDWinCtrlDef AsSymbol <Type>KeyPrompt
				Fields: TypeName		CheckBox
						GenConName		THIS
						GenConField		~<KeyName>Key~
						Text			Translate( ~<Prompt>~ )
						Position		$x,$CurrentY,150,15
						IActionsText    ACTIONS ( Get )
						OActionsText	ACTIONS ( Save )
						Tooltip			Translate( ~Save images within the ranges specified for the <Prompt>~ );

		CurrentY = <Type>KeyPrompt(GetBottom,Position) + $vGap;
	}

	Define: <Type>MinPrompt Using DDWinCtrlDef AsSymbol <Type>MinPrompt
		Fields:	POSITION		$x + 30 $CurrentY 70 $StaticTextHeight
				TEXT			~<Prompt2>~
				RightJustified	TRUE
				TYPENAME		StaticText

	Define: <Type>MinMinusButton Using DDWinCtrlDef AsSymbol <Type>MinMinusButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeColorRange(<Type>,~Min~,-1,<MinValue>,<MaxValue>,<Wrap>))" )
				POSITION		<Type>MinPrompt(GetRight,Position) + $hGap, $CurrentY, 15, $EditTextHeight
				TOOLTIP			~Decrease by 1~
				TYPENAME		~Button~ 
				TEXT			~-~;

	Define: <Type>MinField Using DDWinCtrlDef AsSymbol <Type>MinField
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ValidateRange(<Type>,~Min~,<MinValue>,<MaxValue>,<Wrap>))" )
				GENCONFIELD		~<Type>Min~
				GENCONNAME		THIS
				IACTIONSTEXT	ACTIONS ( Get )
				OACTIONSTEXT	ACTIONS ( Save )
				POSITION		(<Type>MinMinusButton(GetRight,Position) + $hGap) $CurrentY 50 $EditTextHeight
				TEXT			~~
				TOOLTIP			~Select <Type> minimum range for saving next scan~
				TYPENAME		MaskedEditText
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~ ;

	Define: <Type>MinPlusButton Using DDWinCtrlDef AsSymbol <Type>MinPlusButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeColorRange(<Type>,~Min~,1,<MinValue>,<MaxValue>,<Wrap>))" )
				POSITION		<Type>MinField(GetRight,Position)+$hGap, $CurrentY, 15, $EditTextHeight
				TOOLTIP			~Increase by 1~
				TYPENAME		~Button~ 
				TEXT			~+~;

	Define: <Type>MaxPrompt Using DDWinCtrlDef AsSymbol <Type>MaxPrompt
		Fields:	POSITION		<Type>MinPlusButton(GetRight,Position) + $hGap*3 $CurrentY 50 $StaticTextHeight
				TEXT			~~
				RightJustified	TRUE
				TYPENAME		StaticText

	Define: <Type>MaxMinusButton Using DDWinCtrlDef AsSymbol <Type>MaxMinusButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeColorRange(<Type>,~Max~,-1,<MinValue>,<MaxValue>,<Wrap>))" )
				POSITION		<Type>MaxPrompt(GetRight,Position) + $hGap, $CurrentY, 15, $EditTextHeight
				TOOLTIP			~Decrease by 1~
				TYPENAME		~Button~ 
				TEXT			~-~;

	Define: <Type>MaxField Using DDWinCtrlDef AsSymbol <Type>MaxField
		Fields:	DACTIONSTEXT	ACTIONS ( Save )
				GENCONFIELD		~<Type>Max~
				GENCONNAME		THIS
				IACTIONSTEXT	ACTIONS ( Get )
				OACTIONSTEXT	ACTIONS ( Save )
				POSITION		(<Type>MaxMinusButton(GetRight,Position) + $hGap) $CurrentY 50 $EditTextHeight
				TEXT			~~
				TOOLTIP			~Select <Type> maximum range for saving next scan~
				TYPENAME		MaskedEditText
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~ ;

	Define: <Type>MaxPlusButton Using DDWinCtrlDef AsSymbol <Type>MaxPlusButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(ChangeColorRange(<Type>,~Max~,1,<MinValue>,<MaxValue>,<Wrap>))" )
				POSITION		<Type>MaxField(GetRight,Position)+$hGap, $CurrentY, 15, $EditTextHeight
				TOOLTIP			~Increase by 1~
				TYPENAME		~Button~ 
				TEXT			~+~;

	Define: <Type>DefaultButton Using DDWinCtrlDef AsSymbol <Type>DefaultButton
		Fields:	DACTIONSTEXT	ACTIONS ( Save "Exec(OnDefaultColorRange(<Type>))" )
				POSITION		<Type>MaxPlusButton(GetRight,Position)+$hGap, $CurrentY, 50, $EditTextHeight
				TOOLTIP			~Set range for <Type> to default values~
				TYPENAME		~Button~ 
				TEXT			~Default~;


	CurrentY = $CurrentY + $StaticTextHeight;

	return $CurrentY;
}

VOID ChangeColorRange( Type,Range,Amount,MinValue,MaxValue,Wrap )
{
	sum = dlgData( GetNumeric,<Type><Range> ) + <amount>;

	if ( <Wrap> )
	{
		if ( <sum> < <MinValue> )
		{
			sum = <MaxValue>;
		}
		if ( <sum> > <MaxValue> )
		{
			sum = <MinValue>;
		}
	}

	sum = Pin( <sum>,<MinValue>,<MaxValue> );

	if ( !<Wrap> )
	{
		if ( ~<Range>~ == ~Min~ )
		{
			dlg( GetControlValue,~<Type>MaxField~,upperRange );
			if ( Numeric( ~<upperRange>~ ) < <sum> )
			{
				dlg( SetControlValue,~<Type>MaxField~,<sum> );
			}
		}
		else
		{
			dlg( GetControlValue,~<Type>MinField~,lowerRange );

			if ( Numeric( ~<lowerRange>~ ) > <sum> )
			{
				dlg( SetControlValue,~<Type>MinField~,<sum> );
			}
		}
	}

	dlg( SetString,~<sum>~,<Type><Range> );
}


NUMERIC DefineHR500ColorSetupTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	CurrentY = <y>;
	ThisButtonWidth = (<ButtonWidth> * 2.2) + 5;

    Define: Tab<tab> Using DDWinCtrlDef
            Fields: Text    ~Color~
            TypeName        Tab
            Tooltip         Translate( ~Setup SBA output parameters for images to be saved~ )
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ITS_Color.htm" )

	Contains: InListOrder
	{
		CurrentY = $y - 1;
		CurrentX = $x;

		CurrentY = ColorRangeControl( Translate( ~Average Density RGB~ ),~AvgDenRGB~,Translate( ~Red~ ),AvgDenR,$CurrentX,$CurrentY,$hGap,$vGap,0,4095,FALSE );
		CurrentY = ColorRangeControl( ~~,~~,Translate( ~Green~ ),AvgDenG,$CurrentX,$CurrentY,$hGap,$vGap,0,4095,FALSE );
		CurrentY = ColorRangeControl( ~~,~~,Translate( ~Blue~ ),AvgDenB,$CurrentX,$CurrentY,$hGap,$vGap,0,4095,FALSE );
		CurrentY = ColorRangeControl( Translate( ~Average Density Neutral~ ),~AvgDenN~,~~,AvgDenN,$CurrentX,$CurrentY,$hGap,$vGap,0,4095,FALSE );
		CurrentY = ColorRangeControl( Translate( ~Hue - Saturation~ ),~HueSat~,Translate( ~Hue~ ),AvgHue,$CurrentX,$CurrentY,$hGap,$vGap,1,120,TRUE );
		CurrentY = ColorRangeControl( ~~,~~,Translate( ~Sat~ ),AvgSat,$CurrentX,$CurrentY,$hGap,$vGap,0,200,FALSE );
		CurrentY = ColorRangeControl( Translate( ~Enhanced SBA~ ),~SBAFlesh~,~~,SBAFlesh,$CurrentX,$CurrentY,$hGap,$vGap,(-999),999,FALSE );

 		Define: MinLabel Using DDWinCtrlDef AsSymbol MinLabelStaticText
			Fields:	TYPENAME		StaticText
					POSITION		130 + $hGap*2, $y - 7,
									40, <StaticTextHeight>
					TEXT			~Minimum~
					RightJustified	TRUE;

		Define: MaxLabel Using DDWinCtrlDef AsSymbol MaxLabelStaticText
			Fields:	TYPENAME		StaticText
					POSITION		MinLabelStaticText(GetRight,Position) + 87 + $hGap*5, 
									MinLabelStaticText(GetTop,Position),
									50, <StaticTextHeight>
					TEXT			~Maximum~
					RightJustified	TRUE;

		CurrentY = $CurrentY - $StaticTextHeight * 2 + $vGap;

	}

	return TRUE;
}


NUMERIC DefineHR500DataAccessTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	CurrentY = <y>;
	ThisButtonWidth = (<ButtonWidth> * 2.2) + 5;

    Define: Tab<tab> Using DDWinCtrlDef AsSymbol HR500DataAccessTab
            Fields: Text    ~Data~
            TypeName        Tab
            Tooltip         Translate( ~Access to Filmterm and SBA data~ )
			HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ITS_Data.htm" )

	Contains: InListOrder
	{
		TextWidth = 150;

		Define: SeeSbaDataButton Using DDWinCtrlDef AsSymbol SeeSbaDataButton 
            Fields: TypeName		Button
                    Text			Translate( ~View SBA Data~ )
					Position		$x+25,$y+10,140,<StaticTextHeight>
                    DActionsText    ACTION EXEC ( ShowSbaImageDataWindow() ) 
                    Tooltip         ~See the SBA data for this roll of the selected order~
					IsHidden		F
					IsEnabled		T;

		Define: SeeImageSorterSummaryButton Using DDWinCtrlDef AsSymbol SeeImageSorterSummaryButton 
            Fields: TypeName		Button
                    Text			Translate( ~View Image Type Summary~ )
                    Position		SeeSbaDataButton(GetLeft,Position), SeeSbaDataButton(GetBottom,Position) + $vGap*10, 140, <buttonHeight>
                    DActionsText    ACTION EXEC ( ShowImageSorterSummaryWindow() ) 
                    Tooltip         ~View the summary data from the filmterm optimization~
					IsHidden		F
					IsEnabled		T;
	}
	
	return TRUE;
}


NUMERIC DefineScannerTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	vertGap = 10;

	Helpfile = ~ITS_Scanner.htm~;
    Define: Tab<tab> Using DDWinCtrlDef
            Fields: Text            ~Scanner~
                    TypeName        Tab
                    Tooltip         ~Select the scan size, scan area and calibration parameters for the scanner~
					HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "<Helpfile>" )

    Contains: InListOrder
    {
		StaticWidth = 70;			ScanAreaWidth = 50;  ControlWidth = ($ScanAreaWidth)*4;

        Define: FilmFormatStaticText Using DDWinCtrlDef AsSymbol FilmFormatStaticText 
            Fields: TypeName		StaticText
                    Text			~Film Format~
					RIGHTJUSTIFIED	TRUE
                    Position		$x, $y, <StaticWidth>,<StaticTextHeight>

        Define: FilmFormatComboBox Using DDWinCtrlDef AsSymbol FilmFormatComboBox 
            Fields: TypeName		SComboBox  
                    Position		FilmFormatStaticText(Getright,Position) + $hGap,FilmFormatStaticText(GetTop,Position),150, <ComboBoxHeight> 
                    IActionsText    ACTIONS ( GetList(FilmSizeChoices) Get )
					DActionsText	ACTIONS ( Save "Exec(OnFormatChange(3, ~Film format changed.~, FALSE, TRUE, TRUE))" )
				    OActionsText    ACTIONS ( Save )
                    GenConField		~Format~
                    GenConName		THIS
                    Tooltip			Translate( ~Select the film format~ )

	   Define: ScanSizeStatic Using DDWinCtrlDef AsSymbol ScanSizeStatic
			Fields: POSITION		$x,	FilmFormatStaticText(GetBottom,Position) + $vertGap, <StaticWidth>,<StaticTextHeight>
					TEXT			Translate( ~Scan Size~ )
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText

/*		Define: ScanSizeSlider Using DDWinCtrlDef AsSymbol ScanSizeSlider
			Fields: LCLICKUPACTIONSTEXT ACTIONS ( Save "Exec(OnFormatChange(4, ~Scan size changed.~, FALSE, FALSE, TRUE))" )
					GENCONFIELD		SpeedQuality
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		ScanSizeStatic(GetRight,Position) + $hGap,ScanSizeStatic(GetTop,Position),$ControlWidth,<StaticTextHeight> 
					TOOLTIP			~Adjust Scan Size~ 
					TYPENAME		~SLIDER~ 
					IsEnabled		F
					UNITS			1;
*/
		Define: ScanSizeField Using DDWinCtrlDef AsSymbol ScanSizeField
			Fields: POSITION		ScanSizeStatic(GetRight,Position) + $hGap,ScanSizeStatic(GetTop,Position),<EditTextWidth>, <EditTextHeight> 
					GENCONFIELD		ScanSizeField
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					TOOLTIP			Translate( ~Scan Size in MB~ )
					TYPENAME		MaskedEditText
					IsEnabled		F
					IsTabStop		T
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Define: ScanSizeUnitsStatic Using DDWinCtrlDef AsSymbol ScanSizeUnitsStatic
			Fields: POSITION		ScanSizeField(GetRight,Position)+5,
									ScanSizeField(GetTop,Position)+3, 15,<StaticTextHeight>
					TEXT			~Mb~
					RIGHTJUSTIFIED	TRUE
					TYPENAME		StaticText;

		Define: ScanSizeWidthLength Using DDWinCtrlDef AsSymbol ScanSizeWidthLength
			Fields: POSITION		ScanSizeUnitsStatic(GetRight,Position) + $hGap,ScanSizeUnitsStatic(GetTop,Position),<StaticWidth>,<StaticTextHeight> 
					GENCONFIELD		ScanSizeWidthLength
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					TOOLTIP			Translate( ~Scan Size~ )
					TYPENAME		StaticText
					IsTabStop		T ;

/* 
		Define: SetZoomButton Using DDWinCtrlDef AsSymbol SetZoomButton
			Fields:	DACTIONSTEXT	ACTION EXEC ( SetupSetMagButton();OnSetMagButton() )
					POSITION		ScanSizeSlider(GetRight,Position), ScanSizeWidthLength(GetBottom,Position) + $vertGap 32 20
					TOOLTIP			~Setup the scanner to the selected format and zoom~
					TYPENAME		~Button~ 
					TEXT			~Set~
*/
		Define: PositionPrompt Using DDWinCtrlDef AsSymbol PositionPrompt 
			Fields: TypeName		StaticText
					Text			Translate( ~Scan Area~ )
					RIGHTJUSTIFIED	TRUE
					Position		$x,ScanSizeStatic(GetBottom,Position) + $vertGap+2, <StaticWidth>,  <StaticTextHeight> ;

		Define: MiddleXField Using DDWinCtrlDef AsSymbol MiddleXField
			Fields: GENCONFIELD		xPos
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		PositionPrompt(Getright,Position) + $hGap,PositionPrompt(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The X position (in percent) of the middle of the area to scan~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Define: MiddleYField Using DDWinCtrlDef AsSymbol MiddleYField
			Fields: GENCONFIELD		yPos
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		MiddleXField(Getright,Position) + 1,MiddleXField(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The Y position (in percent) of the middle of the area to scan~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Define: ScanWidthField Using DDWinCtrlDef AsSymbol ScanWidthField
			Fields: GENCONFIELD		ScanWidth
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save "Exec(UpdateScanSize(FALSE,FALSE,TRUE))" )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		MiddleYField(Getright,Position) + 1,MiddleYField(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The width (in percent) of the area to scan~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Define: ScanHeightField Using DDWinCtrlDef AsSymbol ScanHeightField
			Fields: GENCONFIELD		ScanLength
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save "Exec(UpdateScanSize(FALSE,FALSE,TRUE))" )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		ScanWidthField(Getright,Position) + 1,ScanWidthField(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The height (in percent) of the area to scan~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Global( MiddleXField,MiddleYField,ScanWidthField,ScanHeightField );

		Define: TestScanButton Using DDWinCtrlDef AsSymbol TestScanButton 
			Fields: TypeName		Button
					Text			Translate(~Test Scan~)
					Position		ScanHeightField(GetRight,Position) + $hGap,ScanHeightField(GetTop,Position), 70,  <StaticTextHeight>
					DActionsText	ACTION EXEC ( OnTestScan() )
					TOOLTIP			Translate( ~Performs a scan with no rotation to set the scan area~ )

		Define: AdjustScanAreaButton Using DDWinCtrlDef AsSymbol AdjustScanAreaButton 
			Fields: TypeName		Button
					Text			Translate(~Set~)
					Position		TestScanButton(GetRight,Position) + $hGap,TestScanButton(GetTop,Position), 32,  <StaticTextHeight>
					DActionsText	ACTION EXEC ( OnAdjustScanArea( FALSE ) )
					IsEnabled		F
					TOOLTIP			Translate( ~Set the active scan area from the current crop~ )

		Define: AllScanAreaButton Using DDWinCtrlDef AsSymbol AllScanAreaButton 
			Fields: TypeName		Button
					Text			Translate(~All~)
					Position		AdjustScanAreaButton(GetRight,Position) + $hGap,AdjustScanAreaButton(GetTop,Position), 35,  <StaticTextHeight>
					DActionsText	ACTION EXEC ( OnAllScanArea() )
					TOOLTIP			Translate( ~Set the active scan area to the largest possible size~ )

		Define: OverscanPrompt Using DDWinCtrlDef AsSymbol OverscanPrompt 
			Fields: TypeName		StaticText
					Text			Translate( ~Overscan Area~ )
					RIGHTJUSTIFIED	TRUE
					Position		$x-4,PositionPrompt(GetBottom,Position) + 3, 74,  <StaticTextHeight> ;

		Define: OSMiddleXField Using DDWinCtrlDef AsSymbol OSMiddleXField
			Fields: GENCONFIELD		OverScanXPos
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		OverscanPrompt(Getright,Position) + $hGap,OverscanPrompt(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The X position (in percent) of the middle of the overscan area~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					IsEnabled		F
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Define: OSMiddleYField Using DDWinCtrlDef AsSymbol OSMiddleYField
			Fields: GENCONFIELD		OverScanYPos
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		OSMiddleXField(Getright,Position) + 1,OSMiddleXField(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The Y position (in percent) of the middle of the overscan area~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					IsEnabled		F
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Define: OverScanWidthField Using DDWinCtrlDef AsSymbol OverScanWidthField
			Fields: GENCONFIELD		OverScanWidth
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save "Exec(UpdateScanSize(FALSE,FALSE,TRUE))" )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		OSMiddleYField(Getright,Position) + 1,OSMiddleYField(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The width (in percent) of the overscan area~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					IsEnabled		F
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Define: OverScanHeightField Using DDWinCtrlDef AsSymbol OverScanHeightField
			Fields: GENCONFIELD		OverScanLength
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					DACTIONSTEXT	ACTIONS ( Save "Exec(UpdateScanSize(FALSE,FALSE,TRUE))" )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		OverScanWidthField(Getright,Position) + 1,OverScanWidthField(GetTop,Position),$ScanAreaWidth , <EditTextHeight> 
					TOOLTIP			Translate( ~The height (in percent) of the overscan area for frame detection~ )
					TYPENAME		MaskedEditText
					IsTabStop		T
					IsEnabled		F
					Mask			~######~
					AllowedChars	~.~
					PromptChar		~ ~ ;

		Global( OSMiddleXField,OSMiddleYField,OverScanWidthField,OverScanHeightField );

		Define: AdjustOverscanAreaButton Using DDWinCtrlDef AsSymbol AdjustOverscanAreaButton 
			Fields: TypeName		Button
					Text			Translate(~Set~)
					Position		TestScanButton(GetRight,Position) + $hGap,OverScanHeightField(GetTop,Position),32,<StaticTextHeight>
					DActionsText	ACTION EXEC ( OnAdjustOverscanArea( FALSE ) )
					IsEnabled		F
					TOOLTIP			Translate( ~Set the active overscan area from the current crop~ )

		Define: AllOverScanAreaButton Using DDWinCtrlDef AsSymbol AllOverScanAreaButton 
			Fields: TypeName		Button
					Text			Translate(~All~)
					Position		AdjustOverscanAreaButton(GetRight,Position) + $hGap,AdjustOverscanAreaButton(GetTop,Position),35,<StaticTextHeight>
					DActionsText	ACTION EXEC ( OnAllOverScanArea() )
					IsEnabled		F
					TOOLTIP			Translate( ~Set the active overscan area to the largest possible size~ );

		yPos = 0;

		Define: CalTimeoutText Using DDWinCtrlDef AsSymbol CalTimeoutText 
				Fields: TypeName        StaticText
						Text            Translate(~Calibration Timeout~)
						RightJustified	TRUE
						Position        $x,PositionPrompt(GetBottom,Position)+($vertGap * 5),100,<StaticTextHeight>

		Define: CalTimeoutField Using DDWinCtrlDef AsSymbol CalTimeoutField 
				Fields: TypeName		MaskedEditText  
						Position		CalTimeoutText(GetRight,Position) + $hGap, CalTimeoutText(Gettop,Position)+2,25,20 
						IActionsText    ~[Get]~
						OActionsText    ~[Save]~
						Mask			~###~
						IsEnabled		F
						GenConName      THIS
						GenConField     ~CalibrationTimeout~
						Tooltip         Translate( ~Set the length of time a stored calibration is valid in hours: 3 is recommended~ )

		Define: CalTimeoutUnitsText Using DDWinCtrlDef AsSymbol CalTimeoutUnitsText 
				Fields: TypeName        StaticText
						Text            Translate(~Hours~)
						LeftJustified	TRUE
						Position		CalTimeoutField(GetRight,Position) + $hGap, CalTimeoutText(Gettop,Position),40,20 
	
		Define: CalTimeoutCheckBox Using DDWinCtrlDef AsSymbol CalTimeoutCheckBox 
			Fields: TypeName		CheckBox
					GenConName		THIS
					GenConField		~IgnoreCalTimeout~
					Text			Translate( ~Retain Stored Calibrations~ )
					IsEnabled		F
					Position		CalTimeoutText(GetLeft,Position) + $hGap*2, CalTimeoutText(GetBottom,Position) + $vGap + 5,150, <StaticTextHeight>
					IActionsText    ACTIONS ( Get )
					DActionsText	ACTIONS ( Save "Exec(OnIgnoreCalTimeoutCheckbox())" )
					OActionsText	ACTIONS ( Save )
					Tooltip			Translate( ~If checked, the stored calibrations will never expire.~ ); 
		
		Define: TraceCheckBox Using DDWinCtrlDef AsSymbol TraceCheckBox 
			Fields: TypeName		CheckBox
					GenConName		THIS
					GenConField		~TraceCalls~
					Text			Translate( ~Trace Calls~ )
					IsEnabled		T
					Position		TestScanButton(GetLeft,Position) - 30,
									CalTimeoutField(GetTop,Position),80, <StaticTextHeight>
					IActionsText    ACTIONS ( Get )
					DActionsText	ACTIONS ( Save "Exec(SetTraceCallsFlag())" )
					OActionsText	ACTIONS ( Save )
					Tooltip			Translate( ~If checked, scanning calls will be traced and recorded in the session log.~ );

// Save for future testing purposes
		Define: AutoScanWrapCheckBox Using DDWinCtrlDef AsSymbol AutoScanWrapCheckBox 
			Fields: TypeName		CheckBox
					GenConName		THIS
					GenConField		~AutoScanWrap~
					Text			~Auto Scan Wrap~
					IsEnabled		F
					IsHidden		T
					Position		TraceCheckBox(GetRight,Position),
									TraceCheckBox(GetTop,Position),98, <StaticTextHeight>
					IActionsText    ACTIONS ( Get )
					DActionsText	ACTIONS ( Save )
					OActionsText	ACTIONS ( Save )
					Tooltip			~If checked, auto scan with unscanned frames will repeat nonstop.~;

		Define: TimingCheckBox Using DDWinCtrlDef AsSymbol TimingCheckBox 
			Fields: TypeName		CheckBox
					GenConName		THIS
					GenConField		~TimeCalls~
					Text			Translate( ~Time Calls~ )
					IsEnabled		T
					Position		TestScanButton(GetLeft,Position) - 30,
									TraceCheckBox(GetBottom,Position),95, <StaticTextHeight>
					IActionsText    ACTIONS ( Get )
					DActionsText	ACTIONS ( Save "Exec(SetTimeCallsFlag())" )
					OActionsText	ACTIONS ( Save )
					Tooltip			Translate( ~If checked, scanning calls will be timed and recorded in the session log.~ );

		Define: LogActivityCheckBox Using DDWinCtrlDef AsSymbol LogActivityCheckBox 
			Fields: TypeName		CheckBox
					GenConName		THIS
					GenConField		~LogActivity~
					Text			Translate( ~Log Activity~ )
					IsEnabled		T
					Position		TestScanButton(GetLeft,Position) - 30,
									TimingCheckBox(GetBottom,Position),95, <StaticTextHeight>
					IActionsText    ACTIONS ( Get )
					DActionsText	ACTIONS ( Save "Exec(OnLogActivity())" )
					OActionsText	ACTIONS ( Save )
					Tooltip			Translate( ~If checked, activity information is written to the session log~ );

		yPos = LogActivityCheckBox(GetBottom,Position);

	}
    return <yPos>;
}


NUMERIC DefineScanTab( tab,&x,&y,&hGap,&vGap,&TabWidth,&TabHeight )
{
	ThisButtonWidth = (<ButtonWidth> * 2.2) + 5;
	TextWidth = 150;

	Helpfile = ~ITS_Scan.htm~;
    Define: Tab<tab> Using DDWinCtrlDef
            Fields: Text			~Scan~
                    TypeName		Tab
                    Tooltip			~Normal tab for scanning~
					HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "<Helpfile>" )

    Contains: INLISTORDER
    {
		ypos = $y;
        ypos = DefineDestinationControls( x,ypos,hGap,vGap );

		Define: ScanSetupsText Using DDWinCtrlDef AsSymbol ScanSetupsText 
            Fields: TypeName		Button
                    Text			Translate( ~Use Setup~ )
					DActionsText	ACTIONS ( Exec(LoadSettings(~~,TRUE,FALSE,FALSE,FALSE,TRUE)) Exec(ResyncScanList()) )
					Tooltip			~Activate the selected scanning setup~
					Position		$x,$ypos + ($vGap*6),<StaticTextWidth>,<StaticTextHeight>

	    Define: ScanSetupsComboBox Using DDWinCtrlDef AsSymbol ScanSetupsComboBox 
			Fields: TypeName        ComboBox  
					Position		ScanSetupsText(GetRight,Position) + $hGap,ScanSetupsText(GetTop,Position),288,<ComboBoxHeight>
					IActionsText	ACTION EXEC ( UpdateScanSetupsList( FALSE ) )
					DropDownActionsText	ACTION EXEC ( UpdateScanSetupsList( FALSE ) )
					DActionsText	ACTIONS ( Save )
					OActionsText	ACTIONS ( Save )
					GenConName		THIS
					GenConField		~ScanSetup~
					Mask			~<$[DATABASE FieldTypes].ScanSetupName[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].ScanSetupName[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].ScanSetupName[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].ScanSetupName[DisallowedChars]>~
					Tooltip			Translate( ~Select the setup to use for scanning~ )

		Define: EditSetups_Button Using DDWinCtrlDef AsSymbol EditSetups_Button 
			Fields:	TypeName		Button
					Text			Translate( ~?~ )
					Position		VolumeBrowseButton(GetLeft,Position),ScanSetupsComboBox(GetTop,Position),
									20,<ButtonHeight>
					DActionsText	ACTION EXEC  ( OnEditSetups() ) 
					Tooltip			Translate( ~Edit the FTScanSetups table~ );

		Define: SaveSetup_Button Using DDWinCtrlDef AsSymbol SaveSetup_Button 
			Fields:	TypeName		Button
					Text			Translate( ~Save~ )
					Position		EditSetups_Button(GetRight,Position) + $hGap,EditSetups_Button(GetTop,Position),
									48,<ButtonHeight>
					DActionsText	ACTIONS ( Save "Exec(OnSaveSetup())" ) 
					Tooltip			Translate( ~Save the current settings in the FTScanSetups table~ );

		Define: SFSFileText Using DDWinCtrlDef AsSymbol SFSFileText 
				Fields: TypeName		StaticText
						Text			Translate(~SFS Boundary Set~)
						RightJustified	TRUE
						Position		$x,SaveSetup_Button(GetBottom,Position) + $vGap*3,
										90,<StaticTextHeight>;

		Define: SFSFileEditText Using DDWinCtrlDef AsSymbol SFSFileEditText 
				Fields: TypeName		EditText  
						Position		SFSFileText(GetRight,Position)+$hGap,
										SFSFileText(GetTop,Position)-2,
										<TextWidth>+106 ,<StaticTextHeight>
                         IActionsText	~[Get]~
                        OActionsText    ~[Save]~
						GenConName		THIS
						GenConField		~SFSFile~
						Tooltip			Translate(~Select the file containing the desired subject failure suppression boundary set~ );

		Define: SFSFileBrowseButton Using DDWinCtrlDef AsSymbol SFSFileBrowseButton 
				Fields: TypeName		Button
						Text			Translate(~?~)
						Position		SFSFileEditText(GetRight,Position) + $hGap,SFSFileEditText(GetTop,Position), 20,  <StaticTextHeight>
						DActionsText	ACTION EXEC ( BrowseForSFSFile() )
						Tooltip			Translate(~Select the file containing the desired subject failure suppression boundary set~ );


	   Define: FilmTypeText Using DDWinCtrlDef AsSymbol FilmTypeText 
			Fields: TypeName        StaticText 
					Position		$x, SFSFileEditText(GetBottom,Position) + $vGap*3,<StaticTextWidth>,15 
					RightJustified	TRUE
					Text			Translate(~Film Type~)

		Define: FilmTypesComboBox Using DDWinCtrlDef AsSymbol FilmTypesComboBox 
			Fields: TypeName        SComboBox  
					Position		FilmTypeText(GetRight,Position) + $hGap FilmTypeText(GetTop,Position) <ThisButtonWidth> <ComboBoxHeight>
					IActionsText	ACTIONS ( Get )
					DActionsText	ACTIONS ( Save Update(FilmTypesComboBox) )
					DropDownActionsText	ACTION EXEC ( UpdateFilmTypesList() )
					OActionsText	ACTIONS ( Save )
					GenConName		THIS
					GenConField		~FilmType~
					Tooltip			Translate(~Select the type of film you are using~ );

        Define: RotationStaticText Using DDWinCtrlDef AsSymbol RotationStaticText 
            Fields: TypeName		StaticText
                    Text			Translate(~Rotation~)
					RightJustified	TRUE
                    Position		$X,FilmTypeText(GetBottom,Position) + $vGap*6,<StaticTextWidth>,<StaticTextHeight>

        Define: RotationComboBox Using DDWinCtrlDef AsSymbol RotationComboBox 
            Fields: TypeName		SComboBox  
                    Position		RotationStaticText(Getright,Position) + $hGap,
									RotationStaticText(GetTop,Position),60, <ComboBoxHeight> 
                    IActionsText    ~[GetList(SaveImageRotationChoices) Get]~
					DActionsText	ACTIONS ( Save "Exec(UpdateScanSize(FALSE,FALSE,TRUE))" )
                    OActionsText    ~[Save]~
                    GenConField		~ScanRotation~
                    GenConName		THIS
                    Tooltip			Translate(~Select an angle of rotation~ );

 		Define: ScansToSaveText Using DDWinCtrlDef AsSymbol ScansToSaveStaticText
			Fields:	POSITION		RotationComboBox(GetRight,Position) + $hGap*17,RotationComboBox(GetTop,Position),
									145, <StaticTextHeight>
					TEXT			Translate(~Number of Scans To Save~)
					IsEnabled		T
					RightJustified	TRUE
					TYPENAME		StaticText

		Define: ScansToSaveField Using DDWinCtrlDef AsSymbol ScansToSaveField
			Fields:	DACTIONSTEXT	ACTIONS ( Save )
					GENCONFIELD		~ScansToSave~
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		ScansToSaveStaticText(GetRight,Position) + $hGap,
									ScansToSaveStaticText(GetTop,Position),
									70, $EditTextHeight
					TEXT			~~
					TOOLTIP			Translate(~Number of images needed to meet the specified criteria~)
					TYPENAME		MaskedEditText
					Mask			~####~
					IsEnabled		T
					PromptChar		~ ~ ;

		Define: ScanFromDataBaseButton Using DDWinCtrlDef AsSymbol ScanFromDataBaseButton
			Fields: TypeName		StaticText
					Position		RotationComboBox(GetRight,Position) + $hGap * 3,
									RotationComboBox(GetTop,Position), 170, 20
					GenConName		THIS
					GenConField		~ScanFromDataBase~
					IsHidden		T
					IsEnabled		F
					Text			Translate(~Scan unscanned frames~)
					Tooltip			Translate(~Frames needing scanning are selected from the database~);

		Define: ScanToDataBaseButton Using DDWinCtrlDef AsSymbol ScanToDataBaseButton
			Fields: TypeName		StaticText
					Position		ScanFromDataBaseButton(GetLeft,Position),
									ScanFromDataBaseButton(GetBottom,Position) + $vGap, 170, 20
					GenConName		THIS
					GenConField		~ScanFromDataBase~
					IsHidden		T
					IsEnabled		F
					Text			Translate(~Scan every frame~)
					Tooltip			Translate(~Every frame is scanned and information is saved in the database~);


		ypos = RotationComboBox(GetBottom,Position);
    }

    return $ypos;
}




NUMERIC DefineDestinationControls( &x,&y,&hGap,&vGap )
{
    Width = 45;             FieldWidth = 200;

    Define: VolumeText Using DDWinCtrlDef AsSymbol VolumeText 
            Fields: TypeName		StaticText
                    Text			~Path~
					RightJustified	TRUE
                    Position		$x,$y, <StaticTextWidth>,  <StaticTextHeight> ;

    Define: VolumeComboBox Using DDWinCtrlDef AsSymbol VolumeComboBox 
            Fields: TypeName		MaskedEditText	// SComboBox  
					Position		VolumeText(GetRight,Position) + $hGap,VolumeText(Gettop,Position),<FieldWidth> + 85 ,<StaticTextHeight>
                    IActionsText    ~[Get]~
					DActionsText	ACTIONS ( Save "Exec(UpdateFreeDiskSpace())" )
                    OActionsText    ACTIONS ( Save )
                    GenConName		THIS
                    GenConField		~Volume~
					Mask			~<$[DATABASE FieldTypes].Path[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].Path[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].Path[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].Path[DisallowedChars]>~
                    Tooltip			~Select the path to save the images for this order~ ;

	Define: VolumeBrowseButton Using DDWinCtrlDef AsSymbol VolumeBrowseButton 
            Fields: TypeName		Button
                    Text			Translate(~?~)
                    Position		VolumeComboBox(GetRight,Position) + $hGap,VolumeComboBox(GetTop,Position), 20,  <StaticTextHeight>
					DActionsText	ACTION EXEC ( BrowseForImagePath() )
					Tooltip			~Find the directory to store the scanned images~ ;

	Global(VolumeBrowseButton);

    Define: CustomerText Using DDWinCtrlDef AsSymbol CustomerText 
            Fields: TypeName		StaticText
                    Text			~Customer ID~
					RightJustified	True
                    Position		$x,VolumeText(GetBottom,Position) + $vGap,<StaticTextWidth>,  <StaticTextHeight> ;
                            
    Define: CustomerField Using DDWinCtrlDef AsSymbol CustomerField       
            Fields: TypeName		MaskedEditText
                    Position		CustomerText(GetRight,Position) + <hGap>, CustomerText(GetTop,Position) $FieldWidth $ButtonHeight               
                    GenConName		THIS
                    GenConField		~CustomerID~
                    IActionsText    ~[Get]~
                    DActionsText    ~[Save]~
                    OActionsText    ~[Save]~
					Mask			~<$[DATABASE FieldTypes].CustomerID[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].CustomerID[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].CustomerID[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].CustomerID[DisallowedChars]>~
                    Tooltip			~This is the Customer ID of the current order.  If the order has not already been created, specify the CustomerID here~ ;

	Define: AddCustomerButton Using DDWinCtrlDef AsSymbol AddCustomerButton 
			Fields: TypeName		Button
					Text			Translate( ~Add Order~ )
					IsEnabled		T
					IsHidden		F
					Position		CustomerField(GetRight,Position) + <hGap>, CustomerField(GetTop,Position), 80,  <buttonHeight>
					DActionsText    ACTION EXEC  ( AddCustomerAndOrder() ) 
					Tooltip         Translate( ~Add an order for the specified customer~ )

	Define: FindCustomerButton Using DDWinCtrlDef AsSymbol FindCustomerButton 
            Fields: TypeName		Button
                    Text			~?~
                    Position		VolumeBrowseButton(GetLeft,Position), AddCustomerButton(GetTop,Position), 20,  <buttonHeight>
                    DActionsText    ACTION EXEC ( FindCustomer() ) 
                    Tooltip         Translate( ~Find the customers who begin with the selected ID~ )

    Define: OrderText Using DDWinCtrlDef AsSymbol OrderText 
            Fields: TypeName		StaticText
                    Text			~Order ID~
					IsEnabled		F
					RightJustified	True
                    Position		$x,CustomerText(GetBottom,Position) + $vGap, <StaticTextWidth>,  <StaticTextHeight> ;
           
    Define: OrderField Using DDWinCtrlDef AsSymbol OrderField       
            Fields: TypeName		MaskedEditText
                    Position		OrderText(GetRight,Position) + <hGap> OrderText(GetTop,Position) $FieldWidth $ButtonHeight          
                    GenConName		THIS
                    GenConField		~Order~
					IsEnabled		F
					IActionsText    ~[Get]~
                    DActionsText    ~[Save]~
                    OActionsText    ~[Save]~
					WantReturnKey	~T~
					ReturnKeyActionsText ACTION EXEC ( HandleOrderIDReturnKey(~~) )
					Mask			~<$[DATABASE FieldTypes].OrderID[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].OrderID[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].OrderID[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].OrderID[DisallowedChars]>~
                    Tooltip			Translate( ~The Order ID for the HR500 Image Type Sorter cannot be changed.~ );

	Define: FindOrdersNeedingScanningButton Using DDWinCtrlDef AsSymbol FindOrdersNeedingScanningButton 
            Fields: TypeName		Button
                    Text			Translate( ~Scan Needed~ )
                    Position		OrderField(GetRight,Position) + <hGap>, OrderField(GetTop,Position),80,<buttonHeight>
                    DActionsText    ACTION EXEC ( FindOrdersNeedingScanning() )
					IsHidden		T
					IsEnabled		F 
                    Tooltip         Translate( ~View orders that need scanning~ );

	Define: SeeScannedImagesButton Using DDWinCtrlDef AsSymbol SeeScannedImagesButton 
            Fields: TypeName		Button
                    Text			Translate( ~Images~ )
                    Position		FindOrdersNeedingScanningButton(GetLeft,Position), FindOrdersNeedingScanningButton(GetBottom,Position) + $vGap, 80,  <buttonHeight>
                    DActionsText    ACTION EXEC ( ShowScannedImagesWindow() ) 
                    Tooltip         Translate( ~View the images for this roll of the selected order~ )

	Define: FindOrderButton Using DDWinCtrlDef AsSymbol FindOrderButton 
            Fields: TypeName		Button
                    Text			~?~
                    Position		FindOrdersNeedingScanningButton(GetRight,Position) + <hGap>, FindOrdersNeedingScanningButton(GetTop,Position), 20,  <buttonHeight>
                    DActionsText    ACTION EXEC ( FindOrder() ) 
                    Tooltip         Translate( ~Find all orders that start with the characters of the Order ID~ )

	Define: ExportImagesButton Using DDWinCtrlDef AsSymbol ExportImagesButton 
            Fields: TypeName		Button
                    Text			Translate( ~Export~ )
                    Position		VolumeBrowseButton(GetRight,Position) + $hGap, VolumeBrowseButton(GetTop,Position), 48,  <buttonHeight>
                    DActionsText    ACTION EXEC ( ExportImages() ) 
                    Tooltip         Translate( ~Export Images for this order~ );

	ThisPositionX = ExportImagesButton(GetLeft,Position);
	ThisPositionY = FindOrderButton(GetTop,Position);

	Define: SetForOrderButton Using DDWinCtrlDef AsSymbol SetForOrderButton 
            Fields: TypeName		Button
                    Text			Translate( ~Update~ )
                    Position		<ThisPositionX>, <ThisPositionY>, 48,  <buttonHeight>
                    DActionsText    ACTION EXEC ( DisplayStatusChoices(Order,<ThisPositionX>,<ThisPositionY> ) ) 
                    Tooltip         Translate( ~Update the scanning information for the entire order~ );

	ThisPositionX = SetForOrderButton(GetLeft,Position);
	ThisPositionY = SetForOrderButton(GetBottom,Position)+$vGap;

	Define: SetForRollButton Using DDWinCtrlDef AsSymbol SetForRollButton 
            Fields: TypeName		Button
                    Text			Translate( ~Update~ )
                    Position		<ThisPositionX>, <ThisPositionY>, 48,  <buttonHeight>
                    DActionsText    ACTION EXEC ( DisplayStatusChoices(Roll,<ThisPositionX>,<ThisPositionY>) ) 
                    Tooltip         Translate( ~Update the scanning information for the entire roll~ );

	ThisPositionX = SetForRollButton(GetLeft,Position);
	ThisPositionY = SetForRollButton(GetBottom,Position)+$vGap;

	Define: SetFrameOverrideButton Using DDWinCtrlDef AsSymbol SetFrameOverrideButton 
			Fields: TypeName		Button
					IsEnabled		F
					Text			Translate( ~Override~ )
					Position		<ThisPositionX>, <ThisPositionY>, 48,  <buttonHeight>
					DActionsText	ACTIONS  ( "Exec(OnOverrideFrameButton( FALSE ))" ) 
					Tooltip			Translate( ~Override and set the Frame #~ );

    Define: RollText Using DDWinCtrlDef AsSymbol RollText 
            Fields: TypeName		StaticText
                    Text			Translate( ~Roll~ )
					RightJustified	True
                    Position		$x,OrderText(GetBottom,Position) + $vGap,<StaticTextWidth>,<StaticTextHeight> ;
  
  
    Define: RollField Using DDWinCtrlDef AsSymbol RollField 
        Fields: TypeName		ComboBox  
                Position        RollText(GetRight,Position) + <hGap>,RollText(GetTop,Position),$FieldWidth,$buttonHeight*4               
                DActionsText    ACTIONS  ( Save "Exec(UpdateFrameField())" ) 
				OActionsText	ACTIONS ( Save )
				DropDownActionsText ACTION CALL ( UpdateRollsCombo(FALSE)  )
                GenConName       THIS
                GenConField		~Roll~
				IsTabStop		T
				Mask			~<$[DATABASE FieldTypes].Roll[Mask]>~
				PromptChar		~<$[DATABASE FieldTypes].Roll[PromptChar]>~
				AllowedChars	~<$[DATABASE FieldTypes].Roll[AllowedChars]>~
				DisallowedChars ~<$[DATABASE FieldTypes].Roll[DisallowedChars]>~
                Tooltip         Translate( ~Enter or select a roll~ );
              
if 0 
{            
    Define: RollField Using DDWinCtrlDef AsSymbol RollField         
            Fields: TypeName		MaskedEditText
                    Position        RollText(GetRight,Position) + <hGap>,RollText(GetTop,Position),$FieldWidth,$buttonHeight               
                    GenConName		THIS
                    GenConField		~Roll~
                    IActionsText	~[Get]~
                    DActionsText    ~[Save]~
                    OActionsText    ~[Save]~
					Mask			~<$[DATABASE FieldTypes].Roll[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].Roll[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].Roll[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].Roll[DisallowedChars]>~
                    Tooltip			Translate( ~Enter Roll Number~ ) ;
}

	Define: FindRollButton Using DDWinCtrlDef AsSymbol FindRollButton 
            Fields: TypeName		Button
                    Text			~?~
                    Position		FindCustomerButton(GetLeft,Position), RollField(GetTop,Position), 20,  <buttonHeight>
                    DActionsText    ACTION EXEC ( FindRolls() ) 
                    Tooltip         Translate( ~Find the roll information for the specified order~ )

    Define: FrameText Using DDWinCtrlDef AsSymbol FrameText 
            Fields: TypeName		Button
                    Text			Translate( ~Frame~ )
					DActionsText    ACTION EXEC ( OpenImage() ) 
                    Tooltip         Translate( ~Open the image of the selected Order, Roll, Frame~ )
                    Position		$x,RollText(GetBottom,Position) + $vGap, <StaticTextWidth>,  <StaticTextHeight> ;
                            
    Define: FrameField Using DDWinCtrlDef AsSymbol FrameField       
            Fields: TypeName        MaskedEditText
                    Position		FrameText(GetRight,Position) + <hGap> FrameText(GetTop,Position) $FieldWidth $buttonHeight               
                    GenConName		THIS
                    GenConField		~Frame~
                    IActionsText	~[Get]~
					DActionsText	ACTIONS ( Save "Exec(UpdateScanButton())" )
                    OActionsText	~[Save]~
					Mask			~<$[DATABASE FieldTypes].Frame[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].Frame[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].Frame[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].Frame[DisallowedChars]>~
                    Tooltip			Translate( ~Enter Frame Number (0 is valid)~ );

   Define: DisplayLastCheckBox Using DDWinCtrlDef AsSymbol DisplayLastCheckBox 
            Fields: TypeName		CheckBox
					GenConName		THIS
					GenConField		~DisplayLastImage~
					Text			Translate( ~Display~ )
					Position		FrameField(GetRight,Position) + $hGap,FrameField(GetTop,Position), 80, <StaticTextHeight>
					DActionsText	ACTIONS ( Save )
					IActionsText    ACTIONS ( Get )
					OActionsText	ACTIONS ( Save )
					Tooltip			Translate( ~If checked, display each image for cropping as it is scanned~ );

	Define: OpenFramesButton Using DDWinCtrlDef AsSymbol OpenFramesButton 
            Fields: TypeName		Button
                    Text			~?~
                    Position		FindCustomerButton(GetLeft,Position), FrameField(GetTop,Position), 20,  <buttonHeight>
                    DActionsText    ACTION EXEC ( OpenFramesButton() ) 
                    Tooltip         ~Find the order image information for the specified order, roll~ ;

    return FrameText(GetBottom,Position);
}

NUMERIC DefineScanControls( &x,&y,&hGap,&vGap )
{
    Width = 51; bHeight = 27;	

   Define: FocusButton Using DDWinCtrlDef AsSymbol FocusButton 
            Fields: TypeName		Button
					Text			~Focus~
					Position		<x> + 3 <y> <Width> <bHeight>
					DActionsText	ACTIONS  ( "Exec(OnFocusButton( TRUE,Translate(~Do you want to focus the scanner now?  If so, insert the film and select Yes when ready.~)))" ) 
					Tooltip			~Focus the scanner~

	Define: CalibrateButton Using DDWinCtrlDef AsSymbol CalibrateButton 
			Fields:	TypeName		Button
					Text			~Calibrate~
					Position		FocusButton(GetRight,Position) + (<hGap>/2),FocusButton(GetTop,Position),<width>,<bHeight>
					DActionsText	ACTIONS  ( "Exec(OnHR500CalibrateButton( FALSE,FALSE,TRUE ))" ) 
					Tooltip			~Calibrate the scanner~

    Define: PrevScanButton Using DDWinCtrlDef AsSymbol PrevScanButton 
            Fields: TypeName		Button
					Text			~<< 1~
					Position		FocusButton(GetRight,Position)*2 + 17,FocusButton(GetTop,Position),<Width>*3/4 <bHeight>
					DActionsText    ACTIONS  ( "Exec(OnScanButtonSetup() ; OnScanButton(-1,FALSE))" ) 
					Tooltip         ~Scan the previous frame~

    Define: ScanButton Using DDWinCtrlDef AsSymbol ScanButton 
            Fields: TypeName		Button
                    Text			~Scan~
                    Position		PrevScanButton(GetRight,Position) + <hGap>,PrevScanButton(GetTop,Position),<Width>*3/4  <bHeight>
                    DActionsText    ACTIONS  ( "Exec(OnScanButtonSetup() ; OnScanButton(0,FALSE))" ) 
                    Tooltip			~Scan the current frame~

    Define: NextScanButton Using DDWinCtrlDef AsSymbol NextScanButton 
            Fields: TypeName		Button
                    Text			~1 >>~
                    Position		ScanButton(GetRight,Position) + <hGap>,ScanButton(GetTop,Position),<Width>*3/4 <bHeight>
                    DActionsText	ACTIONS  ( "Exec(OnScanButtonSetup() ; OnScanButton(1,FALSE))" ) 
                    Tooltip			~Scan the next frame~

	Define: AutoScanCheckBox Using DDWinCtrlDef AsSymbol AutoScanCheckBox 
			Fields: TypeName		CheckBox
					GenConName		THIS
					GENCONFIELD		AutoScan
					Text			~Auto Scan~
					Position		NextScanButton(GetRight,Position)+<hGap> + 3 + <Width>*3/4,
									NextScanButton(GetTop,Position)-6,<Width> + 20,<StaticTextHeight>
					IActionsText    ACTIONS ( Get )
					DActionsText	ACTIONS ( Save "Exec(OnAutoScan())")
					OActionsText	ACTIONS ( Save )
					Tooltip			~Automatically scan successive frames~;

	Define: CutNegPromptCheckBox Using DDWinCtrlDef AsSymbol CutNegPromptCheckBox 
			Fields: TypeName		CheckBox
					GenConName		THIS
					GENCONFIELD		CutNegPrompt
					Text			~Prompt~
					Position		AutoScanCheckBox(GetRight,Position)+2,AutoScanCheckBox(GetTop,Position),<Width> + 15,<StaticTextHeight>
					IActionsText    ACTIONS ( Get )
					DActionsText	ACTIONS ( Save )
					OActionsText	ACTIONS ( Save )
					Tooltip			~Prompt for next frame when scanning cut negatives~;

 	IF 0
	{
		Define: ScanCountField Using DDWinCtrlDef AsSymbol ScanCountField
			Fields: GENCONFIELD		ScanCount
					GENCONNAME		THIS
					IACTIONSTEXT	ACTIONS ( Get )
					OACTIONSTEXT	ACTIONS ( Save )
					POSITION		AutoScanCheckBox(Getright,Position) + $hGap * 2,AutoScanCheckBox(GetTop,Position),35,<EditTextHeight> 
					TOOLTIP			~A Count of the number of scans~
					TYPENAME		MaskedEditText
					Mask			~#####~
					PromptChar		~ ~ ;

		Define: ScanTimeStaticText Using DDWinCtrlDef AsSymbol ScanTimeStaticText 
			Fields: TypeName		StaticText
					GENCONFIELD		LastScanTime
					GENCONNAME		THIS
					Position		ScanCountField(GetRight,Position) + $hGap,ScanCountField(GetTop,Position),50,<StaticTextHeight>
					TOOLTIP			~Time in seconds of the last scan~ ;
	}

    return NextScanButton(GetBottom,Position)-5;
}

VOID RightClick()
{
	if ( KeyState( RSHIFT ) && KeyState( RCONTROL ) )
	{
		IgnoreControlCommands = FALSE;
		EnableScanningControls( TRUE );
		FilmDriveEnabled = DlgData( GetNumeric,FilmDriveEnabled );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
	}
	else if ( KeyState( LSHIFT ) && KeyState( LCONTROL ) )
	{
		if ( DlgData( GetNumeric,AutoScan ) )
		{
			dlg( EnableControls,<CurrentControlsState>,ScanButton );
		}
		dlg( ShowControls,TRUE,AutoScanWrapCheckBox );
		dlg( EnableControls,<CurrentControlsState>,AutoScanWrapCheckBox );
	}
}


VOID DefineDialog()
{
    Left = 5; Top = 5;		hGap = 5; vGap = 2;  x = <Left>; y = <Top>;
    TextHeight = 20;        TextWidth = 110;  ButtonHeight = 20;
    EditTextWidth = 50;
    SliderWidth = 170;
    EditTextWidth = 50;		EditTextHeight = 20;
    ButtonWidth = 60;		ButtonHeight = 20;
    ComboBoxWidth = 100;	ComboBoxHeight = 150;

    TabWidth = $DialogWidth - $hGap * 3;  TabHeight = 260;

	ScreenWidth = App( thisApp,MainWindow,GetClientWidth );
	DialogLeft = ($ScreenWidth * .9) - 90 - $DialogWidth;
	DialogTop = 8;

	if ( <DialogLeft> < 0 )
	{
		DialogLeft = ($ScreenWidth * .9) / 2.0;
	}

    Define: ScannerDlgDefinition Using DDWinDef
            Fields: Position			$DialogLeft $DialogTop $DialogWidth $DialogHeight
                    Title				~HR500 Image Type Sorter~
                    TypeName			~Dialog~
					StatusBar			~3 70 10 20~
					WantsMinimizeBox	TRUE
					RClickDnActionsText	ACTION Exec ( RightClick() )
					//HActionsText		ACTION SHOWHELPPAGE ( KPISHelpFile "Scanning.htm" )
					OACTIONSTEXT		ACTION EXEC ( CloseDialog() );

    Contains: InListOrder
    {
        x = $left + $hGap;      y = $top + 33;

        Define: TabWindow Using DDWinCtrlDef
                Fields: Position	<left> <top> <TabWidth>  <TabHeight>
                        TypeName	TabCtrl
                        Text		~TCS_HOTTRACK | TCS_MULTILINE | TCS_TOOLTIPS~
        Contains: InListOrder
        {
			tab = 0; 
            DefineScanTab( <++tab>,x,y,hGap,vGap,TabWidth,TabHeight );

			DefineHR500ColorSetupTab( <++tab>,x,y,hGap,vGap,TabWidth,TabHeight );

			DefineHR500DataAccessTab( <++tab>,x,y,hGap,vGap,TabWidth,TabHeight );

            DefineFileTab( <++tab>,x,y,hGap,vGap,TabWidth,TabHeight );

		    DefineTransportSetupTab( <++tab>,x,y,hGap,vGap,TabWidth,TabHeight );

            DefineScannerTab( <++tab>,x,y,hGap,vGap,TabWidth,TabHeight );

		    DefineMiscTab( <++tab>,x,y,hGap,vGap,TabWidth,TabHeight );
        }

		y += $TabHeight - 27;

		IF 0
		{
			Define: ScanProgressControl Using DDWinCtrlDef AsSymbol ScanProgressControl
				Fields:	GENCONFIELD		Progress
						GENCONNAME		This
						POSITION		$x,$y,<TabWidth> - $hGap*2,8
						TEXT			~Progress~
						TYPENAME		~Progress~ 
						IACTIONSTEXT	ACTIONS ( Get )
						OACTIONSTEXT	ACTIONS ( Save ) ;
		}

		y = DefineScanControls( Left,y,hGap,vGap ) +  10;

		BottomWithoutTransport = <y> + 25 + 3;

        y = DefineTransportControl( Left,y,hGap,vGap,ButtonHeight ) + 8;

		BottomWithTransport = <y> + 20 + 5;

		y = DefineLoadUnloadControl( Left,y,hGap,vGap,ButtonHeight ) + 30;

		BottomWithLoadUnload = <y>;

		Global( BottomWithoutTransport,BottomWithTransport,BottomWithLoadUnload,DialogWidth );
    };

    ScannerDlgDefinition( Set,Position,~<DialogLeft> <DialogTop> <DialogWidth> <BottomWithOutTransport>~ );

    Global( ScannerDlgDefinition );
}


NUMERIC OnFileTypeChange(LoadingSettings)
{
	dlg( GetInput );

	JPEGEnabled = SimilarStr( ~<$con.dlgData[SaveFileType]>~,JPEG ) || SimilarStr( ~<$con.dlgData[SaveFileType]>~,EXIF );
	 
	TIFFEnabled = SimilarStr( ~<$con.dlgData[SaveFileType]>~,TIFF );

	dlg( EnableControls,<JPEGEnabled>,JPEGQualitySlider,JPEGQualityField );

	if ( !<LoadingSettings> )
	{
		TheFileExtension = ~~;

		if ( <TIFFEnabled> ) { TheFileExtension = ~.tif~; }
		if ( <JPEGEnabled> ) { TheFileExtension = ~.jpg~; }

		dlg( SetString,~<TheFileExtension>~,FileExtension );
	}

	return TRUE;
}

NUMERIC OnDefaultColorRange( Type )
{
	dlg( SetStrings,<Type>Min,<g<Type>MinDefault>,<Type>Max,<g<Type>MaxDefault> );
	dlg( Save,<Type>Min,<Type>Max );

	return TRUE;
}

NUMERIC OnColorChange()
{
	return TRUE;
}


NUMERIC OnSaveImageButton( CleanupScanObject )
{
	dlg( GetInput,GetStrings,Volume,Volume,Order,Order,Roll,Roll,Frame,Frame );

	Ext = ~<$con.DlgData[FileExtension]>~;

	ImagesPath = CreateImagePath( ~<Volume>~,~<Order>~,~<Roll>~,~<Frame>~,~<Ext>~ );
	ImagesPath = MakePath( ~<ImagesPath>~ );

	if ( !BroadcastMessageToAllViews( CanReleaseImage,~<ImagesPath>~ ) )
		{ return Warning( Translate( ~Could not delete\n\n<ImagesPath>\n\nbecause it is still open in a job or layout.~ ) ); }

	if ( !BroadcastMessageToAllViews( ReleaseImage,~<ImagesPath>~ ) )		
		{ return Warning( Translate( ~Could not delete\n\n<ImagesPath>\n\nbecause it is still open in a job or layout.~ ) ); }

	if ( !Files( Delete,~<ImagesPath>~ ) )
	{ 
		errorMsg = GetLastErrorMsg();
		return Warning( Translate( ~Could not delete <ImagesPath>.  <errorMsg>~ ) );
	}

	DisableControlsWhileSaving = TRUE;
	ReadyForSave( <CleanupScanObject> );

	return TRUE;
}


NUMERIC ReadyForSave( CleanupScanObject )
{
	WaitingForOverScan = SizzleControl( GetNumeric,WaitingForOverScan );
	WaitingForDisplay = SizzleControl( GetNumeric,WaitingForDisplay );
	if ( ( !<WaitingForOverScan> ) && ( !<WaitingForDisplay> ) )
	{
		SaveImage( <CleanupScanObject> );
		Return TRUE;
	}
	Return FALSE;
}		

NUMERIC OnSaveSetup()
{
	dlg( GetInput );

	ScanSetupName = ~<$con.DlgData[ScanSetup]>~;

	if ( ~<ScanSetupName>~ == ~~ )
	{
		return Warning( Translate( ~No setup profile name specified in setup field~ ) );
	}

	Key = ~Name = '<$con.DlgData[ScanSetup]>'~;

	Query = ~Select * From FTScanSetups Where <Key>~;

	if ( PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{
		if ( !List( GetFirst,Item ) )
		{
			if ( MessageBox( Translate(~Create a new setup called <$con.DlgData[ScanSetup]>?~),YESNO ) != YES )
			{
				return FALSE;
			}

			List( AddNew,Item );
			Item( Set,Name,~<$con.DlgData[ScanSetup]>~ );
		}
		else
		{
			if ( MessageBox( Translate(~Update the existing setup called <$con.DlgData[ScanSetup]>?~),YESNO ) != YES )
			{
				return FALSE;
			}
		}

		if ( ~<DisplayUnits>~ != ~Inches~ )
		{
			oldXSliderIFactor = DlgData( GetNumeric,XSliderIFactor );
			XSliderIFactor = <DisplayUnits>ToInches( <oldXSliderIFactor> );
			oldFixedNonFdaAdv = DlgData( GetNumeric,FixedNonFDAAdvance );
			FixedNonFDAAdvance = <DisplayUnits>ToInches( <oldFixedNonFdaAdv> );

			DlgData( SetValues,XSliderIFactor,<XSliderIFactor>,FixedNonFDAAdvance,<FixedNonFDAAdvance> );
		}

		oldMinGap = DlgData( GetNumeric,MinInterframeGap );
		minGap = <DisplayUnits>ToLines( <oldMinGap> );
		minGap = Round( <minGap> );
		DlgData( SetValues,MinInterframeGap,~<minGap>~ );

		if ( !Item( UpdateFrom,DlgData ) )
		{
			List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
			return Warning( Translate( ~Could not update FTScanSetups record where <Key>. <theErr>~ ) );
		}

		if ( ~<DisplayUnits>~ != ~Inches~ )
		{
			DlgData( SetValues,XSliderIFactor,<oldXSliderIFactor>,FixedNonFDAAdvance,<oldFixedNonFdaAdv> );
		}

		DlgData( SetValues,MinInterframeGap,~<oldMinGap>~ );

		return List( Update );
	}

	List( GetErrorDescription,0,theErr );
	return Warning( Translate( ~Query Failed: <Query>. <theErr>~ ) );

	// The old way

	Query = ~Select * From FTScanSetups Order By Name~;
	
	GenCon( ScanSetupToAdd,IsCopyOf,dlgData );

	ScanSetupToAdd( Set,Name,~<$con.DlgData[ScanSetup]>~ );

	ScanSetupToAdd( Hang,~[GenCons]~,ScanSetupToAdd );

	Actions = ACTION Doc ( ~FTScanSetups~ OpenOnce FTScanSetupsDoc "AddSetup( ~Scan Setups~,~<Query>~,ScanSetupToAdd );" );

	PerformActions( Actions );

	return TRUE;
}


VOID OnEditSetups()
{
	Query = ~Select * From FTScanSetups Order By Name~;

	Actions = ACTION Doc ( ~FTScanSetups~ OpenOnce FTScanSetupsDoc "Init( ~Image Sorter Scan Setups~,~<Query>~ );" );

	PerformActions( Actions );
}


NUMERIC LoadSettings( SetupName, ForceLoad, CheckIfLoaded, IgnoreFilmDriveEnable, LoadDefaults, DoCalibration )
{
	retval = TRUE;
	if ( !DefinedAndNotNull( SetupName ) )
	{ 
		dlg( GetInput );
		SetupName = ~<$con.dlgData[ScanSetup]>~;
	}

	if ( ( ~<SetupName>~ == ~~ ) || ( !<ForceLoad> && ( ~<SetupName>~ == ~<LastSetupName>~ ) ) )
	{
		if ( !<ForceLoad> )
		{
			dlg( SetStatus,0,Translate( ~No settings changes required~ ) );
			return TRUE;
		}
		else
		{
			dlg( SetStatus,0,Translate( ~No settings were loaded~ ) );
			if ( !<LoadDefaults> )
			{
				return Warning( Translate( ~Please select a Setup first.~ ) );
			}
		}
		if ( !<IgnoreFilmDriveEnable> )
		{
			UpdateFilmDriveSetupsCombo();
			dlg( SetStrings,FilmDriveEnabled,~0~ );
		}
	}
	else
	{
		Key = ~Name = '<SetupName>'~;
		Query = ~Select * from FTScanSetups Where <Key>~;

		if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
		{
			List( GetErrorDescription,0,theErr );
			return Warning( Translate( ~Query Failed: <Query>. <theErr>~ ) );
		}

		if ( !List( GetFirst,Setup ) )
		{
			return Warning( Translate( ~Could not find a setup named <SetupName>~ ) );
		}

		// Disable the current vendor drive settings before changing
		// to a new drive/setup combo

		GetFilmDriveVendor();
		OldFDVendor = ~<FDVendor>~;

		SaveGotoPunchNumber = ~<$con.dlgData[GotoPunchNumber]>~;
		LastFrame = ~~;
		if ( !<IgnoreFilmDriveEnable> )
		{
			dlg( SetStrings,FilmDriveEnabled,~0~ );
			EnableFilmDriveChanged(<CheckIfLoaded>,TRUE,TRUE);
		}

		
		if ( <IgnoreFilmDriveEnable> )
		{
			SaveFilmDriveVendor = ~<$con.dlgData[FilmDriveVendor]>~;
			SaveFilmDriveSetup = ~<$con.dlgData[FilmDriveSetup]>~;
			SaveFilmDriveEnabled = ~<$con.dlgData[FilmDriveEnabled]>~;
			SaveTension = ~<$con.dlgData[Tension]>~;
			SaveAutoScan = ~<$con.dlgData[AutoScan]>~;
			SaveIgnoreXAdjustments = ~<$con.dlgData[IgnoreXAdjustments]>~;
			SaveCutNegPrompt = ~<$con.dlgData[CutNegPrompt]>~;
		}

		if ( !Setup( UpdateIn,dlgData ) )
		{
			return Warning( Translate( ~Failed to update the dialog from <SetupName>~ ) );
		}

		if ( ~<$pcon.Setup[ScannerType]>~ != ~HR500~ )
		{
			dlg( SetStrings,ScannerType,~HR500~ );
		} 

		// Use previous values, so that drive is not changed/detensioned, etc
		if ( <IgnoreFilmDriveEnable> )
		{
			DlgData( SetValues,
					 AutoScan, <SaveAutoScan>,
					 FilmDriveVendor, ~<SaveFilmDriveVendor>~,
					 FilmDriveSetup, ~<SaveFilmDriveSetup>~,
					 FilmDriveEnabled, <SaveFilmDriveEnabled>,
					 FilmTension, <SaveTension>,
					 AutoScan, <SaveAutoScan>,
					 IgnoreXAdjustments, <SaveIgnoreXAdjustments>,
					 CutNegPrompt, <SaveCutNegPrompt> );
			dlg( SetStrings,
					 AutoScan, <SaveAutoScan>,
					 FilmDriveVendor, ~<SaveFilmDriveVendor>~,
					 FilmDriveSetup, ~<SaveFilmDriveSetup>~,
					 FilmDriveEnabled, <SaveFilmDriveEnabled>,
					 FilmTension, <SaveTension>,
					 AutoScan, <SaveAutoScan>,
					 IgnoreXAdjustments, <SaveIgnoreXAdjustments>,
					 CutNegPrompt, <SaveCutNegPrompt> );
		}

		if ( <DisplayUnits> != ~Inches~ )
		{
			XSliderIFactor = NUMERIC( ~<$pcon.Setup[XSliderIFactor]>~ );
			XSliderIFactor = InchesTo<DisplayUnits>( <XSliderIFactor> );

			FixedNonFdaAdv = NUMERIC( ~<$pcon.Setup[FixedNonFDAAdvance]>~ );
			FixedNonFdaAdv = InchesTo<DisplayUnits>( <FixedNonFdaAdv> );

			DlgData( SetValues,XSliderIFactor,~<XSliderIFactor>~,FixedNonFDAAdvance,~<FixedNonFdaAdv>~ );
		}

		minGap = NUMERIC( ~<$pcon.Setup[MinInterframeGap]>~ );
		minGap = LinesTo<DisplayUnits>( <minGap> );
		DlgData( SetValues,MinInterframeGap,~<minGap>~ );

		dlg( Update );

		FilmDriveSetup = ~<$con.dlgData[FilmDriveSetup]>~;
		UpdateFilmDriveSetupsCombo();
		dlg( SetStrings,FilmDriveSetup,~<FilmDriveSetup>~ );

		dlg( SetStatus,0,Translate( ~All settings were updated from the setting named: <SetupName>~ ) );

		NewFilmType = ~<$pcon.Setup[FilmType]>~;
		NewFilmType = ~<$Str.$NewFilmType.WithOutExt>~;
		FilmTermsFile = ~~;
		FilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<NewFilmType>.flt~;
		if ( !Files( FileExists,~<FilmTermsFile>~ ) )
		{
			Warning( Translate( ~The film type associated with scan setup <SetupName> does not exist.\nChoose a different film type and save the scan setup again.~ ) );
		}
	}

	RefreshControls();

	EnableFilmDriveChanged( <CheckIfLoaded>,FALSE,TRUE );

	punchPadding = ~<$pcon.Setup[FrameToPunchPadding]>~;
	if ( ~<punchPadding>~ == ~~ )
	{
		punchPadding = ~5~;
	}

	dlg( SetStrings,FrameToPunch,~<$pcon.Setup[FrameToPunch]>~,
					FrameToPunchPadding,~<punchPadding>~ );

	GetFilmDriveVendor();
	if ( ~<OldFDVendor>~ == ~<FDVendor>~ )
	{
		dlg( SetStrings,GotoPunchNumber,~<SaveGotoPunchNumber>~ );
	}

	UpdateFdaSetupsCombo();

	if ( DlgData( GetNumeric, FilmDriveEnabled ) && ~<FDVendor>~ == ~HR500AFD~ )
	{
		HR500AFD_SetupEdgeDetection();
	}

	retval = OnFormatChange( 1, ~Settings loaded.~, FALSE, FALSE, FALSE, FALSE );

	FilmTypeToLoad = ~<$pcon.Setup[FilmType]>~;
	FilmTypeToLoad = ~<$Str.$FilmTypeToLoad.WithOutExt>~;
	dlg( SelectString,FilmTypesComboBox,~<FilmTypeToLoad>~ );
	dlg( SelectString,ExposureProfileComboBox,~<$pcon.Setup[DRGBProfileName]>~ );
 	dlg( SelectString,EditorComboBox,~<$pcon.Setup[FilmEditor]>~ );

	dlg( SelectString,FilmFormatComboBox,~<$pcon.Setup[Format]>~ );
	dlg( GetInput );
	DlgData( GetValues,Format,Format );
	if ( ( ~<SetupName>~ != ~~ ) && ( ~<$pcon.Setup[Format]>~ != ~<Format>~ ) )
	{
		Warning( Translate( ~The film format in the scan setup is not available with the currently selected film transport.~ ) );
	}

	setupICCProfile = ~<$pcon.Setup[ICCProfile]>~;
	setupOutputProfile = ~<$pcon.Setup[ICCOutputProfile]>~;

	if ( ~<setupICCProfile>~ != ~~)
	{
		Query = ~Select * From Profiles Where Name = '<setupICCProfile>'~;

		if ( !PGenConList( profileList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
		{ 
			profileList( GetErrorDescription,0,theErr );
			Warning( Translate( ~Failed to query for profile (<setupICCProfile>) in the Profiles table.\n\n<Query>\n\n<theErr>~ ) ); 
		}
		if ( profileList( Empty ) )
		{
			Warning( Translate( ~The Scanner Profile (<setupICCProfile>) in the Scan Setup (<SetupName>)\nis not in the Profiles table.\n\nReverting to the previous Scanner Profile...~ ) ); 
		}
	}
	dlg( SelectString,ScannerProfileComboBox,~<setupICCProfile>~ );

	if ( ~<setupOutputProfile>~ != ~~)
	{
		Query = ~Select * From Profiles Where Name = '<setupOutputProfile>'~;

		if ( !PGenConList( profileList2,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
		{ 
			profileList2( GetErrorDescription,0,theErr );
			Warning( Translate( ~Failed to query for profile (<setupOutputProfile>) in the Profiles table.\n\n<Query>\n\n<theErr>~ ) ); 
		}
		if ( profileList2( Empty ) )
		{
			Warning( Translate( ~The Storage Profile (<setupOutputProfile>) in the Scan Setup (<SetupName>)\nis not in the Profiles table.\n\nReverting to the previous Storage Profile...~ ) ); 
		}
	}
	dlg( SelectString,OutputProfileComboBox,~<setupOutputProfile>~ );

	dlg( SetControlValue,~ScanSetupsComboBox~,~<SetupName>~);

	LastSetupName = ~<SetupName>~;

	if ( <ForceLoad> )
	{
		Sleep( 200 );	// let the UI catch up
	}
	
	if ( <retval> )
	{
		retval = OnFormatChange(4, ~Settings loaded.~,FALSE,FALSE,<DoCalibration> );
	}

	return <retval>;
}


NUMERIC OnTensionChange( TensionDriveOnly,RunCalibration,SkipCalibrationCheck )
{
	if ( !Defined( FilmDrive ) )	{ return DriveNotActive(); }

	dlg( GetInput );	
	
	Tension = DlgData( GetNumeric,Tension );

	OnlyTensionTheDrive = FALSE;
	if ( DefinedAndNotNULL( TensionDriveOnly ) )
	{
		OnlyTensionTheDrive = <TensionDriveOnly> ? TRUE : FALSE;
	}

	DoCalibration = TRUE;
	if ( DefinedAndNotNULL( RunCalibration ) )
	{
		DoCalibration = <RunCalibration> ? TRUE : FALSE;
	}

	SkipCalCheck = FALSE;
	if ( DefinedAndNotNULL( SkipCalibrationCheck ) )
	{
		SkipCalCheck = <SkipCalibrationCheck> ? TRUE : FALSE;
	}

	GetFilmDriveVendor();
	if ( !FunctionDefined( ~<FDVendor>_Tension~ ) )
	{
		return VendorNotSelected( ~<FDVendor>_Tension~ );
	}

	if ( !<OnlyTensionTheDrive> )
	{
		SetCurrentPunchNumber( ~~ );
		SetDialogVendorXOffsetInfo( 0, 0.0 );
		SetDialogVendorYOffsetInfo( 0, 0.0 );
	}

	FilmDriveCmdInProgress( (<Tension> != 0) ? Translate( ~Film Tensioning ~ ) : Translate( ~Film Untensioning ~ ) );

	if ( !<FDVendor>_Tension( <Tension> ) )
	{
		dlg( SetStrings,Tension,~~ );
		SetTransportControlsStopped();
		EnableTransportControls( FALSE );
		dlg( EnableControls,TRUE,LoadRevButton,LoadFwdButton );
		if ( !<TensionAborted> )
		{
			dlg( SetStatus,0,Translate( ~Film drive not tensioned.~ ) );
			return ReportFilmDriveError( ~Tension~ );
		}
	}
	
	result = Scanner( GetCurrentTensionState );
	if ( <result> != <Tension> )
	{
		dlg( SetCheck,<result>,TensionBox );
		dlg( Save,TensionBox );
		if ( !<TensionAborted> )
		{
			dlg( SetStatus,0,Translate( ~Film drive not tensioned.~ ) );
			SetTransportControlsStopped();
			EnableTransportControls( FALSE );
			dlg( EnableControls,TRUE,LoadRevButton,LoadFwdButton );
			return ReportFilmDriveError( ~Tension~ );
		}
	}

	if ( <TensionAborted> )
	{	
		TensionAborted = FALSE;
		SetTransportControlsStopped();
		EnableTransportControls( FALSE );
		dlg( EnableControls,TRUE,LoadRevButton,LoadFwdButton );
		dlg( SetStatus,0,Translate( ~Film drive tension aborted.~ ) );
		return FALSE;
	}
	SetTransportControlsStopped();
	EnableTransportControls( <Tension> != 0 );

	// check for expired calibration when drive is de-tensioned.
	if ( !<Tension> )
	{
		dlg( SetStatus,0,Translate( ~Film drive untensioned.~ ) );

		CheckImageSorterCount();

		if ( !<SkipCalCheck> )
		{	
			if ( !CalibrationOk( TRUE,TRUE,FALSE,TRUE ) )
			{
				if ( <DoCalibration> )
				{
					if ( !OnHR500CalibrateButton( FALSE,FALSE,TRUE ) )
					{
						EnableScanningControls( TRUE );
						SetTransportControlsStopped();
						ClearCalibrationHandlers();
						return Warning( Translate( ~Calibration did not complete.~ ) );
					}
				}
			}
		}
	}
	else
	{
		dlg( SetStatus,0,Translate( ~Film drive tensioned.~ ) );
	}

	return TRUE;
}


NUMERIC OnRewindButton()
{
	gStoppingFilmDrive = FALSE;
	if ( !Defined( FilmDrive ) )	{ return DriveNotActive(); }

	GetFilmDriveVendor();
	// Give the transport a chance to override this behavior
	if ( FunctionDefined( ~<FDVendor>_HandleRewind~ ) )
	{
		LastFrame = ~~;
		success = <FDVendor>_HandleRewind();
		CheckImageSorterCount();
		return <success>;
	}

	if ( !IsDriveTensioned( TRUE ) )		{ return DriveNotTensioned(); }

	FilmDriveCmdInProgress( Translate( ~Rewinding ... ~ ) );

	if ( !FunctionDefined( ~<FDVendor>_Rewind~ ) )
	{
		return VendorNotSelected( ~<FDVendor>_Rewind~ );
	}

	if ( !FunctionDefined( ~<FDVendor>_Rewind~ ) )
	{
		return VendorNotSelected( ~<FDVendor>_Rewind~ );
	}

	if ( <FDVendor>_Rewind() )
	{
		gNotchNumber = 0;
		SetCurrentPunchNumber( ~~ );
		EnableScanningControls( FALSE );
		SetTransportControlsRunning();
		ScanFrameBeforeAdvance = TRUE;
		LastFrame = ~~;
	}
	else
	{
		return ReportFilmDriveError( ~Rewind~ );
	}
	return TRUE;
}


VOID FilmDriveOperationComplete( Punch )
{
	if ( !IsNull( ~<OnFilmDriveOperationComplete>~ ) )
	{
		GetFilmDriveVendor();
		if ( ~<FDVendor>~ != ~HR500~ )
		{	Sleep( 50 );	}

		dlg( SetStrings,Punch,~<Punch>~ );
		SizzleControl( Set,Punch,~<Punch>~ );
		dlg( GetInput );
		ScanFromDataBase = DlgData(GetNumeric,ScanFromDataBase);
		FrameToPunch = DlgData(GetNumeric,FrameToPunch) && (~<FDVendor>~ == ~HR500~)  && (~<gFilmMarkType>~ != ~Notch~ );
		FrameToPunchPadding = DlgData(GetNumeric,FrameToPunchPadding);
		SequentialPunches = DlgData( GetNumeric,SequentialPunches) && (~<FDVendor>~ == ~HR500~);
		AutoScan = DlgData( GetNumeric,AutoScan );

		SizzleControl( Set,ScanFromDataBase,~<ScanFromDataBase>~);
		if ( <FrameToPunch> && !<ScanFromDataBase> )
		{
			NewFrame = Format( ~<Punch>~,~%ld~ );
			if ( <FrameToPunchPadding> )
			{
				NewFrame = Format( ~<Punch>~,~%0<FrameToPunchPadding>ld~ );
			}
			SetCurrentFrameNumber( ~<NewFrame>~ );
			SizzleControl( Set,Frame,~<NewFrame>~ );

			dlg( GetInput,GetStrings,Order,Order,Roll,Roll );

			if ( ~<LastOrderID>~ != ~<Order>~ || ~<LastRoll>~ != ~<Roll>~ || ~<LastFrame>~ != ~<NewFrame>~ )
			{
				if ( !ChangeOrderRollFrame( ~<Order>~,~<Roll>~,~<NewFrame>~,FALSE,TRUE ) )
				{
					EnableScanningControls( TRUE );
					SetTransportControlsStopped();
					return;	
				}
			}
			LastOrderID = ~<Order>~;
			LastRoll = ~<Roll>~;
			LastFrame = ~<NewFrame>~;
		}


		// These will be set
		XOffset = DlgData( GetNumeric,TXOffsetPositionInUnits );
		YOffset = DlgData( GetNumeric,EYOffsetPositionInUnits );
		YCorrection = DlgData( GetNumeric,EYOffsetIncrementUnit );

		SizzleControl( Set,XOffset,~<XOffset>~ );
		SizzleControl( Set,YOffset,~<YOffset>~ );
		SizzleControl( Set,EYOffsetIncrementUnit,~<YCorrection>~ );

		// Don't try to verify the punch number if we're jogging film
		if ( !<AutoScan> && <SequentialPunches> && !<ScanFromDataBase> && ( ~<JogNextCommand>~ == ~~ ) && ( ~<JogPrevCommand>~ == ~~ )  && (~<gFilmMarkType>~ != ~Notch~ ))
		{
			if ( <ExpectedNextPunch> != <Punch> && Numeric( ~<ExpectedNextPunch>~ ) >= <MinPunchNumber> )
			{
				if ( !HandleNonsequentialPunch( <Punch>,<ExpectedNextPunch> ) )
				{	
					EnableScanningControls( TRUE );
					SetTransportControlsStopped();
					return;	
				}
			}
		}

		prevSetting = ~<OnFilmDriveOperationComplete>~;
		retval = <OnFilmDriveOperationComplete>;

		if ( !<retval> )
		{
			ClearFilmDriveOperationHandlers();
			EnableScanningControls( TRUE );
			SetTransportControlsStopped();
		}

		if ( ~<OnFilmDriveOperationComplete>~ == ~<prevSetting>~  && !<gPositioningForFocus> )
		{
			ClearFilmDriveOperationHandlers();
		}
		if ( !DlgData(GetNumeric,ScanFromDataBase) )
		{
			dlg( SetStrings,EYOffsetPositionInUnits,~0~ );
		}
		if ( DlgData(GetNumeric,AutoScan) && !DlgData(GetNumeric,ScanFromDataBase) && <ScanFrameBeforeAdvance> && Numeric( ~<ExpectedNextPunch>~ ) > <MinPunchNumber> )
		{
			ScanFrameBeforeAdvance = FALSE;
		}
	}
}

NUMERIC OnScanButton( Position,TestScan )
{
	dlg( GetInput );
	FocusBeforeScan = FALSE;
	DoFrameToPunch = FALSE;
	ClearMagnificationHandlers();
	ClearCalibrationHandlers();
	FilmDriveEnabled = DlgData( GetNumeric,FilmDriveEnabled );
	GetFilmDriveVendor();
	EnableScanningControls( FALSE );
	if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsRunning(); }

	if ( !IsMMXSupportAvailable() )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return Warning( Translate( ~Unable to scan. This computer does not have MMX\nsupport which is required for HR500 scanning.~ ) );
	}

	if ( !Defined( Scanner ) )
	{
		if ( !FindScanner( FALSE ) )
		{
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return FALSE;
		}
	}

	if ( <MagNeeded> )
	{
		OnSetMagnificationComplete = STR ( OnScanButton( ~<Position>~,~<TestScan>~ ); );
		if ( !OnSetMagButton() )
		{
			ClearMagnificationHandlers();
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			Warning( Translate( ~Set magnification failed.~ ) );
			return FALSE;
		}
		return TRUE;
	}

	if ( !CheckLampState() )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	DirtyFlag = SizzleControl( GetNumeric,DirtyFlag );
	if ( <DirtyFlag> && <Position> != 0 )
	{
		Msg = Translate( ~Previous scan has not been saved.  Do you want to save the scanned image before continuing?~ );
		result = MessageBox( ~<Msg>~,YESNOCANCEL );

		if ( <result> == YES )
		{
			if ( !<FilmDriveEnabled> || ~<FDVendor>~ != ~Halse~ )
			{
				OnSaveImageButton( TRUE );
			}
			else
			{
				OnSaveImageButton( FALSE );
			}
		}
		if ( <result> == NO )
		{
			if ( Defined( Scanner ) && (!<FilmDriveEnabled> || ~<FDVendor>~ != ~Halse~) )
			{
				Scanner( CleanupLastScan, SizzleControl );
			}
		}
		else
		{
			EnableScanningControls( TRUE );
			if ( <FilmDriveEnabled> )
			{
				SetTransportControlsStopped();
			}
			return FALSE;
		}
	}

	numSaves = 0.0;
	if ( Defined( Scanner ) && !<TestScan> )
	{
		firstTime = TRUE;
		numSaves = Scanner( GetSavesInProgress );
		while ( <numSaves> > 1.0 )
		{
			if ( <firstTime> )
			{
				dlg( SetStatus,0,~Waiting for save operation to complete.~ );
				firstTime = FALSE;
			}

			Sleep( 250 );
			numSaves = Scanner( GetSavesInProgress );
		}
	}

	numSaves = 0.0;
	if ( !CheckAvailableMem() )
	{
		if ( <numSaves> > 0.0 )
		{
			firstTime = TRUE;
			numSaves = Scanner( GetSavesInProgress );
			while ( <numSaves> > 0.0 )
			{
				if ( <firstTime> )
				{
					dlg( SetStatus,0,Translate( ~Waiting for save operation to complete.~ ) );
					Log( Session,~Waiting for save operation to complete.~ );
					firstTime = FALSE;
				}

				Sleep( 250 );
				numSaves = Scanner( GetSavesInProgress );
			}
		}
	}

	if ( !UpdateLampOnTime( FALSE,FALSE ) )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}


	if ( !<TestScan> && <LastScanIsTestScan> )
	{
		if ( ImageCorrections( GetCrop,~<LastPath>~,cX1,cY1,cW1,cL1 ) )
		{
			cX2 = DlgData( GetNumeric,CropX );
			cY2 = DlgData( GetNumeric,CropY );
			cW2 = DlgData( GetNumeric,CropWidth );
			cL2 = DlgData( GetNumeric,CropLength );

			if ( <cX1> != <cX2> || <cY1> != <cY2> || <cW1> != <cW2> || <cL1> != <cL2> )
			{
				ImageCorrections( UpdateCrop,~<LastPath>~,50,50,100,100 );
			}
		}
	}

	if ( !VerifyProfiles() )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	LastPosition = <Position>;
	CurrentPosition = <Position>;

	SizzleControl( SetValues,FilmDriveAction,~~ );

	ClearFilmDriveOperationHandlers();

	if ( <FilmEditorChanged> )
	{
		UpdateEditorXYOffsetSetting();
	}

	Tension = IsDriveTensioned( TRUE );
	dlg( GetStrings,Volume,Volume,Order,Order,Roll,Roll,Frame,Frame,
	     Punch,Punch,SaveFileType,SaveFileType,
		 CurrentPunchPosition,CurrentPunchPosition,FilmDriveEnabled,FilmDriveEnabled,
		 CurrentXOffset,TXOffsetPositionInUnits,CurrentYOffset,EYOffsetPositionInUnits,
		 AutoScanWrap,AutoScanWrap,DisableFilmDrive,DisableFilmDrive,FrameToPunch,FrameToPunch,
		 TXOffsetIncrementUnit,TXOffsetIncrementUnit,EYOffsetIncrementUnit,EYOffsetIncrementUnit,
		 FrameToPunchPadding,FrameToPunchPadding );

	SequentialPunches = DlgData( GetNumeric,SequentialPunches) && (~<FDVendor>~ == ~HR500~) && (~<gFilmMarkType>~ != ~Notch~ );

	if ( !OrderValid( ~<Order>~ ) )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	DisplayLastImage = DlgData( GetNumeric,DisplayLastImage );
	AutoScan = DlgData( GetNumeric,AutoScan );
	ScanFromDataBase = DlgData( GetNumeric,ScanFromDataBase );
	XPos = DlgData( GetNumeric, XPos );
	YPos = DlgData( GetNumeric, YPos );
	ScanWidth = DlgData( GetNumeric, ScanWidth );
	ScanLength = DlgData( GetNumeric, ScanLength );
	NextPunch = <INVALID_PUNCH>;
	NextXOffset = 0;
	NextXPos = 0;
	NextYPos = 0;
	NextScanWidth = 0;
	NextScanLength = 0;
	SizzleControl( SetValues,NextInfoAdjusted,FALSE,NextPunch,<NextPunch>,
				   NextXOffset,<NextXOffset>,NextXPos,<NextXPos>,NextYPos,<NextYPos>,
				   NextScanWidth,<NextScanWidth>,NextScanLength,<NextScanLength> );

	// User selected NextFrame on strip, which means current frame is aligned
	// Allow focus and scan before Advance and Scan

	if ( Defined( FilmDrive ) && <FilmDriveEnabled> && ~<FDVendor>~ == ~Halse~ && <Position> == 1 && <gScanCount> > 0 )
	{
		gFirstFrameAligned = TRUE;
	}

	if ( <AutoScan> && !<ScanFromDataBase> && <ScanFrameBeforeAdvance> )
	{
		ExpectedNextPunch =  atof( ~<CurrentPunchPosition>~ );
		if ( <Position> != 0 )
		{
			Position = 0;
			CurrentPosition = 0;
		}
	}

	// Do not display the image if we are repeatedly scanning the current frame
	if ( <DisplayLastImage> && <AutoScan> && <LastPosition> == 0 )
	{
		dlg( SetString,~0~,DisplayLastImage );
	}

	if ( ~<CurrentPunchPosition>~ == ~~ || !IsNumeric( ~<CurrentPunchPosition>~ ) )
	{
		CurrentPunchPosition = -1;
		SetCurrentPunchNumber( ~~ );
	}


	if ( ~<Volume>~ == ~~ || ~<Order>~ == ~~ || ~<Roll>~ == ~~ || ~<Frame>~ == ~~ )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return Warning( Translate( ~You must enter values for Path, Order, Roll, and Frame~ ) );
	}

	if ( <FilmDriveEnabled> )
	{
		if ( !FunctionDefined( ~<FDVendor>_FormatPunchNumber~ ) )
		{
			EnableScanningControls( TRUE );
			SetTransportControlsStopped();
			return VendorNotSelected( ~<FDVendor>_FormatPunchNumber~ );
		}
		if ( !FunctionDefined( ~<FDVendor>_ValidPunchRange~ ) )
		{
			EnableScanningControls( TRUE );
			SetTransportControlsStopped();
			return VendorNotSelected( ~<FDVendor>_ValidPunchRange~ );
		}
	}

	if ( !<ScanFromDataBase> )
	{
		if ( !CalibrationOk( FALSE,FALSE,FALSE,TRUE ) )
		{
			AutoScanAfterCal = TRUE;
			OnCalibrationComplete = STR ( OnScanButton( ~<LastPosition>~,~<TestScan>~ ); );

			// if long roll, get current punch; set Goto Punch to current punch
			dlg( SetStrings,GotoPunchNumber,~<CurrentPunchPosition>~ );
			dlg( Save,GotoPunchNumber );

			IsCalStarted = CompleteCalibrationAfterMag( FALSE,<TestScan>,TRUE,TRUE );
			if ( <IsCalStarted> )
			{
				EnableScanningControls( FALSE );
				if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsRunning(); }
				return FALSE;
			}
			else
			{
				AutoScanAfterCal = FALSE;
				ClearCalibrationHandlers();
				EnableScanningControls( TRUE );
				if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
				return TRUE;
			}
		}
	}

	if ( !CheckRangeSettings())
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	if ( <FilmDriveEnabled> && <Tension> && ( <CurrentPunchPosition> < 0 ) )
	{
		SetCurrentPunchNumber( ~~ );
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		if ( ~<FDVendor>~ == ~Halse~ )
		{
			Msg = ~Please load the film.~;
		}
		else if ( ~<FDVendor>~ == ~HR500AFD~ )
		{
			Msg = ~Film drive is not positioned at a valid frame.\n\nPlease manually position the film to a frame.~;
		}
		else
		{
			Msg = ~Film drive is not positioned at a valid punch location.\n\nPlease manually position the film to a punch location.~;
		}
		return Warning( Translate( ~<Msg>~ ) );
	}
	else if ( <FilmDriveEnabled> && !<Tension> && ~<FDVendor>~ == ~Halse~ )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		Msg = ~Please load the film.~;
		return Warning( Translate( ~<Msg>~ ) );
	}


	if ( <TestScan> )
	{
		SizzleControl( SetValues,TestScan,TRUE );
	}

	// Check focus before frame calculation on long roll & strip
	// also for cut neg mode
	FocusEveryFrame = DlgData( GetNumeric,FocusEveryFrame );

	if ( <FocusNeeded> || <FocusEveryFrame> )
	{
		if ( ( Defined( FilmDrive ) && <FilmDriveEnabled> && ( ~<FDVendor>~ == ~HR500~ ) ) ||
		     ( Defined( FilmDrive ) && <FilmDriveEnabled> && ( ~<FDVendor>~ != ~HR500~ ) && (<gAligningFrame> || <gFirstFrameAligned>) ) ||
			 ( !<FilmDriveEnabled> ) )
		{
			FocusBeforeScan = TRUE;
			if ( ~<FDVendor>~ != ~HR500~ && !<gFirstFrameAligned> )
			{
				ScanFrameBeforeAdvance = FALSE;
				if ( <gSkippingBlankFilm> )
				{
					FocusBeforeScan = FALSE;
				}
			}
		}
	}

	// GET THE FRAME NUMBER
	// If we are scanning from the database then ignore loading film drive info
	// from the ScanSetup records
	IgnoreFilmDriveEnable = <ScanFromDataBase>;

	// If no database, get the frame number info from the UI
	if ( !<ScanFromDataBase> )
	{
		if ( !IsNumeric( ~<Frame>~ ) && Defined( FilmDrive ) && <FilmDriveEnabled> && ~<FDVendor>~ != ~HR500~ )
		{
			EnableScanningControls( TRUE );
			SetTransportControlsStopped();
			Warning( Translate( ~Unable to scan.  The frame number must be numeric.~ ) );
			return FALSE;
		}

		if ( !<FilmDriveEnabled> )
		{
			CurrentPunchPosition = <FDVendor>_FormatPunchNumber( ~-1~ );
		}
		// Film Drive should be positioned at a valid punch
		if ( <FilmDriveEnabled> ) 
		{
			if (!<FDVendor>_ValidPunchNumber( ~<CurrentPunchPosition>~ ) )
			{
				EnableScanningControls( TRUE );
				if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
				if ( ~<FDVendor>~ == ~Halse~ )
				{
					Msg = ~Please load the film.~;
				}
				else if ( ~<FDVendor>~ == ~HR500AFD~ )
				{
					Msg = ~Film drive is not positioned at a valid frame.\n\nPlease manually position the film to a frame.~;
				}
				else
				{
					Msg = ~Film drive is not positioned at a valid punch location.\n\nPlease manually position the film to a punch location.~;
				}
				return Warning( Translate( ~<Msg>~ ) );
			}
			else if ( <FrameToPunch> && !<DisableFilmDrive> )
			{
				NewFrame = Format( ~<CurrentPunchPosition>~,~%ld~ );
				FrameToPunchPadding = DlgData(GetNumeric,FrameToPunchPadding);
				if ( <FrameToPunchPadding> )
				{
					NewFrame = Format( ~<CurrentPunchPosition>~,~%0<FrameToPunchPadding>ld~ );
				}
				SetCurrentFrameNumber( ~<NewFrame>~ );
				Frame = ~<NewFrame>~;
				DoFrameToPunch = TRUE;
			}
		}
		if ( IsNumeric( ~<Frame>~ ) )
		{
			len = strlen(~<Frame>~);
			if ( <len> > <MAX_NUMERIC_LENGTH> )
			{
				Warning( Translate( ~The maximum numeric value for the frame number has been exceeded.\nPlease update the number manually.~ ) );
			}
			else
			{
				// Give the transport a chance to translate the position into a frame delta for us if it can; otherwise
				// default the delta to the position value.
				Routine = <FDVendor>_TranslateMoveToFrameDelta;
				
				if ( <FilmDriveEnabled> && FunctionDefined( ~<Routine>~ ) )
					{ FrameDelta = <Routine>( ~<Position>~ ); }
				else
				{
					FrameDelta = ( <FilmDriveEnabled> && ( <FilmDirection> == 1 ) ) ? ( <Position> * (-1) ) : <Position>;
 				}
					
				Frame = <Frame> + <FrameDelta>;
				if ( <Frame> < <MinPunchNumber> )
				{
					//if ( <FilmDriveEnabled> )
					//{
					//	ClearAutoFlag( FALSE );
					//}
					Warning( Translate( ~Unable to scan.  The frame number cannot be less than or equal to 0.~ ) );
					EnableScanningControls( TRUE );
					if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
					return FALSE;
				}

				Frame = FormattedFrame( Format( ~<Frame>~,~%0<len>ld~ ) );
				CurrentScanFrame = ~<Frame>~;
				dlg( SetString,~<Frame>~,Frame,0 );
				DlgData( SetValues,Frame,~<Frame>~ );
			}
		}

		numSaves = 0.0;
		if ( Defined( Scanner ) && !<TestScan> )
		{
			firstTime = TRUE;
			numSaves = Scanner( GetSavesInProgress );
			while ( <numSaves> >= 1.0 && ~<Frame>~ == ~<lastFrameScanned>~ )
			{
				if ( <firstTime> )
				{
					dlg( SetStatus,0,~Waiting for save operation to complete.~ );
					firstTime = FALSE;
				}

				Sleep( 250 );
				numSaves = Scanner( GetSavesInProgress );
			}
		}

		if ( atof(~<Frame>~) != atof(~<Punch>~)  && FunctionDefined( ~<FDVendor>_ResetFrameNumber~ ) )
		{
			<FDVendor>_ResetFrameNumber( ~<Frame>~ );
		}

		if ( <AutoScan> && <FilmDriveEnabled> && (~<FDVendor>~ == ~HR500~ || ~<FDVendor>~ == ~HR500AFD~) )
		{
			NextPunch = ( <LastPosition> < 0 ) ? (-2) : ( <LastPosition> > 0 ) ? -1 : 0;
			NextXOffset = DlgData( GetNumeric,TXOffsetPositionInUnits );
		}
		dlg( SetStrings,Punch,~<CurrentPunchPosition>~ );
		SizzleControl( SetValues,NextInfoAdjusted,FALSE,NextPunch,<NextPunch>,
					   NextXOffset,<NextXOffset>,NextXPos,50.,NextYPos,50.,
					   NextScanWidth,100.,NextScanLength,100. );

		// Special case for Cut Negative Scanning (No Database/No Transport)
		if ( !Defined( FilmDrive ) || !<FilmDriveEnabled> )
		{
			if ( <FocusBeforeScan> )
			{
				Msg = Translate( ~The scanner will automatically focus on the next scan.\n\nPlease insert frame <Frame>.\n\nDo you want to focus and scan now?~ );
				if ( MessageBox( ~<Msg> ~,YESNO ) == NO )
				{
					FocusBeforeScan = FALSE;
					EnableScanningControls( TRUE );
					return FALSE;
				}
				FocusBeforeScan = TRUE;
			}
			else if ( DlgData(GetNumeric,CutNegPrompt) )
			{
				Msg = Translate( ~Please insert frame <Frame>~ );

				GenCon( MbInfo,New,DDCustomMessageBox );
				MbInfo( SetValues,Title,Translate(~HR500 Scanning~),Message,~<Msg>~,
							Button1,Translate(~&Focus and Scan~),Button2,Translate(~&Scan~),Button3,Translate(~&Cancel~),
							SetWindowPos,1,X,-1,Y,-1,Width,325,Height,215 ) ;
				result = CustomMessageBox(MbInfo);
				button = MbInfo(GetNumeric, ButtonPressed);
				if ( <result> == 2 || <button> == 3 )	// result = 2 when X in dialog is pressed
				{
					dlg( SetStatus,0,Translate( ~Scanning cancelled.~ ) );
					EnableScanningControls( TRUE );
					return Warning( Translate( ~Scanning cancelled.~ ) );
				}
				else if ( <button> == 1 )
				{
					FocusBeforeScan = TRUE;
				}
			}
		}
	
		// Update the scanner dialog
		if ( IsNumeric( ~<Frame>~ ) && ( Numeric( ~<Frame>~ ) < 0 ) )
		{
			Frame = FormattedFrame(~000~);
		}

		Frame = FormattedFrame( ~<Frame>~ );
		dlg( SetStrings,Frame,~<Frame>~,Roll,~<Roll>~ );
		dlg( Save,Frame );
		dlg( Save,Roll );

		// 02/08/02 DPT
		// If frame to punch is set and we are not scanning from the database
		// and we are moving film, a call will be made after the movement of 
		// the film to change the order, roll, and frame.
		// So there is no need to make the call here.
		FrameToPunch = DlgData(GetNumeric,FrameToPunch) && (~<gFilmMarkType>~ != ~Notch~ );

		if ( !<FrameToPunch> || <Position> == 0 )
		{
			if ( ~<LastOrderID>~ != ~<Order>~ || ~<LastRoll>~ != ~<Roll>~ || ~<LastFrame>~ != ~<Frame>~ )
			{
				// Warns for no DRGB refs (analyzer values)
				if ( !ChangeOrderRollFrame( ~<Order>~,~<Roll>~,~<Frame>~,FALSE,TRUE ) )
				{ 
					EnableScanningControls( TRUE );
					if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
					return FALSE; 
				}
			}
			LastOrderID = ~<Order>~;
			LastRoll = ~<Roll>~;
			LastFrame = ~<Frame>~;
		}
	}

	// 02/12/02 DPT
	// This used to be done near the top of this function.  But I found a
	// problem where if we were scanning from the database and at the end
	// of the order, we would throw the scan object away and they wouldn't
	// be able to make any changes to the scanner color offsets and reapply
	// them.
	if ( Defined( Scanner ) && (!<FilmDriveEnabled> || ~<FDVendor>~ != ~Halse~) )
	{
		Scanner( CleanupLastScan, SizzleControl );
	}

	// Update the dialog with offset information
	SetDialogVendorXOffsetInfo( <CurrentXOffset>, <TXOffsetIncrementUnit> );
	SetDialogVendorYOffsetInfo( <CurrentYOffset>, <EYOffsetIncrementUnit> );

	EndSettleTime = 0;

	// MAKE SURE SCAN AREA IS CORRECT
	UpdateScanSize(FALSE,TRUE,TRUE);

	if ( !DiskSpaceOK() )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		if ( DlgData( GetNumeric,ScanFromDatabase ) )
		{	ResetNextFrameAfterError( FALSE );	}
		return FALSE;
	}

	if ( Defined( Scanner ) && (~<FDVendor>~ == ~HR500~ || ~<FDVendor>~ == ~HR500AFD~) )
	{
		ResIndex = ResolutionNames( IndexOf,~<$Con.DlgData[ScanResolution]>~ );
		Size	 = atof(Resolutions( ValueOf,$ResIndex ));
		SizzleControl( Set,Size,<Size> );
		HR500_UpdateNextFrameInfo();
		gNotchIncrement = <LastPosition>;
	}

	// DO THE FRAME MOVEMENT IF REQUIRED

	PositionForFocusNeeded = FALSE;
	if ( Defined( FilmDrive ) && <FilmDriveEnabled> && <FocusBeforeScan> && ~<FDVendor>~ == ~Halse~ )
	{
		dlg( SetStrings,GotoPunchNumber,~<CurrentPunchPosition>~ );
	    dlg( Save,GotoPunchNumber );
		PositionForFocusNeeded = Halse_PositionForFocusNeeded();
	}
	else
	{
		PreFocusFrameStatus = FALSE;
	}

	if ( <PositionForFocusNeeded> && <Position> != 0 && !<gSkippingBlankFilm> )
	{
		OnFilmDriveOperationComplete = STR ( Halse_PositionForFocus( FALSE ); );
	}
	else
	{
		OnFilmDriveOperationComplete = STR ( ScanAnImage( ~<Volume>~,~<Order>~,~<Roll>~,~<Frame>~,~<$con.DlgData[FileExtension]>~,<TestScan>,<FocusBeforeScan>,<DoFrameToPunch> ); );
	}

	// If there is no film drive, or if film drive is disabled then clear the handlers
	if ( <AutoScan> && !<ScanFromDataBase> && <SequentialPunches> && (<ExpectedNextPunch> != atof( ~<CurrentPunchPosition>~ ))  && (~<gFilmMarkType>~ != ~Notch~ ) )
	{
		if ( !HandleNonsequentialPunch( atof( ~<CurrentPunchPosition>~ ),<ExpectedNextPunch> ) )
		{	
			OnFilmDriveOperationComplete = STR ( ~FinishScanAfterCalibration( <TestScan>,<FocusBeforeScan> );~ );
			return FALSE;	
		}
	}

	if ( SizzleControl( GetNumeric,TotalMatching ) >= DlgData( GetNumeric,ScansToSave ) && !<gAligningFrame> )
	{
		DlgData( GetValues,ProductID,ProductID,QueueName,QueueName );
		ClearFilmDriveOperationHandlers();
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		msg = ~Image Type Sorting Complete.\n\nThe requested number of scans has been saved.\n\n~;
		msg = Translate( ~<msg>Do you want to print the images using Product <ProductID> to the <QueueName> Printer Queue?~ );
		if ( MessageBox( ~<Msg> ~,YESNO ) == NO )
		{
			dlg( SetStatus,0,Translate( ~Scanning cancelled.~ ) );
			EnableScanningControls( TRUE );
			FocusBeforeScan = FALSE;
			return FALSE;
		}
		else
		{
			Routine = <FDVendor>_TranslateMoveToFrameDelta;
			
			if ( <FilmDriveEnabled> && FunctionDefined( ~<Routine>~ ) )
				{ FrameDelta = <Routine>( ~<Position>~ ); }
			else
			{
				FrameDelta = ( <FilmDriveEnabled> && ( <FilmDirection> == 1 ) ) ? ( <Position> * (-1) ) : <Position>;
 			}
				
			Frame = <Frame> - <FrameDelta>;
			Frame = FormattedFrame( Format( ~<Frame>~,~%0<len>ld~ ) );
			CurrentScanFrame = ~<Frame>~;
			dlg( SetString,~<Frame>~,Frame,0 );
			return CreateImageSorterProofJobs( ~<Order>~,~<ProductID>~,~<QueueName>~ );
		}
	}

	if ( !Defined( FilmDrive ) || !<FilmDriveEnabled> || <DisableFilmDrive> )
	{
		ClearFilmDriveOperationHandlers();
	}

	// If no database and previous frame selected
	else if ( !<ScanFromDataBase>  && <Position> < 0 )
	{
		LastFrame = ~~;
		if ( !<DoPunchWaitOverride> )
		{
			if ( <FilmDirection> == 0 )
			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) - 1;
			}
			else
			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) + 1;
			}
		}
		if ( !OnPreviousFrameButton( TRUE,<DoPunchWaitOverride> ) )
		{
			ClearFilmDriveOperationHandlers();
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return FALSE; // REM OnPreviousFrameButton will display error message
		}
		EndSettleTime = Ticks() + <SettleTime>;
	}

	// If no database and next frame selected
	else if  ( !<ScanFromDataBase>  && <Position> > 0 )
	{
		LastFrame = ~~;
		if ( !<DoPunchWaitOverride> )
		{
			if ( <FilmDirection> == 0 )
			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) + 1;
			}
			else
			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) - 1;
			}
		}
		if ( !OnNextFrameButton( TRUE,<DoPunchWaitOverride>,FALSE,<FocusBeforeScan> ) )
		{
			ClearFilmDriveOperationHandlers();
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return FALSE; // REM OnNextFrameButton will display error message
		}
		EndSettleTime = Ticks() + <SettleTime>;
	}

	// Else just scan the current cut negative or current punch location

	Frame = FormattedFrame( ~<Frame>~ );
	
	// Check to see if the user would like to wait for the film
	// to settle
	if ( <SettleTime> && <EndSettleTime> )
	{
		DeltaSettleTime = ( <EndSettleTime> - Ticks() );
		if ( <DeltaSettleTime> > 0 )
		{
			Sleep( <DeltaSettleTime> );
		}
	}

	// After all frame movement has completed check/setup for wait for next punch
	DoPunchWaitOverride = FALSE;
	AutoScan = DlgData( GetNumeric,AutoScan );

	if ( <AutoScan> && <FilmDriveEnabled> && ~<FDVendor>~ != ~Halse~ )
	{
		if ( <FilmDirection> == 0 )
		{
			NextPunchInc = <LastPosition>;
		}
		else
		{
			NextPunchInc = - <LastPosition>;
		}

		if ( !<DoPunchWaitOverride> )
		{
			ExpectedNextPunch = <ExpectedNextPunch> + <NextPunchInc>;
		}
		else
		{
			ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) + <NextPunchInc>;
		}
		if ( <NextPunch> != <INVALID_PUNCH> )
		{
			DoPunchWaitOverride = TRUE;
		}
	}

	if ( !Defined( FilmDrive ) || !<FilmDriveEnabled> || <DisableFilmDrive> || ( !<ScanFromDataBase> && <Position> == 0 ) )
	{
		SizzleControl( Set,Punch,~<CurrentPunchPosition>~ );
		SizzleControl( Set,ScanFromDataBase,~<ScanFromDataBase>~ );
		dlg( GetInput );
		XOffset = DlgData( GetNumeric,TXOffsetPositionInUnits );
		YOffset = DlgData( GetNumeric,EYOffsetPositionInUnits );
		EYOffsetIncrementUnit = DlgData( GetNumeric,EYOffsetIncrementUnit );

		SizzleControl( Set,XOffset,~<XOffset>~ );
		SizzleControl( Set,YOffset,~<YOffset>~ );
		SizzleControl( Set,EYOffsetIncrementUnit,~<EYOffsetIncrementUnit>~);
		
		retval = FALSE;
		if ( <PositionForFocusNeeded> && !<gSkippingBlankFilm> )
		{
			retval = Halse_PositionForFocus( FALSE );
		}
		else
		{
			retval = ScanAnImage( ~<Volume>~,~<Order>~,~<Roll>~,~<Frame>~,~<$con.DlgData[FileExtension]>~,<TestScan>,<FocusBeforeScan>,<DoFrameToPunch> );
		}

		if ( <retval> && <AutoScan> && !<ScanFromDataBase> && <ScanFrameBeforeAdvance> )
		{
			ScanFrameBeforeAdvance = FALSE;
		}

		if ( !<retval> )
		{
			KeepScanList = FALSE;
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		}

		return <retval>;
	}
	return TRUE;
}


NUMERIC FinishScanAfterMag( TestScan,LastOrderID,LastRoll,Frame,ScanFromDatabase,FocusBeforeScan )
{
	ClearMagnificationHandlers();
	dlg( GetInput );
	dlg( GetStrings,Order,Order,Roll,Roll,Punch,Punch,FilmDriveEnabled,FilmDriveEnabled );

	// Update the scanner dialog
	if ( IsNumeric( ~<Frame>~ ) && ( Numeric( ~<Frame>~ ) < 0 ) )
	{
		Frame = FormattedFrame(~000~);
	}

	Frame = FormattedFrame( ~<Frame>~ );

	if ( !CalibrationOk( FALSE,FALSE,FALSE,TRUE ) )
	{
		AutoScanAfterCal = TRUE;
		OnCalibrationComplete = STR ( StartScanAfterCalibration( <TestScan>,~<Frame>~ ); );
		dlg( SetStrings,GotoPunchNumber,~<CurrentPunchPosition>~ );
	    dlg( Save,GotoPunchNumber );
		IsCalStarted = CompleteCalibrationAfterMag( FALSE,<TestScan>,FALSE,TRUE );
		if ( <IsCalStarted> )
		{
			EnableScanningControls( FALSE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsRunning(); }
			return FALSE;
		}
		else
		{
			AutoScanAfterCal = FALSE;
			ClearCalibrationHandlers();
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			if ( DlgData( GetNumeric,ScanFromDatabase ) )
			{	ResetNextFrameAfterError( FALSE );	}
			return TRUE;
		}
	}

	GetFilmDriveVendor();
	// Special case for Cut Negative Scanning (Database/No Transport)
	if ( !Defined( FilmDrive ) && !<FilmDriveEnabled> && DlgData(GetNumeric,CutNegPrompt))
	{
		Msg = Translate( ~The scanner will automatically focus on the next scan.\n\nPlease insert frame <Frame>.\n\nDo you want to focus and scan now?~ );
		if ( MessageBox( ~<Msg> ~,YESNO ) == NO )
		{
			dlg( SetStatus,0,Translate( ~Scanning cancelled.~ ) );
			EnableScanningControls( TRUE );
			FocusBeforeScan = FALSE;
			if ( DlgData( GetNumeric,ScanFromDatabase ) )
			{	ResetNextFrameAfterError( FALSE );	}
			return Warning( Translate( ~Scanning cancelled.~ ) );
		}
		FocusBeforeScan = TRUE;
	}
	else
	{
		FocusBeforeScan = TRUE;
		if ( ~<FDVendor>~ == ~Halse~ )
		{
			ScanFrameBeforeAdvance = FALSE;
			if ( <gSkippingBlankFilm> )
			{
				FocusBeforeScan = FALSE;
			}
		}
	}


	// Always set the Punch number in the UI (with the punch number in the db) even
	// if there is no Film Drive defined or enabled
	if ( FunctionDefined( ~<FDVendor>_FormatPunchNumber~ ) )
	{
		Punch = <FDVendor>_FormatPunchNumber( ~<Punch>~ );
	}
	dlg( SetStrings,Punch,~<Punch>~ );

	return FinishScanAfterCalibration( <TestScan>,<FocusBeforeScan> );
}


NUMERIC StartScanAfterCalibration( TestScan,Frame )
{
	ClearCalibrationHandlers();
	FocusBeforeScan = FALSE;

	dlg( GetInput,GetStrings,Punch,Punch,FilmDriveEnabled,FilmDriveEnabled );

	GetFilmDriveVendor();

	// Always set the Punch number in the UI (with the punch number in the db) even
	// if there is no Film Drive defined or enabled
	if ( FunctionDefined( ~<FDVendor>_FormatPunchNumber~ ) )
	{
		Punch = <FDVendor>_FormatPunchNumber( ~<Punch>~ );
	}
	dlg( SetStrings,Punch,~<Punch>~ );

	if ( ( !Defined( FilmDrive ) || !<FilmDriveEnabled> ) )
	{
		Msg = Translate( ~The scanner will automatically focus on the next scan.\n\nPlease insert frame <Frame>.\n\nDo you want to focus and scan now?~ );
		if ( MessageBox( ~<Msg> ~,YESNO ) == NO )
		{
			dlg( SetStatus,0,Translate( ~Scanning cancelled.~ ) );
			EnableScanningControls( TRUE );
			FocusBeforeScan = FALSE;
			if ( DlgData( GetNumeric,ScanFromDatabase ) )
			{	ResetNextFrameAfterError( FALSE );	}
			return Warning( Translate( ~Scanning cancelled.~ ) );
		}
		FocusBeforeScan = TRUE;
	}
	else if ( ( ~<FDVendor>~ == ~HR500~ ) ||
	     ( ( ~<FDVendor>~ != ~HR500~ ) && (<gAligningFrame> || <gFirstFrameAligned>) ) )
	{
		FocusBeforeScan = TRUE;
		if ( ~<FDVendor>~ != ~HR500~ )
		{
			ScanFrameBeforeAdvance = FALSE;
			if ( <gSkippingBlankFilm> )
			{
				FocusBeforeScan = FALSE;
			}
		}
	}

	return FinishScanAfterCalibration( <TestScan>, <FocusBeforeScan> );
}


NUMERIC FinishScanAfterCalibration( TestScan,FocusBeforeScan )
{
	FinishScanCommand = ~~;
	dlg( GetInput,GetStrings,Volume,Volume,Order,Order,Roll,Roll,Frame,Frame,
	     Punch,Punch,SaveFileType,SaveFileType,
		 CurrentPunchPosition,CurrentPunchPosition,FilmDriveEnabled,FilmDriveEnabled,
		 DisableFilmDrive,DisableFilmDrive,FrameToPunch,FrameToPunch,
		 CurrentXOffset,TXOffsetPositionInUnits,CurrentYOffset,EYOffsetPositionInUnits,
		 TXOffsetIncrementUnit,TXOffsetIncrementUnit,EYOffsetIncrementUnit,EYOffsetIncrementUnit );

	GetFilmDriveVendor();
	SequentialPunches = DlgData( GetNumeric,SequentialPunches) && (~<FDVendor>~ == ~HR500~)  && (~<gFilmMarkType>~ != ~Notch~ );

	ScanFromDatabase = DlgData(GetNumeric,ScanFromDataBase);
	AutoScan = DlgData( GetNumeric,AutoScan );
	
	DoFrameToPunch = FALSE;
	if ( !<ScanFromDatabase> && <FilmDriveEnabled> && <FrameToPunch>  && (~<gFilmMarkType>~ != ~Notch~ ) )
	{
		DoFrameToPunch = TRUE;
	}

	// This used to be done near the top of OnScanButton.  But I found a
	// problem where if we were scanning from the database and at the end
	// of the order, we would throw the scan object away and they wouldn't
	// be able to make any changes to the scanner color offsets and reapply
	// them.
	if ( Defined( Scanner ) && (!<FilmDriveEnabled> || ~<FDVendor>~ != ~Halse~) )
	{
		Scanner( CleanupLastScan, SizzleControl );
	}

	Position = <CurrentPosition>;

	EndSettleTime = 0;

	// MAKE SURE SCAN AREA IS CORRECT
	UpdateScanSize(FALSE,TRUE,TRUE);

	if ( !DiskSpaceOK() )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		if ( DlgData( GetNumeric,ScanFromDatabase ) )
		{	ResetNextFrameAfterError( FALSE );	}
		return FALSE;
	}

	if ( Defined( Scanner ) && (~<FDVendor>~ == ~HR500~ || ~<FDVendor>~ == ~HR500AFD~) )
	{
		ResIndex = ResolutionNames( IndexOf,~<$Con.DlgData[ScanResolution]>~ );
		Size	 = atof(Resolutions( ValueOf,$ResIndex ));
		SizzleControl( Set,Size,<Size> );
		HR500_UpdateNextFrameInfo();
	}

	// DO THE FRAME MOVEMENT IF REQUIRED

	PositionForFocusNeeded = FALSE;
	if ( Defined( FilmDrive ) && <FilmDriveEnabled> && <FocusBeforeScan> && ~<FDVendor>~ == ~Halse~ )
	{
		dlg( SetStrings,GotoPunchNumber,~<CurrentPunchPosition>~ );
	    dlg( Save,GotoPunchNumber );
		PositionForFocusNeeded = Halse_PositionForFocusNeeded();
	}

	if ( <PositionForFocusNeeded> && <Position> != 0 && !<gSkippingBlankFilm> )
	{
		OnFilmDriveOperationComplete = STR ( Halse_PositionForFocus( FALSE ); );
	}
	else
	{
		OnFilmDriveOperationComplete = STR ( ScanAnImage( ~<Volume>~,~<Order>~,~<Roll>~,~<Frame>~,~<$con.DlgData[FileExtension]>~,<TestScan>,<FocusBeforeScan>,<DoFrameToPunch> ); );
	}

	// If there is no film drive, or if film drive is disabled then clear the handlers
	if ( <AutoScan> && !<ScanFromDataBase> && <SequentialPunches> && (<ExpectedNextPunch> != atof( ~<CurrentPunchPosition>~ ))  && (~<gFilmMarkType>~ != ~Notch~ ) )
	{
		if ( !HandleNonsequentialPunch( atof( ~<CurrentPunchPosition>~ ),<ExpectedNextPunch> ) )
		{	
			OnFilmDriveOperationComplete = STR ( ~FinishScanAfterCalibration( <TestScan>,<FocusBeforeScan> );~ );
			return FALSE;	
		}
	}

	if ( !Defined( FilmDrive ) || !<FilmDriveEnabled> || <DisableFilmDrive> )
	{
		ClearFilmDriveOperationHandlers();
	}

	// If no database and previous frame selected
	else if ( !<ScanFromDataBase>  && <Position> < 0 )
	{
		LastFrame = ~~;
		if ( !<DoPunchWaitOverride> )
		{
			if ( <FilmDirection> == 0 )

			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) - 1;
			}
			else
			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) + 1;
			}
		}
		if ( !OnPreviousFrameButton( TRUE,FALSE ) )
		{
			ClearFilmDriveOperationHandlers();
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return FALSE; // REM OnPreviousFrameButton will display error message
		}
		EndSettleTime = Ticks() + <SettleTime>;
	}

	// If no database and next frame selected
	else if  ( !<ScanFromDataBase>  && <Position> > 0 )
	{
		LastFrame = ~~;
		if ( !<DoPunchWaitOverride> )
		{
			if ( <FilmDirection> == 0 )
			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) + 1;
			}
			else
			{
				ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) - 1;
			}
		}
		if ( !OnNextFrameButton( TRUE,FALSE,FALSE,<FocusBeforeScan> ) )
		{
			ClearFilmDriveOperationHandlers();
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
			return FALSE; // REM OnNextFrameButton will display error message
		}
		EndSettleTime = Ticks() + <SettleTime>;
	}

	// Else just scan the current cut negative or current punch location

	// Update the scanner dialog
	if ( IsNumeric( ~<Frame>~ ) && ( Numeric( ~<Frame>~ ) < 0 ) )
	{
		Frame = FormattedFrame(~000~);
	}

	Frame = FormattedFrame( ~<Frame>~ );
	
	// 02/08/02 DPT
	// If frame to punch is set and we are not scanning from the database,
	// a call will be made after the movement of the film to change the
	// order, roll, and frame.	So there is no need to make the call here.
	FrameToPunch = DlgData(GetNumeric,FrameToPunch)  && (~<gFilmMarkType>~ != ~Notch~ );
	if ( !( <FrameToPunch> && !<ScanFromDataBase> && <Position> == 0 ) )
	{
		if ( ~<LastOrderID>~ != ~<Order>~ || ~<LastRoll>~ != ~<Roll>~ || ~<LastFrame>~ != ~<Frame>~ )
		{
			// Warns for no DRGB refs (analyzer values)
			if ( !ChangeOrderRollFrame( ~<Order>~,~<Roll>~,~<Frame>~,FALSE,TRUE ) )
			{
				EnableScanningControls( TRUE );
				if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
				return FALSE;
			}
		}
		LastOrderID = ~<Order>~;
		LastRoll = ~<Roll>~;
		LastFrame = ~<Frame>~;
	}

	// Check to see if the user would like to wait for the film
	// to settle
	if ( <SettleTime> && <EndSettleTime> )
	{
		DeltaSettleTime = ( <EndSettleTime> - Ticks() );
		if ( <DeltaSettleTime> > 0 )
		{
			Sleep( <DeltaSettleTime> );
		}
	}

	// After all frame movement has completed check/setup for wait for next punch
	DoPunchWaitOverride = FALSE;

	if ( <AutoScan> && <FilmDriveEnabled> && ~<FDVendor>~ != ~Halse~ )
	{
		if ( <FilmDirection> == 0 )
		{
			NextPunchInc = <LastPosition>;
		}
		else
		{
			NextPunchInc = - <LastPosition>;
		}

		if ( !<DoPunchWaitOverride> )
		{
			ExpectedNextPunch = <ExpectedNextPunch> + <NextPunchInc>;
		}
		else
		{
			ExpectedNextPunch = atof( ~<CurrentPunchPosition>~ ) + <NextPunchInc>;
		}
		if ( <NextPunch> != <INVALID_PUNCH> )
		{
			DoPunchWaitOverride = TRUE;
		}
	}

	if ( !Defined( FilmDrive ) || !<FilmDriveEnabled> || <DisableFilmDrive> || ( !<ScanFromDataBase> && <Position> == 0 ) )
	{
		SizzleControl( Set,Punch,~<CurrentPunchPosition>~ );
		SizzleControl( Set,ScanFromDataBase,~<ScanFromDataBase>~ );
		dlg( GetInput );
		XOffset = DlgData( GetNumeric,TXOffsetPositionInUnits );
		YOffset = DlgData( GetNumeric,EYOffsetPositionInUnits );
		EYOffsetIncrementUnit = DlgData( GetNumeric,EYOffsetIncrementUnit );

		SizzleControl( Set,XOffset,~<XOffset>~ );
		SizzleControl( Set,YOffset,~<YOffset>~ );
		SizzleControl( Set,EYOffsetIncrementUnit,~<EYOffsetIncrementUnit>~);
		
		retval = FALSE;
		if ( <PositionForFocusNeeded> && !<gSkippingBlankFilm> )
		{
			retval = Halse_PositionForFocus( FALSE );
		}
		else
		{
			retval = ScanAnImage( ~<Volume>~,~<Order>~,~<Roll>~,~<Frame>~,~<$con.DlgData[FileExtension]>~,<TestScan>,<FocusBeforeScan>,<DoFrameToPunch> );
		}

		if ( <retval> && <AutoScan> && !<ScanFromDataBase> && <ScanFrameBeforeAdvance> )
		{
			ScanFrameBeforeAdvance = FALSE;
		}
		if ( !<retval> )
		{
			EnableScanningControls( TRUE );
			if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		}
		return <retval>;
	}
	return TRUE;
}


NUMERIC ScanAnImage( Volume,Order,Roll,CurrentFrame,Ext,TestScan,FocusBeforeScan,DoFrameToPunch )
{
	FilmDriveEnabled = DlgData( GetNumeric,FilmDriveEnabled );

	if ( !FindScanner(FALSE) )	
	{ 
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE; 
	}

	ClearFilmDriveOperationHandlers();

	if ( !OrderValid( ~<Order>~ ) )
	{ 
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE; 
	}

	if ( !DiskSpaceOK() )
	{ 
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE; 
	}

	if ( !ScanSizeOK( 2 ) )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	Frame = ~<CurrentFrame>~;
	// Override parameter with one set to punch number
	if ( <DoFrameToPunch> )
	{
		DlgData( Get,Frame,Frame );
	}

	FilmType = ~<$con.DlgData[FilmType]>~;
	SizzleControl( Set,FilmTermFile,~<FilmType>~ );

	CheckScanWidthLengthMin();

	ImagesPath = CreateImagePath( ~<Volume>~,~<Order>~,~<Roll>~,~<Frame>~,~<Ext>~ );

	ImagesPath = MakePath( ~<ImagesPath>~ );

	if ( !BroadcastMessageToAllViews( CanReleaseImage,~<ImagesPath>~ ) )
	{ 
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return Warning( Translate( ~Could not delete\n\n<ImagesPath>\n\nbecause it is still open in a job or layout.~ ) ); 
	}

	if ( !BroadcastMessageToAllViews( ReleaseImage,~<ImagesPath>~ ) )		
	{ 
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return Warning( Translate( ~Could not delete\n\n<ImagesPath>\n\nbecause it is still open in a job or layout.~ ) ); 
	}

	// DPT 03/12/01
	// Don't delete the image form disk if this is a test scan because this could cause an entry in the database
	// for this frame with no image on disk for it.
	if ( !<TestScan> )
	{
		if ( !Files( Delete,~<ImagesPath>~ ) )
		{
			// TBD - Temporary Commented out until I find a better
			// TBD - strategy to delete overlaping ImageCorrection Objects
			// TBD - The below statement somtimes gives an sharing violation
			// TBD - on faster machines
			// TBD return Warning( Translate( ~Could not delete <ImagesPath>.  <$Func.GetLastErrorMsg()>~ ) );
		}
	}

	SizzleControl( SetValues,PATH,~<ImagesPath>~,ORDER,~<Order>~,ROLL,~<Roll>~,FRAME,~<Frame>~ );
	EnableScanningControls( FALSE );
	//CloseWindowsOfDocument( ~<ImagesPath>~ );
	if ( !ScanOne(FALSE,<TestScan>,<FocusBeforeScan>) )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	return TRUE;
}


NUMERIC ValidateRange( Type,Range,LowValue,HighValue,Wrap )
{
	FieldName = <Type><Range>Field;

	dlg( GetControlValue,~<FieldName>~,Value );

	if ( ~<Value>~ == ~-~ )
	{
		if ( <LowValue> < 0 )
		{
			return TRUE;
		}
		else
		{
			 msg = ~Value must be greater than or equal to <LowValue>~;
			 dlg( PopupMsg,Translate( ~<msg>~ ) );
			 Action = STR ( SelectControl(~<FieldName>~) );
			 QueueContentsAfter( Action,1000 );
			 dlg( SetControlValue,~<FieldName>~,~<LowValue>~ );
			 return FALSE;
		}

	}

	origValue = Numeric( ~<Value>~ );

	if ( <origValue> < <LowValue> )
	{
		Value = <LowValue>;
	}
	if ( <origValue> > <HighValue> )
	{
		Value = <HighValue>;
	}

	Value = Pin( Numeric( ~<Value>~ ),<LowValue>,<HighValue> );
	if ( <origValue> != <Value> )
	{
		dlg( SetString,~<Value>~,<Type><Range> );
		if ( !<Wrap> )
		{
			return FALSE;
		}
	}

	if ( !<Wrap> )
	{
		if ( ~<Range>~ == ~Min~ )
		{
			dlg( GetControlValue,~<Type>MaxField~,upperRange );
			if ( Numeric( ~<upperRange>~ ) < <Value> )
			{
				dlg( SetControlValue,~<Type>MaxField~,<Value> );
				return FALSE;
			}
		}
		else
		{
			dlg( GetControlValue,~<Type>MinField~,lowerRange );

			if ( Numeric( ~<lowerRange>~ ) > <Value> )
			{
				dlg( SetControlValue,~<Type>MinField~,<Value> );
				return FALSE;
			}
		}
	}
	return TRUE;
}


// the min values were validated on entry. Do this for the max values.

NUMERIC ValidateRanges()
{
	if ( !ValidateRange( ~AvgDenR~,~Max~,0,4095,FALSE ) )
	{	
		msg = ~The max value for AvgDen Red has been adjusted.\nPlease verify your data ranges on the Color Tab.~;
		return Warning( Translate( ~<msg>~ ) );
	}
	if ( !ValidateRange( ~AvgDenG~,~Max~,0,4095,FALSE ) )
	{	
		msg = ~The max value for AvgDen Green has been adjusted.\nPlease verify your data ranges on the Color Tab.~;
		return Warning( Translate( ~<msg>~ ) );
	}
	if ( !ValidateRange( ~AvgDenB~,~Max~,0,4095,FALSE ) )
	{	
		msg = ~The max value for AvgDen Blue has been adjusted.\nPlease verify your data ranges on the Color Tab.~;
		return Warning( Translate( ~<msg>~ ) );
	}
	if ( !ValidateRange( ~AvgDenN~,~Max~,0,4095,FALSE ) )
	{	
		msg = ~The max value for AvgDen Neutral has been adjusted.\nPlease verify your data ranges on the Color Tab.~;
		return Warning( Translate( ~<msg>~ ) );
	}
	if ( !ValidateRange( ~AvgHue~,~Min~,1,120,TRUE ) )
	{	
		msg = ~The min value for Hue has been adjusted.\nPlease verify your data ranges on the Color Tab.~;
		return Warning( Translate( ~<msg>~ ) );
	}
	if ( !ValidateRange( ~AvgHue~,~Max~,1,120,TRUE ) )
	{	
		msg = ~The max value for Hue has been adjusted.\nPlease verify your data ranges on the Color Tab.~;
		return Warning( Translate( ~<msg>~ ) );
	}
	if ( !ValidateRange( ~AvgSat~,~Max~,0,200,FALSE ) )
	{	
		msg = ~The max value for Saturation has been adjusted.\nPlease verify your data ranges on the Color Tab.~;
		return Warning( Translate( ~<msg>~ ) );
	}

	if ( !DlgData(GetNumeric,AvgDenRGBKey) &&
		 !DlgData(GetNumeric,AvgDenNKey)   &&
		 !DlgData(GetNumeric,HueSatKey)	   &&
		 !DlgData(GetNumeric,SBAFleshKey)    )
	{
		msg = ~You have not selected a range key for sorting the images.\n\nDo you want to scan all the images without sorting?~;
		msg = ~<msg>\nIf not, please select No and check a range key on the Color Tab.~;
		if ( MessageBox( Translate( ~<msg>~ ),YESNO ) == NO )
		{ 
			return FALSE; 
		}
	}

	return TRUE;
}

NUMERIC DisplayStatusChoices( Type,x,y )
{
	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	Count = 0;

	GenCon( Choice<++Count>,New,DDMenuItemDef,AddTo,ListMenu,SetValues,
			Text,		~Clear &Path - forget the path to the image~,
			IDText,		~ID~ );

	ActionsText = ACTION Exec ( Update<Type>Images(Path,~''~,TRUE); );
	
	Choice<Count>( SetValuesFrom,ActionsText,ActionsText );

	GenCon( Choice<++Count>,New,DDMenuItemDef,AddTo,ListMenu,SetValues,
			Text,		~Set Order S&tatus - Update the status of the order~,
			IDText,		~ID~,
			ActionsText, ACTION Exec ( OnSetOrderStatus(); ) );

	dlg( DisplayMenu,ListMenu,<x>,<y> );

	return TRUE;
}


NUMERIC OrderValid( OrderID )
{
	if ( !Ado( dBase,Connect,GetValuesFor,~Select CustomerID, ScanSetup, FilmType From Orders Where ID = '<OrderID>'~,CustomerID, ScanSetup, FilmType ) )	
	{ 
		AddCustomerAndOrder();
		OrderScanSetup = ~~;
		OrderFilmType = ~~;
		return TRUE;
	}

	OrderScanSetup = ~<ScanSetup>~;
	OrderFilmType = ~<FilmType>~;

	dlg( SetString,~<CustomerID>~,CustomerID,0 );

	return TRUE;
}


VOID FlushErrorNotification( AddrOfSaveControl )
{
	dlg( SetStatus,0,Translate( ~An error occurred during save.~ ) );
	dlg( SetStatus,1,~~ );
	GenCon( SaveControl, Is, <AddrOfSaveControl>, TEMPORARY );
	HandleHR500Error( Translate( ~An error occurred saving the image to disk.~ ));

	DlgData( GetValues, Frame, CurrentFrame);
	SaveControl( GetValues, Frame, SaveFrame );
	if ( DlgData( GetNumeric,AutoScan ) && ~<CurrentFrame>~ != ~<SaveFrame>~ )
	{
		Scanner( CleanupLastScan,AddrOfSaveControl );
	}

	DisableControlsWhileSaving = FALSE;
	ScanButtonDisabled = FALSE;

	EnableScanningControls(TRUE);
	if ( Defined( FilmDrive ) && DlgData(GetNumeric,FilmDriveEnabled) )
	{
		SetTransportControlsStopped();
	}
}

VOID ImageFlushComplete( AddrOfFlushControl )
{
	HR500ImageFlushComplete( ~<AddrOfFlushControl>~ );
	dlg( SetStatus,1,Translate( ~~ ) );
}


VOID HR500ImageFlushComplete( Control )
{
	GenCon( ControlInfo, Is, ~<Control>~, TEMPORARY );
	SizzleControl( SetValues,TotalMatching,ControlInfo( GetNumeric,TotalMatching ) );

	SavedOrderID = ~<$con.ControlInfo[Order]>~;
	SavedRoll = ~<$con.ControlInfo[Roll]>~;
	SavedFrame = ~<$con.ControlInfo[Frame]>~;
	SavedPath = ~<$con.ControlInfo[Path]>~;
	FDAFailed = ~<$con.ControlInfo[frameStatus]>~;

	LightTime = (ControlInfo( GetNumeric,DataAvailableTime ) - ControlInfo( GetNumeric,ScanStartTime )) / 1000;
	FetchTime = (ControlInfo( GetNumeric,FetchCompleteTime ) - ControlInfo( GetNumeric,DataAvailableTime )) / 1000;
	FlushTime = (ControlInfo( GetNumeric,FlushCompleteTime ) - ControlInfo( GetNumeric,FetchCompleteTime )) / 1000;
	TotalTime = (ControlInfo( GetNumeric,FlushCompleteTime ) - ControlInfo( GetNumeric,ScanStartTime )) / 1000;
	EdgeCollectTime = (ControlInfo( GetNumeric,EdgeCollectCompleteTime ) - ControlInfo( GetNumeric,EdgeCollectStartTime )) / 1000;

	Log( Session,~Image <SavedPath> (<$con.ControlInfo[LastScanWidth]>x<$con.ControlInfo[LastScanHeight]>x<$con.ControlInfo[Depth]>)  On Disk. Light=<LightTime> Fetch=<FetchTime> Flush=<FlushTime> Total=<TotalTime> FrameDetect=<EdgeCollectTime> ~ );
	
	Actions = ACTION Doc ( ImagesDoc "AddImageToList( ~<SavedOrderID>~,~<SavedRoll>~,~<SavedFrame>~,~<SavedPath>~,<FDAFailed> );" );
	QueueContentsAfter( Actions,1000 );

	ScanButtonDisabled = FALSE;

	if ( <DisableControlsWhileSaving> )
	{
		DisableControlsWhileSaving = FALSE;
		EnableScanningControls( TRUE );
	}
	else
	{
		EnableScanningControls( <CurrentControlsState> );
	}
}


VOID RenderOverScanComplete( AddrOfFlushControl )
{
	GenCon( OverScanControl, Is, ~<AddrOfFlushControl>~, TEMPORARY );
	
	RenderTime = (OverScanControl( GetNumeric,RenderOverScanCompleteTime ) - OverScanControl( GetNumeric,RenderOverScanStartTime )) / 1000;

//	Log( Session,~OverScan Image Render time = <RenderTime> ~ );

	buffer = OverScanControl( GetNumeric,ImageBuffer );
	width  = OverScanControl( GetNumeric,ImageBufferWidth );
	height = OverScanControl( GetNumeric,ImageBufferHeight );
	if ( RunningVersion( 5.1 ) )
	{
		DlgData( Get,Frame,frameNumber );
	}
	else
	{
		DlgData( Get,CurrentPunchPosition,frameNumber );
	}
	frameNumber = atof( <frameNumber> );

//	if ( ~<FDVendor>~ == ~Halse~ &&
//		 !<RemoveAdjustFrameOnCompletion> )
//	{
		frameNumber = <frameNumber> + 1;
//	}

	if ( SizzleControl( GetNumeric,AdjustingNextFrame ) )
	{
//		frameNumber = <frameNumber> + 1;		LRAFD Only
		Msg = ~Error detecting next frame (# <frameNumber>)~;
		SizzleControl( SetValues,AdjustingNextFrame,FALSE );
	}
	else
	{
		Msg = ~Positioning current frame (# <frameNumber>)~;
	}

	if ( ~<FDVendor>~ == ~HR500AFD~ )
	{
		gMaxScannedFrame = <frameNumber> + 1;
	}

	Actions = ACTION Doc ( OverScanImage OpenOnce OverScanImage "OpenAsAnOverscanWindow( <buffer>,<width>,<height>,<frameNumber>,<gMaxScannedFrame>,~<Msg>~,~ImageSorter~,~<FDVendor>~,<gHR500AFD_FrameLengthError> );" );

	PerformActions( Actions );
}


VOID EnableScanningControls( value )
{
	if ( <IgnoreControlCommands> ) { return; }

	if ( <CurrentControlsState> != <value> )
	{
		dlg( EnableAllControls,<value>,<value> );
		CurrentControlsState = <value>;
	}

	if ( <KeepScanList> && <value> )
	{
		KeepScanList = FALSE;
	}

	GetFilmDriveVendor();
	if (FunctionDefined( ~<FDVendor>_SetupScanningControls~ ))
	{
		<FDVendor>_SetupScanningControls( <value> );
	}

	if ( DlgData( GetNumeric,AutoScan ) )
	{
		dlg( EnableControls,TRUE,AutoScanCheckBox,DisplayLastCheckBox );
		dlg( EnableControls,FALSE,ScanButton );
	}
	else if ( <ScanButtonDisabled> )
	{
		dlg( EnableControls,FALSE,ScanButton );
	}
	else
	{
		dlg( EnableControls,<value>,ScanButton );
	}

	if ( <DisableControlsWhileSaving> )
	{
		dlg( EnableControls,FALSE,PrevScanButton,NextScanButton );
	}
	else
	{
		dlg( EnableControls,<value>,NextScanButton );
		if (~<FDVendor>~ == ~HR500AFD~ )
		{
			dlg( EnableControls,FALSE,PrevScanButton );
		}
		else
		{
			dlg( EnableControls,<value>,PrevScanButton );
		}
	}

	if ( <AutoScanDeselectPending> && ( <CurrentControlsState> == TRUE ) )
	{
		AutoScanDeselectPending = FALSE;
		if ( ~<FDVendor>~ == ~HR500AFD~ )
		{
			if ( Scanner( IsNextFrameQueued ) )
			{
				dlg( GetStrings,Frame,Frame );
				++Frame;
				SetCurrentFrameNumber( FormatFrameNumber( ~<Frame>~ ) );
			}
		}
	}

	if ( DlgData(GetNumeric,FilmDriveEnabled) || ~<FDVendor>~ == ~None~ )
	{
		dlg( EnableControls,FALSE,VendorSetupComboBox );
	}
	else
	{
		dlg( EnableControls,<value>,VendorSetupComboBox );
	}

	EnableSequentialPunches( <value> );
	dlg( EnableControls,TRUE,SeeScannedImagesButton );
}


VOID ImageFetchComplete()
{
	SizzleControl( SetValues,WaitingForDisplay,TRUE );
	ScanTime = (SizzleControl( GetNumeric,FetchCompleteTime ) - SizzleControl( GetNumeric,ScanStartTime )) / 1000;

	NextFrameResetOnce = FALSE;

	dlg( GetInput );
	showOverScan = DlgData( GetNumeric,AdjustFramePosition );
	TestScan = SizzleControl( GetNumeric,TestScan );
	displayLastImage = SizzleControl( GetNumeric,DisplayLastImage );
	LogActivity = SizzleControl( GetNumeric,LogActivity );
	FilmDriveEnabled = DlgData(GetNumeric,FilmDriveEnabled);
	if ( <showOverScan> && !<TestScan> )
	{
		SizzleControl( SetValues,WaitingForOverScan,TRUE );
		HR500RenderOverScan();
	}
	else
	{
		showOverScan = FALSE;
	}

	SizzleControl( SetValues,Focus,0 );

	ThisPath = ~<$con.SizzleControl[Path]>~;

	dlg( GetInput );

// TBD - IF DO PUNCH WAIT OVERRIDE THEN YOU WILL NEED TO KEEP THE DIALOG DISABLED
	LastOrderID = ~<$con.SizzleControl[Order]>~;
	LastRoll = ~<$con.SizzleControl[Roll]>~;
	LastFrame = ~<$con.SizzleControl[Frame]>~;

	if ( !DlgData(GetNumeric,AutoScan) && !<showOverScan> )
	{
		EnableScanningControls(TRUE);
	}

	ImageCorrections( Free,~<ThisPath>~ );
	ImageCorrections( Free,~<LastPath>~ );

	HR500OpenScannedImage( ~<LastPath>~,~<ThisPath>~,<TestScan> );

	ImageCorrections( GetAndFreeWhenLastView,~<ThisPath>~ );	// NEED THIS TO RECEIVE CROP UPDATES

	LastPath = ~<ThisPath>~;

	if ( !<TestScan> )
	{
		dlg( SetStrings,Progress,~100~,LastScanTime,~<TotalTime>~,ScanCount,DlgData(GetNumeric,ScanCount) + 1 );

		if ( <LogActivity> )
		{
			dlg( SetStatus,0,~Image Scanned After <ScanTime> Seconds~ );
		}
		else
		{
			dlg( SetStatus,0,~Image Scan Completed~ );
		}

		rangeMatch = SizzleControl( GetNumeric,RangeMatch );

		if ( <rangeMatch> )
		{
			Dlg( EnableControls, FALSE, ScanButton );
			ScanButtonDisabled = TRUE;

			SizzleControl( SetValues,WaitingForDisplay,FALSE );
			if ( !<FilmDriveEnabled> || ~<FDVendor>~ != ~Halse~ )
			{
				ReadyForSave( TRUE );
			}
			else
			{
				ReadyForSave( FALSE );
			}

		}
		else
		{
			ScanButtonDisabled = FALSE;
			SizzleControl( SetValues,DirtyFlag,FALSE );
		}
	}
	else
	{
		ScanButtonDisabled = FALSE;
	}

	SizzleControl( SetValues,WaitingForDisplay,FALSE );
	DoAnotherScanViaIdleWait = FALSE;
	if ( FunctionDefined( ~<FDVendor>_NeedsAlignment~ ) )
		{	NeedsAligning = <FDVendor>_NeedsAlignment();	}
	else
		{	NeedsAligning = FALSE;	}
	IgnoreFdaErrors = DlgData( GetNumeric,IgnoreFdaErrors );
	FDAErrorOnPrevious = SizzleControl( GetNumeric,FDAErrorOnPrevious );

//	if ( !<TestScan> && 
//					((<gSkippedLastBlank> && !<gSkippingBlankFilm> && SizzleControl( GetNumeric,AutoSkipFDABlankFrame ) ) ||
//					 (<IgnoreFdaErrors> && <FDAErrorOnPrevious> && <NeedsAligning> )))
//	{
//			
//		if ( FunctionDefined( ~<FDVendor>_ClearAutoFlag~ ) )
//		{
//			<FDVendor>_ClearAutoFlag( TRUE );
//		}
//	}

	if ( DlgData(GetNumeric,AutoScan) )
	{
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> && <DoPunchWaitOverride> )
		{
			DoAnotherScanViaIdleWait = TRUE;
			Action = STR ( WaitingForFilmAdvanceComplete(); );
			QueueContentsAfter( Action,200 );
		}
		else
		{
			if (!ScanAgain() && !<showOverScan> )
			{
				EnableScanningControls(TRUE);
			}
		}
	}
	else
	{
		// We just deselected autoscan and we are waiting for the next queued frame
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> && <DoPunchWaitOverride> )
		{
			Action = STR ( WaitingForFilmAdvanceComplete(); );
			QueueContentsAfter( Action,200 );
		}
	}

	if ( !DlgData(GetNumeric,AutoScan) && <FilmDriveEnabled> &&
		 !<showOverScan> )
	{
			SetTransportControlsStopped();
	}

	if ( <TestScan> )
	{
		LastScanIsTestScan = TRUE;
		dlg( EnableControls,TRUE,AdjustScanAreaButton );
		if ( ~<FDVendor>~ == ~Halse~ || ~<FDVendor>~ == ~HR500AFD~ )
		{	dlg( EnableControls,TRUE,AdjustOverscanAreaButton );	}
	}
	else if ( !<DoAnotherScanViaIdleWait> )
	{
		LastScanIsTestScan = FALSE;
		dlg( EnableControls,FALSE,AdjustScanAreaButton );
		if ( ~<FDVendor>~ == ~Halse~ || ~<FDVendor>~ == ~HR500AFD~ )
		{	dlg( EnableControls,FALSE,AdjustOverscanAreaButton );	}
	}
	else
	{
		LastScanIsTestScan = FALSE;
	}
	//dlg( Update );
	
//	if ( !<TestScan> && 
//				((<gSkippedLastBlank> && !<gSkippingBlankFilm> && SizzleControl( GetNumeric,AutoSkipFDABlankFrame ) ) ||
//				 (<IgnoreFdaErrors> && <FDAErrorOnPrevious> && !SizzleControl( GetNumeric,FDAErrorOnCurrent ) && <NeedsAligning> )))
//	{
//		if ( FunctionDefined( ~<FDVendor>_HandleFastForward~ ) )
//		{
//			<FDVendor>_HandleFastForward();
//		}
//	}
}


VOID OnAutoScan()
{
	dlg( GetInput );

	if ( DlgData(GetNumeric,AutoScan) )
	{
		dlg( SetCheck,FALSE,DisableFilmDriveCheckBox );
		dlg( Save,DisableFilmDriveCheckBox );
		dlg( EnableControls,FALSE,ScanButton );
		ScanFrameBeforeAdvance = TRUE;
	}
	else
	{
		AutoScanDeselectPending = TRUE;
		dlg( EnableControls,<CurrentControlsState>,ScanButton );
	}

	GetFilmDriveVendor();

	if ( DlgData(GetNumeric,AutoScan) )
	{
		dlg( SetCheck, FALSE, AdjustFramePositionBox );
		OnAdjustFramePosition();
		dlg( EnableControls,FALSE,AdjustFramePositionBox );
	}
	else if ( Defined( FilmDrive ) && DlgData( GetNumeric,FilmDriveEnabled ) && ~<FDVendor>~ != ~HR500~ )
	{
		dlg( EnableControls,TRUE,AdjustFramePositionBox );
	}

	if ( FunctionDefined( ~<FDVendor>_SetupEdgeDetection~ ) )
	{
		<FDVendor>_SetupEdgeDetection();
	}
}


NUMERIC  ShowImageSorterSummaryWindow()
{
	dlg( GetInput,GetStrings,FilmType,FilmType );

	Query = ~Select * From ImageSorterSummary~;

	Actions = ACTION DOC ( ~ImageSorterSummary~ OpenOnce ImageSorterSummaryDoc "Init(~~,~<Query>~);" );
	
	return PerformActions( Actions );

	return TRUE;
}

NUMERIC CheckCalibrationAfterMag( DisplayMessage,DisplayStatus )
{
	calStatus = 0;
	ClearMagnificationHandlers();
	dlg( GetInput );
	FilmDriveEnabled = DlgData( GetNumeric,FilmDriveEnabled );
	ignoreTimeout = FALSE;
	calTimeout = 3;

	if ( <ignoreTimeout> )
	{	calTimeout = -1;	}

	userCalTimeout = 3;

	if ( !Scanner( NeedCalibration,<calTimeout>,calStatus,FALSE ) )
	{
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,Translate( ~You will have to calibrate the scanner.~ ) );
		}
		if ( <DisplayMessage> )
		{
			Msg = ~You will have to calibrate before performing this operation.~;
			Warning( Translate( ~<Msg>~ ) );
		}
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	if ( <calStatus> == 1 ) // not needed
	{
		if ( <DisplayStatus> || <DisplayMessage> )
		{
			dlg( SetStatus,0,~Calibration is not needed.~ );
		}
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return TRUE;
	}
	else if ( <calStatus> == 2  || (<calStatus> == 3 && <userCalTimeout> == 0) ||
			  <calStatus> == 4  || <calStatus> == 5 ) // cal needed
	{
		if ( <DisplayMessage> )
		{
			if ( MessageBox( Translate( ~You will have to recalibrate.  Are you ready to start the calibration now?~ ),YESNO ) != YES )
			{ 
				EnableScanningControls( TRUE );
				if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
				return FALSE; 
			}
		}
		if ( <DisplayStatus> )
		{
			dlg( SetStatus,0,~You will have to calibrate before scanning or focusing.~ );
			if ( !<DisplayMessage> )
			{	
				EnableScanningControls( TRUE );
				if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
				return FALSE;	
			}
		}
	}
	else if ( <calStatus> == 3 ) // cal restored
	{
		if ( <DisplayStatus> || <DisplayMessage> )
		{
			dlg( SetStatus,0,~Stored calibration values have been loaded.~ );
		}
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return TRUE;
	}

	if ( !AskIfFilmDriveDetensioned() )
	{
		Warning( Translate( ~The film drive is not detensioned.\n\nCalibration aborted.~ ) );
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}

	DlgData( Get,FilmType,FilmType );
	DlgData( Get,SFSFile,SFSFile );
	if ( ~<SFSFile>~ == ~~ )
	{
		SFSFile = ~<$App.ShareDirectory>\Scan\HR500\kcdfs.satdef~;
	}
	FilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<FilmType>.flt~;
	result = Scanner( IsColorFilterPositionCorrect,~<FilmTermsFile>~,~<FilmType>~,~<SFSFile>~ );
	if ( <result> == -1 )
	{
		ErrMsg = Translate( ~Could not find or load <FilmTermsFile>.~ );
		HandleHR500Error( ~<ErrMsg>~ );
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return FALSE;
	}
	if ( <result> == FALSE )
	{
		EnableScanningControls( TRUE );
		if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
		return Warning( Translate( ~The color filter is not in the correct position for this film type.\nMake sure the filter is in the correct position and then\nselect OK to continue.~ ) );
	}

	if ( MessageBox( Translate( ~Remove any film currently loaded and insert the calibration gate.\n\nPlease do not reload the film until calibration is complete.\n\nAre you ready to Calibrate?~),YESNO ) == YES )
	{ 
		EnableScanningControls( FALSE );
		Scanner( CalibrateAsync, SizzleControl );
		SecondsWaiting = 0;
		Action = STR ( StillCalibrating(FALSE); );
		QueueContentsAfter( Action,1000 );

		LastFilmType = ~<$con.DlgData[FilmType]>~;
		return TRUE;
	}
	Warning( Translate( ~The calibration gate not loaded.\n\nCalibration aborted.~ ) );
	FilmDriveEnabled = DlgData( GetNumeric,FilmDriveEnabled );
	EnableScanningControls( TRUE );
	if ( Defined( FilmDrive ) && <FilmDriveEnabled> ) { SetTransportControlsStopped(); }
	return FALSE;
}


VOID UpdateScanSetupsList(wantSelection)
{
	Query = ~Select Name From FTScanSetups Order By Name~;

	if ( !PGenConList( ScanSetupsList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ScanSetupsList( GetErrorDescription,0,theErr );
		Warning( Translate( ~Failed to query the FTScanSetups table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	ScanSetupsList( MakeStringList,ScanSetups,Name );

	dlg( SetControlFromStringList,ScanSetupsComboBox,ScanSetups,<wantSelection> ? ~Selection~ : ~NoSelection~ );
}


NUMERIC CheckFilmType( DoCalibration )
{
	FilmType = ~<$con.DlgData[FilmType]>~;
	Result = 0.0;
	retval = TRUE;
	if ( (~<FilmType>~ != ~<LastFilmType>~) )
	{
		if ( Defined( Scanner ) )
		{
			if ( (~<LastFilmType>~ != ~~) )
			{
				FilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<FilmType>.flt~;
				LastFilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<LastFilmType>.flt~;
				if ( Scanner( CheckForFilmClassChange,~<FilmTermsFile>~,~<LastFilmTermsFile>~,Result ) )
				{
					if ( <Result> == 1.0 )
					{
						retval = OnFormatChange( 2, ~Film type changed from positive to negative.~, FALSE, FALSE, <DoCalibration> );
					}
					else if ( <Result> == 2.0 )
					{
						retval = OnFormatChange( 2, ~Film type changed from negative to positive.~, FALSE, FALSE, <DoCalibration> );
					}
					else
					{
						dlg( SetStatus,0,~~ );
					}
				}
				else
				{
					dlg( SetStatus,0,~~ );
				}
			}
		}
		LastFilmType = ~<FilmType>~;
	}
	else
	{
		dlg( SetStatus,0,~~ );
	}

	return <retval>;
}


NUMERIC FilmTypeChange( )
{
	FilmType = ~<$con.DlgData[FilmType]>~;
	Result = 0.0;
	retval = FALSE;
	change = FALSE;
	if ( (~<FilmType>~ != ~<LastFilmType>~) )
	{
		if ( Defined( Scanner ) )
		{
			if ( (~<LastFilmType>~ != ~~) )
			{
				FilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<FilmType>.flt~;
				LastFilmTermsFile = ~<$App.ShareDirectory>\Scan\<$con.dlgData[ScannerType]>\FilmTerms\<LastFilmType>.flt~;
				retval = Scanner( CheckForFilmClassChange,~<FilmTermsFile>~,~<LastFilmTermsFile>~,Result );
				if ( <retval> )
				{
					if ( <Result> == 1.0 )
					{
						dlg( SetStatus,0,~Film type changed from positive to negative.~, FALSE, FALSE, TRUE );
					}
					else if ( <Result> == 2.0 )
					{
						dlg( SetStatus,0,~Film type changed from negative to positive.~, FALSE, FALSE, TRUE );
					}
				}
				else
				{
					dlg( SetStatus,0,~~ );
				}
			}
		}
		LastFilmType = ~<FilmType>~;
	}
	else
	{
		dlg( SetStatus,0,~~ );
	}

	return <retval>;
}


NUMERIC CloseDialog()
{
	dlg( GetInput );

	StillScanning = FALSE;

	if ( Defined( Scanner ) )
	{
		if ( Scanner( MagChanging ) )
		{
			Warning( Translate( ~Can't quit now ... Scanner is busy changing mag~ ) );
			dlg( SetDlgHandleActionsFlag, TRUE ) ;
			return FALSE;
		}
		if ( Scanner( Calibrating ) )
		{
			Warning( Translate( ~Can't quit now ... Scanner is busy calibrating~ ) );
			dlg( SetDlgHandleActionsFlag, TRUE ) ;
			return FALSE;
		}	
		
		StillScanning = Scanner( Scanning );	

	}

	if ( <StillScanning> )
	{
		Warning( Translate( ~Sorry, can't quit while the scanner is busy~ ) );
		dlg( SetDlgHandleActionsFlag, TRUE ) ;
		return FALSE;
	}

	if ( Defined( Scanner ) )
	{
		DirtyFlag = SizzleControl( GetNumeric,DirtyFlag );
		if ( <DirtyFlag> )
		{
			Msg = Translate( ~Previous scan has not been saved.  Do you want to save the scanned image before closing the dialog?~ );
			result = MessageBox( ~<Msg>~,YESNOCANCEL );
			if ( <result> == YES )
			{
				PerformActions( Action );
				OnSaveImageButton( TRUE );
				return FALSE;
			}
			else if ( <result> == NO )
			{
				if (CheckForSaveInProgress())
				{
					dlg( SetDlgHandleActionsFlag, TRUE ) ;
					return FALSE;
				}
			}
			else
			{
				dlg( SetDlgHandleActionsFlag, TRUE ) ;
				return FALSE;
			}
		}
		else
		{
			if (CheckForSaveInProgress())
			{
				dlg( SetDlgHandleActionsFlag, TRUE ) ;
				return FALSE;
			}
		}

		Scanner( CleanupLastScan, SizzleControl );
		CheckImageSorterCount();
	}

	if ( Defined( FilmDrive ) )
	{
		if (<gFilmDriveBusy> )
		{
			Warning( Translate( ~Sorry, can't quit while the film drive is moving film~ ) );
			dlg( SetDlgHandleActionsFlag, TRUE ) ;
			return FALSE;
		}
		return CloseFilmDrive( FALSE,TRUE );
	}
	else
	{
		ForgetGlobal( Scanner );

		ImageCorrections( Free,~<LastPath>~ );
		ForgetGlobal( ImageData );
		ForgetGlobal( AfdSetupData );
		ForgetGlobal( ScanErrorInfo );

		Sleep(300);
		dlg( END );
		Exit();
	}
	return FALSE;
}


NUMERIC CheckForSaveInProgress()
{
	if ( Scanner( SaveInProgress ) )
	{
		Msg = Translate( ~A scanned image is currently being saved.  Do you want to cancel the save operation?~ );

		if ( MessageBox( ~<Msg>~,YESNO ) == YES )
		{
			Scanner( CancelSave );
			dlg( SetStatus,1,Translate( ~~ ) );

			return FALSE;
		}
		else
		{
			return TRUE;
		}
	}
	else
	{
		return FALSE;
	}
}


NUMERIC ReOpen()
{
	dlg( SetWindowOrder,TopMost );	// NEEDS DEBUGGED
	return Warning( Translate( ~The HR500 Image Type Sorter is already active.~ ) );
}

NUMERIC HandleOrderIDReturnKey()
{
	dlg( GetInput,GetStrings,OrderID,Order );

	if ( ~<OrderID>~ == ~~ )
	{
		return FALSE;
	}

	if ( !ADO( dBase,Connect,GetValuesFor,~Select ID From Orders where ID = '<OrderID>'~,OrderID ) )
	{
		AddOrder();
	}
	return OnChangeOrderRollFrame( ~<ScannerModel>~,~<OrderID>~,~~,~~ );
}


NUMERIC OnChangeOrderRollFrame( Model,OrderID,Roll,Frame )	// HANDLES MESSAGE FROM OTHER WINDOW TO USE A PARTICULAR ORDER		
{
	if ( !Defined( ScannerModel ) )
	{
		Init( ~<Model>~ );
	}

	ChangeOrderRollFrame( ~<OrderID>~,~<Roll>~,~<Frame>~,TRUE,FALSE );

	return TRUE;
}


NUMERIC ChangeOrderRollFrame( NewOrderID,NewRoll,NewFrame,UpdateFlag,WarnDRGBError )	// HANDLES MESSAGE FROM OTHER WINDOW TO USE A PARTICULAR ORDER & ROLL		
{
	OrderID = ~<NewOrderID>~;
	Roll = ~<NewRoll>~;
	Frame = ~<NewFrame>~;

	if ( ~<Frame>~ == ~~ )
	{
		Frame = 1;
	}

	dlg( SetStrings,Order,~<OrderID>~,Roll,~<Roll>~,Frame,~<Frame>~ );

	OrderValid( ~<OrderID>~ );

	UpdateRollFrameCombos = FALSE;
	if ( IsNULL( ~<UpdateFlag>~ ) )
	{
		UpdateRollFrameCombos = TRUE;
	}
	else if ( !IsNULL( ~<UpdateFlag>~ ) )
	{
		if ( <UpdateFlag> )
		{
			UpdateRollFrameCombos = TRUE;
		}
	}

	if ( <UpdateRollFrameCombos> )
	{
		UpdateRollsCombo(TRUE);
		UpdateFrameField();
	}

	// Reget updated values
	dlg( GetInput,GetStrings,OrderID,Order,Roll,Roll,Frame,Frame );

	FilmFormat = ~~;

	GetFilmDriveVendor();
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate( ~Could not access the shared database. <theErr>~ ) );
	}

	if ( ~<FilmFormat>~ != ~~ && ~<FilmFormat>~ != ~<gCurrentFilmFormat>~ )
	{
		if ( !OnFormatChange( 3, ~Film format changed.~, FALSE, FALSE, FALSE ) )
		{
			return FALSE;
		}
	}

	return TRUE;
}


VOID RefreshPrinterQueueComboBox(wantSelection)
{
	Query = ~Select * From QueueDefinition~;

	if ( !PGenConList( QueueList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		QueueList( GetErrorDescription,0,theErr );
		Warning( Translate( ~Failed to query the QueueDefinition table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	QueueList( MakeStringList,PrinterQueues,QueueName );
	ProductQueueName = ~~;

	DlgData( GetValues,ProductID,ProductID );
	if ( ~<ProductID>~ != ~~ )
	{
		ProductLayoutPath = ~~; IsPackage = FALSE;
		
		if ( ADO( dBase,Connect ) )
		{
			if ( GetLayoutForProofProductID( dBase,~<ProductID>~,ProductLayoutPath,IsPackage ) )
			{
				if ( Document( Job,ParseFile,~<ProductLayoutPath>~ ) )
				{
					if ( Job( GetRenderList,0,RenderList ) )
					{
						if ( RenderList( GetOutputNode,OutputNode ) )
						{
							if ( !OutputNode( GetValues,~QueueName:~,ProductQueueName ) )
							{
								ProductQueueName = ~~;					
							}
						}
					}
				}
			}
		}
	}

	dlg( SetControlFromStringList,PrinterQueueComboBox,PrinterQueues,<wantSelection> ? ~Selection~ : ~NoSelection~ );
	if ( ~<ProductQueueName>~ != ~~ )
	{
		dlg( SelectString,PrinterQueueComboBox,~<ProductQueueName>~ );
	}
}


VOID RefreshProductComboBox(wantSelection)
{
	Query = ~Select * From Products Where Category = 'Proof' AND Package = 0 Order By Category,Sequence,ID~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Products table: <Query>. <theErr>~ );
	}

	Count = List( NumEntries );

	if ( !<Count> )
	{
		Warning( ~You don't have any proof products defined.  Create a proof product and put it in a category called Proof.~ ); 
		return;
	}

	DlgData( GetValues,ProductID,OldProductID );

	List( MakeStringList,ProofProducts,ID );

	dlg( SetControlFromStringList,ProductComboBox,ProofProducts,<wantSelection> ? ~Selection~ : ~NoSelection~ );

	if ( ~<OldProductID>~ != ~~ )
	{
		dlg( SelectString,ProductComboBox,~<OldProductID>~ );
	}

}


VOID RefreshControls()
{
	UpdateFilmTypesList();

	UpdateEditorXYOffsetSetting();
		
	SetupScannerParms();

	RefreshExposureProfilesComboBox(TRUE);

	RefreshScannerProfilesComboBox(TRUE);

	RefreshOuputProfilesComboBox(TRUE);

	OnFileTypeChange(TRUE);

	OnChangeProfilesEnabled();
	
	DlgData( GetValues,ProductID,OldProductID );
	RefreshProductComboBox(TRUE);
	DlgData( GetValues,ProductID,NewProductID );

	if ( ~<OldProductID>~ != ~<NewProductID>~ )
	{
		RefreshPrinterQueueComboBox(TRUE);
	}

	GetFilmDriveVendor();
	if ( ~<FDVendor>~ == ~Halse~ )
	{
		OnFrameRollNumbering();
	}
}


// TRANSPORT CONTROL METHODS

VOID HR500_NoFilmDriveSelected()
{
	// Restore the UI
	// Leave the other labels at their last setting

	// Disable any controls that don't apply
	dlg( SetCheck, FALSE, ContinueFrameNumCheckBox );
	dlg( SetCheck, FALSE, AutoIncRollNumbersCheckBox );
	dlg( SetCheck, FALSE, FocusEveryFrameCheckBox );
	dlg( SetCheck, FALSE, FrameToPunchCheckBox );
	dlg( SetCheck, FALSE, SequentialPunchesCheckBox );
	dlg( SetCheck, FALSE, UseAdjustedFramesCheckBox );
	dlg( SetCheck, FALSE, TwinCheckCheckBox );
	dlg( SetCheck, FALSE, AdjustFramePositionBox );
	dlg( SetCheck, FALSE, AutoSkipBlankFrameBox );
	dlg( SetCheck, FALSE, IgnoreFdaErrorsCheckBox );
	dlg( EnableControls,FALSE,EditFilmEditorsButton );
	dlg( EnableControls,FALSE,EditVendorButton );
	dlg( EnableControls,FALSE,EditorStaticText );
	dlg( EnableControls,FALSE,EditorComboBox );
	dlg( EnableControls,FALSE,EnableFilmDriveBox );
	dlg( EnableControls,FALSE,ViewFilmDriveControlsBox );
	dlg( EnableControls,FALSE,VendorSetupComboBox );
	dlg( EnableControls,FALSE,AdjustFramePositionBox );
	dlg( EnableControls,FALSE,AutoSkipBlankFrameBox );
	dlg( EnableControls,FALSE,EdgeSensitivityTextBox );
	dlg( EnableControls,FALSE,MinGapTextBox );
	dlg( EnableControls,FALSE,GetStripSensorStateButton );
	dlg( EnableControls,FALSE,UseAdjustedFramesCheckBox );
	dlg( EnableControls,FALSE,TwinCheckCheckBox );
	dlg( EnableControls,FALSE,SetFrameOverrideButton );
	dlg( EnableControls,FALSE,IgnoreFdaErrorsCheckBox );
	dlg( EnableControls,FALSE,FrameToPunchCheckBox,FrameToPunchPaddingField );
	dlg( EnableControls,FALSE,SequentialPunchesCheckBox );
	dlg( EnableControls,FALSE,FrameToPunchPaddingField );
	dlg( EnableControls,FALSE,VendorYOffsetStaticText );
	dlg( EnableControls,FALSE,VendorYOffsetTextBox );
	dlg( EnableControls,FALSE,VendorYOffsetClearButton );
	dlg( EnableControls,FALSE,VendorXOffsetStaticText );
	dlg( EnableControls,FALSE,VendorXOffsetTextBox );
	dlg( EnableControls,FALSE,VendorXOffsetClearButton );
	dlg( EnableControls,FALSE,VendorXOffsetZeroButton );
	dlg( EnableControls,FALSE,XSliderIFactorStaticText );
	dlg( EnableControls,FALSE,XSliderIFactorField );
	dlg( EnableControls,FALSE,DisableFrameDetectCheckbox );
	dlg( EnableControls,FALSE,GoToPunchNumberTextBox );
	dlg( EnableControls,FALSE,GoTo_Button );
	dlg( EnableControls,FALSE,EdgeSensitivityStaticText );
	dlg( EnableControls,FALSE,MinGapStaticText,MinGapLabel );
	dlg( EnableControls,FALSE,FixedAdvanceStaticText,FixedAdvanceLabel );
	dlg( EnableControls,FALSE,FixedAdvanceTextBox );

/*
	if ( RunningVersion( 5.1) )
	{
		dlg( EnableControls,FALSE,FdaSetupStaticText,FdaSetupComboBox,EditFdaButton );
	}
	else
	{
		dlg( EnableControls,FALSE,OverrideFrameButton,OverrideFrameTextBox);
	}
*/
	dlg( ShowControls,  TRUE,CutNegPromptCheckBox,PrevScanButton );
	dlg( EnableControls,TRUE,CutNegPromptCheckBox,PrevScanButton );

	dlg( EnableControls,FALSE,ContinueFrameNumCheckBox,AutoIncRollNumbersCheckBox,FocusEveryFrameCheckBox );

    SizzleControl( Set, PreScanNotification, ~~ );
    SizzleControl( Set, ScanCompleteNotification, ~~ );

	// Clear the overscan flag
	SizzleControl( SetValues, OverScan, FALSE);
	dlg( SetString,~~,StripSensorState );

	CurrentFormat = ~<$con.DlgData[Format]>~;

	// We are going to replace the following global variables
	ForgetGlobal( MagNames);
	ForgetGlobal( FullFrameWidths);
	ForgetGlobal( FullFrameHeights);
	ForgetGlobal( MinMagnifications);
	ForgetGlobal( MaxMagnifications);

	// Restore all the control strings
	StringList( OriginalFilmSizeChoices,New,InListOrder,AddStrings,~35mm~,~35mm_Slide~,~46mm~,~62mm_4.5x6~,~62mm_6x4.5~,~62mm_6x6~,~62mm_6x7~,~62mm_6x8~,~62mm_6x9~,~70mm~,~70mm_Unperfed~,~4x5~ );
	NewString( MagNames,Set,~Undefined,35mm,35mm_Slide,46mm,62mm_4.5x6,62mm_6x4.5,62mm_6x6,62mm_6x7,62mm_6x8,62mm_6x9,70mm,70mm_Unperfed,4x5~,Delimiters,~,~ );
	NewString( FullFrameWidths, Set, ~0,26,27,45,44,61,61,61,61,61,60,67,95.32~,Delimiters,~,~ );
	NewString( FullFrameHeights, Set, ~0,38,40,66,58,45,58,71,79,85,88,88,121~,Delimiters,~,~ );
	NewString( MinMagnifications,Set,~0,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5~,Delimiters,~,~ );
	NewString( MaxMagnifications,Set,~0,2.0,2.0,1.46,1.58,1.18,1.18,1.18,1.15,1.11,1.1,1.04,0.74~,Delimiters,~,~ );

	if ( Defined( Scanner ) )
	{
		if ( !<UniversalScanner> )
		{
			ForgetGlobal( MagNames);
			ForgetGlobal( FullFrameWidths);
			ForgetGlobal( FullFrameHeights);
			ForgetGlobal( MinMagnifications);
			ForgetGlobal( MaxMagnifications);

			StringList( OriginalFilmSizeChoices,New,InListOrder,AddStrings,~35mm~,~35mm_Slide~,~46mm~,~62mm_4.5x6~,~62mm_6x4.5~,~62mm_6x6~,~62mm_6x7~,~62mm_6x8~,~62mm_6x9~,~70mm~,~70mm_Unperfed~ );
			NewString( MagNames,Set,		~Undefined,35mm,35mm_Slide,46mm,62mm_4.5x6,62mm_6x4.5,62mm_6x6,62mm_6x7,62mm_6x8,62mm_6x9,70mm,70mm_Unperfed~,Delimiters,~,~ );
			NewString( FullFrameWidths, Set, ~0,26,27,45,44,61,61,61,61,61,60,67~,Delimiters,~,~ );
			NewString( FullFrameHeights, Set, ~0,38,40,66,58,45,58,71,79,85,88,88~,Delimiters,~,~ );
			NewString( MinMagnifications,Set,~0,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5~,Delimiters,~,~ );
			NewString( MaxMagnifications,Set,~0,2.0,2.0,1.46,1.58,1.18,1.18,1.18,1.15,1.11,1.1,1.04~,Delimiters,~,~ );

			if ( ~<CurrentFormat>~ == ~4x5~ )
			{
				Warning( Translate( ~The scanner is not configured to support the 4x5 film format.\nPlease select a different film format.~ ) );
			}
		}
	}
	// Reglobalize the control string variables
	Global( MagNames);

	Global( FullFrameWidths);
	Global( FullFrameHeights);
	Global( MinMagnifications);
	Global( MaxMagnifications);

	ChangeEnableSetOverscanArea( FALSE );
	//OnAllScanArea();
	MaxXIncrementsInInches = 30.00000;
	MaxXIncrementsInDisplayUnits = InchesTo<DisplayUnits>( <MaxXIncrementsInInches> );

	// Restore the film format selections - and current selection if possible
	dlg( SetControlFromStringList, ~FilmSizeChoices~, OriginalFilmSizeChoices, Update );
	dlg( SetControlFromStringList, ~FilmFormatComboBox~, OriginalFilmSizeChoices, Update );
	if ( ~<CurrentFormat>~ != ~~ )
	{
		dlg( SelectString,FilmFormatComboBox,~<CurrentFormat>~ );
	}

	dlg( GetInput );
	if ( ~<CurrentFormat>~ != ~<$con.DlgData[Format]>~ )
	{
		OnFormatChange(1, ~Film format changed.~, FALSE, TRUE, FALSE);
	}
	return;
}


VOID FilmDriveSelected()
{
	GetFilmDriveVendor();
	if ( FunctionDefined( ~<FDVendor>_FilmDriveSelected~ ) )
	{
		<FDVendor>_FilmDriveSelected( ~FTScanSetups~ );
	}
}


OptionalInclude( ~ScannerDocOverrides.txt~ );
NUMERIC Init( TheModel )
{
	if ( Defined( dlg ) )
	{
		if ( ~<TheModel>~ != ~<ScannerModel>~ )
		{
			return Warning( Translate(~Already scanning with the other scanner~) ) ;
		}

		return TRUE;
	}

	ScannerModel = ~<TheModel>~;

	Global( ScannerModel );

	WaitCursor( Begin );

	Version = 5.0;
	Global( Version );

	DisplayUnits = GetPreferredUnits();
	MaxXIncrementsInDisplayUnits = InchesTo<DisplayUnits>( <MaxXIncrementsInInches> );

	if ( DefinedAndNotNull( IgnoreFilmDirectionOnSort ) )
	{
		IgnoreFilmDirection = <IgnoreFilmDirectionOnSort>;
	}

	Tree( Location,~[STRINGS]~,Name,FilmSizeChoices,PluckAndFree );
	StringList:	Name ~FilmSizeChoices~
		Fields: String	~35mm~
		Fields: String	~35mm_Unperfed~
		Fields:	String	~46mm~
		Fields:	String	~46mm_Unperfed~
		Fields: String	~62mm_4.5x6~
		Fields: String	~62mm_6x4.5~
		Fields:	String	~62mm_6x6~
		Fields: String	~62mm_6x7~
		Fields: String	~62mm_6x8~
		Fields: String	~62mm_6x9~
		Fields: String	~Split_70mm~
		Fields:	String	~70mm~
		Fields:	String	~70mm_Unperfed~
		Fields:	String	~4x5~
	Hang:	FilmSizeChoices	~[STRINGS]~ ;

	Tree( Location,~[STRINGS]~,Name,ScanResolutionChoices,PluckAndFree );
	StringList:	Name ~ScanResolutionChoices~
		Fields: String	~LOW~
		Fields: String	~MEDIUM~
		Fields:	String	~HIGH~
	Hang:	ScanResolutionChoices	~[STRINGS]~ ;

	Tree( Location,~[STRINGS]~,Name,FilmDriveVendorList,PluckAndFree );
	StringList: Name FilmDriveVendorList
		Fields: String	~Cut Neg~
		Fields: String	~Long Roll~
//		if ( RunningVersion( 5.1 ) )
//		{
//			Fields: String	~Long Roll Auto Frame~
//		}
		Fields: String	~Strip~
	Hang:	FilmDriveVendorList	~[STRINGS]~ ;

	if ( !Tree( Name,HR500ScanErrorStrings,Location,~[STRINGS]~,Exists ) )
	{
		Define:	HR500ScanErrorStrings	USING DDSymbol AsSymbol HR500ScanErrorStrings
			Fields:	Value	~These strings are messages used by the HR500 Script.~
				Contains:
				{
					Define: LoadLibFailed	using DDText	Fields: Text ~Loading %1: %2~
				}
		Hang:	HR500ScanErrorStrings	~[STRINGS]~ ;

		StringList:	Name ~OutputFileTypes~
			Fields: String	~TIFF~
			Fields: String	~JPEG~
			Fields: String	~EXIF~
		Hang:	OutputFileTypes	~[STRINGS]~ ;

		StringList:	Name ~OutputFileExtensions~
			Fields: String	~.tif~
			Fields: String	~.jpg~
		Hang:	OutputFileExtensions	~[STRINGS]~ ;

		StringList:	Name ~VolumeChoices~
		Hang:	VolumeChoices	~[STRINGS]~ ;

		StringList: Name EditorVendorList
			Fields:	String	~Bremson~
			Fields:	String	~Hicks~
			Fields:	String	~Lucht~
		Hang:	EditorVendorList	~[STRINGS]~ ;
	}

	if (!Tree( Name,HR500FTScanErrorInfo,Location,~[GENCONS]~,Exists ) )
	{
		Dictionary:	DDHR500FTScanErrorInfo
			Fields:	Name APIErrorCode				Type long
			Fields:	Name ScannerErrorCode			Type long
			Fields:	Name Text						Type Text;

		Dictionary: DDHR500FTScannerImageData
			Fields:	Name ImageBuffer				Type long
			Fields:	Name ImageWidth					Type long
			Fields:	Name ImageHeight				Type long
			Fields:	Name ImageDepth					Type long
			Fields: Name ImageLayout				Type Text;


		Dictionary: DDHR500AFDFTSetupData
			Fields:	Name ExpectedLength				Type Double	Precision	6
			Fields:	Name LengthLowerBound			Type Double	Precision	6
			Fields:	Name LengthUpperBound			Type Double	Precision	6
			Fields:	Name MinimumLength				Type Double	Precision	6
			Fields:	Name MinimumGap					Type Double	Precision	6
			Fields: Name StopOnBlanks				Type long
			Fields: Name StopOnSplices				Type long
			Fields: Name StopOnSplitFrame			Type long
			Fields:	Name EdgeDebounce				Type Double	Precision	6;

		Dictionary: DDHR500FTScannerDialogData
			Fields:	Name Location					Type long
			Fields: Name GotoPunchNumber			Type Text
			Fields: Name OverrideFrameNumber		Type Text
			Fields: Name CurrentPunchPosition		Type Text
			Fields: Name xPos						Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name yPos						Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name Scanwidth					Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name Scanlength					Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name Depth						Type long LowValue 1	HighValue 3
			Fields: Name ScanAreaInPercent			Type long 

			Fields: Name OverScanXPos				Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name OverScanYPos				Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name OverScanwidth				Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name OverScanlength				Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100

			Fields:	Name ScanRotation				Type long
			Fields:	Name Icon						Type long
			Fields:	Name SaveFileType				Type Text
			Fields:	Name FileExtension				Type Text
			Fields:	Name JPEGQuality				Type long LowValue 0	HighValue 100
			Fields: Name MaxThumbNailSize			Type long
			Fields:	Name FileResolution				Type long
			Fields: Name ScannerType				Type Text
			Fields: Name ScanResolution				Type Text
			Fields: Name SpeedQuality				Type long   LowValue 0	HighValue 15
			Fields: Name OpticalZoom				Type Double	LowValue (-50.0)	HighValue 50.0
			Fields: Name ScanSizeWidthLength		Type Text
			Fields: Name ScanSizeField				Type Text
			Fields: Name Volume						Type Text
			Fields: Name AutoSaveToDisk				Type long
			Fields: Name CustomerID					Type Text
			Fields: Name Order						Type Text
			Fields: Name Roll						Type Text
			Fields: Name Frame						Type Text
			Fields: Name FetchCompleteNotification	Type Text
			Fields: Name FlushCompleteNotification	Type Text
			Fields: Name FlushErrorNotification		Type Text
			Fields: Name FocusProgressNotification	Type Text
			Fields: Name FocusCompleteNotification	Type Text
			Fields: Name Simulating					Type long
			Fields:	Name BackupFilesPath			Type Text
			Fields: Name DumpRawData				Type long
			Fields: Name FrameToPunch				Type long
			Fields: Name FrameToPunchPadding		Type long	LowValue 0	HighValue 5
			Fields: Name OmitRollInPath				Type long
			Fields: Name SequentialPunches			Type long
			Fields:	Name PathTemplate				Type Text
			Fields: Name UseAdjustedFrames			Type long
			Fields: Name TwinCheck					Type long
			Fields: Name AutoScanWrap				Type long
			Fields: Name TraceCalls					Type long
			Fields: Name TimeCalls					Type long
			Fields: Name FilmType					Type text
			Fields:	Name Punch						Type long

			Fields: Name FrameFormat				Type Text
			Fields: Name RollFormat					Type Text

			Fields: Name Progress					Type long
			Fields: Name DisplayLastImage			Type long

			Fields: Name AutoScan					Type long
			Fields: Name ScanFromDataBase			Type long
			Fields: Name CutNegPrompt				Type long

			Fields: Name SlopeLut					Type  Text
			Fields: Name SlopeLutFile				Type  Text

			Fields: Name ScannerProfileEnabled		Type Long
			Fields: Name ICCProfile					Type Text 

			Fields: Name OutputProfileEnabled		Type Long
			Fields: Name ICCOutputProfile			Type Text 

			Fields: Name EmbedProfile				Type Long

			Fields: Name DRGBProfile				Type Text 
			Fields: Name ReverseDRGBProfile			Type Text 
			Fields: Name DRGBProfileName			Type Text
			Fields: Name NULLProfile				Type Text
			Fields: Name DRGBRefs					Type Text

			Fields: Name TraceExposureDetermination Type Long

			Fields: Name CalibrationFile			Type Text
			Fields: Name CalibrationType			Type Text
			Fields: Name LutFile					Type Text
			Fields: Name ScanCount					Type long
			Fields: Name ScanSetup					Type Text
			Fields: Name LastScanTime				Type Double	Precision	6	Scale 2 LowValue 0
			Fields: Name LastScanFile				Type Text

			Fields: Name CropX						Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name CropY						Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name CropWidth					Type Double	Precision	6	Scale 2 LowValue 5	HighValue 100
			Fields: Name CropLength					Type Double	Precision	6	Scale 2 LowValue 5	HighValue 100

			Fields: Name Tension					Type long

			Fields: Name FilmDriveVendor			Type Text
			Fields: Name FilmDriveSetup				Type Text
			Fields: Name FilmDriveEnabled			Type long
			Fields:	Name Hr500FdaSetup				Type Text
			Fields:	Name ViewDriveControls			Type long

			Fields: Name TXOffsetPositionInUnits	Type long LowValue (-<MaxXIncrements>)	HighValue <MaxXIncrements>;
			Fields: Name TXOffsetPositionInInches	Type Text
			Fields: Name TXOffsetIncrementUnit		Type Double	Precision	1	Scale 6	LowValue 0	HighValue 1

			Fields: Name EXOffsetIncrementUnit		Type Double	Precision	1	Scale 6	LowValue 0	HighValue 1

			Fields: Name EYOffsetPositionInUnits	Type long LowValue (-<MaxYIncrements>)	HighValue <MaxYIncrements>;
			Fields: Name EYOffsetPositionInInches	Type Text
			Fields: Name EYOffsetIncrementUnit		Type Double	Precision	1	Scale 6	LowValue 0	HighValue 1

			Fields: Name FilmEditor					Type Text
			Fields: Name Format						Type Text
			Fields: Name FilmSize					Type Text

			Fields: Name XSliderPosition			Type long LowValue (-300)	HighValue 300
			Fields: Name XSliderPositionUI			Type Text
			Fields: Name XSliderIFactor				Type Double	Precision	12	Scale 12	LowValue 0	HighValue 762
			Fields: Name IgnoreXAdjustments			Type long
			Fields: Name IgnoreFdaErrors			Type long
			Fields: Name DisableFrameDetect			Type long

			Fields:	Name DisableFilmDrive			Type long
			Fields: Name AdjustFramePosition		Type long
			Fields: Name AutoSkipBlankFrame			Type long

			Fields: Name LogActivity				Type long

			Fields: Name FocusRange					Type long

			Fields: Name SharpenDelta				Type long

			Fields: Name LampHours					Type Text
			Fields: Name LampState					Type Text
			Fields: Name StripSensorState			Type Text

			Fields: Name EdgeSensitivity			Type long
			Fields: Name MinInterframeGap			Type Double Precision	12	Scale 12 LowValue 0 High Value 762
			Fields: Name ContinueFrameNumber		Type long
			Fields: Name AutoIncRollNumber			Type long
			Fields: Name FocusEveryFrame			Type long
			Fields: Name FixedNonFDAAdvance			Type Double	Precision	12	Scale 12 LowValue 0 High Value 762
			
			Fields: Name IgnorePredefinedFrameWidths Type long;
			Fields: Name CalibrationTimeout			Type long
			Fields: Name IgnoreCalTimeout			Type long

			Fields: Name ScansToSave				Type long LowValue (10) HighValue (9999)

			Fields:	Name AvgDenNKey					Type long
			Fields:	Name AvgDenNMin					Type long LowValue (0) HighValue (4095)
			Fields:	Name AvgDenNMax					Type long LowValue (0) HighValue (4095)

			Fields:	Name AvgDenRGBKey				Type long
			Fields:	Name AvgDenRMin					Type long LowValue (0) HighValue (4095)
			Fields:	Name AvgDenRMax					Type long LowValue (0) HighValue (4095)
			Fields:	Name AvgDenGMin					Type long LowValue (0) HighValue (4095)
			Fields:	Name AvgDenGMax					Type long LowValue (0) HighValue (4095)
			Fields:	Name AvgDenBMin					Type long LowValue (0) HighValue (4095)
			Fields:	Name AvgDenBMax					Type long LowValue (0) HighValue (4095)

			Fields:	Name HueSatKey					Type long
			Fields:	Name AvgHueMin					Type long LowValue (1) HighValue (120)
			Fields:	Name AvgHueMax					Type long LowValue (1) HighValue (120)
			Fields:	Name AvgSatMin					Type long LowValue (0) HighValue (200)
			Fields:	Name AvgSatMax					Type long LowValue (0) HighValue (200)

			Fields:	Name SBAFleshKey				Type long
			Fields:	Name SBAFleshMin				Type long LowValue (-999) HighValue (999)
			Fields:	Name SBAFleshMax				Type long LowValue (-999) HighValue (999)
			Fields:	Name SFSFile					Type Text

			Fields: Name QueueName					Type Text
			Fields: Name ProductID					Type Text;


		Dictionary:	DDHR500FTControlDict
			Fields: Name	xPos				Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name	yPos				Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name	Scanwidth			Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name	Scanlength			Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name	OpticalZoom			Type Double	LowValue (-50.0)	HighValue 50.0
			Fields: Name	ScanSize			Type Double LowValue    0.5	HighValue 2.0
			Fields:	Name	NextInfoAdjusted	Type long
			Fields:	Name	NextPunch			Type long
			Fields:	Name	NextXOffset			Type long
			Fields: Name	NextXPos			Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name	NextYPos			Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name	NextScanwidth		Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name	NextScanlength		Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name	Depth				Type long   LowValue 1	HighValue 3
			Fields: Name	ScanAreaInPercent	Type Double	Precision	6	Scale 2	

			Fields: Name	CropX				Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100
			Fields: Name	CropY				Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100
			Fields: Name	CropWidth			Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100
			Fields: Name	CropLength			Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100

			Fields: Name	ScannerSharpenAmount Type  long
			Fields: Name	SharpenDelta		Type  long
			Fields: Name	Rotation			Type  long
			Fields: Name	AutoBalance			Type  long
			Fields: Name	Focus				Type  long
			Fields: Name	FocusRange			Type  long
			Fields: Name	ColorCorrection		Type  long	// 1 means use old
			Fields: Name	DynamicRange		Type  long
			Fields: Name	Size				Type  long

			Fields:	Name	Punch				Type long
			Fields: Name	ScanFromDataBase	Type long

			Fields:	Name	SaveFileType		Type  Text
			Fields:	Name	FileExtension		Type  Text
			Fields:	Name	JPEGQuality			Type  long LowValue 0	HighValue 100

			Fields: Name	RenderComplete		 Type  long
			Fields: Name	SaveComplete		 Type  long
			Fields: Name	DatabaseUpdateComplete Type  long
			Fields: Name	DeleteScanObj		 Type  long
			Fields: Name	ScanObj				 Type  long
			Fields: Name	ScanObjIndex		 Type  long
			Fields: Name	SaveObjIndex		 Type  long
			Fields: Name	ImageBuffer			 Type  long
			Fields: Name	ImageBufferWidth	 Type  long
			Fields: Name	ImageBufferHeight	 Type  long
			Fields: Name	ImageBufferDepth	 Type  long
			Fields: Name	ImageBufferLayout	 Type  Text
			Fields: Name	FirstValidPixel		 Type  long
			Fields: Name	LastValidPixel		 Type  long

			Fields: Name	DisplayLastImage	Type   long
			Fields: Name	LockScannerOffsets	Type   long
			Fields: Name	DensityNormalization  Type   long
			Fields: Name	UseAnalyzerDRGBValues Type long
			Fields: Name	DirtyFlag			Type  long
			Fields: Name	AutoSaveToDisk		Type  long
			Fields: Name	redOverride			Type  long
			Fields: Name	greenOverride		Type  long
			Fields: Name	blueOverride		Type  long
			Fields: Name	contrastOverride	Type  long
			Fields: Name	brightnessOverride	Type  long 
			Fields: Name	UseImageOverrides	Type  long
			Fields: Name	UseDigitalIce		Type  long
			Fields: Name	DigitalIceType		Type  long
			Fields: Name	UseSBAPlus			Type  long

			Fields: Name	saDensity			Type  long
			Fields: Name	saRed				Type  long
			Fields: Name	saGreen				Type  long
			Fields: Name	saBlue				Type  long

			Fields: Name	dDensity			Type  long LowValue 0	HighValue 255
			Fields: Name	dRed				Type  long LowValue 0	HighValue 255
			Fields: Name	dGreen				Type  long LowValue 0	HighValue 255
			Fields: Name	dBlue				Type  long LowValue 0	HighValue 255

			Fields: Name	DRGBRef				Type Text

			Fields: Name	SBARedAdjust		Type  long 
			Fields: Name	SBAGreenAdjust		Type  long 
			Fields: Name	SBABlueAdjust		Type  long 
			Fields: Name	SBAFleshAdjust		Type  long
			Fields: Name	SbaR				Type  long 
			Fields: Name	SbaG				Type  long 
			Fields: Name	SbaB				Type  long 
			Fields: Name	SbaFlesh			Type  long
			Fields: Name	ForceSBA			Type  long
			Fields: Name	UsedSBA				Type  long

			Fields: Name	xferDenN			Type  long 
			Fields: Name	xferDenGM			Type  long 
			Fields: Name	xferDenI			Type  long 
			Fields: Name	AvgDenR				Type  long
			Fields: Name	AvgDenG				Type  long
			Fields: Name	AvgDenB				Type  long
			Fields: Name	AvgDenN				Type  long
			Fields: Name	unwtDenGM			Type  long 
			Fields: Name	unwtDenI			Type  long 
			Fields: Name	AvgHue				Type  long
			Fields: Name	AvgSat				Type  long
			Fields: Name	FilmTermFile		Type  Text
			Fields: Name	FilmTermPath		Type  Text

			Fields: Name	Order				Type  Text 
			Fields: Name	Roll				Type  Text 
			Fields: Name	Frame				Type  Text 
			Fields: Name	Path				Type  Text 
			Fields: Name	ICCProfile			Type  Text 
			Fields: Name	ScannerProfileEnabled Type Long
			Fields: Name	ICCOutputProfile	Type  Text
			Fields: Name	OutputProfileEnabled Type Long
			Fields: Name	EmbedProfile		Type Long
			Fields: Name	MaxThumbNailSize	Type  Long
			Fields: Name	FetchTimeout		Type  Long

			Fields: Name	XOffset					Type  Long
			Fields: Name	YOffset					Type  Double Precision 6
			Fields: Name	EYOffsetIncrementUnit	Type  Double Precision 2	Scale 6 LowValue 0	HighValue 1

			Fields: Name	RawImageBuffer		Type  long

			Fields: Name	FetchCompleteNotification	Type Text;
			Fields: Name	FlushCompleteNotification	Type Text;
			Fields: Name	FlushErrorNotification		Type Text;
			Fields: Name	FocusProgressNotification	Type Text;
			Fields: Name	FocusCompleteNotification	Type Text;
			Fields: Name	FocusErrorNotification		Type Text;
			Fields: Name	FocusWarningNotification	Type Text;
			Fields: Name	FocusCancelNotification		Type Text;
			Fields: Name	PreScanNotification			Type Text;
			Fields: Name	ScanCompleteNotification	Type Text;
			Fields: Name	ScanErrorNotification		Type Text;
			Fields: Name	FetchErrorNotification		Type Text;
			Fields: Name	FilmDriveAction				Type Text;
			Fields: Name	RenderOverScanError			Type Text;
			Fields: Name	RenderOverScanComplete		Type Text;
			Fields: Name	FrameDetectErrorNotification Type Text;
			Fields: Name	LoadCompleteNotification	Type Text;
			Fields: Name	UnloadCompleteNotification	Type Text;
			Fields: Name	SpliceDetectedNotification  Type Text;

			Fields: Name	AutoSkipFDABlankFrame		Type long;
			Fields: Name	FrameStatus					Type long;

			Fields: Name	SaveStartTime		Type long;
			Fields: Name	ScanStartTime		Type long;
			Fields: Name	DataAvailableTime	Type long;
			Fields: Name	EdgeCollectStartTime	Type long;
			Fields: Name	EdgeCollectCompleteTime	Type long;
			Fields: Name	FrameDetectStartTime	Type long;
			Fields: Name	FrameDetectCompleteTime	Type long;
			Fields: Name	FetchCompleteTime	Type long;
			Fields: Name	FlushCompleteTime	Type long;
			Fields: Name	RenderOverScanStartTime	Type long;
			Fields: Name	RenderOverScanCompleteTime	Type long;
			Fields: Name	DumpRawData			Type long 
			Fields: Name	DumpRawIRData		Type long 
			Fields: Name	TraceCalls			Type long 
			Fields: Name	TimeCalls			Type long 

			Fields: Name	LastScanX			Type long
			Fields: Name	LastScanY			Type long
			Fields: Name	LastScanWidth		Type long
			Fields: Name	LastScanHeight		Type long
			Fields: Name	LastPixelSumming	Type long
			Fields: Name	LastMagPosition		Type double

			Fields: Name	FullFrameWidth		Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100
			Fields: Name	FullFrameHeight		Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100

			Fields: Name	TestScan			Type long

			Fields: Name	OverScan			Type long
			Fields: Name	OverScanYPos		Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name	OverScanHeight		Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name	OverScanFrameHeight	Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100
			Fields: Name	OverScanXPos		Type Double	Precision	6	Scale 2 LowValue 2	HighValue 98
			Fields: Name	OverScanWidth		Type Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			Fields: Name	OverScanFrameWidth	Type Double	Precision	6	Scale 2	LowValue 0	HighValue 100
			Fields: Name	WaitingForOverScan	Type long
			Fields: Name	WaitingForDisplay	Type long
			Fields: Name	AdjustingNextFrame	Type long
			Fields: Name	FDAErrorOnPrevious	Type long
			Fields: Name	FDAErrorOnCurrent	Type long
			Fields: Name	AutoFDAErrorHandlingEnabled Type long
			Fields: Name	SavedAutoScanState			Type long
			Fields: Name	ImageSizeInMM				Type long
			Fields: Name	FilmEdge					Type long
			Fields: Name	NewStrip					Type long
			Fields: Name	FuzzyPositioningFactor		Type Double Precision 6
			Fields: Name	AlignmentFlag				Type long
			Fields: Name	FramePosition				Type Double Precision	6 
			Fields: Name	UseAdjustedFrames			Type long
			Fields: Name	TwinCheck					Type long
			Fields: Name	IgnoreFdaErrors				Type long
			Fields: Name	FilmDriveType				Type long

			Fields: Name	OverscanFilmType	Type long
			Fields: Name	EdgeSensitivity		Type long
			Fields: Name	MinGap				Type long
			Fields: Name	FilmPosition		Type Double Precision 6
			Fields: Name	FilmStatus			Type long
			Fields: Name	SkippingBlankFilm	Type long
			Fields: Name	DisableFrameDetect	Type long
			Fields: Name	LastMoveDirection	Type long

			Fields: Name	LogActivity			Type long

			Fields:	Name	FileResolution		Type long

			Fields: Name	AdaptiveSharpen		Type long
			Fields: Name	SharpenAmount		Type  Double	Precision	6	Scale 2 LowValue 0	HighValue 2000
			Fields: Name	SharpenFaster		Type long
			Fields: Name	SharpenLimit		Type long
			Fields: Name	SharpenThreshold	Type long
			Fields: Name	SharpenBlurAmount	Type long
			
			Fields: Name	NoiseReductionAmount Type  Double	Precision	6	Scale 2 LowValue 0	HighValue 100
			
			Fields: Name	ExposureTime		Type Double	Precision	6

			Fields: Name	SBALevel			Type long	LowValue 0			HighValue 6
			Fields: Name	CMM					Type long	LowValue 0			HighValue 200
			Fields: Name	PreferenceClass		Type long	LowValue (-1500)	HighValue 2500
			Fields: Name	PCWF				Type long	LowValue 0			HighValue 1500
			Fields:	Name	IgnoreSFS			Type long
			Fields:	Name	SFSFile				Type Text
			Fields:	Name	FilmType			Type Text
			Fields: Name	RescanningFrame		Type long

			Fields:	Name	StopOnSplices		Type long
			Fields:	Name	ExpectedFrameLength	Type long
			Fields:	Name	StopOnSplitFrames	Type long
			Fields: Name    StopOnBlanks        Type long

			Fields: Name	ScansToSave			Type long LowValue (10) HighValue (9999)

			Fields:	Name	AvgDenNKey			Type long
			Fields:	Name	AvgDenNMin			Type long LowValue (0) HighValue (4095)
			Fields:	Name	AvgDenNMax			Type long LowValue (0) HighValue (4095)

			Fields:	Name	AvgDenRGBKey		Type long
			Fields:	Name	AvgDenRMin			Type long LowValue (0) HighValue (4095)
			Fields:	Name	AvgDenRMax			Type long LowValue (0) HighValue (4095)
			Fields:	Name	AvgDenGMin			Type long LowValue (0) HighValue (4095)
			Fields:	Name	AvgDenGMax			Type long LowValue (0) HighValue (4095)
			Fields:	Name	AvgDenBMin			Type long LowValue (0) HighValue (4095)
			Fields:	Name	AvgDenBMax			Type long LowValue (0) HighValue (4095)

			Fields:	Name	HueSatKey			Type long
			Fields:	Name	AvgHueMin			Type long LowValue (1) HighValue (120)
			Fields:	Name	AvgHueMax			Type long LowValue (1) HighValue (120)
			Fields:	Name	AvgSatMin			Type long LowValue (0) HighValue (200)
			Fields:	Name	AvgSatMax			Type long LowValue (0) HighValue (200)


			Fields:	Name	SBAFleshKey			Type long
			Fields:	Name	SBAFleshMin			Type long LowValue (-999) HighValue (999)
			Fields:	Name	SBAFleshMax			Type long LowValue (-999) HighValue (999)

			Fields: Name	RangeMatch			Type long
			Fields: Name	TotalMatching		Type long
			Fields: Name	FTScanSetup			Type Text

			Fields: Name	EdgeDetectStatus	Type long
			Fields: Name	FrameEdgePosition	Type long
			Fields: Name	DetectedFrameLength	Type long
			Fields: Name	PrecedingGapLength	Type long
			;
	}

	NewString( ResolutionNames,	Set,~LOW,MEDIUM,HIGH~,Delimiters,~,~ );
	Global( ResolutionNames );
	NewString( Resolutions,		Set,~250,500,1000~,Delimiters,~,~ );
	Global( Resolutions );
	NewString( PixelSumming, Set, ~4,2,1~,Delimiters,~,~ );
	Global( PixelSumming );

	Tree( Location,~[GENCONS]~,Name,ScanErrorInfo,PluckAndFree );
	Define: ScanErrorInfo Using DDHR500FTScanErrorInfo 
			Fields: APIErrorCode			0
					ScannerErrorCode		0
					Text					~~
	Hang:	ScanErrorInfo	~[GENCONS]~ ;

	Define: ImageData Using DDHR500FTScannerImageData 
			Fields: ImageBuffer					0
					ImageWidth					0
					ImageHeight					0
					ImageDepth					0
					ImageLayout					~~
	;
	Global( ImageData );

	Define: AfdSetupData Using DDHR500AFDFTSetupData
			Fields:	ExpectedLength				0
					LengthLowerBound			0
					LengthUpperBound			0
					MinimumLength				0
					MinimumGap					0.006
					StopOnBlanks				0
					StopOnSplices				0
					StopOnSplitFrame			0
					EdgeDebounce				0.005
	;
	Global( AfdSetupData );

	Define: DlgData Using DDHR500FTScannerDialogData 
			Fields: Location					0
					xPos						50.
					yPos						50.
					ScanWidth					100.
					ScanLength					100.
					OverScanXPos				50.
					OverScanYPos				50.
					OverScanWidth				100.
					OverScanLength				100.
					ScanAreaInPercent			1
					FileResolution				250
					ScanResolution				250
					DisplayLastImage			TRUE
					ScanFromDataBase			FALSE
					JPEGQuality					100
					SaveFileType				~TIFF~
					FileExtension				~.tif~
					MaxThumbNailSize			500
					Format						~35mm~
					LutFile						~~
					ScannerProfileEnabled		1
					EmbedProfile				0
					TraceExposureDetermination  1
					CalibrationFile				~~
					CalibrationType				~All~
					FilmType					~Vericolor III VPS~
					Roll						~1~
					Frame						~001~
					Progress					0
					ScanCount					0
					LastScanTime				0 
					CropX						50.
					CropY						50.
					CropWidth					100.
					CropLength					100.
					Volume						~<$App.ShareDirectory>\OrderImages~
					FilmDriveVendor				~Cut Neg~
					SlopeLut					~SlopeLut~
					AutoSaveToDisk				TRUE
					CustomerID					~Lab~
					Order						~HR500 Image Type Sorter~
					FrameFormat					~<$[Symbols].FrameFormat[Value]>~
					RollFormat					~<$[Symbols].RollFormat[Value]>~
					ScannerType					~HR500~
					ScanSizeWidthLength			0
					ScanSizeField				0
					Punch						0

					TXOffsetPositionInUnits		0
					TXOffsetPositionInInches	~0.0"~
					TXOffsetIncrementUnit		0.

					EXOffsetIncrementUnit		0.

					EYOffsetPositionInUnits		0
					EYOffsetPositionInInches	~0.0"~
					EYOffsetIncrementUnit		0.
					
					XSliderIFactor				0

					IgnoreXAdjustments			0
					IgnoreFdaErrors				0
					DisableFilmDrive			0
					DumpRawData					0
					FrameToPunch				0
					FrameToPunchPadding			5
					OmitRollInPath				0
					PathTemplate				~~
					UseAdjustedFrames			0
					TwinCheck					0
					AutoScanWrap				0
					TraceCalls					0
					TimeCalls					0
					FocusRange					300
					DRGBProfile					~<$App.Directory>\Scan\Hr500\HR5v5.pf~
					ReverseDRGBProfile			~<$App.Directory>\Scan\Hr500\RevHR500Exp.pf~
					DRGBProfileName				~HR500 Exposure~
					LogActivity					0
					CutNegPrompt				1
					EdgeSensitivity				40.
					MinInterframeGap			0.
					IgnorePredefinedFrameWidths FALSE
					ContinueFrameNumber			0
					AutoIncRollNumber			0
					FocusEveryFrame				0
					FixedNonFDAAdvance			0

					CalibrationTimeout			3
					IgnoreCalTimeout			0

					SFSFile						~<$App.ShareDirectory>\Scan\HR500\kcdfs.satdef~
					BackupFilesPath				~<$App.Directory>\Scan\HR500~

					ScanRotation				0
					SpeedQuality				0
					OpticalZoom					0

					ScansToSave					100

					AvgDenNKey					0
					AvgDenNMin					1425
					AvgDenNMax					1450

					AvgDenRGBKey				0
					AvgDenRMin					1500
					AvgDenRMax					1550
					AvgDenGMin					1370
					AvgDenGMax					1420
					AvgDenBMin					1320
					AvgDenBMax					1370

					HueSatKey					0
					AvgHueMin					1
					AvgHueMax					120
					AvgSatMin					0
					AvgSatMax					200

					SBAFleshKey					0
					SBAFleshMin					(-999)
					SBAFleshMax					999

					QueueName					~~	
					ProductID					~~	

	;
	Global( DlgData );

	StatusBarText( Translate( ~Loading HR500 Image Type Sorter~ ) );

	SpeedQualityLowVal = DlgData(GetAttrInfo, SpeedQuality, LowValue);
	SpeedQualityHighVal = DlgData(GetAttrInfo, SpeedQuality, HighValue);

	DefineDialog();

	GenDlg( dlg,Definition,ScannerDlgDefinition,Data,DlgData,Document,$Doc.This,New,Temporary );
	Global( dlg );

	SetupSizzleControl();
	FrameNotInDB = TRUE;

	dlg( GetInput );

	// Forced to Cut Neg/No Film Drive
	<TheModel>_NoFilmDriveSelected();

	LoadSettings(~~, TRUE, FALSE, FALSE,TRUE,TRUE );
	UpdateScanSize( FALSE,FALSE,TRUE );
	SetupScannerParms();

	Action = STR ( UpdateRollsCombo(TRUE); );
	QueueContentsAfter( Action,500 );

	// TBD - remove ????? ResyncScanList();

	//WaitCursor( End );

	StatusBarText( Translate( ~HR500 Image Type Sorter is ready~ ) );

	//SizzleControl( Set,DumpRawData,1 );

	//HeapCheck( Statements ); // THIS FOR DEBUGGING ONLY

	return WaitCursor( End );
}

RefreshRoutine = STR ( OnDocumentRefresh(%ld) );

if ((~<$App.Name>~ !=~DP1.exe~) && (!GetUserPermissions( FilmTermEditing ) ))
{
	Warning( Translate( ~You don't have permission to run the HR500 Image Type Sorter.\nPlease see your administrator.~ ) );
	Exit();
}

if ( !Semaphore( HR500Sem,Create,1,1,HR500Scanner ) )
{
	Warning( ~You are currently using the HR500~ );
	Exit();
}

if ( !HR500Sem( Lock,5 ) )
{
	Warning( ~You are currently using the HR500~ );
	Exit();
}
//Init( ~HR500~ );
