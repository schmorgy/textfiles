//
// Export images Dialog
//
// This panel has been updated to custom LDP export
//
// $Id$
// Version 11th Nov 08 Initial version.
// Version 14th Nov 08 Force the case to upper for the LDP check.
ExportVersion = ~Version 14th November 2008~;

Include: ~GetFullLayout~;
Include: ~FormattingRoutines~;
Include: ~UtilityRoutines~;
Include: ~ExportCmds~;

if (RunningVersion(6.0))
{
	UsingText = 1;
}
else
{
	UsingText = 0;
}

////////////////////////// Configurable Constants ////////////////////////////
//
// The following are considered constants, but may be configured at
// install-time 

// Constants affecting the size and resolution of low-resolution thumbnails.
BravoThumbnailResolution = 75;
BravoThumbnailScaleFactor = 30;

// Queue for Bravo is hardwired when Bravo functionality is turned on.
// Multiple Bravo burners can run off this single shared queue.
BravoQueueName = ~Bravo II~;

/////////////////////////////////// Globals //////////////////////////////////

// BatchID to use if Bravo functionality is enabled.
BravoBatchID = UniquePrintBatchID();

// Simple state variable - keeps track of whether there are images for which
// "Export" has been pressed, but "Finalise" has not yet
BravoExportsPending = 0;

Remote = FALSE;

// Search for the first occurance of a given character in an input string
// when scanning right to left.
//
// Returns: index to the character matching or -1 if not found.
//          (N.B. indexing starts at 0 for the first character.)
//
NUMERIC StrRChr( InputString, TargetChar )
{
    Len = strlen( ~<InputString>~ );
    Loop = $Len-1;
    while ( <Loop> >= 0 )
    {
        substr( ~<InputString>~, <Loop>, 1, CompareChar );
        if ( ~<CompareChar>~ == ~<TargetChar>~ )
        {
             return $Loop;
        }
        Loop -= 1;
    }
    return -1;
}

// Helper function to extract the Roll portion of an image's pathname.
// This relies on the directory structure having Roll as the bottom-most
// folder name.
//
STR GetRollFromImagePath( ImagePath )
{
    Pos = StrRChr( ~<ImagePath>~, ~\~ );
    if ( $Pos < 0 )
    {
        return ~~;
    }
    substr( ~<ImagePath>~, 0, $Pos, TmpString );
    Pos = StrRChr( ~<TmpString>~, ~\~ );
    if ( $Pos < 0 )
    {
        return ~~;
    }
    substr( ~<TmpString>~, $Pos+1, strlen(~<TmpString>~)-$Pos-1, Roll );
    return ~<Roll>~;
}

// Helper function to extract the Roll from the images table based on the path.
//
STR GetRollFromImageTable( ImagePath )
{
    Query = ~select Roll From Images Where Path = '<ImagePath>'~;

    if ( !ADO( dBase,Connect,GetValuesFor,~<Query>~, Roll ) )
    {
	return ~None~;
    }
    return ~<Roll>~;
}

// Helper function: returns TRUE if the Bravo functionality is currently
// enabled.
NUMERIC IsBravoEnabled()
{
    return ( ~<$con.dlgData[BravoEnabled]>~ == ~0~ ) ? FALSE : TRUE;
}

Macros: ~Macros.txt~;

   Left = 5; Top = 5;		hGap = 5; vGap = 2;
    TextHeight = 20;        TextWidth = 110;  
	ButtonHeight = 20;		ButtonWidth = 100;		SmallButtonWidth = 60;
	StaticTextWidth = 65;	StaticTextHeight = 20;
	SmallStaticTextWidth = 50;
	PathTextWidth = 550;
    EditTextWidth = 250;	EditTextHeight = 20;
    ComboBoxWidth = 100;	ComboBoxHeight = 160;
	x = $Left;				y = $Top;


		
VOID DefineDialog( OrderID )
{
	if ( !DataDict( TheDictionary,Get,DDExportImagesv2 ) )
	{
		Dictionary: DDExportImagesv2
			Fields:	Name BatchID			Type Text	// Start of not saved in a setup
			Fields:	Name OrderID			Type Text	
			Fields:	Name Roll				Type Text	
			Fields:	Name Frame				Type Text
			Fields:	Name SubjectID			Type Text
			Fields:	Name OrderItemID		Type Long
			Fields:	Name OrderItemSequence	Type Long
			Fields: Name Testing			Type Long	// End of saved in a setup

			Fields:	Name Setup				Type Text
			Fields:	Name QueueName			Type Text
			Fields:	Name QueueStatus		Type Text
			Fields:	Name Width				Type double
			Fields:	Name Height				Type double
			Fields:	Name CropX				Type double
			Fields:	Name CropY				Type double
			Fields:	Name CropWidth			Type double
			Fields:	Name CropLength			Type double

			Fields:	Name ImageCropX			Type double
			Fields:	Name ImageCropY			Type double
			Fields:	Name ImageCropWidth		Type double
			Fields:	Name ImageCropHeight	Type double
			Fields:	Name OverrideImageCrop	Type long

			Fields:	Name ImageRotation			Type Long
			Fields:	Name OverrideImageRotation	Type Long

			Fields:	Name OutputDirectory	Type Text
			Fields:	Name SaveFileType		Type Text
			// SWMod Begin
			Fields: Name AddROESComments	Type Long
			// SWMod End

			Fields:	Name CompressionQuality Type long
			Fields:	Name MaxThumbNailSize	Type long
			Fields:	Name FileName			Type Text
			Fields:	Name FileNameOptions	Type Long
			Fields:	Name Extension			Type Text
			Fields:	Name Resolution			Type Long
			Fields: Name ScaleFactor		Type double
			Fields:	Name Flatten			Type Long
			Fields:	Name Rotation			Type Long
			Fields: Name AutoRotate			Type Long
			Fields: Name SizeOption			Type Long
			Fields:	Name Quality			Type Long
			Fields:	Name LutFile			Type Text
			Fields:	Name DefaultInputProfile Type Text
			Fields:	Name ICCProfile			Type Text
			Fields:	Name EmbedProfile		Type Long
			Fields:	Name WorkingSpaceProfile Type Text
			Fields:	Name ForceColorManagementOff Type Long
			Fields:	Name OutputProfileEnabled Type Long
			Fields:	Name ChooseProfiles Type Long
			Fields:	Name ColorMatrix		Type Text
			Fields: Name SharpenFast		Type Long
			Fields: Name SharpenValue		Type Long				Lowvalue 0 HighValue 2000
			Fields: Name AdaptiveSharpen	Type Long
			Fields: Name AdaptiveSharpenLimit Type Long				Lowvalue 10 HighValue 255
			Fields: Name AdaptiveSharpenThreshold Type Long			Lowvalue 0 HighValue 100
			Fields: Name AdaptiveSharpenBlur Type Long				Lowvalue 0 HighValue 100

			Fields: Name Density			Type Long				Lowvalue (-100) HighValue 100
			Fields: Name Red				Type Long				Lowvalue (-100) HighValue 100
			Fields: Name Green				Type Long				Lowvalue (-100) HighValue 100
			Fields: Name Blue				Type Long				Lowvalue (-100) HighValue 100
			Fields: Name Contrast			Type Long				Lowvalue (-100) HighValue 100
			Fields: Name Saturation			Type Long				Lowvalue (-100) HighValue 100
			Fields: Name XGamma				Type double				Lowvalue 0.3	HighValue 5.0
			Fields: Name Negative			Type Long			
			Fields: Name GrayScale			Type Long		
			
			Fields: Name IgnoreRejected		Type Long	

			Fields: Name UseFile			Type Text
			Fields: Name UseFileEnabled		Type Long

			Fields: Name ProcessAfter		Type Text
			Fields: Name ProcessAfterFile	Type Text

			Fields: Name RImageCDPath		Type Text
			Fields: Name RImageTemplate		Type Text
			Fields: Name RImageWriter		Type Text
			Fields: Name RImageEnabled		Type Long
			Fields: Name DeleteAfterRImage	Type Long
			Fields:	Name CDPathOptions		Type Long
			Fields: Name Units				Type Text

            Fields: Name BravoNumCopies     Type Long               Lowvalue (0) HighValue 99
            Fields: Name BravoOneRollPerCD  Type Long
            Fields: Name BravoEnabled       Type Long
            Fields: Name BravoQueue         Type Text

			Fields: Name Text1				Type Text
			Fields: Name BoldText1			Type Long
			Fields: Name ItalicText1		Type Long
			Fields: Name WordWrapText1		Type Long
			Fields: Name TextTranslucence1	Type Long				Lowvalue (0) HighValue 100
			Fields: Name TextColor1			Type Text
			Fields: Name ShadowColor1		Type Text
			Fields: Name HorzShadowOffset1	Type Long
			Fields: Name VertShadowOffset1	Type Long
			Fields: Name ShadowStrength1	Type Long
			Fields: Name ShadowBlur1		Type Long
			Fields: Name ShadowEnable1		Type Long
			Fields: Name Angle1				Type double
			Fields: Name TextXPercent1		Type double				// center of the text box, in percentage of the image
			Fields: Name TextYPercent1		Type double				// center of the text box, in percentage of the image
			Fields: Name TextWidthPercent1	Type double				// in percentage of the image, 100 = whole image
			Fields: Name TextHeightPercent1	Type double				// in percentage of the image, 100 = whole image
			Fields:	Name TextRotation1		Type Long
			Fields:	Name TextJustification1	Type Text
			Fields:	Name TextAlignment1		Type Text
			Fields: Name CharacterSet1		Type Text	
			Fields: Name Font1				Type Text	
			Fields: Name Text2				Type Text
			Fields: Name BoldText2			Type Long
			Fields: Name ItalicText2		Type Long
			Fields: Name WordWrapText2		Type Long
			Fields: Name TextTranslucence2	Type Long				Lowvalue (0) HighValue 100
			Fields: Name TextColor2			Type Text
			Fields: Name ShadowColor2		Type Text
			Fields: Name HorzShadowOffset2	Type Long
			Fields: Name VertShadowOffset2	Type Long
			Fields: Name ShadowStrength2	Type Long
			Fields: Name ShadowBlur2		Type Long
			Fields: Name ShadowEnable2		Type Long
			Fields: Name Angle2				Type double
			Fields: Name TextXPercent2		Type double				// center of the text box, in percentage of the image
			Fields: Name TextYPercent2		Type double				// center of the text box, in percentage of the image
			Fields: Name TextWidthPercent2	Type double				// in percentage of the image, 100 = whole image
			Fields: Name TextHeightPercent2	Type double				// in percentage of the image, 100 = whole image
			Fields:	Name TextRotation2		Type Long
			Fields:	Name TextJustification2	Type Text
			Fields:	Name TextAlignment2		Type Text
			Fields: Name CharacterSet2		Type Text	
			Fields: Name Font2				Type Text	
			StringList: Name ExportOrderImagesOrderList
			Hang:	ExportOrderImagesOrderList ~[STRINGS]~ ;
}


	// if you add fields here, add them in AddProshotsProxySetup.txt too 
	Define: DlgData Using DDExportImagesv2 
		Fields:	CropX			50
				CropY			50
				CropWidth		100
				CropLength		100
				ImageCropX		50
				ImageCropY		50
				ImageCropWidth	100
				ImageCropHeight	100
				OverrideImageCrop	0
				OverrideImageRotation 0
				ImageRotation	0
				SharpenFast		1
				XGamma			1.0
				Width			4
				Height			4
				Extension		~.tif~
				Resolution		72
				SaveFileType	~TIFF~
				MaxThumbNailSize 500
				CompressionQuality 100
				ScaleFactor		100
				OrderID			~<OrderID>~
				Units ~in.~
				RImageCDPath	~\~
				TextXPercent1		50
				TextYPercent1		50
				TextWidthPercent1	100
				TextHeightPercent1	100
				TextColor1			~0 255 255 255~
				TextTranslucence1	45
				ShadowColor1		~0 0 0 0~
				HorzShadowOffset1	4
				VertShadowOffset1	4
				ShadowStrength1		100
				ShadowBlur1			50
				ShadowEnable1		0
				CharacterSet1		Western
				TextJustification1  Center
				TextAlignment1		Center
				Font1				Arial
				Angle1				0.0
				TextXPercent2		50
				TextYPercent2		50
				TextWidthPercent2	100
				TextHeightPercent2	100
				TextColor2			~0 255 255 255~
				TextTranslucence2	45
				ShadowColor2		~0 0 0 0~
				HorzShadowOffset2	4
				VertShadowOffset2	4
				ShadowStrength2		100
				ShadowBlur2			50
				ShadowEnable2		0
				Angle2				0.0
				Font2				Arial
				TextJustification2  Center
				TextAlignment2		Center
				CharacterSet2		Western

                BravoEnabled        1
                BravoOneRollPerCD   0
                BravoNumCopies      1
                BravoQueue          ~<BravoQueueName>~

    Define: DlgDefinition Using DDWinDef
            Fields: Position		180 10 $DialogWidth $DialogHeight
                    Title			Translate( ~Export Images~ )
                    TypeName		~Dialog~
					StatusBar		~1 100~
					WantsMinimizeBox TRUE
					DropTypes		~Image~
					HACTIONSTEXT	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportSelectImages.htm" ) 
					DropActionsText	ACTION EXEC ( HandleDrop() )
                    OACTIONSTEXT	ACTION EXEC ( CloseDialog() ) ;

   Contains: InListOrder
    {
	    Define: OrderIDPrompt Using DDWinCtrlDef AsSymbol OrderIDPrompt 
            Fields: TypeName		StaticText
                    Text			Translate( ~Order~ )
					RightJustified	TRUE
                    Position		$x,$y,$StaticTextWidth,$StaticTextHeight

		Define: OrderIDField Using DDWinCtrlDef AsSymbol OrderIDField 
			Fields: TypeName		ComboBox  
					IActionsText	ACTIONS ( GetList(ExportOrderImagesOrderList) Get )
					DActionsText	ACTION EXEC ( OrderSelected() )
					OActionsText	ACTIONS ( Save )
					GenConName       THIS
					GenConField		~OrderID~
					Tooltip         ~Type one or more characters of an Order and press the down arrow or F4 to see orders that begin with those characters.  Press Enter to add a new order. ~
					Mask			~<$[DATABASE FieldTypes].OrderID[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].OrderID[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].OrderID[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].OrderID[DisallowedChars]>~
					WantReturnKey	~T~
					DropDownActionsText ACTION CALL ( FindOrdersLike(TRUE)  )
					ReturnKeyActionsText ACTION EXEC ( OnOrderCombo() )
					Position		OrderIDPrompt(GetRight,Position)+$hGap,OrderIDPrompt(GetTop,Position),<EditTextWidth>,<EditTextHeight>*10

		Define: ViewOrderDataButton Using DDWinCtrlDef AsSymbol ViewOrderDataButton 
            Fields: TypeName		Button
                    Text			Translate( ~?~ )
					Position		OrderIDField(GetRight,Position)+$hGap,OrderIDField(GetTop,Position),20,20
                    DActionsText	ACTION EXEC ( SeeOrder() ) 
                    Tooltip			Translate( ~See Order~ );

		Define: ViewOrderImagesButton Using DDWinCtrlDef AsSymbol ViewOrderImagesButton 
            Fields: TypeName		Button
                    Text			Translate( ~Images~ )
					Position		ViewOrderDataButton(GetRight,Position) + $hGap,ViewOrderDataButton(GetTop,Position),$SmallButtonWidth,$ButtonHeight
                    DActionsText	ACTION EXEC ( SeeFramesForOrder(TRUE) ) 
                    Tooltip			Translate( ~View the images for the selected order ~ );

		Define: AddImagesForOrderButton Using DDWinCtrlDef AsSymbol AddImagesForOrderButton 
            Fields: TypeName		Button
                    Text			Translate( ~Add~ )
					Position		ViewOrderImagesButton(GetRight,Position)+$hGap,ViewOrderImagesButton(GetTop,Position),$SmallButtonWidth,$ButtonHeight
                    DActionsText	ACTION EXEC ( AddImagesForOrder() ) 
                    Tooltip			Translate( ~Add all images on the order to the list of images to export~ );

		Define: IgnoreRejectedBox Using DDWinCtrlDef AsSymbol IgnoreRejectedBox 
            Fields: TypeName		CheckBox
                    Text			Translate( ~Ignore Rejected~ )
					Position		AddImagesForOrderButton(GetRight,Position)+$hGap,AddImagesForOrderButton(GetTop,Position),$ButtonWidth,$ButtonHeight
                    IActionsText	ACTIONS ( Get ) 
					DActionsText	ACTIONS ( Save ) 
					OActionsText	ACTIONS ( Save ) 
                    GenConName       THIS
                    GenConField		~IgnoreRejected~
                    Tooltip			Translate( ~If checked, the rejected images of the order or roll will not be added to the list of images to export~ );

	    Define: RollPrompt Using DDWinCtrlDef AsSymbol RollPrompt 
            Fields: TypeName		StaticText
                    Text			Translate( ~Roll~ )
					RightJustified	TRUE
                    Position		OrderIDPrompt(GetLeft,Position),OrderIDPrompt(GetBottom,Position) + $vGap,$StaticTextWidth,$StaticTextHeight

		Define: RollsCombolBox Using DDWinCtrlDef AsSymbol RollsCombolBox 
            Fields: TypeName		SComboBox  
                    Position		RollPrompt(GetRight,Position) + $hGap,RollPrompt(GetTop,Position),<EditTextWidth>,<EditTextHeight> * 10
					IActionsText	ACTIONS ( GetList(RollList) Get )
					DActionsText	ACTION EXEC ( NewRollSelected() )	
					OActionsText	ACTIONS ( Save )
					DropDownActionsText ACTION CALL ( UpdateRollsCombo(0)  )
					ReturnKeyActionsText ACTION EXEC ( NewRollSelected()  )
					Mask			~<$[DATABASE FieldTypes].Roll[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].Roll[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].Roll[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].Roll[DisallowedChars]>~
                    GenConName       THIS
                    GenConField		~Roll~
					IsTabStop		T
                    Tooltip         ~Select a roll~;

		Define: ViewRollDataButton Using DDWinCtrlDef AsSymbol ViewRollDataButton 
            Fields: TypeName		Button
                    Text			Translate( ~?~ )
					Position		RollsCombolBox(GetRight,Position)+$hGap,RollsCombolBox(GetTop,Position),20,20
                    DActionsText	ACTION EXEC ( SeeRollsForOrder() ) 
                    Tooltip			Translate( ~See the roll data for this order~ );

		Define: ViewRollImagesButton Using DDWinCtrlDef AsSymbol ViewRollImagesButton 
            Fields: TypeName		Button
                    Text			Translate( ~Images~ )
					Position		ViewRollDataButton(GetRight,Position) + $hGap,ViewRollDataButton(GetTop,Position),$SmallButtonWidth,$ButtonHeight
                    DActionsText	ACTION EXEC ( SeeFramesForRoll(TRUE) ) 
                    Tooltip			Translate( ~View the image(s) for the selected roll~ );

		Define: AddImagesForRollButton Using DDWinCtrlDef AsSymbol AddImagesForRollButton 
            Fields: TypeName		Button
                    Text			Translate( ~Add~ )
					Position		ViewRollImagesButton(GetRight,Position)+$hGap,ViewRollImagesButton(GetTop,Position),$SmallButtonWidth,$ButtonHeight
                    DActionsText	ACTION EXEC ( AddImagesForRoll() ) 
                    Tooltip			Translate( ~Add all image(s) on the roll to the list of images to export~ );

		IF 0
		{
			Define: FramePrompt Using DDWinCtrlDef AsSymbol FramePrompt 
				Fields: TypeName		StaticText
						Text			Translate( ~Frames~ )
						RightJustified	TRUE
						Position		RollPrompt(GetLeft,Position),RollPrompt(GetBottom,Position) + $vGap,$StaticTextWidth,$StaticTextHeight

			Define: FrameField Using DDWinCtrlDef AsSymbol FrameField 
				Fields: TypeName		EditText  
						Position		FramePrompt(GetRight,Position) + $hGap,FramePrompt(GetTop,Position),<EditTextWidth>,<EditTextHeight> 
						IActionsText	ACTIONS ( Get )
						DActionsText	ACTIONS ( Save  )
						OActionsText	ACTIONS ( Save )
						GenConName       THIS
						GenConField		~Frame~
						Tooltip         ~Starting frame number or blank to use the file name as the frame ID~;

			Define: ViewFrameDataButton Using DDWinCtrlDef AsSymbol ViewFrameDataButton 
				Fields: TypeName		Button
						Text			Translate( ~?~ )
						Position		FrameField(GetRight,Position)+$hGap,FrameField(GetTop,Position),20,20
						DActionsText	ACTION EXEC ( SeeFramesForOrder(FALSE) ) 
						Tooltip			Translate( ~See the roll data for this order~ );
		}

		Define: ExportSetupsText Using DDWinCtrlDef AsSymbol ExportSetupsText 
            Fields: TypeName		Button
                    Text			~Use Setup~
					DActionsText	ACTION EXEC ( OnUseSetupButton(TRUE, FALSE) )
					Tooltip			~Activate the selected export setup~
                    Position		RollPrompt(GetLeft,Position),RollPrompt(GetBottom,Position) + $vGap*6,$StaticTextWidth,$StaticTextHeight

	    Define: ExportSetupsComboBox Using DDWinCtrlDef AsSymbol ExportSetupsComboBox 
			Fields: TypeName        ComboBox  
					Position		ExportSetupsText(GetRight,Position) + $hGap,ExportSetupsText(GetTop,Position),<EditTextWidth>,<ComboBoxHeight>
					//IActionsText	ACTION EXEC ( UpdateSetupsList() )
					DropDownActionsText	ACTION EXEC ( UpdateSetupsList() )
					DActionsText	ACTIONS ( Save )
					OActionsText	ACTIONS ( Save )
					GenConName		THIS
					GenConField		~Setup~
					Mask			~<$[DATABASE FieldTypes].ScanSetupName[Mask]>~
					PromptChar		~<$[DATABASE FieldTypes].ScanSetupName[PromptChar]>~
					AllowedChars	~<$[DATABASE FieldTypes].ScanSetupName[AllowedChars]>~
					DisallowedChars ~<$[DATABASE FieldTypes].ScanSetupName[DisallowedChars]>~
					Tooltip			~Select the setup to use for export~

		Define: EditSetups_Button Using DDWinCtrlDef AsSymbol EditSetups_Button 
			Fields:	TypeName		Button
					Text			Translate( ~?~ )
					Position		ExportSetupsComboBox(GetRight,Position)+$hGap,ExportSetupsComboBox(GetTop,Position),
									20,<ButtonHeight>
					DActionsText	ACTION EXEC  ( OnEditSetups() ) 
					Tooltip			Translate( ~Edit the ExportSetups table~ );

		Define: SaveSetup_Button Using DDWinCtrlDef AsSymbol SaveSetup_Button 
			Fields:	TypeName		Button
					Text			Translate( ~Save~ )
					Position		EditSetups_Button(GetRight,Position) + $hGap,EditSetups_Button(GetTop,Position),$SmallButtonWidth,<ButtonHeight>
					DActionsText	ACTION EXEC ( OnSaveSetup() ) 
					Tooltip			Translate( ~Save the current settings in the ExportSetups table~ );

		Define: TabWindow Using DDWinCtrlDef AsSymbol TabWindow
			Fields: Position	ExportSetupsText(GetLeft,Position),ExportSetupsText(GetBottom,Position) + $vGap*10 $PathTextWidth+$ButtonWidth+80 250
					TypeName	TabCtrl
					Text		~TCS_HOTTRACK | TCS_MULTILINE | TCS_TOOLTIPS~
				Contains: InListOrder
				{
					TabIndex = 0;

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Images~
								TypeName		Tab
								Tooltip			~Select the images you wish to export~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Images.htm" )

						Contains: INLISTORDER
						{
							DefineImagesTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Bravo~
    							TypeName		Tab
								IsEnabled		F
								Tooltip			~Select options for writing a CD~
//								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_WriteCD.htm" )

						Contains: INLISTORDER
						{
							DefineBravoTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Format~
								TypeName		Tab
								Tooltip			~Define export characteristics~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Format.htm" )

						Contains: INLISTORDER
						{
							DefineFormatTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Size~
								TypeName		Tab
								Tooltip			~Define size characteristics~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Size.htm" )

						Contains: INLISTORDER
						{
							DefineSizeTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Adjust~
								TypeName		Tab
								Tooltip			~Select how to adjust the images~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Adjust.htm" )

						Contains: INLISTORDER
						{
							DefineAdjustTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}


					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Sharpen~
								TypeName		Tab
								Tooltip			~Select how much to sharpen the images~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Sharpen.htm" )

						Contains: INLISTORDER
						{
							DefineSharpenTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Convert~
								TypeName		Tab
								Tooltip			~Convert images to another color space~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Convert.htm" )

						Contains: INLISTORDER
						{
							DefineConvertTabControls($hGap+3,SaveSetup_Button(GetBottom,Position) + 55);
						}

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Color Manage~
								TypeName		Tab
								Tooltip			~Convert images to another color space~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_ColorManage.htm" )

						Contains: INLISTORDER
						{
							DefineColorManageTabControls($hGap+3,SaveSetup_Button(GetBottom,Position) + 55);
						}

						Define: Tab<++TabIndex> Using DDWinCtrlDef
							Fields: Text			~Add Text 1~
									TypeName		Tab
									IsEnabled		F
									Tooltip			~Select options for writing a CD~
									HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Text.htm" )

							Contains: INLISTORDER
							{
								DefineTextTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55,1);
							}

						Define: Tab<++TabIndex> Using DDWinCtrlDef
							Fields: Text			~Add Text 2~
									TypeName		Tab
									IsEnabled		F
									Tooltip			~Select options for writing a CD~
									HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Text.htm" )

							Contains: INLISTORDER
							{
								DefineTextTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55,2);
							}
					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Destination~
								TypeName		Tab
								Tooltip			~Select where to export the images to~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_Destination.htm" )

						Contains: INLISTORDER
						{
							DefineDestinationTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}

					Define: Tab<++TabIndex> Using DDWinCtrlDef
						Fields: Text			~Process After~
								TypeName		Tab
								Tooltip			~Specify processing to occur after the last image is written~
								HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_ProcessAfter.htm" )

						Contains: INLISTORDER
						{
							DefineProcessAfterTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
						}

						Define: Tab<++TabIndex> Using DDWinCtrlDef
							Fields: Text			~RImage~
									TypeName		Tab
									IsEnabled		F
									Tooltip			~Select options for writing a CD~
									HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "ExportImages_WriteCD.htm" )

							Contains: INLISTORDER
							{
								DefineCDTabControls($hGap,SaveSetup_Button(GetBottom,Position) + 55);
							}

				}

  
		DialogWidth = TabWindow(GetRight,Position) + ($hGap * 2);

		Define: ExplorerButton Using DDWinCtrlDef AsSymbol ExplorerButton 
            Fields: TypeName		Button
                    Text			Translate( ~Explorer~ )
					Position		($DialogWidth - (($ButtonWidth+$hGap) * 6))/2 TabWindow(GetBottom,Position)+$vGap*3,$ButtonWidth, $ButtonHeight
                    DActionsText	ACTION EXEC ( OnExplorerButton() ) 
					IsEnabled		T
                    Tooltip			Translate( ~Drag images from an explorer window to this dialog~ );

		Define: TestButton Using DDWinCtrlDef AsSymbol TestButton 
            Fields: TypeName		Button
                    Text			Translate( ~Test~ )
					Position		ExplorerButton(GetRight,Position)+$hGap,ExplorerButton(GetTop,Position),$ButtonWidth, $ButtonHeight
                    DActionsText	ACTION EXEC ( OnTestButton() ) 
					IsEnabled		T
                    Tooltip			Translate( ~See what your current selections look like on the first selected image.  If the control key is depressed, the job will be viewed as text.~ );

		Define: GoButton Using DDWinCtrlDef AsSymbol GoButton 
            Fields: TypeName		Button
                    Text			Translate( ~Export~ )
					Position		TestButton(GetRight,Position)+$hGap,TestButton(GetTop,Position),$ButtonWidth, $ButtonHeight
                    DActionsText	ACTION EXEC ( OnGoButton(TRUE) ) 
					IsEnabled		T
                    Tooltip			Translate( ~Generate jobs for flattening or exporting~ );

		Define: StopButton Using DDWinCtrlDef AsSymbol StopButton 
            Fields: TypeName		Button
                    Text			Translate( ~Stop~ )
					Position		GoButton(GetRight,Position)+$hGap,GoButton(GetTop,Position),$ButtonWidth, $ButtonHeight
                    DActionsText	ACTION EXEC ( OnStopButton() ) 
					IsEnabled		F
                    Tooltip			Translate( ~Stop Importing~ );

		Define: JobQueueButton Using DDWinCtrlDef AsSymbol JobQueueButton 
            Fields: TypeName		Button
                    Text			Translate( ~Job Queue~ )
					Position		StopButton(GetRight,Position)+$hGap,StopButton(GetTop,Position),$ButtonWidth, $ButtonHeight
                    DActionsText	ACTION EXEC ( OnJobQueueButton() ) 
                    Tooltip			Translate( ~View the jobs in queue~ );

		Define: OverAllHelpButton Using DDWinCtrlDef AsSymbol OverAllHelpButton
			Fields:	TypeName		Button
					Position		JobQueueButton(GetRight,Position)+$hGap,JobQueueButton(GetTop,Position),$ButtonWidth,$StaticTextHeight
					Text			~Help~
					DActionsText	ACTION EXEC ( OnOverAllHelpButton() )
					Tooltip			~Help for the entire dialog.  Press F1 for help with individual tabs~;

    };

	DialogHeight = JobQueueButton(GetBottom,Position) + $vGap + 35;

    DlgDefinition( Set,Position,~100 20 <DialogWidth> <DialogHeight>~ );
	if ( GenCon( PreviewOptions,GetFrom,PreviewOptions,~[GENCONS]~ ) )
	{
		PreviewOptions(GetValue,PreferredUnits,value);
		if (~<value>~ == ~Inches~)
		{
			value = ~in.~;
		}
		else if (~<value>~ == ~Centimeters~)
		{
			value = ~cm.~;
		}
		else if (~<value>~ == ~Millimeters~)
		{
			value = ~mm.~;
		}

		DlgData(SetValue,Units,~<value>~);
	}
	GenDlg( dlg,Definition,DlgDefinition,Data,DlgData,Document,$Doc.This,New,Temporary );
	dlg( EnableControls,FALSE,BravoQueueBox );
    Global( dlg,DlgDefinition,dlgData );
}

VOID DefineImagesTabControls(x,y)
{
	Define: ImagesListBox Using DDWinCtrlDef AsSymbol ImagesListBox
		Fields:	POSITION		$x+10,$y-5,$PathTextWidth+55,($EditTextHeight+1) * 10.0
				GENCONNAME		THIS
				GENCONFIELD		~ImagePath~
				AllowMultipleSelection	TRUE
				IACTIONSTEXT	ACTIONS ( Get )
				DACTIONSTEXT	ACTIONS ( Save "Exec(OnImageSelected();)"  )
				OACTIONSTEXT	ACTIONS ( Save )
				NoDuplicates	TRUE
				ToolTip			Translate( ~Drag images to export here from an explorer or an Order Images window~ )
				TYPENAME		ListBox ;

	Define: DeleteAllButton Using DDWinCtrlDef AsSymbol DeleteAllButton 
		Fields: TypeName		Button
				Text			Translate( ~Remove All~ )
				RightJustified	TRUE
				Position		ImagesListBox(GetRight,Position) + $hGap,$y,$ButtonWidth,$StaticTextHeight
				DActionsText	ACTION EXEC ( ForgetAllImages() ) 
				ToolTip			Translate( ~Remove all images from the list of images to export~ )

	Define: DeleteButton Using DDWinCtrlDef AsSymbol DeleteButton 
		Fields: TypeName		Button
				Text			Translate( ~Remove Selected~ )
				RightJustified	TRUE
				Position		DeleteAllButton(GetLeft,Position),DeleteAllButton(GetBottom,Position)+$vGap,$ButtonWidth,$StaticTextHeight
				DActionsText	ACTION EXEC ( ForgetSelectedImages() ) 
				ToolTip			Translate( ~Remove the selected images from the list of images to export~ )

	Define: OpenImageButton Using DDWinCtrlDef AsSymbol OpenImageButton 
		Fields: TypeName		Button
				Text			Translate( ~Open Selected~ )
				RightJustified	TRUE
				Position		DeleteButton(GetLeft,Position),DeleteButton(GetBottom,Position)+$vGap+5,$ButtonWidth,$StaticTextHeight
				DActionsText	ACTION EXEC ( OnOpenButton() ) 
				ToolTip			Translate( ~Open the selected images for viewing~ )

	Define: CloseAllButton Using DDWinCtrlDef AsSymbol CloseAllButton 
		Fields: TypeName		Button
				Text			Translate( ~Close All~ )
				RightJustified	TRUE
				Position		OpenImageButton(GetLeft,Position),OpenImageButton(GetBottom,Position)+$vGap,$ButtonWidth,$StaticTextHeight
				DActionsText	ACTION EXEC ( CloseAllOpenImages() ) 
				ToolTip			Translate( ~Close all image windows~ )
}



VOID DefineFormatTabControls(x,y)
{
	Define: FlattenBox Using DDWinCtrlDef AsSymbol FlattenBox
		Fields: TypeName		RadioButton  
				Position		$x+10,$y,600,$StaticTextHeight
				IActionsText	~[Get]~
				DActionsText	~[
									UnCheckButton(ExportBox) 
									CheckButton(FlattenBox)
									"Exec(OnFlatten();)"
								 ]~
				OActionsText	~[Save]~
				GenConName		THIS
				GenConField		~Flatten~
				RadioTrueValue	~1~
 				Text			Translate(~Flatten the images by applying stored corrections (density,color,etc) to the original image and clear the corrections.~)
				Tooltip			~Useful before archiving your images to tape or if another system will read them~;

	Define: ExportBox Using DDWinCtrlDef AsSymbol ExportBox
		Fields: TypeName		RadioButton  
				Position		FlattenBox(GetLeft,Position),FlattenBox(GetBottom,Position)+$vGap,FlattenBox(GetWidth,Position),$StaticTextHeight
				IActionsText	~[Get]~
				DActionsText	~[
									UnCheckButton(FlattenBox) 
									CheckButton(ExportBox)
									"Exec(OnFlatten();)"
								 ]~
				OActionsText	~[Save]~
				GenConName		THIS
				GenConField		~Flatten~
				RadioTrueValue	~0~
 				Text			Translate(~Export new images files with corrections (density,color,etc.) using either the specified settings or the following layout~)
				Tooltip			~Useful for sending images to another system.~;


	Define: UsePrompt Using DDWinCtrlDef AsSymbol UsePrompt
		Fields:	TypeName		StaticText
				Text			~Use Layout~
				RightJustified	TRUE
				Position		$x,ExportBox(GetBottom,Position) + $vGap*8,$StaticTextWidth,$StaticTextHeight

	Define: UseFileField Using DDWinCtrlDef AsSymbol UseFileField
		Fields:	TypeName EditText
				Position UsePrompt(GetRight,Position)+$hGap,UsePrompt(GetTop,Position),$PathTextWidth-50,$StaticTextHeight
				GenConName THIS
				GenConField ~UseFile~
				IActionsText ~[Get]~
				DActionsText ~[Save]~
				OActionsText ~[Save]~
				Tooltip ~Select a layout to define the format of the exported images~;

	Define: UseFileBrowseButton Using DDWinCtrlDef AsSymbol UseFileBrowseButton 
		Fields: TypeName		Button
				Text			Translate( ~?~ )
				Position		UseFileField(GetRight,Position)+$hGap,UseFileField(GetTop,Position),20,20
				DActionsText	ACTION EXEC ( BrowseForUseFile() ) 
				Tooltip			Translate( ~Select a layout to define the format of the exported images~ );

	Define: OpenUseFileButton Using DDWinCtrlDef AsSymbol OpenUseFileButton 
		Fields: TypeName		Button
				Text			Translate( ~Open~ )
				Position		UseFileBrowseButton(GetRight,Position)+$hGap,UseFileBrowseButton(GetTop,Position),50,20
				DActionsText	ACTION EXEC ( OpenUseFile(~~) ) 
				Tooltip			Translate( ~Open the layout you have selected~ );

	Define: UseFileEnabledCheckBox Using DDWinCtrlDef AsSymbol UseFileEnabledCheckBox
		fields:	TypeName		Checkbox
				Position		OpenUseFileButton(GetRight,Position) + $hGap OpenUseFileButton(GetTop,Position) 60 , $StaticTextHeight
				GenConField		~UseFileEnabled~
				GenConName		This
				Text			~Enabled~
				IActionsText	ACTIONS ( Get )
				DACTIONSTEXT	ACTION EXEC ( OnUseFileCheckBox() )
				OActionsText	ACTIONS ( Save )
				Tooltip			~If checked, the preceding layout is used to define how to write the image(s).  Otherwise, the settings in this dialog determine how to write the image(s).~;


	Define: FileTypeStaticText Using DDWinCtrlDef AsSymbol FileTypeStaticText
		fields:	TypeName StaticText
				Text ~File Type:~
				RightJustified TRUE
				Position UsePrompt(GetLeft,Position),UsePrompt(GetBottom,Position)+$vGap*8,$StaticTextWidth,$StaticTextHeight

	Define: FileTypeComboBox Using DDWinCtrlDef AsSymbol FileTypeComboBox
		fields: TypeName SComboBox  
				Position FileTypeStaticText(GetRight,Position)+$hGap,FileTypeStaticText(GetTop,Position),$StaticTextWidth*2,$StaticTextHeight*9
				IActionsText ~[GetList(SaveImageFileTypeChoices) Get]~
				DActionsText ACTIONS ( Save Exec("OnFileTypeChange(TRUE)") )
				OActionsText ACTIONS ( Save )
				GenConName THIS
				GenConField ~SaveFileType~
				Tooltip ~Select a file type~;

	Define: PreviewSizePrompt Using DDWinCtrlDef AsSymbol PreviewSizePrompt
		fields:	TypeName StaticText
				Text ~Max size of the longest side for the preview image (pixels)~
				RightJustified TRUE
				IsEnabled F
				Position FileTypeComboBox(GetRight,Position)+$hGap,FileTypeComboBox(GetTop,Position)+2,$StaticTextWidth*4.5,$StaticTextHeight

	Define: PreviewSizeField Using DDWinCtrlDef AsSymbol PreviewSizeField
		Fields:	TypeName MaskedEditText
				Position PreviewSizePrompt(GetRight,Position)+$hGap,PreviewSizePrompt(GetTop,Position)-2,$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~MaxThumbNailSize~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~####~
				PromptChar	 ~ ~		
				IsEnabled		F
				Tooltip ~Enter the size in pixels of the longest side~;

	Define: CompressionQualityPrompt Using DDWinCtrlDef AsSymbol CompressionQualityPrompt
		fields:	TypeName StaticText
				Text ~Compression Quality~
				RightJustified TRUE
				IsEnabled F
				Position PreviewSizeField(GetRight,Position)+$hGap,PreviewSizePrompt(GetTop,Position),100,$StaticTextHeight

	Define: CompressionQualityField Using DDWinCtrlDef AsSymbol CompressionQualityField
		Fields:	TypeName MaskedEditText
				Position CompressionQualityPrompt(GetRight,Position)+$hGap,CompressionQualityPrompt(GetTop,Position)-2,50,$StaticTextHeight
				GenConName THIS
				GenConField ~CompressionQuality~
				IActionsText ~[Get]~
				DActionsText ~[Save]~
				OActionsText ~[Save]~
				Mask		 ~###~
				PromptChar	 ~ ~		
				IsEnabled		F
				Tooltip ~Enter quality value between 0 and 100.   0 = not used.   1 = extremely low quality (very high compression).  100 = very high quality ( low compression). ~;

			
	Define: ExtensionPrompt Using DDWinCtrlDef AsSymbol ExtensionPrompt
		fields:	TypeName StaticText
				Text ~Extension~
				RightJustified TRUE
				Position FileTypeStaticText(GetLeft,Position),FileTypeStaticText(GetBottom,Position)+$vGap,$StaticTextWidth,$StaticTextHeight

	Define: ExtensionField Using DDWinCtrlDef AsSymbol ExtensionField
		Fields:	TypeName MaskedEditText
				Position ExtensionPrompt(GetRight,Position)+$hGap,ExtensionPrompt(GetTop,Position)-2,$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~Extension~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~%%%%%%%%~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the file extension to append to the file name~;

	Define: ExtensionWarning Using DDWinCtrlDef AsSymbol ExtensionWarning
		fields:	TypeName		StaticText
				Text			~Should be blank if the filename in the destination tab provides the extension~
				LeftJustified	TRUE
				Position ExtensionField(GetRight,Position)+5,ExtensionPrompt(GetTop,Position)+2,400,$StaticTextHeight

// SWMod Begin
	Define: AddROESCommentsCheckBox Using DDWinCtrlDef AsSymbol AddROESCommentsCheckBox
		fields:	TypeName		Checkbox
				Position 		25,ExtensionPrompt(GetBottom,Position)+$vGap,150,$StaticTextHeight
				GenConField		~AddROESComments~
				GenConName		This
				Text			~Add ROES Comments~
				IActionsText	ACTIONS ( Get )
				OActionsText	ACTIONS ( Save )
				Tooltip			~If checked, the ROES comment information will be added to the exported images files.~;
// SWMod End
}



VOID DefineSizeTabControls(x,y)
{
	Define: RotationPrompt Using DDWinCtrlDef AsSymbol RotationPrompt
		Fields:	TypeName		StaticText
				Text			~Rotation~
				RightJustified	TRUE
				Position		$x,$y,$StaticTextWidth,$StaticTextHeight

	Define: RotationComboBox Using DDWinCtrlDef AsSymbol RotationComboBox 
        Fields: TypeName		SComboBox  
                Position		RotationPrompt(Getright,Position) + $hGap,
								RotationPrompt(GetTop,Position),<SmallStaticTextWidth>, <ComboBoxHeight> 
                IActionsText    ~[GetList(SaveImageRotationChoices) Get]~
                OActionsText    ~[Save]~
                GenConField		~Rotation~
                GenConName		THIS
				IActionsText	ACTIONS ( GetList(SaveImageRotationChoices) GET )
				DActionsText	ACTIONS ( SAVE )
				OActionsText	ACTIONS ( SAVE )
                Tooltip			~Select the amount to rotate the image by when it is exported~ ;

	Define: AutoRotateRadioButton90 Using DDWinCtrlDef AsSymbol AutoRotateRadioButton90 
		Fields: TypeName		RadioButton  
				Position		RotationComboBox(Getright,Position) + $hGap*5,
								RotationComboBox(GetTop,Position),120, <StaticTextHeight> 
				GenConField		~AutoRotate~
				RadioTrueValue	~90~
 				Text			~Auto Rotate 90 CW~
				IActionsText	ACTIONS ( GET )
				DActionsText	ACTIONS ( CheckButton(AutoRotateRadioButton90) 
											UnCheckButton(AutoRotateRadioButton270) 
											UnCheckButton(AutoRotateRadioButtonOff)
											Save "Exec(OnRotationButton();") )
				OActionsText	ACTIONS ( SAVE )
				Tooltip			~Rotate the image clockwise if the orientation of the image does not match the orientation of the node~;

	Define: AutoRotateRadioButton270 Using DDWinCtrlDef AsSymbol AutoRotateRadioButton270 
		Fields: TypeName		RadioButton  
				Position		AutoRotateRadioButton90(Getright,Position) + $hGap*5,
								AutoRotateRadioButton90(GetTop,Position),AutoRotateRadioButton90(GetWidth,Position), <StaticTextHeight> 
				GenConField		~AutoRotate~
				RadioTrueValue	~270~
 				Text			~Auto Rotate 90 CCW~
				IActionsText	ACTIONS ( GET )
				DActionsText	ACTIONS ( CheckButton(AutoRotateRadioButton270) 
											UnCheckButton(AutoRotateRadioButton900) 
											UnCheckButton(AutoRotateRadioButtonOff) 
											Save "Exec(OnRotationButton();") )
				OActionsText	ACTIONS ( SAVE )
				Tooltip ~Rotate the image counter clockwise if the orientation of the image does not match the orientation of the node~;

	Define: AutoRotateRadioButtonOff Using DDWinCtrlDef AsSymbol AutoRotateRadioButtonOff 
		Fields: TypeName		RadioButton  
				Position		AutoRotateRadioButton270(Getright,Position) + $hGap*5,
								AutoRotateRadioButton270(GetTop,Position),120, <StaticTextHeight> 
				GenConField		~AutoRotate~
				RadioTrueValue	~0~
 				Text			~Auto Rotate Off~
				IActionsText	ACTIONS ( GET )
				DActionsText	ACTIONS ( CheckButton(AutoRotateRadioButtonOff) 
											UnCheckButton(AutoRotateRadioButton90) 
											UnCheckButton(AutoRotateRadioButton270) 
											Save "Exec(OnRotationButton();") )
				OActionsText	ACTIONS ( SAVE )
				Tooltip			~Do not auto rotate the image~;


	Define: XResolutionStaticText Using DDWinCtrlDef AsSymbol XResolutionStaticText
		fields:	TypeName StaticText
				Text ~Resolution~
				RightJustified TRUE
				Position RotationPrompt(GetLeft,Position),RotationPrompt(GetBottom,Position) + $vGap*6,$StaticTextWidth,$StaticTextHeight

	Define: XResolutionEditText Using DDWinCtrlDef AsSymbol XResolutionEditText
		fields:	TypeName MaskedEditText
				Position XResolutionStaticText(GetRight,Position)+$hGap,XResolutionStaticText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~Resolution~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~############~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the resolution in pixels per inch~;

	Define: ScaleFactorStaticText Using DDWinCtrlDef AsSymbol ScaleFactorStaticText
		fields:	TypeName StaticText
				Text ~Scale Factor~
				RightJustified TRUE
				Position XResolutionEditText(GetRight,Position)+$hGap,XResolutionStaticText(GetTop,Position),$StaticTextWidth,$StaticTextHeight

	Define: ScaleFactorEditText Using DDWinCtrlDef AsSymbol ScaleFactorEditText
		fields:	TypeName MaskedEditText
				Position ScaleFactorStaticText(GetRight,Position)+$hGap,ScaleFactorStaticText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~ScaleFactor~
				IActionsText ~[Get]~
                DActionsText ACTION EXEC ( UpdateScaleFactorTooltip() )
				OActionsText ~[Save]~
				Mask		 ~######~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the scale factor as a percentage.  For example, 100 percent = no change, 200 percent = 2x, 50 percent = 1/2 x~;

	Define: PercentageStaticText Using DDWinCtrlDef AsSymbol ScaleFactorStaticText
		fields:	TypeName StaticText
				Text ~%~
				LeftJustified TRUE
				Position ScaleFactorEditText(GetRight,Position)+$hGap,ScaleFactorEditText(GetTop,Position)+ 3,$StaticTextWidth,$StaticTextHeight

	Define: WidthStaticText Using DDWinCtrlDef AsSymbol WidthStaticText
		fields:	TypeName StaticText
				Text ~Width~
				RightJustified TRUE
				Position XResolutionStaticText(GetLeft,Position),XResolutionEditText(Getbottom,Position)+$vGap*6,$StaticTextWidth,$StaticTextHeight

	Define: WidthEditText Using DDWinCtrlDef AsSymbol WidthEditText
		fields:	TypeName MaskedEditText
				Position WidthStaticText(GetRight,Position)+$hGap,WidthStaticText(GetTop,Position)-2,$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~Width~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the width of the exported image(s)~;

	Define: WidthUnitsStaticText Using DDWinCtrlDef AsSymbol WidthUnitsStaticText
		fields:	TypeName StaticText
				LeftJustified TRUE
				GenConField ~Units~
				IActionsText ~[Get]~
				Position WidthEditText(GetRight,Position)+$hGap,WidthStaticText(GetTop,Position),18,$StaticTextHeight

	Define: HeightStaticText Using DDWinCtrlDef AsSymbol HeightStaticText
		fields:	TypeName		StaticText
				Text			~Height~
				RightJustified	TRUE
				Position		WidthUnitsStaticText(GetRight,Position)+$hGap,WidthStaticText(GetTop,Position),$StaticTextWidth-23,$StaticTextHeight

	Define: HeightEditText Using DDWinCtrlDef AsSymbol HeightEditText
		fields:	TypeName MaskedEditText
				Position HeightStaticText(GetRight,Position)+$hGap,WidthEditText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~Height~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the height of the exported image(s)~;

	Define: HeightUnitsStaticText Using DDWinCtrlDef AsSymbol HeightUnitsStaticText
		fields:	TypeName StaticText
				LeftJustified TRUE
				GenConField ~Units~
				IActionsText ~[Get]~
				Position HeightEditText(GetRight,Position)+$hGap,HeightStaticText(GetTop,Position),18,$StaticTextHeight

	Define: SizeByStaticText Using DDWinCtrlDef AsSymbol SizeByStaticText
		fields:	TypeName		StaticText
				Text			~Size By~
				RightJustified	TRUE
				Position		HeightUnitsStaticText(GetRight,Position)+$hGap,WidthStaticText(GetTop,Position),$StaticTextWidth,$StaticTextHeight

   Define:SizingComboBox Using DDWinCtrlDef AsSymbol SizingComboBox 
        Fields: TypeName			SComboBox  
                Position			SizeByStaticText(GetRight,Position) + $hGap,HeightEditText(Gettop,Position),300 ,<ComboBoxHeight> 
                IActionsText		ACTION EXEC ( RefreshSizeChoicesComboBox(TRUE) )
                OActionsText		~[Save]~
                GenConName			THIS
                GenConField			~SizeOption~
				IsIndex				TRUE
				DActionsText		~[Save Exec("OnSizingChange()")]~
                Tooltip				~Select how to resize the exported image~;

	CropStaticWidth = $StaticTextWidth;

	Define: CropXStaticText Using DDWinCtrlDef AsSymbol CropXStaticText
		fields:	TypeName StaticText
				Text ~Crop X~
				RightJustified TRUE
				Position XResolutionStaticText(GetLeft,Position),WidthStaticText(GetBottom,Position) + $vGap*6,$CropStaticWidth,$StaticTextHeight

	Define: CropXEditText Using DDWinCtrlDef AsSymbol CropXEditText
		fields:	TypeName MaskedEditText
				Position CropXStaticText(GetRight,Position)+$hGap,CropXStaticText(GetTop,Position)-2,$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~CropX~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the X coordinate for the middle of the crop~;

	Define: CropYStaticText Using DDWinCtrlDef AsSymbol CropYStaticText
		fields:	TypeName StaticText
				Text Translate(~Crop Y~)
				RightJustified TRUE
				Position CropXEditText(GetRight,Position)+$hGap,CropXStaticText(GetTop,Position),$CropStaticWidth,$StaticTextHeight

	Define: CropYEditText Using DDWinCtrlDef AsSymbol CropYEditText
		fields:	TypeName MaskedEditText
				Position CropYStaticText(GetRight,Position)+$hGap,CropXEditText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~CropY~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the Y coordinate for the middle of the crop~;

	Define: CropWidthStaticText Using DDWinCtrlDef AsSymbol CropWidthStaticText
		fields:	TypeName StaticText
				Text Translate(~Crop Width~)
				RightJustified TRUE
				Position CropYEditText(GetRight,Position)+$hGap,CropXStaticText(GetTop,Position),$CropStaticWidth,$StaticTextHeight

	Define: CropWidthEditText Using DDWinCtrlDef AsSymbol CropWidthEditText
		fields:	TypeName MaskedEditText
				Position CropWidthStaticText(GetRight,Position)+$hGap,CropXEditText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~CropWidth~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the width of the crop as a percentage of the total image~;


	Define: CropLengthStaticText Using DDWinCtrlDef AsSymbol CropLengthStaticText
		fields:	TypeName StaticText
				Text Translate(~Crop Height~)
				RightJustified TRUE
				Position CropWidthEditText(GetRight,Position),CropXStaticText(GetTop,Position),$CropStaticWidth,$StaticTextHeight

	Define: CropLengthEditText Using DDWinCtrlDef AsSymbol CropLengthEditText
		fields:	TypeName MaskedEditText
				Position CropLengthStaticText(GetRight,Position)+$hGap,CropXEditText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~CropLength~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the height of the crop as a percentage of the total image~;

	Define: MaxPossibleButton Using DDWinCtrlDef AsSymbol MaxPossibleButton
		fields:	TypeName Button
				Text Translate(~Reset Crop~)
				DActionsText	ACTION EXEC ( ResetCrop() )
				Position CropLengthEditText(GetRight,Position)+$hGap * 6,CropLengthEditText(GetTop,Position),$ButtonWidth,$StaticTextHeight
				Tooltip ~Reset the crop to use the max possible image.  (50,50,100,100)~;

	CropStaticWidth = $StaticTextWidth;

	Define: ImageCropXStaticText Using DDWinCtrlDef AsSymbol ImageCropXStaticText
		fields:	TypeName StaticText
				Text ~Image X~
				RightJustified TRUE
				Position XResolutionStaticText(GetLeft,Position),CropXStaticText(GetBottom,Position) + $vGap,$CropStaticWidth,$StaticTextHeight

	Define: ImageCropXEditText Using DDWinCtrlDef AsSymbol ImageCropXEditText
		fields:	TypeName MaskedEditText
				Position ImageCropXStaticText(GetRight,Position)+$hGap,ImageCropXStaticText(GetTop,Position)-2,$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~ImageCropX~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the X coordinate for the middle of the image crop.    This overrides the image crop in the database.~;

	CropStaticWidth = $StaticTextWidth;

	Define: ImageCropYStaticText Using DDWinCtrlDef AsSymbol ImageCropYStaticText
		fields:	TypeName StaticText
				Text Translate(~Image Y~)
				RightJustified TRUE
				Position ImageCropXEditText(GetRight,Position)+$hGap,ImageCropXStaticText(GetTop,Position),$CropStaticWidth,$StaticTextHeight

	Define: ImageCropYEditText Using DDWinCtrlDef AsSymbol ImageCropYEditText
		fields:	TypeName MaskedEditText
				Position ImageCropYStaticText(GetRight,Position)+$hGap,ImageCropXEditText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~ImageCropY~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Enter the Y coordinate for the middle of the image crop.  This overrides the image crop in the database.~;

	Define: ImageCropWidthStaticText Using DDWinCtrlDef AsSymbol ImageCropWidthStaticText
		fields:	TypeName StaticText
				Text Translate(~Image Width~)
				RightJustified TRUE
				Position ImageCropYEditText(GetRight,Position)+$hGap,ImageCropXStaticText(GetTop,Position),$CropStaticWidth,$StaticTextHeight

	Define: ImageCropWidthEditText Using DDWinCtrlDef AsSymbol ImageCropWidthEditText
		fields:	TypeName MaskedEditText
				Position ImageCropWidthStaticText(GetRight,Position)+$hGap,ImageCropXEditText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~ImageCropWidth~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Percentage of the image width to use.  Overrides the image width in the database~;


	Define: ImageCropLengthStaticText Using DDWinCtrlDef AsSymbol ImageCropLengthStaticText
		fields:	TypeName StaticText
				Text Translate(~Image Height~)
				RightJustified TRUE
				Position ImageCropWidthEditText(GetRight,Position),ImageCropXStaticText(GetTop,Position),$CropStaticWidth,$StaticTextHeight

	Define: ImageCropLengthEditText Using DDWinCtrlDef AsSymbol ImageCropLengthEditText
		fields:	TypeName MaskedEditText
				Position ImageCropLengthStaticText(GetRight,Position)+$hGap,ImageCropXEditText(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				GenConName THIS
				GenConField ~ImageCropHeight~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Mask		 ~#########~
				AllowedChars ~.~
				PromptChar	 ~ ~		
				Tooltip ~Percentage of the image height to use.  Overrides the Image height in the database~;

	Define: ImageCropOverrideBox Using DDWinCtrlDef AsSymbol ImageCropOverrideBox
		fields:	TypeName CheckBox
				Position MaxPossibleButton(GetLeft,Position),ImageCropLengthEditText(GetTop,Position),140,$StaticTextHeight
				GenConName THIS
				Text		~Override Image Crop~
				GenConField ~OverrideImageCrop~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Tooltip ~If checked,the Image Crop in the database is ignored and the values to the left are used~;
	
	Define: OverrideImageRotationBox Using DDWinCtrlDef AsSymbol OverrideImageRotationBox
		fields:	TypeName CheckBox
				Position ImageCropOverrideBox(GetLeft,Position),ImageCropOverrideBox(GetBottom,Position)+$vGap,140,$StaticTextHeight
				GenConName THIS
				Text		~Override Image Rotation~
				GenConField ~OverrideImageRotation~
				IActionsText ~[Get]~
				OActionsText ~[Save]~
				Tooltip ~If checked,the Image Rotation in the database is ignored and the value to the right is used~;

	Define: ImageRotationComboBox Using DDWinCtrlDef AsSymbol ImageRotationComboBox 
        Fields: TypeName		SComboBox  
                Position		OverrideImageRotationBox(Getright,Position) + $hGap,
								OverrideImageRotationBox(GetTop,Position),<SmallStaticTextWidth>, <ComboBoxHeight> 
                IActionsText    ~[GetList(SaveImageRotationChoices) Get]~
                OActionsText    ~[Save]~
                GenConField		~ImageRotation~
                GenConName		THIS
				IActionsText	ACTIONS ( GetList(SaveImageRotationChoices) GET )
				DActionsText	ACTIONS ( SAVE )
				OActionsText	ACTIONS ( SAVE )
                Tooltip			~Override the image rotation that is stored in the database~ ;
}


VOID DefineSharpenTabControls(x,y)
{
	Define: SharpenStaticText Using DDWinCtrlDef AsSymbol SharpenStaticText
		fields:	TypeName		StaticText
				Text			~Sharpen~
				RightJustified	TRUE
				Position		$X, $y, $StaticTextWidth , 20

	Define: SharpenRadioButtonFaster Using DDWinCtrlDef AsSymbol SharpenRadioButtonFaster
		fields: TypeName		RadioButton  
				Position		SharpenStaticText(GetRight,Position)+$hGap*5,$y ,100 ,20 
				GenConField		~SharpenFast~
				GenConName		This
				RadioTrueValue	~1~
				Text			~Faster~
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save CheckButton(SharpenRadioButtonFaster) UnCheckButton(SharpenRadioButtonNormal)  )				
				Tooltip			~Use a fast, high quality sharpening algorithm~;

	Define: SharpenRadioButtonNormal Using DDWinCtrlDef AsSymbol SharpenRadioButtonNormal
		fields: TypeName		RadioButton  
				Position		SharpenRadioButtonFaster(GetRight,Position) + $hGap ,SharpenRadioButtonFaster(GetTop,Position) ,
								SharpenRadioButtonFaster(GetWidth,Position) ,$StaticTextHeight 
				GenConField		~SharpenFast~
				GenConName		This
				RadioTrueValue	~0~
 				Text			~Higher Quality~
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save UnCheckButton(SharpenRadioButtonFaster) CheckButton(SharpenRadioButtonNormal)  )				
				Tooltip			~Use a very high quality sharpening algorithm~;

	Define: SharpenValueStaticText Using DDWinCtrlDef  AsSymbol SharpenValueStaticText
		fields:	TypeName		StaticText
				Text			~Amount~
				RightJustified	TRUE
				Position		$X,SharpenRadioButtonFaster(GetBottom,Position) + $vGap*5 SharpenStaticText(GetWidth,Position)  $StaticTextHeight

	Define: SharpenValueEditText Using DDWinCtrlDef  AsSymbol SharpenValueEditText
		fields:	TypeName		MaskedEditText
				Position		SharpenValueStaticText(GetRight,Position) + $hGap , SharpenValueStaticText(GetTop,Position), 40 , $StaticTextHeight
				GenConField		~SharpenValue~
				GenConName		This
				Mask			~####~
				AllowedChars	~~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(SharpenValueSlider) )				
				Tooltip			~Sharpening amounts in DP2 produce approximately half as much sharpening as KPIS.  To get the same amount of sharpening as KPIS, double the amount used in KPIS.~

	Define: SharpenValueSlider Using DDWinCtrlDef AsSymbol SharpenValueSlider
		fields:	TypeName		Slider
				Position		SharpenValueEditText(GetRight,Position) + $hGap, SharpenValueEditText(GetTop,Position), 320  20
				GenConField		~SharpenValue~
				GenConName		This
				UNITS			1
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(SharpenValueEditText) )			
				Tooltip			~Sharpening amounts in DP2 produce approximately half as much sharpening as KPIS.  To get the same amount of sharpening as KPIS, double the amount used in KPIS.~;

	Define: SharpenMethodCheckBox Using DDWinCtrlDef AsSymbol SharpenMethodCheckBox
		fields:	TypeName		Checkbox
				Position		SharpenValueSlider(GetRight,Position) + $hGap SharpenValueSlider(GetTop,Position) 110 , $StaticTextHeight
				GenConField		~AdaptiveSharpen~
				GenConName		This
				Text			~Adaptive Sharpen~
				DACTIONSTEXT	ACTION EXEC ( OnSharpenMethodCheckBox() )
				Tooltip			~Use adaptive sharpening~;

	Define: LimitValueStaticText Using DDWinCtrlDef AsSymbol LimitValueStaticText
		fields:	TypeName		StaticText
				Text			~Limit~
				RightJustified	TRUE
				Position		$X, SharpenMethodCheckBox(GetBottom,Position) + $vGap*5, SharpenValueStaticText(GetWidth,Position) , 20

	Define: LimitValueEditText Using DDWinCtrlDef  AsSymbol LimitValueEditText
		fields:	TypeName		MaskedEditText
				Position		LimitValueStaticText(GetRight,Position)+$hGap LimitValueStaticText(GetTop,Position) SharpenValueEditText(GetWidth,Position)  $StaticTextHeight
				GenConField		~AdaptiveSharpenLimit~
				GenConName		This
				Mask			~####~
				PromptChar		~ ~	
				IsEnabled		F
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(LimitValueSlider) )			
				Tooltip			~Set adaptive sharpen limit.~

	Define: LimitValueSlider Using DDWinCtrlDef AsSymbol LimitValueSlider
		fields:	TypeName		Slider
				Position		LimitValueEditText(GetRight,Position)+$hGap LimitValueEditText(GetTop,Position)  SharpenValueSlider(GetWidth,Position)  $StaticTextHeight
				GenConField		~AdaptiveSharpenLimit~
				GenConName		This
				IsEnabled		F
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(LimitValueEditText) )		
				UNITS			1
				Tooltip			~Set adaptive sharpen limit.~;

	Define: ThresholdStaticText Using DDWinCtrlDef AsSymbol ThresholdStaticText
		fields:	TypeName		StaticText
				Text			~Threshold~
				RightJustified	TRUE
				Position		$X LimitValueStaticText(GetBottom,Position) + $vGap LimitValueStaticText(GetWidth,Position)  $StaticTextHeight

	Define: ThresholdEditText Using DDWinCtrlDef  AsSymbol ThresholdEditText
		fields:	TypeName		MaskedEditText
				Position		ThresholdStaticText(GetRight,Position) + $hGap, ThresholdStaticText(GetTop,Position) LimitValueEditText(GetWidth,Position),  $StaticTextHeight
				GenConField		~AdaptiveSharpenThreshold~
				GenConName		This
				Mask			~####~
				AllowedChars	~~
				PromptChar		~ ~	
				IsEnabled		F	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(ThresholdSlider) )		
				Tooltip			~Set adaptive sharpen threshhold~

	Define: ThresholdSlider Using DDWinCtrlDef   AsSymbol ThresholdSlider
		fields:	TypeName		Slider
				Position		ThresholdEditText(GetRight,Position) + $hGap ThresholdEditText(GetTop,Position) LimitValueSlider(GetWidth,Position)  $StaticTextHeight
				GenConField		~AdaptiveSharpenThreshold~
				GenConName		This
				IsEnabled		F
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(ThresholdEditText) )		
				UNITS			1
				Tooltip			~Set adaptive sharpen threshold~;

	Define: AdaptiveSharpenBlurStaticText Using DDWinCtrlDef   AsSymbol AdaptiveSharpenBlurStaticText
		fields:	TypeName		StaticText
				Text			~Blur~
				RightJustified	TRUE
				Position		$X ThresholdStaticText(GetBottom,Position) + $vGap ThresholdStaticText(GetWidth,Position)  $StaticTextHeight

	Define: AdaptiveSharpenBlurEditText Using DDWinCtrlDef AsSymbol AdaptiveSharpenBlurEditText
		fields:	TypeName		MaskedEditText
				Position		AdaptiveSharpenBlurStaticText(GetRight,Position) + $hGap AdaptiveSharpenBlurStaticText(GetTop,Position)  
								ThresholdEditText(GetWidth,Position)  $StaticTextHeight
				GenConField		~AdaptiveSharpenBlur~
				GenConName		This
				Mask			~####~
				AllowedChars	~~
				PromptChar		~ ~
				IsEnabled		F	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(AdaptiveSharpenBlurSlider) )		
				Tooltip			~Set adaptive sharpen blur~

	Define: AdaptiveSharpenBlurSlider Using DDWinCtrlDef AsSymbol AdaptiveSharpenBlurSlider
		fields:	TypeName		Slider
				Position		AdaptiveSharpenBlurEditText(GetRight,Position) + $hGap AdaptiveSharpenBlurStaticText(GetTop,Position) ThresholdSlider(GetWidth,Position)  $StaticTextHeight
				GenConField		~AdaptiveSharpenBlur~
				GenConName		This
				IsEnabled		F
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(AdaptiveSharpenBlurEditText) )	
				UNITS			1	
				Tooltip ~Set adaptive sharpen blur~;

	Define: SharpnessHelpButton Using DDWinCtrlDef AsSymbol SharpnessHelpButton
		fields:	TypeName		Button
				Text			~Help~
				ToolTip			~Help with the sharpening options~
				DActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "INSharpness.htm" )
				Position		AdaptiveSharpenBlurSlider(GetRight,Position) + $StaticTextHeight,
								AdaptiveSharpenBlurSlider(GetTop,Position),
								50,20;
}


VOID DefineAdjustTabControls(x,y)
{
	Define: DensityStaticText Using DDWinCtrlDef  AsSymbol DensityStaticText
		fields:	TypeName		StaticText
				Text			~Density~
				RightJustified	TRUE
				Position		$X,$Y $StaticTextWidth  $StaticTextHeight

	Define: DensityEditText Using DDWinCtrlDef  AsSymbol DensityEditText
		fields:	TypeName		MaskedEditText
				Position		DensityStaticText(GetRight,Position) + $hGap , DensityStaticText(GetTop,Position),50 , $StaticTextHeight
				GenConField		~Density~
				GenConName		This
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(DensitySlider) )				
				Tooltip			~Alter the density of the exported image~

	Define: DensitySlider Using DDWinCtrlDef AsSymbol DensitySlider
		fields:	TypeName		Slider
				Position		DensityEditText(GetRight,Position) + $hGap, DensityEditText(GetTop,Position), 340  20
				GenConField		~Density~
				GenConName		This
				UNITS			1
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(DensityEditText) )			
				Tooltip			~Alter the density of the exported image~;


	Define: RedStaticText Using DDWinCtrlDef  AsSymbol RedStaticText
		fields:	TypeName		StaticText
				Text			~Red~
				RightJustified	TRUE
				Position		$X,DensityStaticText(GetBottom,Position) + $vGap $StaticTextWidth  $StaticTextHeight

	Define: RedEditText Using DDWinCtrlDef  AsSymbol RedEditText
		fields:	TypeName		MaskedEditText
				Position		RedStaticText(GetRight,Position) + $hGap , RedStaticText(GetTop,Position),50 , $StaticTextHeight
				GenConField		~Red~
				GenConName		This
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(RedSlider) )				
				Tooltip			~Alter the red balance of the exported image~

	Define: RedSlider Using DDWinCtrlDef AsSymbol RedSlider
		fields:	TypeName		Slider
				Position		RedEditText(GetRight,Position) + $hGap, RedEditText(GetTop,Position), DensitySlider(GetWidth,Position)  20
				GenConField		~Red~
				GenConName		This
				UNITS			1
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(RedEditText) )			
				Tooltip			~Alter the red balance of the exported image~;


	Define: GreenStaticText Using DDWinCtrlDef  AsSymbol GreenStaticText
		fields:	TypeName		StaticText
				Text			~Green~
				RightJustified	TRUE
				Position		$X,RedStaticText(GetBottom,Position) + $vGap $StaticTextWidth  $StaticTextHeight

	Define: GreenEditText Using DDWinCtrlDef  AsSymbol GreenEditText
		fields:	TypeName		MaskedEditText
				Position		GreenStaticText(GetRight,Position) + $hGap , GreenStaticText(GetTop,Position),50 , $StaticTextHeight
				GenConField		~Green~
				GenConName		This
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(GreenSlider) )				
				Tooltip			~Alter the green balance of the exported image~

	Define: GreenSlider Using DDWinCtrlDef AsSymbol GreenSlider
		fields:	TypeName		Slider
				Position		GreenEditText(GetRight,Position) + $hGap, GreenEditText(GetTop,Position), DensitySlider(GetWidth,Position)  20
				GenConField		~Green~
				GenConName		This
				UNITS			1
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(GreenEditText) )			
				Tooltip			~Alter the green balance of the exported image~;


	Define: BlueStaticText Using DDWinCtrlDef  AsSymbol BlueStaticText
		fields:	TypeName		StaticText
				Text			~Blue~
				RightJustified	TRUE
				Position		$X,GreenStaticText(GetBottom,Position) + $vGap $StaticTextWidth  $StaticTextHeight

	Define: BlueEditText Using DDWinCtrlDef  AsSymbol BlueEditText
		fields:	TypeName		MaskedEditText
				Position		BlueStaticText(GetRight,Position) + $hGap , BlueStaticText(GetTop,Position),50 , $StaticTextHeight
				GenConField		~Blue~
				GenConName		This
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(BlueSlider) )				
				Tooltip			~Alter the blue balance of the exported image~

	Define: BlueSlider Using DDWinCtrlDef AsSymbol BlueSlider
		fields:	TypeName		Slider
				Position		BlueEditText(GetRight,Position) + $hGap, BlueEditText(GetTop,Position), DensitySlider(GetWidth,Position)  20
				GenConField		~Blue~
				GenConName		This
				UNITS			1
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(BlueEditText) )			
				Tooltip			~Alter the Blue balance of the exported image~;

	Define: ContrastStaticText Using DDWinCtrlDef  AsSymbol ContrastStaticText
		fields:	TypeName		StaticText
				Text			~Contrast~
				RightJustified	TRUE
				Position		$X,BlueStaticText(GetBottom,Position) + $vGap $StaticTextWidth  $StaticTextHeight

	Define: ContrastEditText Using DDWinCtrlDef  AsSymbol ContrastEditText
		fields:	TypeName		MaskedEditText
				Position		ContrastStaticText(GetRight,Position) + $hGap , ContrastStaticText(GetTop,Position),50 , $StaticTextHeight
				GenConField		~Contrast~
				GenConName		This
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(ContrastSlider) )				
				Tooltip			~Alter the contrast of the exported image~

	Define: ContrastSlider Using DDWinCtrlDef AsSymbol ContrastSlider
		fields:	TypeName		Slider
				Position		ContrastEditText(GetRight,Position) + $hGap, ContrastEditText(GetTop,Position), DensitySlider(GetWidth,Position)  20
				GenConField		~Contrast~
				GenConName		This
				UNITS			1
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(ContrastEditText) )			
				Tooltip			~Alter the Contrast balance of the exported image~;

	Define: XGammaStaticText Using DDWinCtrlDef  AsSymbol XGammaStaticText
		fields:	TypeName		StaticText
				Text			~XGamma~
				RightJustified	TRUE
				Position		$X,ContrastStaticText(GetBottom,Position) + $vGap $StaticTextWidth  $StaticTextHeight

	Define: XGammaEditText Using DDWinCtrlDef  AsSymbol XGammaEditText
		fields:	TypeName		MaskedEditText
				Position		XGammaStaticText(GetRight,Position) + $hGap , XGammaStaticText(GetTop,Position),50 , $StaticTextHeight
				GenConField		~XGamma~
				GenConName		This
				Mask			~#######~
				AllowedChars	~-.~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(XGammaSlider) )				
				Tooltip			~Alter the gamma of the exported image~

	Define: XGammaSlider Using DDWinCtrlDef AsSymbol XGammaSlider
		fields:	TypeName		Slider
				Position		XGammaEditText(GetRight,Position) + $hGap, XGammaEditText(GetTop,Position), DensitySlider(GetWidth,Position)  20
				GenConField		~XGamma~
				GenConName		This
				UNITS			.01
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(XGammaEditText) )			
				Tooltip			~Alter the Gamma of the exported image~;

	Define: SaturationStaticText Using DDWinCtrlDef  AsSymbol SaturationStaticText
		fields:	TypeName		StaticText
				Text			~Saturation~
				RightJustified	TRUE
				Position		$X,XGammaStaticText(GetBottom,Position) + $vGap $StaticTextWidth  $StaticTextHeight

	Define: SaturationEditText Using DDWinCtrlDef  AsSymbol SaturationEditText
		fields:	TypeName		MaskedEditText
				Position		SaturationStaticText(GetRight,Position) + $hGap , SaturationStaticText(GetTop,Position),50 , $StaticTextHeight
				GenConField		~Saturation~
				GenConName		This
				Mask			~####~
				AllowedChars	~-~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(SaturationSlider) )				
				Tooltip			~Alter the saturation of the exported image~

	Define: SaturationSlider Using DDWinCtrlDef AsSymbol SaturationSlider
		fields:	TypeName		Slider
				Position		SaturationEditText(GetRight,Position) + $hGap, SaturationEditText(GetTop,Position), DensitySlider(GetWidth,Position)  20
				GenConField		~Saturation~
				GenConName		This
				UNITS			1
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save Update(SaturationEditText) )			
				Tooltip			~Alter the saturation of the exported image~;

	Define: NegativeBox Using DDWinCtrlDef AsSymbol NegativeBox 
		Fields: TypeName		CheckBox
				Text			Translate( ~Negative~ )
				Position		DensitySlider(GetRight,Position) + 20,DensityStaticText(GetTop,Position), <StaticTextWidth>+10,  <StaticTextHeight>
				GenConName		THIS
                GenConField		~Negative~	
				IActionsText    ACTIONS ( Get )
				DActionsText	ACTIONS ( Save )
				OActionsText	ACTIONS ( Save )
				Tooltip         ~Convert the image to a negative~

	Define: GrayScaleBox Using DDWinCtrlDef AsSymbol GrayScaleBox 
		Fields: TypeName		CheckBox
				Text			Translate( ~Gray Scale~ )
				Position		NegativeBox(GetLeft,Position),NegativeBox(GetBottom,Position)+$vGap, <StaticTextWidth>+10,  <StaticTextHeight>
				GenConName		THIS
                GenConField		~GrayScale~	
				IActionsText    ACTIONS ( Get )
				DActionsText	ACTIONS ( Save )
				OActionsText	ACTIONS ( Save )
				Tooltip         ~Convert the image to gray scale.  Remove all the color~
}



VOID DefineConvertTabControls(x,y)
{
	PromptWidth = $StaticTextWidth + 20;

	Define: LutPrompt Using DDWinCtrlDef AsSymbol LutPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Lut~ )
				RightJustified	TRUE
				Position		$x,$y,$PromptWidth,$StaticTextHeight

	Define: LutField Using DDWinCtrlDef AsSymbol LutField 
		Fields: TypeName		EditText  
				Position		LutPrompt(GetRight,Position) + $hGap,LutPrompt(GetTop,Position),<PathTextWidth>,<EditTextHeight> 
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConName       THIS
				GenConField		~LutFile~
				Tooltip         ~Select a lut to filter the image through~;

	Define: LutBrowseButton Using DDWinCtrlDef AsSymbol LutBrowseButton 
		Fields: TypeName		Button
				Text			Translate( ~?~ )
				Position		LutField(GetRight,Position)+$hGap,LutField(GetTop,Position),20,20
				DActionsText	ACTION EXEC ( BrowseForLut() ) 
				Tooltip			Translate( ~Find the lut you wish to apply~ );

	Define: ColorMatrixPrompt Using DDWinCtrlDef AsSymbol ColorMatrixPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~ColorMatrix~ )
				RightJustified	TRUE
				Position		<x>,LutPrompt(GetBottom,Position) + $vGap,<PromptWidth>,<StaticTextHeight>

	Define: ColorMatrixField Using DDWinCtrlDef AsSymbol ColorMatrixField 
		Fields: TypeName		EditText  
				Position		ColorMatrixPrompt(GetRight,Position) + $hGap,ColorMatrixPrompt(GetTop,Position),<PathTextWidth>,<EditTextHeight> 
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConName       THIS
				GenConField		~ColorMatrix~
				Tooltip         ~Select a color matrix to filter the image through~;

	Define: ColorMatrixBrowseButton Using DDWinCtrlDef AsSymbol ColorMatrixBrowseButton 
		Fields: TypeName		Button
				Text			Translate( ~?~ )
				Position		ColorMatrixField(GetRight,Position)+$hGap,ColorMatrixField(GetTop,Position),20,20
				DActionsText	ACTION EXEC ( BrowseForColorMatrix() ) 
				Tooltip			Translate( ~Find the color matrix you wish to apply~ );

 }

VOID DefineColorManageTabControls(x,y)
{
	PromptWidth = $StaticTextWidth + 20;


	Define: ForceColorManagementOffBox Using DDWinCtrlDef AsSymbol ForceColorManagementOffBox 
		Fields: TypeName		CheckBox
 				Text			Translate( ~Do not apply color management when exporting these images~ )
				Position		$x+25,$y+10 ,<PromptWidth>*6,<StaticTextHeight>
				GenConName		THIS
                GenConField		~ForceColorManagementOff~	
				IActionsText    ACTIONS ( Get )
				DActionsText	~[ 
									Save
									"Exec(OnForceColorManagementOff();)" 
								 ]~
				OActionsText	ACTIONS ( Save )
				Tooltip         Translate( ~No color management will be applied to the exported image(s).~)

	Define: OutputProfileStaticText Using DDWinCtrlDef AsSymbol OutputProfileStaticText
        Fields: TypeName        StaticText
                Text            ~Output Profile~
				RightJustified	TRUE
                Position		<x>+10,ForceColorManagementOffBox(GetBottom,Position) + $vGap,<PromptWidth>+30,<StaticTextHeight>

	Define: OutputProfileComboBox Using DDWinCtrlDef AsSymbol OutputProfileComboBox 
        Fields: TypeName			SComboBox  
                Position			OutputProfileStaticText(GetRight,Position) + $hGap,OutputProfileStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                IActionsText		ACTION EXEC ( RefreshOutputProfilesComboBox(TRUE) )
                OActionsText		~[Save]~
 				DActionsText		ACTIONS ( "Exec(NewOutputProfileSelected(0))" UpdateControl (EmbedProfileComboBox) )
				GenConName			THIS
                GenConField			~ICCProfile~
				DropDownActionsText ACTION CALL ( RefreshOutputProfilesComboBox(FALSE) )
                Tooltip				~Select the profile that describes the color space to store the image in.~

	Define: EnableProfileBox Using DDWinCtrlDef AsSymbol EnableProfileBox 

		Fields: TypeName		CheckBox
				Text			Translate( ~Enabled~ )
				Position		OutputProfileComboBox(GetRight,Position) + ($hGap * 1),OutputProfileComboBox(GetTop,Position), <StaticTextWidth>,  <StaticTextHeight>
				GenConName		THIS
                GenConField		~OutputProfileEnabled~	
				IActionsText    ACTIONS ( Get )
				OActionsText	ACTIONS ( Save )
				Text			Translate( ~Enabled~ )
				Tooltip         ~Enable or disable the use of the selected output profile.  If you leave this box unchecked, the profile in the printer queue will be used.~
 


	Define: ChooseProfilesBox Using DDWinCtrlDef AsSymbol ChooseProfilesBox 
		Fields: TypeName		CheckBox
 				Text			Translate( ~Choose Working Space and Default Input Profiles (Overrides the Color Management Dialog Box on the Edit Menu)~ )
				Position		<x>+25,EnableProfileBox(GetBottom,Position) + $vGap,<PromptWidth>*7,<StaticTextHeight>
				GenConName		THIS
                GenConField		~ChooseProfiles~	
				IActionsText    ACTIONS ( Get )
				DActionsText	~[ 
									Save
									"Exec(OnChooseProfiles();)" 
								 ]~

				OActionsText	ACTIONS ( Save )
				Tooltip         Translate( ~Choose a default input profile, working space and output profile.  The default input profile will only be used if there is no profile assigned to the image in the database and the image has no embedded profile.~)


	Define: WorkingSpaceProfileStaticText Using DDWinCtrlDef AsSymbol WorkingSpaceProfileStaticText 
        Fields: TypeName        StaticText
                Text            ~Working Space Profile~
				RightJustified	TRUE
                Position		<x>+10,ChooseProfilesBox(GetBottom,Position) + $vGap*3,<PromptWidth>+30,<StaticTextHeight>

    Define: WorkingSpaceProfileComboBox Using DDWinCtrlDef AsSymbol WorkingSpaceProfileComboBox 
        Fields: TypeName			SComboBox  
                Position			WorkingSpaceProfileStaticText(GetRight,Position) + $hGap,WorkingSpaceProfileStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                IActionsText		ACTION EXEC ( RefreshWorkingSpaceProfilesComboBox(TRUE) )
                OActionsText		~[Save]~
                GenConName			THIS
                GenConField			~WorkingSpaceProfile~
				DropDownActionsText ACTION CALL ( RefreshWorkingSpaceProfilesComboBox(FALSE) )
                Tooltip				~Select the working space profile to be used.~;

	Define: InputProfileStaticText Using DDWinCtrlDef AsSymbol InputProfileStaticText 
        Fields: TypeName        StaticText
                Text            ~Default Input Profile~
				RightJustified	TRUE
                Position		<x>+10,WorkingSpaceProfileStaticText(GetBottom,Position) + $vGap,<PromptWidth>+30,<StaticTextHeight>

    Define: InputProfileComboBox Using DDWinCtrlDef AsSymbol InputProfileComboBox 
        Fields: TypeName			SComboBox  
                Position			InputProfileStaticText(GetRight,Position) + $hGap,InputProfileStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                IActionsText		ACTION EXEC ( RefreshInputProfilesComboBox(TRUE) )
                OActionsText		~[Save]~
                GenConName			THIS
                GenConField			~DefaultInputProfile~
				DropDownActionsText ACTION CALL ( RefreshInputProfilesComboBox(FALSE) )
                Tooltip				~Select a Default Input profile.  This profile will be used if the assigned profile in the database (if any), the embedded profile (if any), the default input profile (if any), or the working space, if none of the above were present.  ~


	Define: ColorMgmtSettingsGroupBox Using DDWinCtrlDef AsSymbol ColorMgmtSettingsGroupBox
		Fields:	TypeName		GroupBox
				Text			~Color Management for these Images Only~
				Position		20,$y-5 ,670,150


 	Define: EmbedProfileBox Using DDWinCtrlDef AsSymbol EmbedProfileBox 
		Fields: TypeName		CheckBox
				Text			Translate( ~Embed Profile~ )
				Position		ChooseProfilesBox(GetLeft,Position),ColorMgmtSettingsGroupBox(GetBottom,Position) + $vGap+20, <StaticTextWidth>+40,  <StaticTextHeight>
				GenConName		THIS
                GenConField		~EmbedProfile~	
				IActionsText    ACTIONS ( Get )
 				DActionsText	ACTIONS ( Save "Exec(OnEmbedProfileBox())" )
				OActionsText	ACTIONS ( Save )
				Tooltip         ~Embed the output profile in the image(s).~
	
	Define: DefaultOutputProfileStaticText Using DDWinCtrlDef AsSymbol DefaultOutputProfileStaticText
		Fields:	TypeName		StaticText
				GenConName		THIS
				Text			~Profile to Embed~
				RightJustified	TRUE	
				Position		EmbedProfileBox(GetRight,Position)+$hGap,EmbedProfileBox(GetTop,Position)+4,100,$StaticTextHeight;

	Define: EmbedProfileComboBox Using DDWinCtrlDef AsSymbol EmbedProfileComboBox 
		      Fields: TypeName			SComboBox  
                Position			DefaultOutputProfileStaticText(GetRight,Position) + $hGap,DefaultOutputProfileStaticText(Gettop,Position),250 ,<ComboBoxHeight> 
                IActionsText		ACTION EXEC ( RefreshEmbedProfilesComboBox(TRUE) )
                OActionsText		~[Save]~
				GenConName			THIS
                GenConField			~ICCProfile~
 				DActionsText		ACTIONS ( "Exec(NewEmbedProfileSelected())" UpdateControl (OutputProfileComboBox) )
				DropDownActionsText ACTION CALL ( RefreshEmbedProfilesComboBox(FALSE) )
                Tooltip				~Select the profile to embed.~

	Define: EmbedProfileGroupBox Using DDWinCtrlDef AsSymbol EmbedProfileGroupBox
		Fields:	TypeName		GroupBox
				Text			~Profile to Embed~
				Position		20,ColorMgmtSettingsGroupBox(GetBottom,Position) + $vGap ,670,DefaultOutputProfileStaticText(GetBottom,Position) + $vGap + 10 - (ColorMgmtSettingsGroupBox(GetBottom,Position) + $vGap)

}



VOID DefineDestinationTabControls(x,y)
{
	Define: OutputDirectoryPrompt Using DDWinCtrlDef AsSymbol OutputDirectoryPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Directory~ )
				RightJustified	TRUE
				Position		$x+10,$y,$StaticTextWidth,$StaticTextHeight

	Define: OutputDirectoryField Using DDWinCtrlDef AsSymbol OutputDirectoryField 
		Fields: TypeName		EditText  
				Position		OutputDirectoryPrompt(GetRight,Position) + $hGap,OutputDirectoryPrompt(GetTop,Position),<PathTextWidth>,<EditTextHeight> 
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConName       THIS
				GenConField		~OutputDirectory~
				Tooltip         ~Select the directory to write exported images to~;

	Define: OutputButton Using DDWinCtrlDef AsSymbol OutputButton 
		Fields: TypeName		Button
				Text			Translate( ~?~ )
				Position		OutputDirectoryField(GetRight,Position)+$hGap,OutputDirectoryField(GetTop,Position),20,20
				DActionsText	ACTION EXEC ( BrowseOutputPath() ) 
				Tooltip			Translate( ~Browse to find the directory to write exported images to~ );

	Define: FileNamePrompt Using DDWinCtrlDef AsSymbol FileNamePrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~File Name~ )
				RightJustified	TRUE
				Position		OutputDirectoryPrompt(GetLeft,Position),OutputDirectoryPrompt(GetBottom,Position) + $vGap*2,$StaticTextWidth,$StaticTextHeight

	Define: FileNameField Using DDWinCtrlDef AsSymbol FileNameField 
		Fields: TypeName		MLEditText  
				Position		FileNamePrompt(GetRight,Position)+2 + $hGap,FileNamePrompt(GetTop,Position),<PathTextWidth>-4,<EditTextHeight>*3 
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConName       THIS
				GenConField		~FileName~
				NoHorizontalScroll 1
				Tooltip         ~The file name pattern to use for writing the exported images.  It should contain macros or other wildcards to create unique file names.~;

	Define: ClearButton Using DDWinCtrlDef AsSymbol ClearButton
		fields:	TypeName		Button
				Position		OutputButton(GetLeft,Position),FileNameField(GetTop,Position),$SmallStaticTextWidth,$StaticTextHeight
				Text			~Clear~
				DActionsText	ACTION EXEC ( OnFileClearButton() )
				Tooltip			~Clear the file name field~;

	Define: FileHelpButton Using DDWinCtrlDef AsSymbol FileHelpButton
		fields:	TypeName		Button
				Position		ClearButton(GetLeft,Position),ClearButton(Getbottom,Position)+$vGap,$SmallStaticTextWidth,$StaticTextHeight
				Text			~Help~
				DActionsText	ACTION EXEC ( OnFileHelpButton() )
				Tooltip			~Help with creating directory and file names~;

	Define: FileNameOptionsPrompt Using DDWinCtrlDef AsSymbol FileNameOptionsPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Options~ )
				RightJustified	TRUE
				Position		FileNamePrompt(GetLeft,Position),FileNameField(GetBottom,Position) + $vGap*2,$StaticTextWidth,$StaticTextHeight

	Define:FileNameComboBox Using DDWinCtrlDef AsSymbol FileNameComboBox 
        Fields: TypeName			SComboBox  
                Position			FileNameOptionsPrompt(GetRight,Position) + $hGap,FileNameOptionsPrompt(Gettop,Position),300 ,<ComboBoxHeight> 
                IActionsText		ACTION EXEC ( RefreshFilenameChoicesComboBox(TRUE) )
                OActionsText		~[Save]~
                GenConName			THIS
                GenConField			~FileNameOptions~
				IsIndex				TRUE
                Tooltip				~Select how to name exported image~

	Define: UseFileNamePrompt Using DDWinCtrlDef AsSymbol UseFileNamePrompt 
		Fields: TypeName		button
				Text			Translate( ~Use~ )
				DActionsText	ACTION EXEC ( OnUseFileNameOption() )
				Tooltip			~Paste the selected macro into the File Name at the insertion point~
				Position		FileNameComboBox(Getright,Position)+$hGap,FileNameComboBox(GetTop,Position),$StaticTextWidth,$StaticTextHeight

	Define: QueueNameStaticText Using DDWinCtrlDef AsSymbol QueueNameStaticText
		Fields:	TypeName		StaticText
				Text			Translate(~Queue~)
				RightJustified	TRUE
				Position		FileNameOptionsPrompt(GetLeft,Position),UseFileNamePrompt(GetBottom,Position) + $vGap* 6,$StaticTextWidth,$StaticTextHeight;

	Query = ~Select QueueName From QueueDefinition Where PrinterModel = 'Disk' Order By QueueName~;

	Define: QueueNameComboBox Using DDWinCtrlDef AsSymbol QueueNameComboBox
		Fields:	TypeName			SComboBox
				GenConName			THIS
				GenConField			~QueueName~
				Position			QueueNameStaticText(GetRight,Position)+$hGap,QueueNameStaticText(GetTop,Position),200,$StaticTextHeight*4
                IActionsText		ACTION EXEC ( RefreshQueueComboBox(TRUE) )
				DActionsText		ACTIONS ( Save "Exec(NewQueueNameSelected())" )
				OActionsText		~[Save]~ 
				DropDownActionsText ACTION CALL ( RefreshQueueComboBox(TRUE)  )
				Tooltip				~Select the Disk Queue that will render the image(s)~;

	Define: QueueStatusStaticText Using DDWinCtrlDef AsSymbol QueueStatusStaticText
		Fields:	TypeName		StaticText
				GenConName		THIS
				GenConField		~QueueStatus~	
				Position		QueueNameComboBox(GetRight,Position)+$hGap*2,QueueNameComboBox(GetTop,Position)+3,80,$StaticTextHeight*2;

	Define: SeePrintersButton Using DDWinCtrlDef AsSymbol SeePrintersButton 
		Fields: TypeName		Button
				Text			Translate( ~?~ )
				DActionsText	ACTION EXEC ( SeePrintersForDisk() )
				Position		UseFileNamePrompt(GetLeft,Position),QueueNameComboBox(GetTop,Position),20,$StaticTextHeight
				Tooltip			~View the renderers that are rendering to disk~;

	Define: CheckQueueButton Using DDWinCtrlDef AsSymbol CheckQueueButton 
		Fields: TypeName		Button
				Text			Translate( ~Refresh~ )
				DActionsText	ACTION EXEC ( RefreshQueueStatus() )
				Position		SeePrintersButton(Getright,Position)+$hGap*3,QueueNameComboBox(GetTop,Position),$StaticTextWidth,$StaticTextHeight
				Tooltip			~Check again to see if any renderers are rendering to disk~;
 
}


VOID DefineProcessAfterTabControls(x,y)
{
	Define: ScriptPrompt Using DDWinCtrlDef AsSymbol ScriptPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Script~ )
				RightJustified	TRUE
				Position		$x,$y,$StaticTextWidth,$StaticTextHeight

	Define: ScriptField Using DDWinCtrlDef AsSymbol ScriptField 
		Fields: TypeName		EditText  
				Position		ScriptPrompt(GetRight,Position) + $hGap,ScriptPrompt(GetTop,Position)-2,<PathTextWidth>,<EditTextHeight> 
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConName       THIS
				GenConField		~ProcessAfterFile~
				Tooltip         ~Select a script to run after the last image is written~;

	Define: BrowseProcessAfterButton Using DDWinCtrlDef AsSymbol BrowseProcessAfterButton 
        Fields: TypeName		Button
                Text			Translate( ~?~ )
				Position		ScriptField(GetRight,Position)+$hGap,ScriptField(GetTop,Position),20,20
                DActionsText	ACTION EXEC ( BrowseForProcessAfterFile() ) 
                Tooltip			Translate( ~Browse to find the process after script~ );

	Define: TriggerPrompt Using DDWinCtrlDef AsSymbol TriggerPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Trigger~ )
				RightJustified	TRUE
				Position		ScriptPrompt(GetLeft,Position),ScriptPrompt(GetBottom,Position)+$vGap,ScriptPrompt(GetWidth,Position),<EditTextHeight> 

	Define: TriggerField Using DDWinCtrlDef AsSymbol TriggerField 
		Fields: TypeName		EditText  
				Position		TriggerPrompt(GetRight,Position) + $hGap,TriggerPrompt(GetTop,Position)-2,<PathTextWidth>,<EditTextHeight> 
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConName       THIS
				GenConField		~ProcessAfter~
				Tooltip         ~Enter an optional trigger to invoke a routine in the file.~;
}


/*
 * Display controls in Bravo Tab of window.
 */
VOID DefineBravoTabControls(x,y)
{
    BravoTextWidth = $StaticTextWidth + 70;
	Define: BravoNumCopiesPrompt Using DDWinCtrlDef AsSymbol BravoNumCopiesPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Number of Copies~ )
				RightJustified	TRUE
				Position		$x+10,$y,$BravoTextWidth,$StaticTextHeight
				Tooltip			~How many copies of each CD to produce.~

	Define: BravoNumCopiesEditText Using DDWinCtrlDef  AsSymbol BravoNumCopiesEditText
		fields:	TypeName		MaskedEditText
				Position		BravoNumCopiesPrompt(GetRight,Position)+$hGap,BravoNumCopiesPrompt(GetTop,Position),24,$StaticTextHeight
				GenConField		~BravoNumCopies~
				GenConName		This
				Mask			~##~
				AllowedChars	~-~
				PromptChar		~ ~	
				IActionsText	ACTIONS ( Get )	
				OActionsText	ACTIONS ( Save )
				DActionsText	ACTIONS ( Save )
				Tooltip			~How many copies of each CD to produce.~

	Define: BravoOneRollPerCDPrompt Using DDWinCtrlDef AsSymbol BravoOneRollPerCDPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Limit to one roll per CD?~ )
				RightJustified	TRUE
				Position		BravoNumCopiesPrompt(GetLeft,Position),BravoNumCopiesPrompt(GetBottom,Position),$BravoTextWidth,$StaticTextHeight
                Tooltip			Translate( ~If checked, only one roll will be written on each CD.~ );

	Define: BravoOneRollPerCDBox Using DDWinCtrlDef AsSymbol BravoOneRollPerCDBox 
        Fields: TypeName		CheckBox
                Text			Translate( ~~ )
				Position		BravoOneRollPerCDPrompt(GetRight,Position)+$hGap,BravoOneRollPerCDPrompt(GetTop,Position),60,$ButtonHeight
                IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
                GenConName       THIS
                GenConField		~BravoOneRollPerCD~
                Tooltip			Translate( ~If checked, only one roll will be written on each CD.~ );

	Define: BravoQueuePrompt Using DDWinCtrlDef AsSymbol BravoQueuePrompt
		Fields: TypeName		StaticText
				Text			Translate( ~Print Queue~ )
				RightJustified	TRUE
				Position		BravoOneRollPerCDPrompt(GetLeft,Position),BravoOneRollPerCDPrompt(GetBottom,Position),$BravoTextWidth,$StaticTextHeight
                Tooltip			Translate( ~There is only one Bravo II queue, so the user cannot change this setting.~ );

    // This box is actually permanently greyed out, since the queue is
    // hard-wired for Bravo. But it does display the hard-wired queue as
    // a reminder to the administrator.
    //
	Define: BravoQueueBox Using DDWinCtrlDef AsSymbol BravoQueueBox 
        Fields: TypeName		EditText
                Text			Translate( ~~ )
				Position		BravoQueuePrompt(GetRight,Position)+$hGap,BravoQueuePrompt(GetTop,Position),80,$ButtonHeight
                IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
                GenConName       THIS
                GenConField		~BravoQueue~
                Tooltip			Translate( ~There is only one Bravo II queue, so the user cannot change this setting.~ );

	Define: BravoFinaliseCDButton Using DDWinCtrlDef AsSymbol BravoFinaliseCDButton 
		Fields: TypeName		button
				Text			Translate( ~Finalise CD(s)~ )
				DActionsText	ACTION EXEC ( OnBravoFinaliseCDButton(TRUE) )
				Tooltip			~Schedule the images selected (and Exported) to be burnt on Bravo~
				Position		BravoQueuePrompt(GetLeft,Position),BravoQueuePrompt(GetBottom,Position)+$vGap,70,$ButtonHeight

	Define: BravoEnabled Using DDWinCtrlDef AsSymbol BravoEnabled
        Fields: TypeName		CheckBox
                Text			Translate( ~Bravo Functionality Enabled?~ )
				Position		$x+500,$y+140,150,$ButtonHeight
                IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
                GenConName       THIS
                GenConField		~BravoEnabled~
                Tooltip			Translate( ~If checked, then Bravo functionality supercedes any other settings in this dialog, where necessary. This must be ticked/unticked BEFORE the "Export" or "Finalise" button is first pressed.~ );
}
VOID DefineCDTabControls(x,y)
{
	Define: WritersPrompt Using DDWinCtrlDef AsSymbol WritersPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~RImage Writer~ )
				RightJustified	TRUE
				Position		$x+10,$y,$StaticTextWidth+25,$StaticTextHeight

	Define: WritersComboBox Using DDWinCtrlDef AsSymbol WritersComboBox 
		Fields: TypeName        SComboBox  
				Position		WritersPrompt(GetRight,Position) + $hGap,WritersPrompt(GetTop,Position)-2,<StaticTextWidth>*4,<ComboBoxHeight>
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save )
				OActionsText	ACTIONS ( Save )
				GenConName		THIS
				GenConField		~RImageWriter~
				DropDownActionsText ACTION CALL ( UpdateRimageWritersList(TRUE)  )
				Tooltip			~Select the RImage writer to use~

	Define: OpenWritersButton Using DDWinCtrlDef AsSymbol OpenWritersButton 
        Fields: TypeName		Button
                Text			Translate( ~?~ )
				Position		WritersComboBox(GetRight,Position)+$hGap,WritersComboBox(GetTop,Position),20,$ButtonHeight
				DActionsText	ACTION EXEC ( OnOpenWritersBox() ) 
                Tooltip			Translate( ~See the defined RImage writers~ );


	Define: RImageEnabledBox Using DDWinCtrlDef AsSymbol RImageEnabledBox 
        Fields: TypeName		CheckBox
                Text			Translate( ~Enabled~ )
				Position		OpenWritersButton(GetRight,Position)+$hGap,OpenWritersButton(GetTop,Position),60,$ButtonHeight
                IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
                GenConName       THIS
                GenConField		~RImageEnabled~
                Tooltip			Translate( ~If checked, Images will be written to CD.~ );

	Define: OpenRImageOrdersButton Using DDWinCtrlDef AsSymbol OpenRImageOrdersButton 
        Fields: TypeName		Button
                Text			Translate( ~Jobs~ )
				Position		RImageEnabledBox(GetRight,Position)+$hGap,RImageEnabledBox(GetTop,Position),50,$ButtonHeight
				DActionsText	ACTION EXEC ( OnOpenRImageOrders() ) 
                Tooltip			Translate( ~See the RImage jobs for this writer~ );

	Define: TemplatePrompt Using DDWinCtrlDef AsSymbol TemplatePrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Template~ )
				RightJustified	TRUE
				Position		WritersPrompt(GetLeft,Position),WritersPrompt(GetBottom,Position)+4,WritersPrompt(GetWidth,Position),<StaticTextHeight>

	Define: TemplateComboBox Using DDWinCtrlDef AsSymbol TemplateComboBox 
		Fields: TypeName        SComboBox  
				Position		TemplatePrompt(GetRight,Position) + $hGap,TemplatePrompt(GetTop,Position)-2,<StaticTextWidth>*4,<ComboBoxHeight>
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save )
				OActionsText	ACTIONS ( Save )
				GenConName		THIS
				GenConField		~RimageTemplate~
				DropDownActionsText ACTION CALL ( PopulateRImageTemplateCombo()  )
				Tooltip			~Select the template that describes how to write to CD.  Only templates that have file lists can be used during exporting.~

	Define: TemplateButton Using DDWinCtrlDef AsSymbol TemplateButton 
        Fields: TypeName		Button
                Text			Translate( ~?~ )
				Position		TemplateComboBox(GetRight,Position)+$hGap,TemplateComboBox(GetTop,Position),20,$ButtonHeight
				DActionsText	ACTION EXEC ( OnTemplateBox() ) 
                Tooltip			Translate( ~See the predefined templates that can be used with Export Images.~ );


	Define: CDPathPrompt Using DDWinCtrlDef AsSymbol CDPathPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Output Media Path~ )
				RightJustified	TRUE
				Position		TemplatePrompt(GetLeft,Position),TemplatePrompt(GetBottom,Position)+4,WritersPrompt(GetWidth,Position),<StaticTextHeight>

	Define: CDPathField Using DDWinCtrlDef AsSymbol CDPathField 
		Fields: TypeName		MLEditText  
				Position		CDPathPrompt(GetRight,Position)+2 + $hGap,CDPathPrompt(GetTop,Position),<PathTextWidth>-16,<EditTextHeight>*3 
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConName       THIS
				GenConField		~RImageCDPath~
				NoHorizontalScroll 1
				Tooltip         ~The file name pattern to use for placing the file on CD. It should contain macros or other wildcards to create unique file names.~;

	Define: DeleteAfterBox Using DDWinCtrlDef AsSymbol DeleteAfterBox 
		Fields: TypeName		CheckBox
				Text			Translate( ~Delete After~ )
				Position		CDPathField(GetRight,Position)+$hGap,CDPathField(GetTop,Position),80,$ButtonHeight
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
				GenConName       THIS
				GenConField		~DeleteAfterRImage~
				Tooltip			Translate( ~If checked, the exported images will be deleted after they are written to the RImage~ );

	Define: CDPathOptionsPrompt Using DDWinCtrlDef AsSymbol CDPathOptionsPrompt 
		Fields: TypeName		StaticText
				Text			Translate( ~Options~ )
				RightJustified	TRUE
				Position		CDPathPrompt(GetLeft,Position),CDPathField(GetBottom,Position) + $vGap*2,WritersPrompt(GetWidth,Position),$StaticTextHeight

	Define:CDPathComboBox Using DDWinCtrlDef AsSymbol CDPathComboBox 
        Fields: TypeName			SComboBox  
                Position			CDPathOptionsPrompt(GetRight,Position) + $hGap,CDPathOptionsPrompt(Gettop,Position),300 ,<ComboBoxHeight> 
                IActionsText		ACTION EXEC ( RefreshCDPathChoicesComboBox(TRUE) )
                OActionsText		~[Save]~
                GenConName			THIS
                GenConField			~CDPathOptions~
				IsIndex				TRUE
                Tooltip				~Select how to name images on CD~

	Define: UseCDPathPrompt Using DDWinCtrlDef AsSymbol UseCDPathPrompt 
		Fields: TypeName		button
				Text			Translate( ~Use~ )
				DActionsText	ACTION EXEC ( OnUseCDPathOption() )
				Tooltip			~Paste the selected macro into the File Name at the insertion point~
				Position		CDPathComboBox(Getright,Position)+$hGap,CDPathComboBox(GetTop,Position),$StaticTextWidth,$StaticTextHeight
}

VOID DefineTextTabControls(x,y,TBNUM)
{
	Define: TextStaticText<TBNUM> Using DDWinCtrlDef AsSymbol TextStaticText<TBNUM> 
		Fields: TypeName		StaticText
				Text			Translate( ~Text~ )
				Position		$x+10,$y,$StaticTextWidth-40,$StaticTextHeight


	Define: TextEditText<TBNUM> Using DDWinCtrlDef AsSymbol TextEditText<TBNUM> 
		Fields: TypeName		MLEditText  
				Position		TextStaticText<TBNUM>(GetRight,Position)+2 + $hGap,TextStaticText<TBNUM>(GetTop,Position),250,<EditTextHeight>*3
				UseSystemFont	T
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConField		~Text<TBNUM>~
				DisallowedChars  ~<$Chr.tilde>~
				Tooltip         ~Enter the text you want to place over the image~;


	ypos	= TextEditText<TBNUM>(GetTop,Position) + 12;
	TextStaticTextWidth = 40;
	TextEditTextWidth = 60;

	Define: TextXStaticText<TBNUM> Using DDWinCtrlDef AsSymbol TextXStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~X (%):~
			Position TextEditText<TBNUM>(GetRight,Position)+ 14 + $hGap + 3, <ypos> $TextStaticTextWidth+8 20;

	Define: TextXEditText<TBNUM> Using DDWinCtrlDef AsSymbol TextXEditText<TBNUM>
	fields:	TypeName MaskedEditText
			Position TextXStaticText<TBNUM>(GetRight,Position)+1, TextXStaticText<TBNUM>(GetTop,Position) , $TextEditTextWidth-20, 20
			Mask		 ~############~  
			AllowedChars ~.-~
			GenConField ~TextXPercent<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set horizontal text center as a percentage of image width.  A value of 50 centers it.  A value greater than 50 moves it right, and a value less than 50 moves it left.~;

	Define: TextYStaticText<TBNUM> Using DDWinCtrlDef AsSymbol TextYStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Y (%):~
			Position TextXEditText<TBNUM>(GetRight,Position)+10, <ypos> $TextStaticTextWidth+11 20;

	Define: TextYEditText<TBNUM> Using DDWinCtrlDef AsSymbol TextYEditText<TBNUM>
	fields:	TypeName MaskedEditText
			Position TextYStaticText<TBNUM>(GetRight,Position)+1, <ypos> , $TextEditTextWidth-20, 20
			Mask		 ~############~  
			AllowedChars ~.-~
			GenConField ~TextYPercent<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set vertical text center as a percentage of the image width.  A value of 50 centers it.  A value greater than 50 moves it down, and a value less than 50 moves it up.~;

	ypos = <ypos> + 30;
	Define: TextWidthStaticText<TBNUM> Using DDWinCtrlDef AsSymbol TextWidthStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Width (%):~
			Position TextXStaticText<TBNUM>(GetLeft,Position), <ypos> $TextStaticTextWidth+8 20;

	Define: TextWidthEditText Using DDWinCtrlDef AsSymbol TextWidthEditText
	fields:	TypeName MaskedEditText
			Position TextWidthStaticText<TBNUM>(GetRight,Position)+1, <ypos> , $TextEditTextWidth-21, 20
			Mask		 ~############~  
			AllowedChars ~.~
			GenConField ~TextWidthPercent<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set text width as a percentage of the image width.~;

	Define: TextHeightStaticText<TBNUM> Using DDWinCtrlDef AsSymbol TextHeightStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Height (%):~
			Position TextWidthEditText(GetRight,Position)+8, <ypos> $TextStaticTextWidth+15 20;

	Define: TextHeightEditText<TBNUM> Using DDWinCtrlDef AsSymbol TextHeightEditText<TBNUM>
	fields:	TypeName MaskedEditText
			Position TextHeightStaticText<TBNUM>(GetRight,Position)+1, <ypos> , $TextEditTextWidth-21, 20
			Mask		 ~############~  
			AllowedChars ~.~
			GenConField ~TextHeightPercent<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set text height as a percentage of the image height.~;

	Define: TextColorButton<TBNUM><TBNUM> Using DDWinCtrlDef AsSymbol TextColorButton<TBNUM>
	fields:	TypeName Button
			Position	TextStaticText<TBNUM>(GetLeft,Position),TextEditText<TBNUM>(GetBottom,Position) + 5,80,20 
			GenConField ~TextColor<TBNUM>~
			IActionsText ~[Get]~
			DActionsText ~[COLORDLG Save UpdateControl(TextColorEditText<TBNUM>)]~
			OActionsText ~[Save]~
			Text		Translate( ~Text Color...~)
			Tooltip ~Select the text color~;

	Define: TextColorEditText<TBNUM> Using DDWinCtrlDef AsSymbol TextColorEditText<TBNUM> 
		Fields: TypeName		EditText  
				Position		TextColorButton<TBNUM>(GetRight,Position)+2 + $hGap,TextColorButton<TBNUM>(GetTop,Position),200,$StaticTextHeight
				IActionsText	ACTIONS ( Get )
				DActionsText	ACTIONS ( Save  )
				OActionsText	ACTIONS ( Save )
				GenConField		~TextColor<TBNUM>~
				Tooltip         ~Enter the color (red, green, blue)~;

	Define: BoldBox<TBNUM> Using DDWinCtrlDef AsSymbol BoldBox<TBNUM> 
		Fields: TypeName		CheckBox
				Text			Translate( ~Bold~ )
				Position		TextColorButton<TBNUM>(GetLeft,Position),TextColorButton<TBNUM>(GetBottom,Position) + 10,80,$ButtonHeight
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
				GenConField		~BoldText<TBNUM>~
				Tooltip			Translate( ~If checked, Bold text will be used~ );

	Define: ItalicBox<TBNUM> Using DDWinCtrlDef AsSymbol ItalicBox<TBNUM> 
		Fields: TypeName		CheckBox
				Text			Translate( ~Italic~ )
				Position		BoldBox<TBNUM>(GetRight,Position) + 10,BoldBox<TBNUM>(GetTop,Position),70,$ButtonHeight
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
				GenConField		~ItalicText<TBNUM>~
				Tooltip			Translate( ~If checked, Italic text will be used~ );
	Define: WordWrapBox<TBNUM> Using DDWinCtrlDef AsSymbol WordWrapBox<TBNUM> 
		Fields: TypeName		CheckBox
				Text			Translate( ~Word Wrap~ )
				Position		ItalicBox<TBNUM>(GetRight,Position) + 5,BoldBox<TBNUM>(GetTop,Position),80,$ButtonHeight
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
				GenConField		~WordWrapText<TBNUM>~
				Tooltip			Translate( ~If checked, text will be word wrapped~ );

	Define:	FontScriptStaticText<TBNUM> Using DDWinCtrlDef AsSymbol FontScriptStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Character Set:~
			Position	BoldBox<TBNUM>(GetLeft,Position) ,BoldBox<TBNUM>(GetBottom,Position)+ 10,70,20

	Define:	CharacterSetComboBox<TBNUM> Using DDWinCtrlDef AsSymbol CharacterSetComboBox<TBNUM>
	fields: TypeName SComboBox  
			Position FontScriptStaticText<TBNUM>(GetRight,Position) + 5, FontScriptStaticText<TBNUM>(GetTop,Position) 240 80
			GenConField ~CharacterSet<TBNUM>~
			UseSystemFont T
			DActionsText	ACTION EXEC ( UpdateCharacterSetComboBox(<TBNUM>)) 
			OActionsText	ACTIONS ( Save ) 
			Tooltip ~Select a character set~; 

	Define:	FontStaticText<TBNUM> Using DDWinCtrlDef AsSymbol FontStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Font:~
			Position FontScriptStaticText<TBNUM>(GetLeft,Position), FontScriptStaticText<TBNUM>(GetBottom,Position) + 5 70 20

	Define:	FontComboBox<TBNUM> Using DDWinCtrlDef AsSymbol FontComboBox<TBNUM>
	fields: TypeName SComboBox  
			Position FontStaticText<TBNUM>(GetRight,Position) + 5, FontStaticText<TBNUM>(GetTop,Position) 240 180
			GenConField ~Font<TBNUM>~
			InsertValueIntoList ~T~
			UseSystemFont T
			DropDownActionsText	ACTIONS ( GetInstalledFonts(<TBNUM>) ) 
			IActionsText	ACTIONS ( GetInstalledFonts(<TBNUM>) ) 
			DActionsText	ACTIONS ( Save ) 
			OActionsText	ACTIONS ( Save ) 
			Tooltip ~Select a font~;

	Define: ShadowColorButton<TBNUM> Using DDWinCtrlDef AsSymbol ShadowColorButton<TBNUM>
	fields:	TypeName Button
			Position	WordWrapBox<TBNUM>(GetRight,Position)+90,WordWrapBox<TBNUM>(GetTop,Position),100,20 
			GenConField ~ShadowColor<TBNUM>~
			IActionsText ~[Get]~
			DActionsText ~[COLORDLG Save]~
			OActionsText ~[Save]~
			Text		Translate( ~Shadow Color...~)
			Tooltip ~Select the shadow color~;

	Define: HorzShadowOffsetStaticText<TBNUM> Using DDWinCtrlDef AsSymbol HorzShadowOffsetStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Horizontal Shadow Offset:~
			Position ShadowColorButton<TBNUM>(GetRight,Position)+10, ShadowColorButton<TBNUM>(GetTop,Position)  80 30;

	Define: HorzShadowOffsetEditText<TBNUM> Using DDWinCtrlDef AsSymbol HorzShadowOffsetEditText<TBNUM>
	fields:	TypeName MaskedEditText
			Position HorzShadowOffsetStaticText<TBNUM>(GetRight,Position)+3, HorzShadowOffsetStaticText<TBNUM>(GetTop,Position) + 3 , $TextEditTextWidth-20, 20
			Mask		 ~####~  
			AllowedChars ~-~
			GenConField ~HorzShadowOffset<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
			IActionsText	ACTIONS ( Get ) 
			DActionsText	ACTIONS ( Save ) 
			OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set horizontal shadow offset in pixels.~;

	Define: VertShadowOffsetStaticText<TBNUM> Using DDWinCtrlDef AsSymbol VertShadowOffsetStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Vertical Shadow Offset:~
			Position HorzShadowOffsetEditText<TBNUM>(GetRight,Position)+3, HorzShadowOffsetEditText<TBNUM>(GetTop,Position)  80 30;

	Define: VertShadowOffsetEditText<TBNUM> Using DDWinCtrlDef AsSymbol VertShadowOffsetEditText<TBNUM>
	fields:	TypeName MaskedEditText
			Position VertShadowOffsetStaticText<TBNUM>(GetRight,Position)+1, VertShadowOffsetStaticText<TBNUM>(GetTop,Position) + 3 , $TextEditTextWidth-20, 20
			Mask		 ~####~  
			AllowedChars ~-~
			GenConField ~VertShadowOffset<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
			IActionsText	ACTIONS ( Get ) 
			DActionsText	ACTIONS ( Save ) 
			OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set vertical shadow offset in pixels.~;



	Define: EnableShadowBox<TBNUM> Using DDWinCtrlDef AsSymbol EnableShadowBox<TBNUM> 
		Fields: TypeName		CheckBox
				Text			Translate( ~Enable Shadows~ )
				Position		ShadowColorButton<TBNUM>(GetLeft,Position) ,ShadowColorButton<TBNUM>(GetBottom,Position) + 20,100,12
				IActionsText	ACTIONS ( Get ) 
				DActionsText	ACTIONS ( Save ) 
				OActionsText	ACTIONS ( Save ) 
				GenConField		~ShadowEnable<TBNUM>~
				Tooltip			Translate( ~If checked, shadows will be used~ );

	Define: TextTranslucenceStaticText<TBNUM> Using DDWinCtrlDef AsSymbol TextTranslucenceStaticText<TBNUM> 
		Fields: TypeName		StaticText
				Text			Translate( ~Text Translucence~ )
				Position		EnableShadowBox<TBNUM>(GetLeft,Position) ,EnableShadowBox<TBNUM>(GetBottom,Position)+10,100,20 

	Define: TextTranslucenceEditText<TBNUM> Using DDWinCtrlDef AsSymbol TextTranslucenceEditText<TBNUM> 
		Fields: TypeName		MaskedEditText  
				Position		TextTranslucenceStaticText<TBNUM>(GetRight,Position)+2 + $hGap,TextTranslucenceStaticText<TBNUM>(GetTop,Position),40,20 
				IActionsText	ACTIONS ( Get )
				DActionsText	~[Save]~
				OActionsText	~[Save]~
				GenConField		~TextTranslucence<TBNUM>~
				Mask		 ~####~
				Tooltip         ~Enter text translucence.  A value of 0 will show the full strength of the text.  A value of 100 will show no text.  A value of 50 will blend the text and the image.~;

	Define: ShadowBlurStaticText<TBNUM> Using DDWinCtrlDef AsSymbol ShadowBlurStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Shadow Blur:~
			Position EnableShadowBox<TBNUM>(GetRight,Position)+10, EnableShadowBox<TBNUM>(GetTop,Position)  80 16;

	Define: ShadowBlurEditText Using DDWinCtrlDef AsSymbol ShadowBlurEditText
	fields:	TypeName MaskedEditText
			Position ShadowBlurStaticText<TBNUM>(GetRight,Position)+3, ShadowBlurStaticText<TBNUM>(GetTop,Position) + 3 , $TextEditTextWidth-20, 20
			Mask		 ~####~  
			AllowedChars ~~
			GenConField ~ShadowBlur<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
			IActionsText	ACTIONS ( Get ) 
			DActionsText	ACTIONS ( Save ) 
			OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set shadow blur 0 -> 100~;

	Define: ShadowStrengthStaticText<TBNUM> Using DDWinCtrlDef AsSymbol ShadowStrengthStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Shadow Strength:~
			Position ShadowBlurEditText(GetRight,Position)+3, ShadowBlurEditText(GetTop,Position)  80 30;

	Define: ShadowStrengthEditText Using DDWinCtrlDef AsSymbol ShadowStrengthEditText
	fields:	TypeName MaskedEditText
			Position ShadowStrengthStaticText<TBNUM>(GetRight,Position)+1, ShadowStrengthStaticText<TBNUM>(GetTop,Position) + 3 , $TextEditTextWidth-20, 20
			Mask		 ~####~  
			AllowedChars ~~
			GenConField ~ShadowStrength<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
			IActionsText	ACTIONS ( Get ) 
			DActionsText	ACTIONS ( Save ) 
			OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set shadow strength 0 -> 100~;

	Define: AngleStaticText<TBNUM> Using DDWinCtrlDef AsSymbol AngleStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Rotation:~
			Position TextYEditText<TBNUM>(GetRight,Position) + 10, TextYEditText<TBNUM>(GetTop,Position)  50 20;

	Define: AngleEditText<TBNUM> Using DDWinCtrlDef AsSymbol AngleEditText<TBNUM>
	fields:	TypeName MaskedEditText
			Position AngleStaticText<TBNUM>(GetRight,Position) + 2, AngleStaticText<TBNUM>(GetTop,Position) , 50, 20
			Mask		 ~#########~  
			AllowedChars ~-.~
			GenConField ~Angle<TBNUM>~
			PromptChar	 ~ ~		
			InsertOn	~T~	
			IActionsText	ACTIONS ( Get ) 
			DActionsText	ACTIONS ( Save ) 
			OActionsText	ACTIONS ( Save ) 
			Tooltip ~Set arbitrary text angle 0 -> 360 degrees~;

	Define: JustificationStaticText<TBNUM> Using DDWinCtrlDef AsSymbol JustificationStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Just:~
			Tooltip ~Justification~
			Position AngleEditText<TBNUM>(GetRight,Position) + 10, AngleEditText<TBNUM>(GetTop,Position)  25 20;

	Define: TextJustificationComboBox<TBNUM> Using DDWinCtrlDef AsSymbol TextJustificationComboBox<TBNUM> 
        Fields: TypeName		SComboBox  
                 Position		JustificationStaticText<TBNUM>(Getright,Position) + $hGap ,
								JustificationStaticText<TBNUM>(GetTop,Position),<SmallStaticTextWidth>+5, <ComboBoxHeight> 
               GenConField		~TextJustification<TBNUM>~
				IActionsText	ACTIONS ( GetList(TextJustificationChoices) Get )
				DActionsText	ACTIONS ( SAVE )
				OActionsText	ACTIONS ( SAVE )
				DropDownActionsText	ACTION EXEC ( PopulateJustificationCombo(<TBNUM>) )
                Tooltip			~Select Left, Center or Right horizontal text justification~ ;



	Define: TextRotationPrompt<TBNUM> Using DDWinCtrlDef AsSymbol TextRotationPrompt<TBNUM>
		Fields:	TypeName		StaticText
				Text			Translate( ~Orientation:~)
				Position		AngleStaticText<TBNUM>(GetLeft,Position),AngleEditText<TBNUM>(GetBottom,Position)+10,55,20 

	Define: TextRotationComboBox<TBNUM> Using DDWinCtrlDef AsSymbol TextRotationComboBox<TBNUM> 
        Fields: TypeName		SComboBox  
                 Position		TextRotationPrompt<TBNUM>(Getright,Position) + $hGap ,
								TextRotationPrompt<TBNUM>(GetTop,Position),<SmallStaticTextWidth>-8, <ComboBoxHeight> 
               GenConField		~TextRotation<TBNUM>~
				IActionsText	ACTIONS ( GetList(TextRotationChoices) Get )
				DActionsText	ACTIONS ( SAVE )
				OActionsText	ACTIONS ( SAVE )
				DropDownActionsText	ACTION EXEC ( PopulateTextRotationCombo(<TBNUM>) )
                Tooltip			~Select 90 for top to bottom, 180 for upside down, 270 for bottom to top flow~ ;

	Define: AlignmentStaticText<TBNUM> Using DDWinCtrlDef AsSymbol AlignmentStaticText<TBNUM>
	fields:	TypeName StaticText
			Text ~Align:~
			Tooltip ~Alignment~
			Position TextRotationComboBox<TBNUM>(GetRight,Position) + 10, TextRotationComboBox<TBNUM>(GetTop,Position)  25 20;

	Define: TextAlignmentComboBox<TBNUM> Using DDWinCtrlDef AsSymbol TextAlignmentComboBox<TBNUM> 
        Fields: TypeName		SComboBox  
                 Position		AlignmentStaticText<TBNUM>(Getright,Position) + $hGap ,
								AlignmentStaticText<TBNUM>(GetTop,Position),<SmallStaticTextWidth>+5, <ComboBoxHeight> 
               GenConField		~TextAlignment<TBNUM>~
				IActionsText	ACTIONS ( GetList(TextAlignmentChoices) Get )
				DActionsText	ACTIONS ( SAVE )
				OActionsText	ACTIONS ( SAVE )
				DropDownActionsText	ACTION EXEC ( PopulateAlignmentCombo(<TBNUM>) )
                Tooltip			~Select Top, Center or Bottom vertical text Alignment~ ;

	Define: PositionGroupBox<TBNUM> Using DDWinCtrlDef
	fields:	TypeName GroupBox
			Text ~Position~
			Position		TextXStaticText<TBNUM>(GetLeft,Position)-15 + $hGap,TextStaticText<TBNUM>(GetTop,Position)-8,415,<EditTextHeight>*3+20;

	Define: ShadowsGroupBox<TBNUM> Using DDWinCtrlDef
	fields:	TypeName GroupBox
			Text ~Shadows and Translucence~
			Position		ShadowColorButton<TBNUM>(GetLeft,Position)-10 ,ShadowColorButton<TBNUM>(GetTop,Position)-15,380,<EditTextHeight>*3+45;
}


NUMERIC PopulateRImageTemplateCombo()
{
	Query = ~Select Distinct ID From RImageTemplates Where FileType = 0 Order By ID~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Failed to query the Rolls table.\n\n<Query>\n\n<theErr>~ ) ); 
	}

	List( MakeStringList,TemplateList,ID );

	return dlg( SetControlFromStringList,TemplateComboBox,TemplateList,~NoSelection~ );
}


NUMERIC PopulateTextRotationCombo(TBNUM)
{

	StringList( TextRotationChoices,New );
	TextRotationChoices( AddString,~0~ );
	TextRotationChoices( AddString,~90~ );
	TextRotationChoices( AddString,~180~ );
	TextRotationChoices( AddString,~270~ );

	return dlg( SetControlFromStringList,TextRotationComboBox<TBNUM>,TextRotationChoices,~NoSelection~ );
}

NUMERIC PopulateJustificationCombo(TBNUM)
{
	StringList( TextJustificationChoices,New );
	TextJustificationChoices( AddString,~Left~ );
	TextJustificationChoices( AddString,~Center~ );
	TextJustificationChoices( AddString,~Right~ );
	return dlg( SetControlFromStringList,TextJustificationComboBox<TBNUM>,TextJustificationChoices,~NoSelection~ );
}

NUMERIC PopulateAlignmentCombo(TBNUM)
{
	StringList( TextAlignmentChoices,New );
	TextAlignmentChoices( AddString,~Top~ );
	TextAlignmentChoices( AddString,~Center~ );
	TextAlignmentChoices( AddString,~Bottom~ );

	return dlg( SetControlFromStringList,TextAlignmentComboBox<TBNUM>,TextAlignmentChoices,~NoSelection~ );
}

// Called when user clicks Finalise CD button on Bravo tab.
//
// Count up the number of images in the batch, then prompt the user if they
// are sure they want to burn the CD.
//
// If the user confirms, populate the database BravoBatch table with info
// on the batch-wide parameters. Then set all the entries for this batch
// in the JobQueue table to Ready.
//
// Finally, resets state so the user can enter a new batch.
//
// Returns TRUE on success.
//
NUMERIC OnBravoFinaliseCDButton( warn )
{
	ReenableControls();	

    dlg( GetInput );

    BatchID = ~<BravoBatchID>~;
    OrderID = ~<$con.DlgData[OrderID]>~;
    NumCopies = ~<$con.DlgData[BravoNumCopies]>~;
    OneRollPerCD = ~<$con.DlgData[BravoOneRollPerCD]>~;
    
    // Get a count of the number of images in this batch.
    //
    Cmd = ~SELECT OrderItemID FROM JobQueue WHERE BatchID='<BatchID>' AND PrintStatus = 8~;
    count = ADO( dBase, Connect, RecordCountFor, ~<Cmd>~ );
    if ( $count == 0 )
    {
        ShowWarning( ~Cannot finalise for CD as no images have been selected for Batch <BatchID>.
Select images and click "Export" button before attempting to finalise.~ );
        return TRUE;
    }
    else if ( $count < 0 )
    {
        dBase( GetErrorDescription,theErr );
        Log( Session, ~OnBravoFinaliseCDButton: RecordCountFor failed: <theErr> (BatchID=<BatchID>)~ );
        ShowWarning( ~Job Aborted.
Cmd Failed.  <theErr>.  <Cmd>~ );
        CleanupDatabase( dBase,~~,~<BatchID>~ );
        return FALSE;
    }

    if (<warn>)
    {
        if ( MessageBox( ~Are you sure you want to burn <Count> image (including thumbnails) on CD?~,YESNO ) != YES )
        {
            return FALSE;
        }
    }

    // Create record in BravoBatch table with batch-wide settings for this
    // batch.
    //
    Cmd = ~INSERT INTO BravoBatch( BatchID, OrderID, NumCopies, OneRollPerCD ) Values('<BatchID>','<OrderID>','<NumCopies>','<OneRollPerCD>')~;

    if ( !dBase( Cmd, ~<Cmd>~ ) )
    {
        dBase( GetErrorDescription,theErr );
        Log( Session, ~OnBravoFinaliseCDButton: Insert into BravoBatch failed: <theErr> (BatchID=<BatchID>) (Cmd=<Cmd>)~ );
        ShowWarning( ~Cmd Failed.  <theErr>.  <Cmd>~ );
        CleanupDatabase( dBase,~~,~<BatchID>~ );
        return FALSE;
    }
    
    // Change the jobs to ready and let em rip!

    Cmd = ~Update JobQueue Set PrintStatus = 1 Where BatchID = '<BatchID>' AND PrintStatus = 8~;

    if ( !dBase( Cmd, ~<Cmd>~ ) )
    {
        dBase( GetErrorDescription,theErr );
        Log( Session, ~OnBravoFinaliseCDButton: Connect failed: <theErr> (BatchID=<BatchID>)~ );
        ShowWarning( ~Cmd Failed.  <theErr>.  <Cmd>~ );
        CleanupDatabase( dBase,~~,~<BatchID>~ );
        return FALSE;
    }

    ShowProgress( ~<count> images (including thumbnails) finalised for burning on Bravo in batch <BatchID>.~ );

    // Once done... BatchID to use for next bunch of CDs, IF the user continues
    // to use the current ExportImages dialog.
    BravoBatchID = UniquePrintBatchID();
	DlgData( SetValues,BatchID,~<BravoBatchID>~ );

    // Keep track that all exported images have been finalised.
    BravoExportsPending = 0;
    if ( $Remote == <BravoExport> )
    {
        UpdateStatus(~<OrderID>~, <ConversionExportFinaliseDone>, ~BravoStatus~);
    }
    return TRUE;
}

NUMERIC OnOpenWritersBox()
{
	Query = ~Select * From RImageWriters Order By ID~;

	Actions = ACTION Doc ( ~RImageDoc~ OpenOnce RImageDoc "Init();" );

	return PerformActions( Actions );
}

NUMERIC OnTemplateBox()
{
	Query = ~Select * From RImageTemplates Order By ID~;

	Actions = ACTION Doc ( ~RImageTemplatesDoc~ OpenOnce RImageTemplatesDoc "Init( ~All~,~<Query>~ );" );

	return PerformActions( Actions );
}

VOID OnSharpenMethodCheckBox()
{
	dlg( GetInput );

	WantAdaptive = DlgData(GetNumeric,AdaptiveSharpen );

	dlg( EnableControls,<WantAdaptive>,LimitValueEditText,LimitValueSlider,ThresholdEditText,
			ThresholdSlider,AdaptiveSharpenBlurEditText,AdaptiveSharpenBlurSlider   );
}

VOID OnForceColorManagementOff()
{
	ChooseProfiles = DlgData(GetNumeric,ChooseProfiles );
	ForceColorManagementOff = DlgData(GetNumeric,ForceColorManagementOff );

	if (<ForceColorManagementOff>)
	{
		// clear choose profiles
		dlg( SetCheck,FALSE,ChooseProfilesBox );
		DlgData( SetValue, ChooseProfiles, 0);
//		dlg( SetCheck,FALSE,EnableProfileBox );
		dlg( EnableControls,FALSE,InputProfileComboBox,WorkingSpaceProfileComboBox,OutputProfileComboBox,EnableProfileBox);
	}
	else
	{
		dlg( EnableControls,TRUE,OutputProfileComboBox, EnableProfileBox);
		dlg( EnableControls,FALSE,InputProfileComboBox,WorkingSpaceProfileComboBox);
	}

}



VOID OnEmbedProfileBox()
{
	Embed = DlgData(GetNumeric,EmbedProfile );
	if (<Embed>)
	{
		dlg( EnableControls,TRUE,EmbedProfileComboBox);
	}
	else
	{
		dlg( EnableControls,FALSE,EmbedProfileComboBox);
	}

}

VOID OnChooseProfiles()
{
	dlg( GetInput );

	ChooseProfiles = DlgData(GetNumeric,ChooseProfiles );
	ForceColorManagementOff = DlgData(GetNumeric,ForceColorManagementOff );

	if (<ChooseProfiles>)
	{
		dlg( SetCheck,FALSE,ForceColorManagementOffBox );
		DlgData( SetValue, ForceColorManagementOff, 0);
		dlg( EnableControls,TRUE,InputProfileComboBox,WorkingSpaceProfileComboBox);
		dlg( EnableControls,TRUE,OutputProfileComboBox,EnableProfileBox);
	}
	else
	{
		dlg( EnableControls,FALSE,InputProfileComboBox,WorkingSpaceProfileComboBox);
		dlg( EnableControls,TRUE,OutputProfileComboBox,EnableProfileBox);
	
	}

}

VOID OnRotationButton()
{
	dlg( GetInput );

	if ( DlgData( GetNumeric,AutoRotate ) == 90 )
	{
		dlg( SetCheck,TRUE,AutoRotateRadioButton90 );
		dlg( SetCheck,FALSE,AutoRotateRadioButton270,AutoRotateRadioButtonOff );
	}
	else if ( DlgData( GetNumeric,AutoRotate ) == 270 )
	{
		dlg( SetCheck,TRUE,AutoRotateRadioButton270 );
		dlg( SetCheck,FALSE,AutoRotateRadioButton90,AutoRotateRadioButtonOff );
	}
	else
	{
		dlg( SetCheck,TRUE,AutoRotateRadioButtonOff );
		dlg( SetCheck,FALSE,AutoRotateRadioButton90,AutoRotateRadioButton270 );
	}
}


VOID RefreshFileNameChoicesComboBox()
{
	StringList( ChoiceList,New,InListOrder,AddStrings,
				~Order\Frame~,
				~Order\Roll\Frame~,
				~Order\Roll\FileName~,
				~Order\FileName~,
				~Incrementing Sequence~,
				~Order~,
				~Roll~,
				~Frame~,
				~FileName~,
				~FileName Without Extension~,
				~Extension~,
				~Image Folder~,
				~Roll Folder~,
				~RImage Job ID~
				 );

	dlg( SetControlFromStringList,FileNameComboBox,ChoiceList,Selection );
}


VOID RefreshCDPathChoicesComboBox()
{
	StringList( ChoiceList,New,InListOrder,AddStrings,
				~Order\Frame~,
				~Order\Roll\Frame~,
				~Order\Roll\FileName~,
				~Order\FileName~,
				~Incrementing Sequence~,
				~Order~,
				~Roll~,
				~Frame~,
				~FileName~,
				~FileName Without Extension~,
				~Extension~,
				~Image Folder~,
				~Roll Folder~,
				~RImage Job ID~
				 );

	dlg( SetControlFromStringList,CDPathComboBox,ChoiceList,Selection );
}


VOID OnUseFileNameOption()
{
	index = dlg( ComboBox,FileNameComboBox,GetSelectedIndex );

	i = 0;

	if ( <index> == <i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderFramePathForNode(1)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderRollFramePathForNode(1)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderRollFileNamePathForNode(1)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderFileNamePathForNode(1)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.IncrementingSequence(3)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,OrderID)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Roll)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Frame)>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).FileName>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).FileName.WithoutExt>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).Ext>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).Path>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}	
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).ParentFolder>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}	
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<RImageJobID>~ ); MACROSON
		dlg( EditText,FileNameField,Paste ); 
	}
}



VOID OnUseCDPathOption()
{
	index = dlg( ComboBox,CDPathComboBox,GetSelectedIndex );

	i = 0;

	if ( <index> == <i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderFramePathForNode(1)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderRollFramePathForNode(1)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderRollFileNamePathForNode(1)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.OrderFileNamePathForNode(1)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.IncrementingCDPathSequence(3)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,OrderID)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Roll)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Frame)>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).FileName>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).FileName.WithoutExt>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).Ext>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).Path>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}	
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<$@Func.ImageFieldForNode(1,Path).ParentFolder>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}	
	else if ( <index> == <++i> )
	{
		MACROSOFF dlg( CopyToClipboard,~<RImageJobID>~ ); MACROSON
		dlg( EditText,CDPathField,Paste ); 
	}
}

VOID RefreshSizeChoicesComboBox()
{
	StringList( ChoiceList,New,InListOrder,AddStrings,~Use exact width and height~,
				~Use width and calculate height proportionally~,
				~Use height and calculate width proportionally~,
				~Use longest side and calculate other side proportionally~,
				~Ignore width and height and use original size of the image~,
				~Swap exact width and height as needed for best fit~,
				~Resize by a Scale Factor (percentage)~ );

	dlg( SetControlFromStringList,SizingComboBox,ChoiceList,Selection );
}


VOID OnSizingChange()
{
	index = dlg( ComboBox,SizingComboBox,GetSelectedIndex );
	dlg( SetControlTitle,WidthStaticText,~Width~ );
	UpdateScaleFactorTooltip();

	if ( <index> == 0 || <index> == 5 )
	{
		dlg( EnableControls,TRUE,WidthEditText,HeightEditText,RotationComboBox );
		dlg( EnableControls,FALSE,ScaleFactorEditText );
		dlg( EnableControls,TRUE,XResolutionEditText );
	}
	else if ( <index> == 1 )
	{

		dlg( EnableControls,FALSE,HeightEditText );
		dlg( EnableControls,TRUE,WidthEditText,RotationComboBox );
		dlg( EnableControls,FALSE,ScaleFactorEditText );
		dlg( EnableControls,TRUE,XResolutionEditText );
	}
	else if ( <index> == 2 )
	{
		dlg( EnableControls,TRUE,HeightEditText,RotationComboBox );
		dlg( EnableControls,FALSE,WidthEditText );
		dlg( EnableControls,FALSE,ScaleFactorEditText );
		dlg( EnableControls,TRUE,XResolutionEditText );
	}
	else if ( <index> == 3 )
	{
		dlg( SetControlTitle,WidthStaticText,~Long Side~ );
		dlg( EnableControls,FALSE,HeightEditText );
		dlg( EnableControls,TRUE,WidthEditText,RotationComboBox );
		dlg( EnableControls,FALSE,ScaleFactorEditText );
		dlg( EnableControls,TRUE,XResolutionEditText );
	}
	else if ( <index> == 4 )
	{
		dlg( EnableControls,FALSE,WidthEditText,HeightEditText );
		dlg( EnableControls,FALSE,ScaleFactorEditText,RotationComboBox );
		dlg( SetControlValue,RotationComboBox,0);
		dlg( EnableControls,TRUE,XResolutionEditText );
	}
	else if ( <index> == 6 )
	{
		dlg( EnableControls,FALSE,WidthEditText,HeightEditText,RotationComboBox );
		dlg( SetControlValue,RotationComboBox,0);
		dlg( EnableControls,TRUE,ScaleFactorEditText );
		dlg( SetControlValue,XResolutionEditText,100);
		dlg( EnableControls,FALSE,XResolutionEditText );
	}
}

VOID UpdateScaleFactorTooltip()
{
	dlg( GetControlValue,ScaleFactorEditText,ScaleFactor );
	index = dlg( ComboBox,SizingComboBox,GetSelectedIndex );
	if (<index> == 6)
	{
		if ( IsNull( ~<ScaleFactor>~ ) || ~<ScaleFactor>~ == ~.~)
		{
			ScaleFactor = 100.0;
		}
		else if (<ScaleFactor> <= 0.0)
		{
			ScaleFactor = 100.0;
		}
		else if (<ScaleFactor> > 10000)
		{
			dlg( SetValueInCtrlDef, ScaleFactorEditText, ~Tooltip~, ~Scale Factor cannot be more than 10000.~);
			return;
		}

		if (<ScaleFactor> == 100.0)
		{
			dlg( SetValueInCtrlDef, ScaleFactorEditText, ~Tooltip~, ~Resize the image to <ScaleFactor> % of its original width and height.  (No resizing will occur).~);
		}
		else
		{
			dlg( SetValueInCtrlDef, ScaleFactorEditText, ~Tooltip~, ~Resize the image to <ScaleFactor> % of its original width and height~);
		}
	}
	else
	{
		dlg( SetValueInCtrlDef, ScaleFactorEditText, ~Tooltip~, ~Scale Factor not used~);
	}

}


VOID UpdateRimageImageTypeList()
{
	StringList( theStringList,New,Is,~<$[DATABASE FieldTypes].RImageType[ChoiceList]>~ );
	dlg( SetControlFromStringList,ImageTypeComboBox,theStringList,NoSelection );
}



VOID UpdateRimageWritersList(wantSelection)
{
	Query = ~Select * From RImage Order By ID~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the RImage table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	List( MakeStringList,Writers,ID );

	dlg( SetControlFromStringList,WritersComboBox,Writers,<wantSelection> ? ~Selection~ : ~NoSelection~ );
}


VOID RefreshOutputProfilesComboBox(wantSelection)
{
	Query = ~Select * From Profiles Where (Type = 'Output') Or (Type Like 'W%') And Path <> ''~;

	if ( !PGenConList( ProfilesList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ProfilesList( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	ProfilesList( MakeStringList,OutputProfiles,Name );

	dlg( SetControlFromStringList,OutputProfileComboBox,OutputProfiles,<wantSelection> ? ~Selection~ : ~NoSelection~ );
}


VOID RefreshEmbedProfilesComboBox(wantSelection)
{
	Query = ~Select * From Profiles Where (Type = 'Input') Or (Type = 'Output') Or (Type Like 'W%')  And Path <> ''~;

	if ( !PGenConList( ProfilesList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ProfilesList( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	ProfilesList( MakeStringList,OutputProfiles,Name );

	dlg( SetControlFromStringList,EmbedProfileComboBox,OutputProfiles,<wantSelection> ? ~Selection~ : ~NoSelection~ );
}


VOID RefreshInputProfilesComboBox(wantSelection)
{
	Query = ~Select * From Profiles Where (Type = 'Input' OR Type = 'WorkingSpace') And Path IS NOT NULL~;

	if ( !PGenConList( ProfilesList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ProfilesList( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	DlgData( GetValue, DefaultInputProfile, DI);
	ProfilesList( MakeStringList,InputProfiles,Name );

	dlg( SetControlFromStringList,InputProfileComboBox,InputProfiles,<wantSelection> ? ~Selection~ : ~NoSelection~ );
	dlg( SetControlValue, InputProfileComboBox, ~<DI>~);
}


VOID RefreshWorkingSpaceProfilesComboBox(wantSelection)
{
	Query = ~Select * From Profiles Where Type Like 'W%' And Path <> ''~;

	if ( !PGenConList( ProfilesList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ProfilesList( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the Profiles table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	ProfilesList( MakeStringList,WorkingSpaceProfiles,Name );

	DlgData( GetValue, WorkingSpaceProfile, WS);

	dlg( SetControlFromStringList,WorkingSpaceProfileComboBox,WorkingSpaceProfiles,<wantSelection> ? ~Selection~ : ~NoSelection~ );
	dlg( SetControlValue, WorkingSpaceProfileComboBox, ~<WS>~);
}


VOID RefreshQueueComboBox(wantSelection)
{
	Query = ~Select QueueName From QueueDefinition Where PrinterModel = 'Disk' Order By QueueName~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the QueueDefinition table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	List( MakeStringList,DiskQueues,QueueName );

	dlg( SetControlFromStringList,QueueNameComboBox,DiskQueues,<wantSelection> ? ~Selection~ : ~NoSelection~ );
}

VOID NewOutputProfileSelected(Initial)
{
	dlg( GetInput );

	OutputProfile = ~<$con.DlgData[ICCProfile]>~;
	QueueName = ~<$con.DlgData[QueueName]>~;

	dlg( EnableControls,1,EmbedProfileBox );

	if (!<Initial>)
	{
		dlg( SetCheck,TRUE,EnableProfileBox );
		DlgData( SetValue, OutputProfileEnabled, 1);
	}
}


VOID NewEmbedProfileSelected()
{
	dlg( GetInput );

	OutputProfile = ~<$con.DlgData[ICCProfile]>~;
	QueueName = ~<$con.DlgData[QueueName]>~;

	dlg( EnableControls,1,EmbedProfileBox );

}

VOID NewQueueNameSelected()
{
	dlg( GetInput );

	OutputProfile = ~<$con.DlgData[ICCProfile]>~;
	QueueName = ~<$con.DlgData[QueueName]>~;

	//dlg( SetControlTitle, EmbedProfileBox, ~Embed <OutputProfile>~ );
}

VOID RefreshQueueStatus()
{
	dlg( GetInput );

	QueueName = ~<$con.DlgData[QueueName]>~;

	if ( IsNULL( ~<QueueName>~ ) )
	{
		dlg( SetStrings,QueueStatus,~No disk print queues exist~ );
		return;
	}

	Query = ~Select * From Printers Where QueueName In (Select QueueName From QueueDefinition Where PrinterModel = 'Disk')~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the QueueDefinition table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	
	count = 0;

	while ( List(GetNext,Printer) )
	{
		if ( Printer( GetNumeric,Status ) == 1 )
		{
			++count;
		}
	}

	dlg( SetStrings,QueueStatus,~has <count> renderer(s)~ );
}


VOID SeePrintersForDisk()
{
	Query = ~Select * From Printers Where PrinterModel = 'Disk' Order By PrinterName~;

	Actions = ACTION Doc ( ~PrintersDoc~ OpenOnce PrintersDoc "Init( ~Printers Exporting To Disk~,~<Query>~ );" );

	PerformActions( Actions );
}



NUMERIC ShowWarning( Msg )
{
	return Warning( ~<Msg>~ );
}


NUMERIC ShowProgress( Msg )
{
	log( Session,~<$Job.Title>: <msg>~ );
	return dlg( SetStatus,0,~<Msg>~ );
}

Stop = FALSE;

VOID OnStopButton()
{
	Stop = TRUE;
}


NUMERIC OrderSelected()
{
	return dlg( SetControlFocus,OrderIDField );
}


NUMERIC OnOrderCombo()
{
  if ( FindOrdersLike(FALSE) )
  {
	UpdateRollsCombo( FALSE );
  }

  return OrderSelected();
}


NUMERIC FindOrdersLike()
{
	dlg( GetInput );

	StringList( EmptyList,New );

	dlg( SetControlValue,RollsCombolBox,~~ );
	dlg( SetControlFromStringList,RollsCombolBox,EmptyList );

	dlg( ListBox,ImagesListBox,ResetContent );

	if ( IsNULL(~<$con.DlgData[OrderID]>~) )
	{
		return ShowProgress( Translate( ~Enter an OrderID or enter one or more characters of the OrderID and press the ?~ ) );
	}

	Query = ~Select ID From Orders Where ID Like '<$con.DlgData[OrderID]>%' AND CustomerID <> 'Product'~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return ShowWarning( Translate( ~Query Failed.\n\n<Query>\n\n<theErr>~ ) ); 
	}

	Count = List( NumEntries );

	if ( !<Count> )
	{
		return ShowProgress( ~There are no orders that begin with <$con.DlgData[OrderID]>~ );
	}

	List( MakeStringList,OrdersList,ID );

	dlg( SetControlFromStringList,OrderIDField,OrdersList,Selection,SelectString,OrderIDField,~~  );

	return ShowProgress( Translate( ~There are <Count> order(s) that begin with <$con.DlgData[OrderID]>~ ) );
}


NUMERIC OnFileHelpButton()
{
	TheAction = ACTION SHOWHELPPAGE ( KPISHelpFile "Disk_Setup.htm" );

	return PerformActions( TheAction );
}


VOID OnFileClearButton()
{
	dlg( SetStrings,FileName,~~ );
}


NUMERIC OnOverAllHelpButton()
{
	TheAction = ACTION SHOWHELPPAGE ( KPISHelpFile "ExportSelectImages.htm" );

	return PerformActions( TheAction );
}


VOID OnFlatten()
{
	dlg( GetInput );

	Flatten = MakeNumber( ~<$con.DlgData[Flatten]>~ );

	dlg( SetControlTitle,GoButton,<Flatten> ? Translate( ~Flatten~ ) : Translate( ~Export~ ) );

	dlg( EnableControls,!<Flatten>,WidthEditText,HeightEditText,ResolutionEditText );
	dlg( EnableControls,!<Flatten>,CropXEditText,CropYEditText,CropWidthEditText,CropLengthEditText );
	dlg( EnableControls,!<Flatten>,ImageCropXEditText,ImageCropYEditText,ImageCropWidthEditText,ImageCropLengthEditText );
	dlg( EnableControls,!<Flatten>,FileNameField,OutputDirectoryField,RotationComboBox );
	dlg( EnableControls,!<Flatten>,AutoRotateRadioButton90,AutoRotateRadioButton270,AutoRotateRadioButtonOff );
	dlg( EnableControls,!<Flatten>,UseFileField,UseFileBrowseButton,OpenUseFileButton,UseFileEnabledCheckBox );
	dlg( EnableControls,!<Flatten>,FileNameField,OutputDirectoryField );
	
	dlg( EnableControls,!<Flatten>,ImageCropOverrideBox,OverrideImageRotationBox,ImageRotationComboBox,SizingComboBox );
	
	

	if ( <Flatten> )
	{
		dlg( SetStrings,UseFileEnabled,0 );
	}

	dlg( Title,<Flatten> ? Translate( ~Flatten Images~ ) : Translate( ~Export Images~ ) );
}

VOID ResetCrop()
{
	dlg( SetStrings,CropX,50,CropY,50,CropWidth,100,CropLength,100 );
}



NUMERIC OnImageSelected()
{
	return TRUE;
}


NUMERIC AddImagesForOrder()
{
	dlg( GetInput );

	if ( ~<$con.DlgData[OrderID]>~ == ~~ )
	{
		return ShowProgress( Translate( ~Enter an OrderID~ ) );
	}

	ShowProgress( Translate( ~Searching For Order <$con.DlgData[OrderID]>~ ) );

	RejectedWhereClause = DlgData( GetNumeric,IgnoreRejected ) ? ~AND Rejected = 0~ : ~~;

	count = 0;

	Query = ~Select * From Images where OrderID = '<$con.DlgData[OrderID]>' <RejectedWhereClause> Order By Roll,Frame~;	
	
	if ( PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		Tab = Chr(9);

		while ( List( GetNext,Record ) )
		{
			if ( !IsNull( ~<$pcon.Record[Path]>~ ) )
			{
				dlg( ListBox,ImagesListBox,AddString,~<$pcon.Record[Path]>~ );
				++count;
			}
		}
	}

    Msg =  ~Added <Count> Images(s) for Order <$con.DlgData[OrderID]>.~;
	ShowProgress( Translate( ~<Msg>~ ) );
    if ( $Remote == <BravoExport>)
    {
        UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionExportImagesAdded>, ~BravoStatus~);
    }
    else
    {
        UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionExportImagesAdded>, ~ProxiesStatus~);
    }

	return TRUE;
}


VOID SelectATab( num )
{
	if ( Defined( dlg ) )
	{
		dlg( SelectTab,TabWindow,~<num>~ );
	}
}


NUMERIC AddImagesForRoll()
{
	dlg( GetInput );

	if ( ~<$con.DlgData[OrderID]>~ == ~~ )
	{
		return ShowProgress( Translate( ~Enter an OrderID~ ) );
	}

	if ( ~<$con.DlgData[Roll]>~ == ~~ )
	{
		return ShowProgress( Translate( ~Enter a Roll~ ) );
	}


	ShowProgress( Translate( ~Searching For Order <$con.DlgData[OrderID]>, Roll <$con.DlgData[Roll]>~ ) );

	RejectedWhereClause = DlgData( GetNumeric,IgnoreRejected ) ? ~AND Rejected = 0~ : ~~;

	count = 0;

	Query = ~Select * From Images where OrderID = '<$con.DlgData[OrderID]>' AND Roll = '<$con.DlgData[Roll]>' <RejectedWhereClause> Order By Roll,Frame~;	
	
	if ( PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		Tab = Chr(9);

		while ( List( GetNext,Record ) )
		{
			if ( !IsNull( ~<$pcon.Record[Path]>~ ) )
			{
				dlg( ListBox,ImagesListBox,AddString,~<$pcon.Record[Path]>~ );
				++count;
			}
		}
	}

	ShowProgress( Translate( ~Added <Count> Images(s) for Order <$con.DlgData[OrderID]>, Roll <$con.DlgData[Roll]>~ ) );
	
	return TRUE;
}



VOID OnEditSetups()
{
	Query = ~Select * From ExportImageSetups Order By Setup~;

	Actions = ACTION Doc ( ~ExportImageSetups~ OpenOnce ExportImageSetupsDoc "Init( ~Export Image Setups~,~<Query>~ );" );

	PerformActions( Actions );
}


NUMERIC NewRollSelected()
{
	return TRUE;
}



NUMERIC UpdateRollsCombo(WantSelection)
{
	dlg( GetInput,GetStrings,OrderID,OrderID );

	if ( IsNULL(~<OrderID>~) )
	{ 
		return FALSE;
	}

	Query = ~(Select Roll From Rolls Where OrderID = '<OrderID>') Union (Select Distinct Roll From Images Where OrderID = '<OrderID>')  Order By Roll~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		return ShowWarning( Translate( ~Failed to query the Rolls table.\n\n<Query>\n\n<theErr>~ ) ); 
	}

	List( MakeStringList,RollsList,Roll );

	dlgData( Set,Roll,~~ );

	if (<WantSelection> == 0)
	{
		return dlg( SetControlFromStringList,RollsCombolBox,RollsList,NoSelection );
	}
	else
	{
		dlg( SetControlValue,RollsCombolBox,~~ );
		return dlg( SetControlFromStringList,RollsCombolBox,RollsList );
	}

}



NUMERIC ForgetAllImages()
{
	if ( !dlg( ListBox,ImagesListBox,GetCount ) )
	{
		return FALSE;
	}

	if ( MessageBox( Translate(~Are you sure you want to remove all image(s) from the list? ~),YESNO ) != YES )
	{
		return FALSE;
	}

	return dlg( ListBox,ImagesListBox,ResetContent );
}


NUMERIC ForgetSelectedImages()
{
	if ( !dlg( ListBox,ImagesListBox,GetCount ) )
	{
		return FALSE;
	}


	if ( MessageBox( Translate(~Are you sure you want to remove the selected image(s) from the list? ~),YESNO ) != YES )
	{
		return FALSE;
	}

	return dlg( ListBox,ImagesListBox,DeleteSelected );
}


NUMERIC OnJobQueueButton()
{
	dlg( GetInput );

	if ( IsBravoEnabled() )
	{
        // If it's a Bravo export, then there is only one queue and we ignore
        // the QueueName setting.
		Query = STR ( Select * From JobQueue Where QueueName = '<BravoQueueName>' );
		QueueName = ~<BravoQueueName>~;
	}
	else
	{
		if ( IsNull( ~<<$con.DlgData[QueueName]>>~ ) )
		{
			return ShowWarning( Translate( ~You must select a queue name to view~ ) );
		}
		Query = STR ( Select * From JobQueue Where QueueName = '<$con.DlgData[QueueName]>' );
		QueueName = ~<$con.DlgData[QueueName]>~;
	}

	Query = STR ( Select * From JobQueue Where QueueName = '<$con.DlgData[QueueName]>' );

	OpenMethod = KeyState( RSHIFT ) ? Open : OpenOnce;

	Actions = ACTION Doc ( ~JobQueue~ <OpenMethod> JobQueueDoc "Init( Translate( ~Jobs For Queue <$con.DlgData[QueueName]>~ ),~<Query>~ );" );
	
	return PerformActions( Actions );
}



NUMERIC OnSaveSetup()
{
	dlg( GetInput );

	SetupName = ~<$con.DlgData[Setup]>~;

	if ( ~<SetupName>~ == ~~ )
	{
		return ShowWarning( Translate( ~No setup name specified~ ) );
	}

	Key = ~Setup = '<$con.DlgData[Setup]>'~;

	Query = ~Select * From ExportImageSetups Where <Key>~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return ShowWarning( Translate( ~Query Failed: <Query>. <theErr>~ ) );
		
	}

	if ( !List( GetFirst,Item ) )
	{
		if ( MessageBox( Translate(~Create a new setup called <$con.DlgData[Setup]>?~),YESNO ) != YES )
		{
			return FALSE;
		}

		if ( !List( AddNew,Item ) )
		{
			List( GetErrorDescription,0,theErr );
			return ShowWarning( Translate( ~AddNew for ExportImageSetups Failed:. <theErr>~ ) );
		}

		Item( Set,Name,~<$con.DlgData[Setup]>~ );
	}
	else
	{
		if ( MessageBox( Translate(~Update the existing setup called <$con.DlgData[Setup]>?~),YESNO ) != YES )
		{
			return FALSE;
		}
	}

	if ( !Item( UpdateFrom,DlgData ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		return ShowWarning( Translate( ~Could not update ExportImageSetups record where <Key>. <theErr>~ ) );
	}

	if ( !List( Update ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		return ShowWarning( Translate( ~Could not update ExportImageSetups record where <Key>. <theErr>~ ) );
	}

	return TRUE;
}


VOID UpdateSetupsList()
{
	SelectedSetup = ~<$con.DlgData[Setup]>~;

	Query = ~Select Setup From ExportImageSetups Order By Setup~;

	if ( !PGenConList( ExportSetupsList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ExportSetupsList( GetErrorDescription,0,theErr );
		ShowWarning( Translate( ~Failed to query the ExportImageSetups table.\n\n<Query>\n\n<theErr>~ ) ); 
		return;
	}

	ExportSetupsList( MakeStringList,Setups,Setup );

	dlg( SetControlFromStringList,ExportSetupsComboBox,Setups,~Selection~ );

	if (~<SelectedSetup>~ != ~~)
	{
		dlg(SelectString, ~ExportSetupsComboBox~, ~<SelectedSetup>~);
	}
}

NUMERIC OnUseSetupButton( DisplayWarning )
{

	dlg( GetInput );
	SetupName = ~<$con.dlgData[Setup]>~;

	if ( IsNull( ~<SetupName>~ ) )
	{
		if ( !<DisplayWarning> )
		{
			return FALSE;
		}

		return ShowWarning( Translate( ~You must select a setup to load~ ) );
	}

	Key = ~Setup = '<SetupName>'~;

	Query = ~Select * from ExportImageSetups Where <Key>~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return ShowWarning( Translate( ~Query Failed: <Query>. <theErr>~ ) );
	}

	if ( !List( GetFirst,Setup ) )
	{
		return ShowWarning( Translate( ~Could not find a setup named <SetupName>~ ) );
	}

	if ( !Setup( UpdateIn,dlgData ) )
	{
		return ShowWarning( Translate( ~Failed to update the dialog from <SetupName>~ ) );
	}

	// get the crop right for overriding image crop.  Some setups were wrong on pre 4.2
	dlgData(GetValue,ImageCropX, BetterNotBeZero1);
	dlgData(GetValue,ImageCropY, BetterNotBeZero2);
	dlgData(GetValue,ImageCropWidth, BetterNotBeZero3);
	dlgData(GetValue,ImageCropHeight, BetterNotBeZero4);

	if (
		<BetterNotBeZero1> == 0.0 && <BetterNotBeZero2> == 0.0 
		&& <BetterNotBeZero3> == 0.0 && <BetterNotBeZero4> == 0.0 )
		{
			dlgData(SetValue,ImageCropX,50);
			dlgData(SetValue,ImageCropY,50);
			dlgData(SetValue,ImageCropWidth,100);
			dlgData(SetValue,ImageCropHeight,100);
		}

	dlg( Update );

	OnFlatten();

	OnSharpenMethodCheckBox();

	OnForceColorManagementOff();

	OnEmbedProfileBox();

	OnRotationButton();

	FileExtension = ~<$pcon.Setup[Extension]>~;		// Remember the extension from the setup

	OnFileTypeChange(FALSE);							// Enable/Disable controls as needed

	dlg( SetStrings,Extension,~<FileExtension>~ );	// Restore the extension from the setup

	OnSizingChange();

	NewOutputProfileSelected(1);
	NewEmbedProfileSelected();
	OnForceColorManagementOff();
	ShowProgress( Translate( ~Loaded Setup: <SetupName>~ ) );

	return TRUE;
}

// New Version of OnUseSetup above
NUMERIC UseSetup( SetupName )
{

	if ( IsNull( ~<SetupName>~ ) )
	{
        return FALSE;
	}

	Key = ~Setup = '<SetupName>'~;

	Query = ~Select * from ExportImageSetups Where <Key>~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return ShowWarning( Translate( ~Query Failed: <Query>. <theErr>~ ) );
	}

	if ( !List( GetFirst,Setup ) )
	{
		return ShowWarning( Translate( ~Could not find a setup named <SetupName>~ ) );
	}

	if ( !Setup( UpdateIn,dlgData ) )
	{
		return ShowWarning( Translate( ~Failed to update the dialog from <SetupName>~ ) );
	}

	// get the crop right for overriding image crop.  Some setups were wrong on pre 4.2
	dlgData(GetValue,ImageCropX, BetterNotBeZero1);
	dlgData(GetValue,ImageCropY, BetterNotBeZero2);
	dlgData(GetValue,ImageCropWidth, BetterNotBeZero3);
	dlgData(GetValue,ImageCropHeight, BetterNotBeZero4);

	if (
		<BetterNotBeZero1> == 0.0 && <BetterNotBeZero2> == 0.0 
		&& <BetterNotBeZero3> == 0.0 && <BetterNotBeZero4> == 0.0 )
		{
			dlgData(SetValue,ImageCropX,50);
			dlgData(SetValue,ImageCropY,50);
			dlgData(SetValue,ImageCropWidth,100);
			dlgData(SetValue,ImageCropHeight,100);
		}

	dlg( Update );

	OnFlatten();

	OnSharpenMethodCheckBox();

	OnRotationButton();

	FileExtension = ~<$pcon.Setup[Extension]>~;		// Remember the extension from the setup

	OnFileTypeChange(FALSE);							// Enable/Disable controls as needed

	dlg( SetStrings,Extension,~<FileExtension>~ );	// Restore the extension from the setup

	OnSizingChange();

	ShowProgress( Translate( ~Loaded Setup: <SetupName>~ ) );

        if ( $Remote == <BravoExport>)
        {
            UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionExportSetupComplete>, ~BravoStatus~);
        }
        else
        {
            UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionExportSetupComplete>, ~ProxiesStatus~);
        }
	return TRUE;
}

NUMERIC CheckShared( Path )
{
	if ( IsNULL( ~<Path>~ ) )
	{
		return TRUE;
	}

	if ( !Files( IsUNC,~<Path>~ ) && NetworkOperation() )
	{
		Msg = Translate( UIMessages,UnsharedFile,~<Path>~ );

		if ( MessageBox( ~<Msg>~,YESNO ) != YES )
			{ return FALSE; }
	}

	return TRUE;
}



NUMERIC BrowseOutputPath()
{
	dlg( GetInput );

	if ( FileDialog( DefaultDirectory,~<$con.DlgData[OutputDirectory]>~,Title,Translate(~Find output directory~),PATH,Path,DefaultFile,~In this directory~,Save ) )
	{
		if ( !CheckShared( ~<Path>~ ) )
		{
			return FALSE;
		}

		return dlg( SetStrings,OutputDirectory,~<$Str.$Path.Path>~ );
	}

	return FALSE;
}


NUMERIC BrowseForLut()
{
	if ( FileDialog( DefaultDirectory,~<$App.ShareDirectory>\Tables~,Title,Translate(~Find the lut~),PATH,Path,Open ) )
	{
		if ( !CheckShared( ~<Path>~ ) )
		{
			return FALSE;
		}

		return dlg( SetStrings,LutFile,~<Path>~ );
	}

	return FALSE;
}


NUMERIC BrowseForUseFile()
{
	if ( FileDialog( DefaultDirectory,~<$App.ShareDirectory>\Layouts~,Title,Translate(~Find the desired layout~),PATH,Path,Open ) )
	{
		if ( !CheckShared( ~<Path>~ ) )
		{
			return FALSE;
		}

		return dlg( SetStrings,UseFile,~<Path>~ );
	}

	return FALSE;
}


NUMERIC BrowseForProcessAfterFile()
{
	if ( FileDialog( DefaultDirectory,~<$App.ShareDirectory>\Scripts~,Title,Translate(~Find the desired script~),PATH,Path,Open ) )
	{
		if ( !CheckShared( ~<Path>~ ) )
		{
			return FALSE;
		}

		return dlg( SetStrings,ProcessAfterFile,~<Path>~ );
	}

	return FALSE;
}


NUMERIC BrowseForColorMatrix()
{
	if ( FileDialog( DefaultDirectory,~<$App.ShareDirectory>\Tables~,Title,Translate(~Find the color matrix~),PATH,Path,Open ) )
	{
		if ( !CheckShared( ~<Path>~ ) )
		{
			return FALSE;
		}

		return dlg( SetStrings,ColorMatrix,~<Path>~ );
	}

	return FALSE;
}

NUMERIC OpenUseFile( LayoutPath )
{
	if ( IsNULL( ~<LayoutPath>~ ) )
	{
		if ( IsNull( ~<$con.DlgData[UseFile]>~ ) )
		{
			return ShowWarning( ~You must specify a file first~ );
		}

		IsMultiple = FALSE;

		LayoutPath = GetFullLayout( ~<$con.DlgData[UseFile]>~,IsMultiple );

		if ( IsNull( ~<LayoutPath>~ ) )
			{ return FALSE; }
	}

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( !Window( GetNext,aView ) )
			continue;

		aView( Get,ViewType,ViewType );

		if ( ~<ViewType>~ == LayoutView )
		{
			aView( GetDocumentPath,DocumentPath );

			if ( ~<DocumentPath>~ == ~<LayoutPath>~ )
			{ 
				Window( SetWindowOrder,Top );
				return TRUE;
			}
		}
	}

	CurrentlyOpen = NumWindows( LayoutOrJob );

	MaxOpenJobsOrLayouts = ~<$[Symbols].MaxOpenJobsOrLayouts[Long]>~;

	if ( <MaxOpenJobsOrLayouts> < 1 )
	{ 
		MaxOpenJobsOrLayouts = 1;
	}

	if ( <CurrentlyOpen> >= <MaxOpenJobsOrLayouts> )
	{
		return Warning( ~You cannot have more than 10 jobs or layouts open at once~ );
	}

	if (!Document( aLayout,Open,~<LayoutPath>~,Layout,~~ ) )
		{ return ShowWarning( ~Could not open <LayoutPath>~ ); }

	return TRUE;
}



VOID OnUseFileCheckBox()
{
	dlg( GetInput );

	UseFileEnabled = DlgData( GetNumeric,UseFileEnabled );

	dlg( EnableControls,!<UseFileEnabled>,WidthEditText,HeightEditText,XResolutionEditText );
	dlg( EnableControls,!<UseFileEnabled>,CropXEditText,CropYEditText,CropWidthEditText,CropLengthEditText );
	dlg( EnableControls,!<UseFileEnabled>,ImageCropXEditText,ImageCropYEditText,ImageCropWidthEditText,ImageCropLengthEditText );
	dlg( EnableControls,!<UseFileEnabled>,RotationComboBox );
	dlg( EnableControls,!<UseFileEnabled>,AutoRotateRadioButton90,AutoRotateRadioButton270,AutoRotateRadioButtonOff );

	dlg( EnableControls,!<UseFileEnabled>,RImageEnabledBox,CDPathField,DeleteAfterBox,CDPathComboBox,UseCDPathPrompt );

	if ( <UseFileEnabled> && DlgData( GetNumeric,Flatten ) )
	{
		dlg( SetStrings,Flatten,0 );
	}
}


NUMERIC OnFileTypeChange(UpdateCompressionQuality)
{
	dlg( GetInput );

	if ( !IsNULL( String( BeginsWith,~TIFF~,~<$con.DlgData[SaveFileType]>~ ) ) )
	{
		dlg( EnableControls,TRUE,PreviewSizeField,PreviewSizePrompt );
		dlg( EnableControls,FALSE,CompressionQualityField,CompressionQualityPrompt );
		return dlg( SetStrings,Extension,~.tif~ );
	}
	else if ( !IsNULL( String( BeginsWith,~EXIF~,~<$con.DlgData[SaveFileType]>~ ) ) )
	{
		dlg( EnableControls,TRUE,PreviewSizeField,PreviewSizePrompt,CompressionQualityField,CompressionQualityPrompt );
		if ( <UpdateCompressionQuality> )
		{
			dlg( SetStrings,CompressionQuality,100 );
		}
		return dlg( SetStrings,Extension,~.jpg~ );
	}
	else if ( SimilarStr(~JPEG Min~,~<$con.DlgData[SaveFileType]>~ ) )
	{
		dlg( EnableControls,FALSE,PreviewSizeField,PreviewSizePrompt );
		dlg( EnableControls,TRUE,CompressionQualityField,CompressionQualityPrompt );
		if ( <UpdateCompressionQuality> )
		{
			dlg( SetStrings,CompressionQuality,10 );
		}
		return dlg( SetStrings,Extension,~.jpg~ );
	}
	else if ( SimilarStr(~JPEG Low~,~<$con.DlgData[SaveFileType]>~ ) )
	{
		dlg( EnableControls,FALSE,PreviewSizeField,PreviewSizePrompt );
		dlg( EnableControls,TRUE,CompressionQualityField,CompressionQualityPrompt );
		if ( <UpdateCompressionQuality> )
		{
			dlg( SetStrings,CompressionQuality,25 );
		}
		return dlg( SetStrings,Extension,~.jpg~ );
	}
	else if ( SimilarStr(~JPEG Normal~,~<$con.DlgData[SaveFileType]>~ ) )
	{
		dlg( EnableControls,FALSE,PreviewSizeField,PreviewSizePrompt );
		dlg( EnableControls,TRUE,CompressionQualityField,CompressionQualityPrompt );
		if ( <UpdateCompressionQuality> )
		{
			dlg( SetStrings,CompressionQuality,50 );
		}
		return dlg( SetStrings,Extension,~.jpg~ );
	}
	else if ( SimilarStr(~JPEG High~,~<$con.DlgData[SaveFileType]>~ ) )
	{
		dlg( EnableControls,FALSE,PreviewSizeField,PreviewSizePrompt );
		dlg( EnableControls,TRUE,CompressionQualityField,CompressionQualityPrompt );
		if ( <UpdateCompressionQuality> )
		{
			dlg( SetStrings,CompressionQuality,75 );
		}
		return dlg( SetStrings,Extension,~.jpg~ );
	}
	else if ( SimilarStr(~JPEG Max~,~<$con.DlgData[SaveFileType]>~ ) )
	{
		dlg( EnableControls,FALSE,PreviewSizeField,PreviewSizePrompt );
		dlg( EnableControls,TRUE,CompressionQualityField,CompressionQualityPrompt );
		if ( <UpdateCompressionQuality> )
		{
			dlg( SetStrings,CompressionQuality,100 );
		}
		return dlg( SetStrings,Extension,~.jpg~ );
	}
	else if ( SimilarStr(~JPEG~,~<$con.DlgData[SaveFileType]>~ ) )
	{
		dlg( EnableControls,FALSE,PreviewSizeField,PreviewSizePrompt );
		dlg( EnableControls,TRUE,CompressionQualityField,CompressionQualityPrompt );
		if ( <UpdateCompressionQuality> )
		{
			dlg( SetStrings,CompressionQuality,100 );
		}
		return dlg( SetStrings,Extension,~.jpg~ );
	}

	return FALSE;
}


NUMERIC OpenExistingImage( Path )
{
	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( !Window( GetNext,aView ) )
			continue;

		aView( Get,ViewType,ViewType );

		if ( ~<ViewType>~ == ImageEditView || ~<ViewType>~ == ImageView )
		{
			aView( GetDocumentPath,DocumentPath );

			if ( ~<DocumentPath>~ == ~<Path>~ )
			{ 
				Window( SetWindowOrder,Top );
				return TRUE;
			}
		}
	}

	return FALSE;
}


NUMERIC OnOpenButton()
{
	count = 0;		Index = -1;

	SelectedCount = dlg( ListBox,ImagesListBox,GetSelectedCount );
				
	while ( dlg( ListBox,ImagesListBox,GetNthSelectedItem,<++Index>,Path ) > 0 )
	{
		if ( NumWindows( Image ) >= 10 )
		{
			return Warning( ~You already have 10 images open~ );
		}

		if ( !OpenExistingImage( ~<Path>~ ) )
		{
			if ( !Document( TheImage,Open,~<Path>~,Image,~~ ) )
			{ 
				return Warning( ~Failed to open <Path>~ );
			}

			ForgetLocal( TheImage );
		}

		++count;
	}

	if ( <count> < <SelectedCount> )
	{
		Warning( Translate( ~You can only have <count> images open at a time~ ) );
	}

	return TRUE;
}


NUMERIC CloseAllOpenImages()
{
	if ( !GenCon( View,GetActiveView ) )
		{ return ShowWarning( ~There was no active view~ ); }

	Count = Index = 0;

	app( ThisApp,MessagePump,3 );

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( Window( GETNEXT,aView ) )
		{
			aView( GET,ViewType,ViewType );

			if ( ~<ViewType>~ == ~ImageEditView~ )
			{
				aView( GetDocumentPath,DocumentPath );
				Window( CloseWindow );
				ThisApp( MessagePump,3 );
				++Count;
				Index = 0;
			}
		}
	}

	ThisApp( MessagePump,0 );

	return TRUE;
}

NUMERIC AuditPaths()
{
	if ( !CheckShared( ~<$Con.DlgData[UseFile]>~ ) ) { return FALSE; }

	if ( !CheckShared( ~<$Con.DlgData[ProcessAfterFile]>~ ) ) { return FALSE; }

	if ( !CheckShared( ~<$Con.DlgData[LutFile]>~ ) ) { return FALSE; }

	if ( !CheckShared( ~<$Con.DlgData[ColorMatrix]>~ ) ) { return FALSE; }


	return TRUE;
}

NUMERIC OnGoButton( warn )
{
	if ( aThread( IsActive ) )
	{
		return ShowWarning( ~Exporting is still active.  Please try again shortly~ );
	}

	dlg( GetInput );

	if ( ~<$con.DlgData[OrderID]>~ == ~~ )
	{
		return ShowWarning( Translate(~Order ID cannot be NULL~) );
	}

	ScaleFactor = Numeric(~<$Con.DlgData[ScaleFactor]>~);
	Sizing = dlg( ComboBox,SizingComboBox,GetSelectedIndex );

	if ( <ScaleFactor> > 10000 && <Sizing> == 6)
	{
		return ShowWarning( Translate(~Scale Factor cannot be more than 10000~) );
	}

	if ( !DlgData( GetNumeric,Flatten ) )
	{
		if ( ~<$con.DlgData[OutputDirectory>]~ == ~~ )
		{
			dlg( SelectTab,TabWindow,8 );
			return ShowWarning( Translate(~Directory cannot be NULL~) );
		}


		if ( ~<$con.DlgData[FileName]>~ == ~~ )
		{
			dlg( SelectTab,TabWindow,8 );
			return ShowWarning( Translate(~File name cannot be NULL~) );
		}
	}

	if ( !IsBravoEnabled() )
	{
	if ( ~<$con.DlgData[QueueName]>~ == ~~ )
	{
		dlg( SelectTab,TabWindow,8 );
		return ShowWarning( Translate(~QueueName cannot be NULL~) );
	}


	Query = ~Select ICCProfile From QueueDefinition Where QueueName = '<$con.DlgData[QueueName]>'~;	

	if ( !ADO( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		Invoke( ShowWarning,~Failed to connect to the database.  <theErr>~ );
		return FALSE;
	}

	if ( !PGenConList( ICCProfileList,Connection,dBase,cursor,Forward,Query,~<Query>~ ) )
	{
		ICCProfileList( GetErrorDescription,0,theErr );
		Invoke( ShowWarning,Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
		return FALSE;
	}

	if ( ICCProfileList( GetFirst,Item ) )
	{
		QueueProfile = ~<$pcon.Item[ICCProfile]>~;
	}

	if ( DlgData( GetNumeric,OutputProfileEnabled )  == 0)
	{
		if ( DlgData( GetNumeric,EmbedProfile ) != 0 )
		{
			if ( DlgData( GetNumeric,ForceColorManagementOff ) == 0 )
			{
				RequestedProfileToEmbed = ~<$con.DlgData[ICCProfile]>~;
				if ( ~<RequestedProfileToEmbed>~ != ~~ && ~<QueueProfile>~ != ~~)
				{
					if ( !SimilarStr( ~<RequestedProfileToEmbed>~,~<QueueProfile>~ )  )
					{
						Query2 =  ~Select PrinterName,ComputerName From Printers Where QueueName = '<$con.DlgData[QueueName]>'~;
						if ( !PGenConList( PrinterList,Connection,dBase,cursor,Forward,Query,~<Query2>~ ) )
						{
							PrinterList( GetErrorDescription,0,theErr );
							Invoke( ShowWarning,Translate(DBMessages,QueryFailed,~<Query2>~,~<theErr>~) );
							return FALSE;
						}
						if ( PrinterList( GetFirst,Item2 ) )
						{
							PrinterName = ~<$pcon.Item2[PrinterName]>~;
							ComputerName = ~<$pcon.Item2[ComputerName]>~;
						}


						MessageBoxResult = MessageBox( ~Warning: Potential Profile Mismatch.  You have chosen to use the ICC profile ( <QueueProfile> ) in the printer queue table for Queue <$con.DlgData[QueueName]>  to color manage the image(s).  You have chosen to embed profile <RequestedProfileToEmbed>.  Do you want to use <RequestedProfileToEmbed> to color manage the image(s)?

Choose Yes if color management is on on workstation <ComputerName> and <RequestedProfileToEmbed> is the correct ICC profile.
It is safe to choose No if color management is off on workstation <ComputerName>.
~,YESNOCANCEL ) ;
						if ( ~<MessageBoxResult>~ == YES )
						{
							 DlgData( SetValue, OutputProfileEnabled, 1);

						}
						else if ( ~<MessageBoxResult>~ == CANCEL)
						{
							return FALSE;
						}
						else
						{
							ShowWarning( Translate( ~If color management is off on workstation <ComputerName> no profile will be used to color manage the image(s) and <RequestedProfileToEmbed> will be embedded in the output image(s).  If color management is on on workstation <ComputerName>, <QueueProfile> will be used to color manage the image and <RequestedProfileToEmbed> will be embedded in the output image(s).~));
							Log( Session, ~Potential profile mismatch with Exported Images to printer queue <$con.DlgData[QueueName]> for printer <PrinterName> on workstation <ComputerName>.  Profile <QueueProfile> was chosen to color manage the image and Profile <RequestedProfileToEmbed> was chosen to embed in the output image(s).   If color management is off on workstation <ComputerName> no profile will be used to color manage the image and <RequestedProfileToEmbed> will be embedded in the output image(s).~ );
						}				
					}
				}
			}
		}
	}
	}


	
	Count = dlg( ListBox,ImagesListBox,GetCount	);

	if ( !<Count> )
	{
		return ShowWarning( Translate( ~There are no image(s) to export~ ) );
	}

	WantRImage = DlgData( GetNumeric,RImageEnabled ) && !DlgData( GetNumeric,Testing );

	if ( <WantRImage> )
	{
		if ( IsNULL( String( BeginsWith,~\~,~<$con.DlgData[RImageCDPath]>~ ) ) )
		{
			dlg( EnableControls,FALSE,StopButton );	
			dlg( EnableControls,TRUE,GoButton );	

			return Warning( ~The RImage Output Media Path needs to begin with a \~ );
		}
	}

	if ( DlgData( GetNumeric,Flatten ) )
	{
        if ( <warn> )
        {
		    if ( MessageBox( ~Are you sure you want to flatten <Count> image(s)? ~,YESNO ) != YES )
			    { return FALSE; }
        }
	}
	else
	{
        // Don't do the "Are you sure?" warning here for Bravo exports.
        // Bravo exports get the warning when the Bravo "Finalise CD(s)"
        // button is pressed.
        if ( <warn> )
        {
            if ( !IsBravoEnabled() )
            {
                if ( MessageBox( ~Are you sure you want to export <Count> image(s)? ~,YESNO ) != YES )
                    { return FALSE; }
            }
        }
	}
	
	Stop = FALSE;

	dlg( EnableControls,TRUE,StopButton );	
	dlg( EnableControls,FALSE,GoButton );	
    if ( IsBravoEnabled() )
    {
        // Also disallow (grey-out) use of "Use Setup" and "Finalise CD"
        // button until Export has finished.
        dlg( EnableControls,FALSE,ExportSetupsText );
	    dlg( EnableControls,FALSE,BravoFinaliseCDButton );
    }

	ShowProgress( Translate( ~starting~ ) );

	Query = ~Select * From Images where OrderID = '<$con.DlgData[OrderID]>' Order By Roll,Frame~;	

    // Get the BatchID to use:
    //  - for Bravo we use a single value for multiple "Exports" to the same CD (or CD set)
    //     - on Bravo, we only get a new BatchID once the user has pressed
    //       "Finalise CD(s)".
    //  - for non-Bravo, each "Export" is a separate unique BatchID.
    //
    if ( IsBravoEnabled() )
    {
        BravoExportsPending = <BravoExportsPending> + <Count>;
	    BatchID = ~<BravoBatchID>~;
    }
    else
    {
	    BatchID = UniquePrintBatchID();
    }

	DlgData( SetValues,BatchID,~<BatchID>~,OrderID,~<$con.DlgData[OrderID]>~,OrderItemID,1,OrderItemSequence,1,QueueName,~<$con.DlgData[QueueName]>~ );
	
	if ( !dlg( ListBox,ImagesListBox,MakeStringList,PathList ) )
	{
		return ShowWarning( ~Failed to make a list of images to export~ );
	}

	if ( DlgData(GetNumeric,Flatten) )
	{
		if ( !VerifyImagesCanBeFlattened( PathList ) )
		{
            // Reset all controls upon error.
			dlg( EnableControls,FALSE,StopButton );	
			dlg( EnableControls,TRUE,GoButton );	
            if ( IsBravoEnabled() )
            {
                dlg( EnableControls,TRUE,ExportSetupsText );
                dlg( EnableControls,TRUE,BravoFinaliseCDButton );
            }

			return Warning( Translate( ~One or more of the images could not be processed.~ ) );;
		}
	}

	PathList( Permanent );	// WILL BE DELETED BY THE THREAD

	DlgData( SetValue,Testing,0 );

	aThread( New,ExportFilesFromList,PathList(GetObject) );

	return TRUE;
}


NUMERIC VerifyImagesCanBeFlattened( &PathList )
{
	More = PathList( GetFirstString,TheSelectedImagePath );

	Entries = PathList( Count );
				
	while ( <More> )
	{
		Invoke( ShowProgress,~Checking <++count> of <Entries>: <TheSelectedImagePath>~ );

		if ( !Files( FileExists,~<TheSelectedImagePath>~ ) )
		{
			return Warning( Translate( ~<TheSelectedImagePath> does not exist.~ ) );
		}

		SelectedImagePath = ~<$Str.$TheSelectedImagePath.WithoutExt><$con.DlgData[Extension]>~; // DESTINATION PATH

		if ( !BroadcastMessageToAllViews( CanReleaseImage,~<SelectedImagePath>~ ) )
			{ return Warning( Translate( ~Could not flatten\n\n<Path>\n\nbecause it is still open in a job or layout.~ ) ); }

		if ( !BroadcastMessageToAllViews( ReleaseImage,~<SelectedImagePath>~ ) )		
			{ return Warning( Translate( ~Could not flatten\n\n<Path>\n\nbecause it is still open in a job or layout.~ ) ); }

		BroadcastMessageToAllViews( ReleaseImageChain,~<SelectedImagePath>~ );

		CloseWindowByPath( ~<SelectedImagePath>~ );

		if ( Files( FileExists,~<SelectedImagePath>~ ) )
		{
			if ( !Files( IsWritable,~<SelectedImagePath>~ ) )
			{
				return Warning( Translate( ~Could not flatten\n\n<SelectedImagePath>\n\nThe file exists, but it is not writable.~ ) );
			}
		}

		More = PathList( GetNextString,TheSelectedImagePath );

		if ( DlgData( GetNumeric,Testing ) )
			break;
	}

	return TRUE;
}


NUMERIC CloseWindowByPath(Path)
{
	Count = Index = 0;

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( Window( GETNEXT,aView ) )
		{
			aView( GetDocumentPath,DocumentPath );

			if ( SimilarStr( ~<DocumentPath>~,~<Path>~ ) )
			{
				return Window( CloseWindow );
			}
		}
	}

	return FALSE;
}


NUMERIC OnTestButton()
{
	if ( aThread( IsActive ) )
	{
		return ShowWarning( ~Exporting is still active.  Please try again shortly~ );
	}

	dlg( GetInput );

	if ( ~<$con.DlgData[OrderID]>~ == ~~ )
	{
		return ShowWarning( Translate(~Order ID cannot be NULL~) );
	}

	ScaleFactor = Numeric(~<$Con.DlgData[ScaleFactor]>~);
	Sizing = dlg( ComboBox,SizingComboBox,GetSelectedIndex );

	if ( <ScaleFactor> > 10000 && <Sizing> == 6)
	{
		return ShowWarning( Translate(~Scale Factor cannot be more than 10000~) );
	}

	Count = dlg( ListBox,ImagesListBox,GetCount	);

	DlgData( SetValue,Testing,1 );
	
	Stop = FALSE;

	Query = ~Select * From Images where OrderID = '<$con.DlgData[OrderID]>' Order By Roll,Frame~;	

	BatchID = ~0~; // UniquePrintBatchID();

	DlgData( SetValues,BatchID,~<BatchID>~,OrderID,~<$con.DlgData[OrderID]>~,OrderItemID,1,OrderItemSequence,1,QueueName,~<$con.DlgData[QueueName]>~ );
	
	if ( !dlg( ListBox,ImagesListBox,MakeSelectedStringList,PathList ) )
	{
		return ShowWarning( Translate( ~You must select an image to test with~ ) );
	}

	if ( PathList( Empty ) )
	{
		return ShowWarning( Translate( ~You must select an image to test with~ ) );
	}

	PathList( Permanent );	// WILL BE DELETED BY THE THREAD

	if ( ExportFilesFromList( PathList(GetObject) ) )
	{
		if ( KeyState( Control ) )
		{
			ViewFileInNotepad( ~<TestJobPath>~ );
		}
		else
		{
			OpenUseFile( ~<TestJobPath>~ );
		}

		Action = STR ( DelayedRemoveAJob( ~<TestJobPath>~ ); );

		QueueContentsAfter( Action,1000 );
	}

	return TRUE;
}


VOID DelayedRemoveAJob( Path )
{
	Files( Delete,~<Path>~ );
}


NUMERIC ViewAsText()
{
	if ( !GenCon( OrderItemCategory,GETACTIVEVIEW ) )
		{ return ShowWarning( Translate(UIMessages,NoActiveView) ); }			

	if ( !OrderItemCategory( GetSelected,OrderItemsToView ) )
		{ return ShowWarning( Translate(OrderItemsMessages,NoOrderItems) ); }

	Count = OrderItemsToView( ChildCount );

	if ( <Count> <= 0 )
		{ return ShowWarning( Translate(OrderItemsMessages,NoItemsSelected) ); }

	Program = ~<$Sys.Directory>\Notepad.exe~;

	if ( !Files( FileExists,~<Program>~ ) )
	{
		return ShowWarning( Translate( OrderItemsMessages,NoFindNotepad,~<Program>~ ) );
	}

	while ( OrderItemsToView(GetNext,OrderItem) )
	{
		if ( !ShellExecute( Open,~<Program>~,~<$con.OrderItem[JobPath]>~ ) )
		{
			GetLastError( ErrorString,theErr );
			return ShowWarning( Translate( OrderItemsMessages,CantOpenFile,~<$con.OrderItem[JobPath]>~,~<theErr>~ ) );
		}
	}

	return TRUE;
}


VOID ReenableControls()
{
	dlg( EnableControls,FALSE,StopButton );	
	dlg( EnableControls,TRUE,GoButton );
    if ( IsBravoEnabled() )
    {
        dlg( EnableControls,TRUE,ExportSetupsText );
        dlg( EnableControls,TRUE,BravoFinaliseCDButton );
    }
}

// This is called after the "Export" button has been pressed, and all
// necessary processing (e.g. adding entries to JobQueue) have been done.
// This re-enables controls that were disallowed during the export and
// also displays an appropriate "progress message".
//
// For Bravo, the message also includes a mention of thumbnails.
//
NUMERIC ExportComplete( Count,BatchID,RImageJobID )
{
	ReenableControls();	

    Plural = ~~;
    if ( <Count> > 1 )
    {
        Plural = ~s~;
    }
    ThumbMsg = ~~;
    if ( IsBravoEnabled() )
    {
        // If Bravo is enabled, then thumbnails are generated too.
        ThumbMsg = ~(plus thumbnail<Plural>) ~;
    }
	Msg = ~Processed <Count> Image<Plural> <ThumbMsg>for Batch <BatchID>~;
    if ( IsBravoEnabled() )
    {
        Msg = ~<Msg>. Click "Finalise CD(s)" on Bravo tab when all images added.~;
    }

	if ( !IsNull(~<RImageJobID>~) )
	{
		Msg = ~<Msg>.  Submitted RImage CD Job <RImageJobID>.~;
	}

    if ( $Remote == <BravoExport>)
    {
        UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionExportRunComplete>, ~BravoStatus~);
    }
    else
    {
        UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionExportRunComplete>, ~ProxiesStatus~);
    }

	return ShowProgress( ~<Msg>~ );
}


NUMERIC ExportFailed( Count )
{
	ReenableControls();
	return ShowProgress( ~Failure after processing <Count> Image(s)~ );
}

// ***************************   QUEUE WORK FOR RIMAGE WRITING   ***************************

NUMERIC AddRImageJob( &Connection,JobID,&TemplateRecord )			// SETUP THE MAIN RIMAGE JOB IN THE RIMAGEORDERS TABLE
{
	Query = ~Select * From RImageOrders Where ID = '<JobID>'~;

	if ( !PGenConList( List,Connection,Connection,GetRecordFor,~<Query>~,NewRecord ) )
	{
		List( GetErrorDescription,0,theErr );
		Invoke( ShowWarning,~Failed to add a record to the RImageOrders table for ID <JobID>.  <theErr>~ );
		return FALSE;
	}

	if ( !NewRecord( UpdateFrom,TemplateRecord ) )
	{
		Invoke( ShowWarning,~Failed to update the RImageOrders record for ID <JobID>.  <theErr>~ );
		return FALSE;
	}

	NewRecord( Set,ID,~<JobID>~ );
	NewRecord( Set,Writer,~<$con.DlgData[RImageWriter]>~ );
	Now = Time();
	NewRecord( Set,SubmitDate,~<Now>~ );
	NewRecord( Set,Progress,~0~ );
	NewRecord( Set,OrderID,~<$con.DlgData[OrderID]>~ );

	if ( !List( Update ) )
	{
		List( GetErrorDescription,0,theErr );
		Invoke( ShowWarning,~Failed update RImageOrders table for ID <JobID>.  <theErr>~ );
		return FALSE;
	}

	Query = ~SELECT * FROM RImageMergeTemplates WHERE ID = '<$pcon.TemplateRecord[ID]>' Order By FieldNumber~;

	if ( !PGenConList( MergeList,Connection,Connection,cursor,Forward,Query,~<Query>~ ) )
	{
		MergeList( GetErrorDescription,0,theErr );
		Invoke( ShowWarning,Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
		return FALSE;
	}

	while ( MergeList( GetNext,Item ) )
	{
		Data = ~<$pcon.Item[FieldData]>~;

		if ( !IsNull( ~<Data>~ ) )	// GET CHUNK ONLY WORKS ONCE ON LONGTEXT FIELDS
		{
			connection( Cmd,~Insert Into RImageMerge(ID,FieldNumber,FieldData) values('<JobID>',<$pcon.Item[FieldNumber]>,'<Data>')~ );
		}
	}
	
	Invoke( ShowProgress,~Added RImage Job <JobID> for Writer <$con.DlgData[RImageWriter]>~  );

	return TRUE;
}


NUMERIC AddRImageOtherFiles( &Connection,JobID,&StaticEditList )		// ADD THE STATIC FILES FROM THE EDIT LIST TEMPLATE
{
	while ( StaticEditList( GetNext,Item ) )
	{
		if ( !AddRImageFile( Connection,~<JobID>~,~<$pcon.Item[ToPath]>~,~<$pcon.Item[FromPath]>~ ) )
		{
			return FALSE;
		}
	}

	return TRUE;
}


NUMERIC AddRImageFile( &Connection,JobID,ToPath,FromPath )				// ADD A FILE TO BE EXPORTED
{
	ToPath = IsNULL(~<ToPath>~) ? ~\~ : ~<ToPath>~;

	Cmd = ~Insert Into RImageEditList(ID,ToPath,FromPath) Values('<JobID>','<ToPath>','<FromPath>')~;

	if ( !Connection( Cmd,~<Cmd>~ ) )
	{
		Connection( GetErrorDescription,theErr );
		Invoke( ShowWarning,~Failed to add to the edit list for RImage Job <JobID>. <Cmd>. <theErr>~ );
		return FALSE;
	}

	return TRUE;
}


NUMERIC OnOpenRImageOrders()
{
	if ( IsNull(~<$con.DlgData[RImageWriter]>~) )
	{
		return Warning( Translate(~You must choose a writer first~) );
	}

	Query = ~Select * From RImageOrders Where Writer = '<$con.DlgData[RImageWriter]>' Order By Progress, Priority desc,SubmitDate~;
	Actions = ACTION DOC ( RImageOrdersDoc OpenOnce RImageOrdersDoc "Init(~<$con.DlgData[RImageWriter]>~,~<Query>~);" );
	return PerformActions( Actions );
}


// Cleanup the database on error.
// 
// For some reason, the original version of this was stubbed out by Kodak.
// It certainly seems to work for Bravo at least... so unstubbed and augmented
// to cleanup BravoBatch and BravoBatchImages entries too.
//
NUMERIC CleanupDatabase( &Connection,RImageJobID,BatchID )				// GET RID OF THE EDIT LIST AND JOB
{
	if ( !IsNULL( ~<RImageJobID>~ ) )	// CLEAN THE RIMAGE STUFF
	{
		Connection( Cmd,~Delete From RImageEditLists Where ID = '<RImageJobID>'~ );
		Connection( Cmd,~Delete From RImageOrders Where ID = '<RImageJobID>'~ );
	}

	if ( !IsNULL( ~<BatchID>~ ) )		//  CLEAN THE JOBQUEUE
	{
        // Where are going to do a number of operations upon database tables for
        // a given batch ID. To avoid human error + repetition, the where clause
        // is defined here.
        WhereClause = ~Where BatchID='<BatchID>'~;

        // First, remove all Job files listed in the JobQueue for the current
        // batch. This makes sense for all cases - not just Bravo!

        Query = ~SELECT JobPath FROM JobQueue <WhereClause>~;
        if ( PGenConList( List, Connection, Connection, Cursor, Forward,
                          Query, ~<Query>~ ) )
        {
            while ( List( GetNext, Entry ) )
            {
                Files( Delete, ~<$pcon.Entry[JobPath]>~ );
            }
        }

        // Now remove the JobQueue entries themselves for the given batch.
		Connection( Cmd,~Delete From JobQueue <WhereClause>~ );

        if ( IsBravoEnabled() )
        {
            Connection( Cmd,~Delete From BravoBatch <WhereClause>~ );
            Connection( Cmd,~Delete From BravoBatchImages <WhereClause>~ );
        }
	}

	return TRUE;
}

// ***************************    END QUEUING FOR RIMAGE WRITING   ***************************


NUMERIC ExportFilesFromList( ListAddr )				// RUNS ON A THREAD
{
	ResetIncrementingSequence();

	StringList( PathList,Is,<ListAddr>,Temporary );	// LIST OF IMAGE FILES TO EXPORT

	count = 0;
	
	if ( !ADO( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		Invoke( ShowWarning,~Failed to connect to the database.  <theErr>~ );
		return FALSE;
	}

	Stop = FALSE;

	ListIndex = -1;

	More = PathList( GetFirstString,SelectedImagePath );

	Entries = PathList( Count );

	FileNameSequence = 0;

	RImageJobID = ~~;

	WantRImage = DlgData( GetNumeric,RImageEnabled ) && !DlgData( GetNumeric,Testing );

	if ( <WantRImage> )		// ARE WE COPYING THE EXPORTED IMAGES TO CD?
	{
		if ( IsNull( ~<$con.DlgData[RImageTemplate]>~ ) )
		{
			Invoke( ShowWarning,~No template was specified~ );
			Invoke( ReenableControls );
			return FALSE;
		}

		Query = ~Select * from RImageTemplates Where ID = '<$con.DlgData[RImageTemplate]>'~;

		if ( !PGenConList( TemplatesList,Connection,dBase,GetRecordFor,~<Query>~,TemplateRecord ) )
		{
			TemplatesList( GetErrorDescription,0,theErr );
			Invoke( ShowWarning,~Failed to get the Template record for <$con.DlgData[RImageTemplate]>.  <theErr>~ );
			Invoke( ReenableControls );
			return FALSE;
		}

		Query = ~Select * from RImageEditListTemplates Where ID = '<$con.DlgData[RImageTemplate]>'~;

		if ( !PGenConList( StaticFiles,Connection,dBase,Cursor,Static,Query,~<Query>~ ) )
		{
			StaticFiles( GetErrorDescription,0,theErr );
			Invoke( ShowWarning,~Failed to get the Edit List template for <$con.DlgData[RImageTemplate]>  <theErr>~ );
			Invoke( ReenableControls );
			return FALSE;
		}

		BasePath = ~~;

		RImageJobID = UniqueRImageJobID();

		if ( !AddRImageJob(dBase,~<RImageJobID>~,TemplateRecord ) )
		{ 
			CleanupDatabase( dBase,~<RImageJobID>~,~<BatchID>~ );
			Invoke( ReenableControls );
			return FALSE;
		}

		if ( !AddRImageOtherFiles(dBase,~<RImageJobID>~,StaticFiles) )
		{ 
			CleanupDatabase( dBase,~<RImageJobID>~,~<BatchID>~ );
			Invoke( ReenableControls );
			return FALSE;
		}
	}
				
	while ( <More> && !<Stop> )	// NOW TAKE CARE OF EACH OF THE INDIVIDUAL IMAGES
	{
		Invoke( ShowProgress,~<SelectedImagePath>~ );

		LastEntry = <++count> == <Entries>;

        if ( IsBravoEnabled() )
        {
            // If Bravo, then we need the real OrderID. Otherwise, uses RImage
            //  tertiary logic below.
            AppOrderID =	~<$con.dlgData[OrderID]>~;
        }
        else
        {
            AppOrderID =	<WantRImage> ? ~<$con.dlgData[OrderID]>~ : ~~;
        }
		ToPath =		<WantRImage> ? ~<$con.dlgData[RImageCDPath]>~ : ~~;
		RImageJobID =	<WantRImage> ? ~<RImageJobID>~ : ~~;
		DeleteAfterRImage =	<WantRImage> ? Numeric(~<$con.dlgData[DeleteAfterRImage]>~) : FALSE;

		QueueJobFor( dBase,~<SelectedImagePath>~,DlgData(GetNumeric,Flatten),<LastEntry>,~<RImageJobID>~,~<ToPath>~,<DeleteAfterRImage>,~<AppOrderID>~ );

		DlgData( SetValues,OrderItemID,DlgData(GetNumeric,OrderItemID)+1,OrderItemSequence,DlgData(GetNumeric,OrderItemSequence)+1 );

		if ( DlgData( GetNumeric,Testing ) )	{ return TRUE; }

		More = PathList( GetNextString,SelectedImagePath );
	}

    // Are we dealing with the Bravo export or not?...
    //  - With Bravo, we don't set job to ready until "Finalise" button is pressed,
    //    so skip this step.
    if ( !IsBravoEnabled() )
    {
        // NOT BRAVO...
        // CHANGE THE JOBS TO READY AND LET EM RIP!

        Cmd = ~Update JobQueue Set PrintStatus = 1 Where BatchID = '<$con.DlgData[BatchID]>' AND PrintStatus = 8~;

        if ( !dBase( Cmd,~<Cmd>~ ) )
        {
            dBase( GetErrorDescription,theErr );
            Invoke( ShowWarning,~Cmd Failed.  <theErr>.  <Cmd>~ );
            CleanupDatabase( dBase,~<RImageJobID>~,~<BatchID>~ );
            Invoke( ReenableControls );
            return FALSE;
        }
    }

	Invoke( ExportComplete,<count>,~<$con.DlgData[BatchID]>~,~<RImageJobID>~ );

	return TRUE;
}



TestJobPath = ~~;


// Check if an entry already exists in BravoBatchImages table for this
// image and size combination. Doing this check avoids the need to
// unnecessarily build a job file, render it and then figure out (after all
// that) there is a duplicate and handle it.
//
// Returns TRUE if entry already exists.
//
NUMERIC BravoIsInBatchImages( &dBase,Image,Setup )
{
    Query = ~SELECT Roll FROM BravoBatchImages WHERE BatchID='<BravoBatchID>' AND SourcePath='<Image>' AND SetupSize='<Setup>'~;
    count = dBase( RecordCountFor, ~<Query>~ );

    // TRUE if count is positive.
    return ( $count > 0 );
}

// Check if an entry already exists in BravoBatchImages table for this
// image (in any size). If so, we are guaranteed that a job will already
// have been created for a thumbnail of the same image. 
//
// Returns TRUE if a thumbnail already exists.
//
NUMERIC BravoGotThumbnail( &dBase,Image )
{
    Query = ~SELECT Roll FROM BravoBatchImages WHERE BatchID='<BravoBatchID>' AND SourcePath='<Image>'~;
    count = dBase( RecordCountFor, ~<Query>~ );

    // TRUE if count is positive.
    return ( $count > 0 );
}

// Create an entry in the BravoBatchImages table.
// Complements BravoIsInBatchImages function.
//
// Returns 0 on failure.
//
NUMERIC BravoAddToBatchImages( &dBase,Image,Setup )
{
    // Need to work out the "roll" value to use.
    // Confusingly, this is NOT the value of the roll field in the dialog
    // - that quantity is just the last roll that was used for any images
    //   exported.
    // We used to derive it from the Image path. It's the quantity between the
    // last and second last '\'s. We know this because of structured directory
    // naming during image import.
    //
    // However ROES does not use this convention, so we need to look at the images
    // table and use the Roll set there. For ROES orders this will probably be "None"
    // however this works for both ROES and Non ROES orders.
    //
//  Roll = GetRollFromImagePath( ~<Image>~ );
    Roll = GetRollFromImageTable( ~<Image>~ );
    if ( ~<Roll>~ == ~~ )
    {
        return 0;
    }

    Cmd = ~INSERT INTO BravoBatchImages(BatchID,SetupSize,SourcePath,Roll) VALUES('<BravoBatchID>','<Setup>','<Image>','<Roll>')~;
    return dBase( Cmd, ~<Cmd>~ );
}


NUMERIC QueueJobFor( &dBase,Image,Flatten,LastEntry,RImageJobID,ToPath,DeleteAfterRImage,AppOrderID )
{
	if ( IsNull( ~<Image>~ ) )
	{
		Invoke( ShowWarning,~No image to export~ );
		return FALSE;
	}

    if ( IsBravoEnabled() )
    {
        // Check if we have already got a job for this image at this resolution.
        if ( BravoIsInBatchImages( dBase,~<Image>~,~<$con.DlgData[Setup]>~ ) )
        {
            // No work to do. Job already exists for this.
            return TRUE;
        }
    }

    // Prepare a job file for the main image itself and then "queue" it in
    // the database.
    //
	JobID = 0;

	JobPath = CreateJobPath(JobID);

	if ( IsNull( ~<JobPath>~ ) )
	{
		Invoke( ShowWarning,~Couldn't create a unique job path~ );
		return FALSE;
	}

	if ( !CreateAJob( ~<JobPath>~,~<Image>~,~<LastEntry>~,~<RImageJobID>~,~<ToPath>~,<DeleteAfterRImage>,~<AppOrderID>~,FALSE ) )
	{
		return FALSE;
	}

    // Check if we are running in "Test" mode, in which case we just generate
    // the above Test file, set TestJobPath (below) and return.
    // OTHERWISE, we add the Job to the database queue - and then if Bravo
    // we generate the thumbnail.
    //
	if ( !DlgData( GetNumeric,Testing ) )
	{
		if ( !AddJobToDatabase( dbase,~<JobPath>~,~<JobID>~ ) )
		{
			return FALSE;
		}

        if ( IsBravoEnabled() )
        {
            // Bravo functionality is enabled, so we need to do a few things...
            
            // a) First work out if we need to generate a thumbnail for this
            //    image.
            // We only want to do this of not adding ROES comments allready
            // ie dont do proxies for proxies.
            AddROESComments = DlgData( GetNumeric,AddROESComments );

            if (<AddROESComments>)
            {
                 NeedThumbnail = FALSE;
            }
            else
            {
                NeedThumbnail = !BravoGotThumbnail(dBase,~<Image>~);
            }

            // b) Create an entry in the BravoBatchImages for this image,
            //    so that we won't do the work again in future.
            //    This has to be done after step a), otherwise we'll confuse
            //    BravoGotThumbnail().
            //
            if ( !BravoAddToBatchImages( dBase,~<Image>~,
                                         ~<$con.DlgData[Setup]>~ ) )
            {
                Invoke( ShowWarning,~Couldn't create a BravoBatchImages entry~ );
                return FALSE;
            }

            if ( <NeedThumbnail> )
            {
                // c) Generate a job file for a thumbnail version of the file.
                //
                JobID = 0;
                JobPath = CreateJobPath(JobID);

                if ( IsNull( ~<JobPath>~ ) )
                {
                    Invoke( ShowWarning,~Couldn't create a unique job path for thumbnail~ );
                    return FALSE;
                }

                // We've done the preamble (and got a JobID and JobPath) - now
                // build the Job file. The last parameter (TRUE), indicates that
                // a thumbnail is to be built.
                if ( !CreateAJob( ~<JobPath>~,~<Image>~,~<LastEntry>~,~<RImageJobID>~,~<ToPath>~,<DeleteAfterRImage>,~<AppOrderID>~,TRUE ) )
                {
                    return FALSE;
                }

                if ( !AddJobToDatabase( dbase,~<JobPath>~,~<JobID>~ ) )
                {
                    return FALSE;
                }
            }
        }
	}
	else
	{
		TestJobPath =  ~<JobPath>~;
	}

	Invoke( ShowProgress,~Queued Job <JobID> for <Image>~ );

	return TRUE;
}

FileNameSequence = 0;
CDPathSequence = 0;

STR IncrementingSequence( NumDigits )
{
	return Format( ~<FileNameSequence>~,~%0<NumDigits>ld~ );
}


CDPathSequence = 0;

STR IncrementingCDPathSequence( NumDigits )
{
	return Format( ~<CDPathSequence>~,~%0<NumDigits>ld~ );
}

VOID ResetIncrementingSequence()
{
	FileNameSequence = CDPathSequence = 0;
}

VOID getLDPLut (AppOrderID, ImagePath, &LDPLut)
{
    if (!GetWorkStationSettings( ~JobImport~,~BlackAndWhite~,Temp,Enabled ) )
    {
        SetWorkStationSettings( ~JobImport~,~BlackAndWhite~,~<$@Func.CustomerBWForNode(10000)>~,TRUE );
    } 

    if (!GetWorkStationSettings( ~JobImport~,~BlueTone~,Temp,Enabled ) )
    {
        SetWorkStationSettings( ~JobImport~,~BlueTone~,~\\Storage1\DP2\Tables\Blue Tone -25r  40b.txt~,TRUE ); 
    }

    if (!GetWorkStationSettings( ~JobImport~,~CopperTone~,Temp,Enabled ) )
    {
        SetWorkStationSettings( ~JobImport~,~CopperTone~,~\\Storage1\DP2\Tables\Copper_tone_35r_-10g_-40b.txt~,TRUE );
    }

	Query = ~select SequenceID From Images Where OrderID = '<AppOrderID>' and Path = '<ImagePath>'~;

	if ( !ADO( dBase,Connect,GetValuesFor,~<Query>~,lut ) )
	{
        Log( Session, ~getLDPLut: No Custom LUT for <AppOrderID> <ImagePath>)~ );
    }
    else
    {
        if (~<lut>~ == ~Sepia~)
        {
            GetWorkStationSettings( ~JobImport~ ,Sepia,LDPLut,Enabled );
        }

        if (~<lut>~ == ~BW~)
        {
            GetWorkStationSettings( ~JobImport~ ,BlackAndWhite,LDPLut,Enabled );
        }

        if (~<lut>~ == ~Copper~)
        {
            GetWorkStationSettings( ~JobImport~ ,CopperTone,LDPLut,Enabled );
        }

        if (~<lut>~ == ~Blue~)
        {
            GetWorkStationSettings( ~JobImport~ ,BlueTone,LDPLut,Enabled );
        }
        Log( Session, ~getLDPLut: LUT set to <lut>: <LDPLut>  <AppOrderID> <ImagePath>)~ );
    }
}

VOID getRenderPathForOrder ( OrderID, &renderPath )
{
    Query = ~Select renderpath From conversion where OrderID = '<OrderID>'~;

    if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
    {
        if ( List( GetNext, Record ) )
        {
             renderPath = ~<$pcon.Record[renderpath]>~;
             Log( Session, ~getRenderPathForOrder renderpath = <renderPath> for OrderID <OrderID>~);
        }
    }
    else
    {
        Log( Session, ~getRenderPathForOrder renderpath not found OrderID <OrderID> !!!!!>~);
    }
}

NUMERIC CreateAJob( JobPath,ImagePath,LastEntry,RImageJobID,ToPath,DeleteAfterRImage,AppOrderID,IsThumbnail )
{
    // This function has been updated to extract a custom LUT contained
    // in the image table under SequenceID for LDP orders.
    LDPLut = ~~;

    // In addition we set the conversion tables render path for LDP
    renderPath = ~~;

	if ( !File( Job,Open,~<JobPath>~,Create,Write ) )	// CREATE AND OPEN THE JOB
	{
		Invoke( ShowWarning,~Could not create the job file <JobPath>~  );
		return FALSE;
	}

	if ( !File( Job, UnicodeOutput ) )	// Unicode for Japanese text is necessary
	{
		return FALSE;
	}


	Resolution = 100; 
	
	if ( !IsNull(~<$Con.DlgData[Resolution]>~) )
	{
		Resolution = Numeric(~<$Con.DlgData[Resolution]>~);
	}

	if ( <Resolution> <= 0 )
	{
		Resolution = 100;
	}

	ScaleFactor = 100; 
	
	if ( !IsNull(~<$Con.DlgData[ScaleFactor]>~) )
	{
		ScaleFactor = Numeric(~<$Con.DlgData[ScaleFactor]>~);
	}

	if ( <ScaleFactor> <= 0 )
	{
		ScaleFactor = 100;
	}

    if ( <IsThumbnail> )
    {
        Resolution = ~<BravoThumbnailResolution>~;
        ScaleFactor = ~<BravoThumbnailScaleFactor>~;
    }

	Job( ~FileType: Job ;~ );

	Job( CRLF,WRITELINE,~Macros:   |Macros.txt|~ );

	Job( CRLF,WRITELINE,~UnitOfMeasure: Inches;~ );

	Job( CRLF,WRITELINE,~BeginInclude();~ );


	Job( CRLF,WRITELINE,~RImageJobID = |<RImageJobID>|;~ );
	Job( CRLF,WRITELINE,~OrderID = |<AppOrderID>|;~ );

	++FileNameSequence;
	++CDPathSequence;

	Job( CRLF,WRITELINE,~FileNameSequence = |<FileNameSequence>|;~ );
	Job( CRLF,WRITELINE,~CDPathSequence = |<CDPathSequence>|;~ );

	MACROSOFF

	Job( CRLF,WRITELINE,~STR IncrementingSequence( NumDigits )			{ return Format( |<FileNameSequence>|,|%0<NumDigits>ld| ); }~ );
	Job( CRLF,WRITELINE,~STR IncrementingCDPathSequence( NumDigits )	{ return Format( |<CDPathSequence>|,|%0<NumDigits>ld| ); }~ );

	MACROSON

	if (~<$Con.DlgData[Units]>~ == ~in.~)
	{
		MetricsToInchesConversion = 1.0;
	}
	else if (~<$Con.DlgData[Units]>~ == ~cm.~)
	{
		MetricsToInchesConversion = 1.0/2.54;
	}
	else if (~<$Con.DlgData[Units]>~ == ~mm.~)
	{
		MetricsToInchesConversion = 1.0/25.4;
	}

	Job( CRLF,WRITELINE,~MetricsToInchesConversion = <MetricsToInchesConversion>;~ );

	Job( CRLF,WRITELINE,~ImageWidth = |<$Con.DlgData[Width]>|; ImageHeight = |<$Con.DlgData[Height]>|; Resolution = |<Resolution>|; ScaleFactor = |<ScaleFactor>|;~);

	Job( CRLF,WRITELINE,~OverrideImageCrop = |<$Con.DlgData[OverrideImageCrop]>|;~ );
	Job( CRLF,WRITELINE,~ImageCropX = |<$Con.DlgData[ImageCropX]>|; ImageCropY = |<$Con.DlgData[ImageCropY]>|;~ );
	Job( CRLF,WRITELINE,~ImageCropWidth = |<$Con.DlgData[ImageCropWidth]>|; ImageCropHeight = |<$Con.DlgData[ImageCropHeight]>|;~ );
	Job( CRLF,WRITELINE,~TextXPercent = |<$Con.DlgData[TextXPercent]>|; TextWidthPercent = |<$Con.DlgData[TextWidthPercent]>|;~ );
	Job( CRLF,WRITELINE,~TextYPercent = |<$Con.DlgData[TextYPercent]>|; TextHeightPercent = |<$Con.DlgData[TextHeightPercent]>|;~ );
	Job( CRLF,WRITELINE,~OverrideImageRotation = |<$Con.DlgData[OverrideImageRotation]>|;~ );
	Job( CRLF,WRITELINE,~ImageRotation = |<$Con.DlgData[ImageRotation]>|;~ );

	Job( CRLF,WRITELINE,~NUMERIC GetDimensions( Image )~ );	
	Job( ~{~ );
	Job( ~	if ( !GetImageInfo( |<Image>|,MaxWidth,Width,MaxHeight,Height ) ) ~ );
	Job( ~	{~ );	
	Job( ~		Log( Session, |Could not open <Image>| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( CRLF,WRITELINE,~	ImageWidth = <Width>/<Resolution>*<MetricsToInchesConversion>;  ImageHeight = <Height>/<Resolution>*<MetricsToInchesConversion>;~ );
	Sizing = dlg( ComboBox,SizingComboBox,GetSelectedIndex );
	if ( <Sizing> == 6 )
	{
	MACROSOFF
	Job( ~	while ( <ImageWidth>  * <ScaleFactor> / 100.0  < 1.0 )~ );
	Job( ~	{~ );
	Job( ~	     ImageWidth = <ImageWidth> * 2.0 ;~ );
	Job( ~	     ImageHeight = <ImageHeight> * 2.0 ;~ );
	Job( ~	     Resolution = <Resolution> / 2.0 ;~ );
	Job( ~	}~ );
	Job( ~	while ( <ImageHeight> * <ScaleFactor>  / 100.0 < 1.0 )~ );
	Job( ~	{~ );
	Job( ~	     ImageWidth = <ImageWidth> * 2.0 ;~ );
	Job( ~	     ImageHeight = <ImageHeight> * 2.0 ;~ );
	Job( ~	     Resolution = <Resolution> / 2.0 ;~ );
	Job( ~	}~ );
	Job( ~	while ( <ImageWidth> * <ScaleFactor>  / 100.0 > 100.0 )~ );
	Job( ~	{~ );
	Job( ~	     ImageWidth = <ImageWidth> / 2.0 ;~ );
	Job( ~	     ImageHeight = <ImageHeight> / 2.0 ;~ );
	Job( ~	     Resolution = <Resolution> * 2.0 ;~ );
	Job( ~	}~ );
	Job( ~	while ( <ImageWidth> * <ScaleFactor>  / 100.0 > 100.0 )~ );
	Job( ~	{~ );
	Job( ~	     ImageWidth = <ImageWidth> / 2.0 ;~ );
	Job( ~	     ImageHeight = <ImageHeight> / 2.0 ;~ );
	Job( ~	     Resolution = <Resolution> * 2.0 ;~ );
	Job( ~	}~ );
	Job( ~	if ( <Resolution> < 10 ) ~ );
	Job( ~	{~ );	
	Job( ~		Log( Session, |<Image> cannot be sized at <ScaleFactor> percent.  It is too small.| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	if ( <Resolution> > 5000 ) ~ );
	Job( ~	{~ );	
	Job( ~		Log( Session, |<Image> cannot be sized at <ScaleFactor> percent.  It is too large.| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	if ( <ImageWidth> * <ScaleFactor> / 100.0 < 1 ) ~ );
	Job( ~	{~ );	
	Job( ~		Log( Session, |<Image> cannot be sized at <ScaleFactor> percent.  It is too small.| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	if ( <ImageWidth> * <ScaleFactor> / 100.0 > 100 ) ~ );
	Job( ~	{~ );	
	Job( ~		Log( Session, |<Image> cannot be sized at <ScaleFactor> percent.  It is too large.| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	if ( <ImageHeight> * <ScaleFactor> / 100.0 < 1 )~ );
	Job( ~	{~ );	
	Job( ~		Log( Session, |<Image> cannot be sized at <ScaleFactor> percent.  It is too small.| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	if ( <ImageHeight> * <ScaleFactor> / 100.0 > 100 )~ );
	Job( ~	{~ );	
	Job( ~		Log( Session, |<Image> cannot be sized at <ScaleFactor> percent.  It is too large.| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	MACROSON
	}
	Job( CRLF );
	Job( ~	if ( ImageCorrections( GetCrop,|<Image>|,cropX,cropY,cropW,cropH,Rotation ) ) ~ );
	Job( ~	{~ );
	Job( ~	   if ( <ImageCropWidth> && <ImageCropHeight> && <OverrideImageCrop> )~ );	
	Job( ~     {~ );
	Job( ~	     cropX = <ImageCropX>;~ );
	Job( ~	     cropY = <ImageCropY>;~ );
	Job( ~	     cropW = <ImageCropWidth>;~ );
	Job( ~	     cropH = <ImageCropHeight>;~ );
	Job( ~     }~ );
	Job( ~	   if ( <OverrideImageRotation> )~ );	
	Job( ~     {~ );
	Job( ~	     Rotation = <ImageRotation>;~ );
	Job( ~     }~ );
	Job( ~	   if ( SimilarStr(|<Rotation>|,|90|,|270| ) )~ );	
	Job( ~	   {~ );
	Job( ~	     Temp = <ImageWidth>;~ );
	Job( ~	     ImageWidth = <ImageHeight>;~ );	
	Job( ~	     ImageHeight = <Temp>;~ );	
	Job( ~	   }~ );
	Job( ~	   if ( !<cropW> )	{ cropH = cropW = 100;}~ );	
	Job( ~	   if ( !<cropH> )	{ cropH = cropW = 100;}~ );	
	Job( ~	   if ( !<cropX> )	{ cropX = cropY = 50;}~ );	
	Job( ~	   if ( !<cropY> )	{ cropX = cropY = 50;}~ );	
	Job( ~	   ImageWidth = <ImageWidth> * <cropW> / 100;~ );
	Job( ~	   ImageHeight = <ImageHeight> * <cropH> / 100;~ );	
	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	Job( CRLF,WRITELINE,~NUMERIC UpdateImagePath( OldPath,NewPath )~ );	
	Job( ~{~ );
	Job( ~	if ( SimilarStr( |<OldPath>|,|<NewPath>| ) )~ );
	Job( ~	{~ );	
	Job( ~		return TRUE;~ );
	Job( ~	}~ );
	Job( ~	if ( !ADO( dBase,Connect,Cmd,|Update Images Set Path = '<NewPath>' Where Path = '<OldPath>'| ) )~ );
	Job( ~	{~ );
	Job( ~		Log( Session, |Could not change <OldPath> to <NewPath> in the Images table| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

    if ( IsBravoEnabled() )
    {
        Job( CRLF,WRITELINE,~STR GetPrinterOutputPath()~ );	
        Job( ~{~ );
        Job( ~	if ( !PGenConList( List,Connect,Cursor,Forward,Query,|SELECT p.OutputPath AS POPath FROM JobQueue j INNER JOIN Printers p ON p.PrinterName=j.PrinterName WHERE BatchID='<BravoBatchID>'| ) )~ );
        Job( ~	{~ );
        Job( ~		Warning( |Error connecting to database to find printer output path for Batch <BravoBatchID> in the JobQueue table| );~ );
        Job( ~		Exit();~ );
        Job( ~	}~ );
        Job( ~	if ( !List( GetNext, Entry ) )~ );
        Job( ~	{~ );
        Job( ~		Warning( |Error getting printer output path for Batch <BravoBatchID> in the JobQueue table| );~ );
        Job( ~		Exit();~ );
        Job( ~	}~ );
        MACROSOFF
        Job( ~	return |<$pcon.Entry[POPath]>|;~ );
        MACROSON
        Job( ~}~ );
        Job( CRLF );
    }
	
	// SWMod Begin
	AddROESComments = DlgData( GetNumeric,AddROESComments );

    // User may have checked the ROES comments box.
    // But for Bravo, we always turn on ROES comments for thumbnails.
	if (<AddROESComments> || ( IsBravoEnabled() && <IsThumbnail> ) )
	{
		// Get the roll and frame info to be added
        // NOTE: The query below used to use LIKE instead of '=' and
        //       was WAY SLOW because LIKE ignores the DB index.
		Query = ~select OrderID,Roll From Images Where Path = '<ImagePath>'~;
		if ( !ADO( dBase,Connect,GetValuesFor,~<Query>~,imageOrderID,roll ) )
		{
			dBase( GetErrorDescription,theErr );
			Invoke( ShowWarning,Translate( ~Failed to get the roll from the Images table. Query:<Query>.  Error:<theErr>~ ) );
			return FALSE;
		}

		Job( CRLF,WRITELINE,~NUMERIC AddROESCommentsToImage()~ );	
		Job( ~{~ );
		Job( ~	GenCon( PrintComplete,IsPrintPage,PrintComplete );~ );
		Job( ~	PrintComplete( Get,IMAGEPATH,DestPath );~ );
		Job( ~	if (!ShellExecute( Open, javaw, |-jar "<$App.ShareDirectory>\CLCommentator.jar" "<DestPath>" "OriginalOrder=<imageOrderID>;FileName=<roll>\<$str.$ImagePath.FileName>;"|))~ );
		Job( ~	{~ );
		Job( ~		theErr = GetLastErrorMsg();~ );
		Job( ~		Warning( |ShellExecute failed calling CLCommentator.  Error:<theErr>| );~ );
		Job( ~		Exit();~ );
		Job( ~	}~ );
		Job( ~	return TRUE;~ );
		Job( ~}~ );
		Job( CRLF );
	}
	// SWMod End

	Job( CRLF,WRITELINE,~NUMERIC AddImageToRImageEditList()~ );	
	Job( ~{~ );
	Job( ~	GenCon( PrintComplete,IsPrintPage,PrintComplete );~ );
	Job( ~	PrintComplete( Get,IMAGEPATH,FromPath );~ );
	Job( ~	PrintComplete( Get,ExpandedCDSaveName,ExpandedCDSaveName );~ );
	Job( ~	if ( !ADO( dBase,Connect,Cmd,|Insert Into RImageEditList(ID,ToPath,FromPath,DeleteAfter) Values('<RImageJobID>','<ExpandedCDSaveName>','<FromPath>',<DeleteAfterRImage>)| ) )~ );
	Job( ~	{~ );
	Job( ~		Log( Session, |Could not add <FromPath> to the EditList for RImageJob for ID = <RImageJobID>| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	Job( CRLF,WRITELINE,~NUMERIC ReleaseRImageJob()~ );	
	Job( ~{~ );
	Job( ~	if ( !ADO( dBase,Connect,Cmd,|Update RImageOrders Set Progress = 1 Where ID = '<RImageJobID>'| ) )~ );
	Job( ~	{~ );
	Job( ~		Log( Session, |Could not release the RImageJob for ID = <RImageJobID>| );~ );
	Job( ~		Error();~ );
	Job( ~	}~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );

	Job( CRLF,WRITELINE,~NUMERIC FinishFlatten()~ );	
	Job( ~{~ );
	Job( ~	tries = 0;~ );
	Job( ~	while ( TRUE )~ );
	Job( ~	{~ );
	Job( ~		if ( Files( Rename,|<ImagePath>_ZZZ|,|<$Str.$ImagePath.WithoutExt><$con.DlgData[Extension]>| ) )~ );	
	Job( ~			break;~ );
	Job( ~		if ( GetLastError() != 32 )~ );	
	Job( ~		{~ );
	Job( ~			errMsg = GetLastErrorMsg();~ );
	Job( ~			err = GetLastError();~ );
	Job( ~			Files( Delete,|<ImagePath>_ZZZ| );~ );
	Job( ~			Log( Session, Translate( |FlattenImage: Could not rename <ImagePath>_ZZZ to <ImagePath>.  <errMsg>| ) );~ );
	Job( ~			return FALSE;~ ) ;
	Job( ~		}~ );
	Job( ~		++tries;~ );
	Job( ~		if ( <tries> > 10 )~ );	
	Job( ~		{~ );
	Job( ~			err = GetLastError();~ );
	Job( ~			errMsg = GetLastErrorMsg();~ );
	Job( ~			Files( Delete,|<ImagePath>_ZZZ| );~ );
	Job( ~			Log( Session,|FlattenImage: Failed to rename <ImagePath>_ZZZ to <ImagePath>. Error=<err>. <errMsg>.| );~ );
	Job( ~			return FALSE;~ );
	Job( ~		}~ );
	Job( ~		Sleep( 1000 );~ );
	Job( ~	}~ );
	Job( ~	Log( Session,|FlattenImage: Removing Image Corrections for <ImagePath>| );~ );
	Job( ~	ImageCorrections( Reset,|<ImagePath>| );~ );
	Job( ~	ImageCorrections( UpdateCrop,|<ImagePath>|,50,50,100,100 );~ );
	Job( ~	UpdateImagePath( |<ImagePath>|,|<$Str.$ImagePath.WithoutExt><$con.DlgData[Extension]>| );~ );
	Job( ~	return TRUE;~ );
	Job( ~}~ );
	Job( CRLF );


	Sizing = dlg( ComboBox,SizingComboBox,GetSelectedIndex );

	if ( DlgData( GetNumeric,Flatten ) || <Sizing> == 4 )	// USE THE ORIGINAL SIZE IF FLATTENING
	{
		Job( ~GetDimensions(|<ImagePath>|);~ );
		Job( ~  ImageHeight = ( <ImageHeight> / <MetricsToInchesConversion> );~ );
		Job( ~  ImageWidth = ( <ImageWidth> / <MetricsToInchesConversion>);~ );
	}
	else if ( <Sizing> == 1 )
	{
		Job( ~GetDimensions(|<ImagePath>|);~ );
		Job( ~DesiredWidth = |<$con.DlgData[Width]>*<MetricsToInchesConversion>|;~ );
		MACROSOFF
		Job( ~ImageHeight = (<DesiredWidth> * <ImageHeight>) / <ImageWidth>;~ );
		Job( ~ImageWidth = <DesiredWidth>;~ );
		MACROSON
	}
	else if ( <Sizing> == 2 )
	{
		Job( ~GetDimensions(|<ImagePath>|);~ );
		Job( ~DesiredHeight = |<$con.DlgData[Height]>*<MetricsToInchesConversion>|;~ );
		MACROSOFF
		Job( ~ImageWidth = (<DesiredHeight> * <ImageWidth>) / <ImageHeight>;~ );
		Job( ~ImageHeight = <DesiredHeight>;~ );
		MACROSON
	}
	else if ( <Sizing> == 3 )
	{
		Job( ~GetDimensions(|<ImagePath>|);~ );
		Job( ~DesiredSize = |<$con.DlgData[Width]>*<MetricsToInchesConversion>|;~ );
		MACROSOFF
		Job( ~if ( <ImageWidth> > <ImageHeight> )~ );
		Job( ~{~ );
		Job( ~  ImageHeight = (<DesiredSize> * <ImageHeight>) / <ImageWidth>;~ );
		Job( ~  ImageWidth = <DesiredSize>;~ );
		Job( ~}~ );
		Job( ~else~ );
		Job( ~{~ );
		Job( ~  ImageWidth = (<DesiredSize> * <ImageWidth>) / <ImageHeight>;~ );
		Job( ~  ImageHeight = <DesiredSize>;~ );
		Job( ~}~ );
		MACROSON
	}
	else if ( <Sizing> == 5 )	// EXACT WIDTH AND HEIGHT BUT ROTATE FOR BEST FIT
	{
		Job( ~GetDimensions(|<ImagePath>|);~ );
		Job( ~DesiredWidth = |<$con.DlgData[Width]>*<MetricsToInchesConversion>|;~ );
		Job( ~DesiredHeight = |<$con.DlgData[Height]>*<MetricsToInchesConversion>|;~ );
		MACROSOFF
		Job( ~if ( <ImageWidth> > <ImageHeight> )~ );	// LANDSCAPE
		Job( ~{~ );
		Job( ~  ImageWidth = Max(<DesiredWidth>,<DesiredHeight>);~ );
		Job( ~  ImageHeight = Min(<DesiredWidth>,<DesiredHeight>);~ );
		Job( ~}~ );
		Job( ~else~ );	// PORTAIT
		Job( ~{~ );
		Job( ~  ImageHeight = Max(<DesiredWidth>,<DesiredHeight>);~ );
		Job( ~  ImageWidth = Min(<DesiredWidth>,<DesiredHeight>);~ );
		Job( ~}~ );
		MACROSON
	}
	else if ( <Sizing> == 6 )	// RESIZE IMAGE BY A SCALE FACTOR
	{
		Job( ~GetDimensions(|<ImagePath>|);~ );
		Job( ~ScaleFactor = <$con.DlgData[ScaleFactor]>;~ );
		MACROSOFF
		Job( ~if (<ScaleFactor> < 0){ ScaleFactor == 100.0;}~);
		Job( ~ImageWidth = <ImageWidth> * <ScaleFactor> / 100.0;~ );
		Job( ~ImageHeight = <ImageHeight> * <ScaleFactor> / 100.0;~ );
		MACROSON
	}
	else  // has to be 0
	{
		ImageWidth = ~<$con.DlgData[Width]>*<MetricsToInchesConversion>~;
		ImageHeight = ~<$con.DlgData[Height]>*<MetricsToInchesConversion>~;
	}

	if ( <LastEntry> )
	{
		UserProcessAfterFile = ~<$con.DlgData[ProcessAfterFile]>~;

		if ( !IsNULL( ~<$con.DlgData[ProcessAfterFile]>~ ) )
		{
			Job( CRLF,WRITELINE,~OptionalInclude( |<UserProcessAfterFile>| );~ );
		}
	}

	Job( CRLF,WRITELINE,~EndInclude();~ );
	
	if ( DlgData( GetNumeric,UseFileEnabled ) && !DlgData( GetNumeric,Flatten ) )
	{
		Job( CRLF,WRITELINE,~Use: |<$con.DlgData[UseFile]>|;~ );
	}
	else
	{
		Job( CRLF,WRITELINE,~Main:~ );
		Job( ~	IWidth: <ImageWidth>;~ );
		Job( ~	IHeight: <ImageHeight>;~ );
		Job( ~	IColor: 0 255 255 255;~ );
	}

	Job( CRLF,WRITELINE,~IL: 1~ );
	Job( ~	IFile: |<ImagePath>|;~ );

	Job( CRLF,WRITELINE,~IL: 10000~ );
	Job( ~	IFile: |<ImagePath>|;~ );

// Commented lines are an example of how to write text over the image.  Paul Forleo 5/2/03
	if ( !DlgData( GetNumeric,UseFileEnabled ) )
	{
		Job( ~	ILocation: 0 0 <ImageWidth> <ImageHeight>;~ );
		Job( ~	AutoCrop: 50 50 <$con.DlgData[CropX]> <$con.DlgData[CropY]> <$con.DlgData[CropWidth]> <$con.DlgData[CropLength]>; ~ );

		if ( MakeNumber( ~<$con.DlgData[AdaptiveSharpen]>~ ) )
		{
			Job( ~	Adaptivesharpen:			<$con.DlgData[AdaptiveSharpen]>~ );
			Job( ~	Adaptivesharpenblur:		<$con.DlgData[AdaptiveSharpenLimit]>~ );
			Job( ~	Adaptivesharpenlimit:		<$con.DlgData[AdaptiveSharpenThreshold]>~ );
			Job( ~	Adaptivesharpenthreshold:	<$con.DlgData[AdaptiveSharpenBlur]>~ );
		}

		SharpenKeyword = MakeNumber( ~<$con.DlgData[SharpenFast]>~ ) ? ~SharpenFaster~ : ~Sharpen~;
		Job( ~	<SharpenKeyword>:	<$con.DlgData[SharpenValue]>~ );

		Job( ~	Density: <$con.DlgData[Density].numeric>;~ );
		Job( ~	RGB: 0, <$con.DlgData[Red].numeric>, <$con.DlgData[Green].numeric>, <$con.DlgData[Blue].numeric>;~ );
		Job( ~	XGamma: <$con.DlgData[XGamma].numeric>;~ );
		Job( ~	Contrast: <$con.DlgData[Contrast].numeric>;~ );
		Job( ~	Saturation: <$con.DlgData[Saturation].numeric>;~ );
		Job( ~	Negative: <$con.DlgData[Negative].boolean>;~ );

        // For export LDP orders we update the LUT based on the SequenceID which
        // Is overloaded to hold the LUT for each Image
        substr( ~<$con.DlgData[OrderID]>~, 0, 3, startChars );
		startChars = Upper( ~<startChars>~ );
        if ( ~<startChars>~ == ~LDP~)
        {
            getLDPLut(~<$con.DlgData[OrderID]>~, ~<ImagePath>~, LDPLut);

            getRenderPathForOrder( ~<$con.DlgData[OrderID]>~, renderPath ); 

            if (~<LDPLut>~ == ~~)
            {
		        Job( ~	MakeGrayScale: false;~ );
            }
            else
            {
		        Job( ~	MakeGrayScale: true;~ );
            }
        }
        else
        {
		    Job( ~	MakeGrayScale: <$con.DlgData[GrayScale].boolean>;~ );
        }

//		Job( ~	Text: |Copyright Joe Photographer|;~ );
//		Job( ~	TColor: 0 255 255 255;~ );
//		Job( ~	TStyle: 3 ;~ );
//		Job( ~	TranslucentText: 50 ;~ );

		if ( !DlgData( GetNumeric,Flatten ) )
		{
			if ( DlgData( GetNumeric,AutoRotate ) )
			{
				Job( ~	AutoRotate: <$con.DlgData[AutoRotate].numeric>;~ );
			}

			Job( ~	RotateFromDisk: <$con.DlgData[Rotation].numeric>;~ );

			if ( MakeNumber(~<$con.DlgData[OverrideImageCrop]>~) )
			{
				Job( ~	ImagecropX: <$con.DlgData[ImageCropX]>~ );
				Job( ~	ImagecropY: <$con.DlgData[ImageCropY]>~ );
				Job( ~	ImagecropWidth: <$con.DlgData[ImageCropWidth]>~ );
				Job( ~	ImagecropHeight: <$con.DlgData[ImageCropHeight]>~ );
				Job( ~	OverrideImageCrop: 1~ );
			}

			if ( MakeNumber(~<$con.DlgData[OverrideImageRotation]>~) )
			{
				Job( ~	OverrideImageRotation: <$con.DlgData[ImageRotation]>~ );
			}

		}
		
		TBINDEX = 1;
		while ( <TBINDEX> < 3)
		{
			EnableText = 1;
			ThisText  = ~<$con.DlgData[Text<TBINDEX>]>~;
			if (~<ThisText>~ == ~~)
			{
				EnableText = 0; 
			}
			if (<EnableText>)
			{
				
				TextXPercent = ~<$con.DlgData[TextXPercent<TBINDEX>].numeric>~;
				if (<TextXPercent> < 0.0)
				{
					TextXPercent = 0.0;        Log(Session, ~******* ExportImagesDoc Init Remote = <RemoteRun>~);
				} 
				else if (<TextXPercent> > 100.0)
				{
					TextXPercent = 100.0;
				}
				TextYPercent = ~<$con.DlgData[TextYPercent<TBINDEX>].numeric>~;
				if (<TextYPercent> < 0.0)
				{
					TextYPercent = 0.0;
				}
				else if (<TextYPercent> > 100.0)
				{
					TextYPercent = 100.0;
				}

				TextWidthPercent = ~<$con.DlgData[TextWidthPercent<TBINDEX>].numeric>~;
				TextHeightPercent = ~<$con.DlgData[TextHeightPercent<TBINDEX>].numeric>~;

				if (<TextWidthPercent> < 0.0)
				{
					TextWidthPercent = 0.0;
				}
				else if (<TextWidthPercent> > 100.0)
				{
					TextWidthPercent = 100.0;
				}
				if (<TextHeightPercent> < 0.0)
				{
					TextHeightPercent = 0.0;
				}
				else if (<TextHeightPercent> > 100.0)
				{
					TextHeightPercent = 100.0;
				}

				NodeNumber = 10000 + <TBINDEX>;
				Job( CRLF,WRITELINE,~IL: <NodeNumber>~ );
				if ( <TextXPercent> < <TextWidthPercent> / 2) 
				{
					IXPercentCenter =  <TextWidthPercent> / 2;  
				}
				else if ( <TextXPercent> > 100.0 - <TextWidthPercent> / 2)
				{
					IXPercentCenter = 100.0 - <TextWidthPercent> / 2;
				}
				else
				{
					IXPercentCenter =  <TextXPercent>;
				}

				if ( <TextYPercent> < <TextHeightPercent> / 2) 
				{
					IYPercentCenter =  <TextHeightPercent> / 2;  
				}
				else if ( <TextYPercent> > 100.0 - <TextHeightPercent> / 2)
				{
					IYPercentCenter = 100.0 - <TextHeightPercent> / 2;
				} 
				else
				{
					IYPercentCenter =  <TextYPercent>;
				}

				IXPercentLeft = ( <IXPercentCenter>  - <TextWidthPercent> / 2.0) ;
				IYPercentTop = ( <IYPercentCenter>  - <TextHeightPercent> / 2.0) ;

				Job( ~  ILocation: <IXPercentLeft> * <ImageWidth> / 100.0 <IYPercentTop> * <ImageHeight> / 100.0  0 0;~ );
				Job( ~  TLocation: 0  0  <TextWidthPercent> * <ImageWidth> / 100.0  <TextHeightPercent> * <ImageHeight> / 100.0 ;~ );
				Job( ~	Text: |<$con.DlgData[Text<TBINDEX>]>|;~ );

				Job( ~	TextColorOverride: |<$con.DlgData[TextColor<TBINDEX>]>|;~ );
				Job( ~	TStyle: 3 ;~ );
				Job( ~	TranslucentText: <$con.DlgData[TextTranslucence<TBINDEX>].numeric>;~ );
				Job( ~	RotateText: <$con.DlgData[TextRotation<TBINDEX>].numeric>;~ );
				Job( ~	Justification: <$con.DlgData[TextJustification<TBINDEX>]>;~ );
				Job( ~	TextAlignment: <$con.DlgData[TextAlignment<TBINDEX>]>;~ );
				Job( ~	WordWrap: <$con.DlgData[WordWrapText<TBINDEX>].numeric>;~ );
				TextStyleBold = ~<$con.DlgData[BoldText<TBINDEX>].numeric>~;
				TextStyleItalic = ~<$con.DlgData[ItalicText<TBINDEX>].numeric>~;
				TextStyle = <TextStyleBold> + 2 * <TextStyleItalic>;
				Job( ~	TStyle: <TextStyle>;~ );
				// Shadows
				Job( ~	ShadowEnable: <$con.DlgData[ShadowEnable<TBINDEX>].numeric>;~ );
				Job( ~	ShadowColor: <$con.DlgData[ShadowColor<TBINDEX>]>;~ );
				Job( ~	ShadowOffset: <$con.DlgData[HorzShadowOffset<TBINDEX>].numeric> , <$con.DlgData[VertShadowOffset<TBINDEX>].numeric>;~ );
				Job( ~	ShadowStrength: <$con.DlgData[ShadowStrength<TBINDEX>].numeric>;~ );
				Job( ~	ShadowBlur: <$con.DlgData[ShadowBlur<TBINDEX>].numeric>;~ );
				Job( ~	IRotation: <$con.DlgData[Angle<TBINDEX>].numeric>;~ );
				Job( ~	TFont: |<$con.DlgData[Font<TBINDEX>]>|;~ );
				Job( ~	TScriptSystem: |<$con.DlgData[CharacterSet<TBINDEX>]>|;~ );
			}

			TBINDEX = <TBINDEX> + 1;
		}

		Job( CRLF,WRITELINE,~AfterEffects:~ );
		Job( ~	Colormatrix:	|<$con.DlgData[Colormatrix]>|;~ );

        // For export LDP orders we update the LUT based on the SequenceID which
        // Is overloaded to hold the LUT for each Image
        if (~<LDPLut>~ != ~~)
        {
  		    Job( ~	Lut:			|<LDPLut>|;~ );
        } 
        else
        {
		    Job( ~	Lut:			|<$con.DlgData[LutFile]>|;~ );
        }

		Job( CRLF,WRITELINE,~Saveimage:~ );
		if ( IsBravoEnabled() )
		{
            // For Bravo, the queue is hard-wired.
			Job( ~	QueueName:		|<BravoQueueName>|;~ );
		}
		else
		{
			Job( ~	QueueName:		|<$con.DlgData[QueueName]>|;~ );
		}
		Job( ~	Copies:			1;~ );
		Job( ~	Enabled:		1;~ );
        if ( $IsThumbnail )
        {
            // Always use JPEG format for thumbnails.
            Job( ~	Savefiletype:	|JPEG|;~ );
        }
        else
        {
            Job( ~	Savefiletype:	|<$con.DlgData[SaveFileType]>|;~ );
        }
		Job( ~	CDSaveName:		|<$con.DlgData[RImageCDPath]>|;~ );
		Job( ~	CompressionQuality:		|<$con.DlgData[CompressionQuality]>|;~ );

		if ( SimilarStr( ~<$con.DlgData[SaveFileType]>~,~EXIF~,~TIFF~ ) && MakeNumber( ~<$con.DlgData[MaxThumbnailSize]>~ )  )
		{
			Job( ~	PreviewSize:		|<$con.DlgData[MaxThumbnailSize]>|;~ );
		}
		if ( <Sizing> != 6)
		{
			Job( ~	xRes:			<Resolution>;~ );
		}
		else
		{
			MACROSOFF
			Job( ~	xRes:			<Resolution>;~ );
			MACROSON
		}
		//Job( ~	Rotated:		|<$con.DlgData[Rotation]>|;~ );

		if ( DlgData( GetNumeric,ForceColorManagementOff )  == 1)
		{
			Job( ~	ForceColorManagementOff:	1;~ );
		}

		ChooseProfiles = DlgData(GetNumeric,ChooseProfiles );
		if (<ChooseProfiles>)
		{
			DefaultInputProfile = ~<$con.DlgData[DefaultInputProfile]>~;
			if ( !SimilarStr( ~<DefaultInputProfile>~, ~~ ) )
			{
				Job( ~	DefaultInputProfile:	|<DefaultInputProfile>|;~ );
			}

			WorkingSpaceProfile = ~<$con.DlgData[WorkingSpaceProfile]>~;
			if ( !SimilarStr( ~<WorkingSpaceProfile>~, ~~ ) )
			{
				Job( ~	WorkingSpaceProfile:	|<WorkingSpaceProfile>|;~ );
			}
		}

		ICCProfile = ~<$con.DlgData[ICCProfile]>~;
		if ( !SimilarStr( ~<ICCProfile>~, ~~ ) )
		{
			if ( DlgData( GetNumeric, OutputProfileEnabled) )
			{
				Job( ~	ImageOutputProfile:	|<ICCProfile>|;~ );
			}
			else if ( DlgData( GetNumeric,ForceColorManagementOff )  == 1)
			{
				// in case embed profile is on, we embed the selected one, not the one in the queue
				Job( ~	ImageOutputProfile:	|<ICCProfile>|;~ );
			}
		}
		if ( DlgData( GetNumeric,EmbedProfile ) )
		{
			Job( ~	EmbedProfileInOutputImage:	1;~ );
		}
		else
		{
			Job( ~	EmbedProfileInOutputImage:	0;~ );
		}

		ProcessAfterString = ~~;

		if ( DlgData( GetNumeric,Flatten ) )
		{
			Job( ~	Savename:		|<ImagePath>_ZZZ|;~ );
			ProcessAfterString =	~ ; FinishFlatten(); ~;
		}
		else
		{
			
			SafeFileName = String( RemoveCRLF,~<$con.DlgData[FileName]>~ );
		
            // If this is an LDP order then set the renderpath
            if (~<renderPath>~ != ~~)
            {	
                TheDir = ~<renderPath>~;
            }
            else
            {
                TheDir = ~<$con.DlgData[OutputDirectory]>~;
            }
            TheExt = ~<$con.DlgData[Extension]>~;
			
            if ( IsBravoEnabled() )
            {
                // If we are using the Bravo, then the output path depends on
                // the specific Bravo writer ("printer") that is being used.
                // This value is obtained via the OutputPath field of the
                // DP2 Printers table.
                //
                if ( <IsThumbnail> )
                {
                    // Thumbnails are always JPEG and always go in directory
                    // lo-res.
                    TheExt = ~.jpg~;
                    Directory = ~lo-res~;
                }
                else
                {
//                  Directory = ~<$@Func.ImageFieldForNode(1,Roll)>_<$con.DlgData[Setup]>~;
                    Directory = ~<$con.DlgData[Setup]>~;
                }
//              Job( ~	Savename:	|<$@Func.GetPrinterOutputPath()>\Batch-<BravoBatchID>\<Directory>\<$@Func.ImageFieldForNode(1,Roll)>_<$@Func.ImageFieldForNode(1,Path).FileName.WithoutExt><TheExt>|;~ );

                Job( ~	Savename:	|<$@Func.GetPrinterOutputPath()>\Batch-<BravoBatchID>\<Directory>\<$@Func.ImageFieldForNode(1,Roll)>\<$@Func.ImageFieldForNode(1,Path).FileName.WithoutExt><TheExt>|;~ );
            }
            else
            {
                Job( ~	Savename:	|<TheDir>\<SafeFileName><TheExt>|;~ );
            }
			
			if ( !IsNull(~<RImageJobID>~) )
			{
				ProcessAfterString = STR ( AddImageToRImageEditList(); );
			}
			
			// SWMod Begin
			AddROESComments = DlgData( GetNumeric,AddROESComments );

            // User may have checked the ROES comments box.
            // But for Bravo, we always turn on ROES comments for thumbnails.
            if (<AddROESComments> || ( IsBravoEnabled() && <IsThumbnail> ) )
			{
				ProcessAfterString = STR ( AddROESCommentsToImage(); <ProcessAfterString>; );
			}
			// SWMod End
		}

		if ( <LastEntry> )
		{
			if ( !IsNULL( ~<RImageJobID>~ ) )
			{
				ProcessAfterString = STR ( <ProcessAfterString> ReleaseRImageJob(); );
			}

			UserProcessAfter = STR ( <$con.DlgData[ProcessAfter]> );

			if ( !IsContentsNULL( UserProcessAfter ) )
			{
				ProcessAfterString = STR ( <ProcessAfterString> ; <UserProcessAfter>; );
			}
		}


		Job( ~	ProcessAfter: |<ProcessAfterString>|~ );
	}

	Job( Close );

	return TRUE;
}



NUMERIC AddJobToDatabase( &dbase,JobPath,JobID )
{
	if ( IsBravoEnabled() )
	{
        // For Bravo the queue is always hard-wired.
		QueueName = ~<BravoQueueName>~;
	}
	else
	{
		QueueName = ~<$con.DlgData[QueueName]>~;
	}

	while ( TRUE )
	{
		Now = Time();

		Fields = ~JobPath,QueueName,SubmitDate,BatchID,OrderID,OrderSequence,OrderItemID,OrderItemQty,OrderItemSequence,JobID,PrintStatus,Priority,Owner~;

		Values = ~'<JobPath>','<$con.DlgData[QueueName]>',<Now>,'<$con.DlgData[BatchID]>','<$con.DlgData[OrderID]>',1,
					<$con.DlgData[OrderItemID]>,1,<$con.DlgData[OrderItemSequence]>,'<JobID>',8,50,'<$App.UserName>'~;

		Cmd = ~Insert Into JobQueue(<Fields>) Values(<Values>)~;

		if ( dbase( Cmd,~<cmd>~ ) )
			break;

		dbase( GetErrorNumber,err,GetErrorDescription,theErr );

		if ( !dbase( ErrorIs,<err>,~Duplicate~) )
		{	
			Invoke( ShowWarning,Translate( ~Failed to add job to the JobQueue.  <Cmd>.  <theErr>~ ) );
			return FALSE;
		}
	}

	return TRUE;
}


STR CreateJobPath(&JobID)
{
	JobPath = ~<$App.ShareDirectory>\ExportImages~;

	Directory( Create,~<JobPath>~ );

	while ( TRUE )
	{

		JobID = UniqueJobID();

		JobName = ~Job_<JobID>~;

		if ( !Files( FileExists,~<JobPath>\<JobName>~ ) )
			break;
	}

	return ~<JobPath>\<JobName>~;
}


NUMERIC HandleDrop()
{
	if ( !GenCon( DragDropInfo,GetDropInfo ) )
	{ 
		return FALSE;
	}
	
	Tree( Location,~[GenCons]~,Name,DragDropInfo,Pluck );	// REMOVE THE DRAG INFO FROM THE TREE

	if ( !GenCon( SrcView,Is,~<$CON.DragDropInfo[SrcView]>~ ) )		// SEE IF THIS IS A DROP FROM OUTSIDE THE APPLICATION 
		{ return ExternalDrop(DragDropInfo); }			

	if ( ~<$con.SrcView[ViewDataType]>~ != Image )
		{ return ShowWarning( ~The DstView contains <$con.DstView[ViewDataType]> instead of Image~ ); }

	while ( SrcView( Find,IsSelected,~1~,FromLocation,ImageIcon ) )	// LOOP FOR EACH SELECTED ITEM IN THE VIEW
	{
		dlg( ListBox,ImagesListBox,AddString,~<$Con.ImageIcon[Path]>~ );					
		
		ImageIcon( Set,IsSelected,FALSE );
	}
	
	dlg( EnableControls,FALSE,StopButton );	

	return TRUE;
}


NUMERIC ExternalDrop( &DragDropInfo )
{
	if ( !DragDropInfo( GetCopyOfDraggedFiles,DraggedFileList ) )
	{ 
		return ShowWarning( Translate(~There were no files in the object you dragged~) );
	}

	count = DraggedFileList( ChildCount );
		
	if ( $count <= 0 )
	{ 
		return ShowWarning( ~There were no files in the object you dragged~; )
	}

	if ( <count> > 1 )
	{
		SortOrder = CustomMessageBox( Title,~Export Images~,Message,~Sort files by ...~,
										Button1,~File Name~,
										Button2,~Creation Date~,
										Button3,~Cancel~ );
		if ( <SortOrder> == 1 )
		{
			DraggedFileList( SortListBy,~Text~,~CreationTime~ );
		}
		else if ( <SortOrder> == 2 )
		{
			DraggedFileList( SortListBy,~CreationTime~,~Text~ );
		}
		else 
		{
			return FALSE;
		}
	}

	return ProcessDraggedFiles( DraggedFileList );;
}


NUMERIC ProcessDraggedFiles( &DraggedFileList )
{
	count = 0;

	dlg( EnableControls,TRUE,StopButton );

	more = DraggedFileList( GetFirst,Image );

	while ( <more> )
	{
		dlg( ListBox,ImagesListBox,AddString,~<$Con.Image[Text]>~ );

		++count;

		more = DraggedFileList( GetNext,Image );
	}

	dlg( EnableControls,FALSE,StopButton );

	return 0;
}


NUMERIC CheckFile( &dBase,ImagePath,Order,WhichRoll,WhichFrame )
{
	ShowProgress( Translate( ~Checking <ImagePath>~ ) );

	if ( !SQLSafe( ~<ImagePath>~ ) )
	{
		ShowWarning( ~Can't handle a path with a ' in it.  <ImagePath>~ );
		continue;
	}

	ImagePath = MakePath( Type,UNC,~<ImagePath>~);

	if ( !Files( IsUNC,~<ImagePath>~ ) && NetworkOperation() )
	{
		Msg = Translate( UIMessages,UnsharedFile,~<ImagePath>~ );

		if ( MessageBox( ~<Msg>~,YESNO ) != YES )
			{ return FALSE; }
	}

	return TRUE;
}



NUMERIC OnExplorerButton()
{
	Actions = ACTION DOC ( Explorer Open ExplorerDoc "Init(~Explore~,~~);" );
	return PerformActions( Actions );
}


NUMERIC SeeOrder()
{
	dlg( GetInput );

	dlgData( GetValues,OrderID,OrderID );

	Criteria = ~~;

	if ( ~<OrderID>~ == ~~ )
	{
		Actions = ACTIONS ( Doc( ~Search~ Open SearchDoc "Search( ~Orders~ );" ) );
		return PerformActions( Actions );
	}

	Query = ~Select * From Orders Where ID Like '<OrderID>%'~;

	OpenMethod = KeyState( RSHIFT ) ? Open : OpenOnce;

	Actions = ACTION DOC ( ~OrdersDoc~ <OpenMethod> OrdersDoc "Init( ~<OrderID>~,~<Query>~ );" );

	return PerformActions( Actions );
}


NUMERIC SeeRollsForOrder()
{
	dlg( GetInput );

	dlgData( GetValues,OrderID,OrderID,Roll,Roll );

	if ( ~<OrderID>~ == ~~ )
	{
		return ShowWarning( Translate( ~OrderID cannot be NULL~ ) );
	}

	Query = ~Select * From Rolls Where OrderID In ('<OrderID>') Order By OrderID,Roll~;

	OpenMethod = KeyState( RSHIFT ) ? Open : OpenOnce;

	Actions = ACTION Doc ( ~Rolls~ <OpenMethod> RollsDoc "Init( ~'<OrderID>'~,~<Query>~ );" );

	return PerformActions( Actions );
}


NUMERIC SeeFramesForOrder(AsImages)
{
	dlg( GetInput );
	dlgData( GetValues,OrderID,OrderID,Roll,Roll );

	if ( ~<OrderID>~ == ~~ )
	{
		return ShowWarning( Translate( ~OrderID cannot be NULL~ ) );
	}

	Query = ~Select * From Images Where OrderID In ('<OrderID>') Order By OrderID,Roll,Frame~;

	WhichDoc = <AsImages> ? ImagesDoc : ImagesDataDoc;

	Actions = ACTION Doc ( ~OrderImages~ OpenOnce <WhichDoc> "Init( ~<OrderID>~,<AsImages>,~<Query>~,0 );" );
	return PerformActions( Actions );
}


NUMERIC SeeFramesForRoll(AsImages)
{
	dlg( GetInput );
	dlgData( GetValues,OrderID,OrderID,Roll,Roll );

	if ( ~<OrderID>~ == ~~ )
	{
		return ShowWarning( Translate( ~OrderID cannot be NULL~ ) );
	}

	if ( ~<Roll>~ == ~~ )
	{
		return ShowWarning( Translate( ~Roll cannot be NULL~ ) );
	}

	Query = ~Select * From Images Where OrderID In ('<OrderID>') AND Roll = '<Roll>' Order By OrderID,Roll,Frame~;

	WhichDoc = <AsImages> ? ImagesDoc : ImagesDataDoc;

	Actions = ACTION Doc ( ~OrderImages~ OpenOnce <WhichDoc> "Init( ~<OrderID>~,<AsImages>,~<Query>~,0 );" );
	return PerformActions( Actions );
}


VOID CloseDialog()
{
	if ( aThread( IsActive ) )
	{
		dlg( SetDlgHandleActionsFlag,TRUE ) ;
		ShowWarning( ~Exporting is still active.  Please try again shortly~ );
		return;
	}

    // If user has exported images but possibly forgotten to click
    // "Finalise CD(s)". Give the user the chance to back out and click
    // "Finalise CD(s)" if they choose.
    if ( IsBravoEnabled() && <BravoExportsPending> )
    {
        if ( MessageBox( ~You have exported <BravoExportsPending> images (+ thumbnails) for burning on the Bravo but have not pressed "Finalise".
Are you sure you want to abort?~,YESNO ) == NO )
        {
            // User has changed mind. Back out.
            return;
        }

        // User is sure...
        if ( ADO( dBase,Connect ) )
        {
            // Clean up entries in the database for this batch.
            CleanupDatabase( dBase, ~~, ~<BravoBatchID>~ );
        }
    }

    dlg( END );
    Exit();
}

VOID CloseDialogNOWarn( OrderID )
{
    // If user has exported images but possibly forgotten to click
    // "Finalise CD(s)". Give the user the chance to back out and click
    // "Finalise CD(s)" if they choose.
    if ( IsBravoEnabled() && <BravoExportsPending> )
    {
        if ( MessageBox( ~You have exported <BravoExportsPending> images (+ thumbnails) for burning on the Bravo but have not pressed "Finalise".
Are you sure you want to abort?~,YESNO ) == NO )
        {
            // User has changed mind. Back out.
            return;
        }

        // User is sure...
        if ( ADO( dBase,Connect ) )
        {
            // Clean up entries in the database for this batch.
            CleanupDatabase( dBase, ~~, ~<BravoBatchID>~ );
        }
    }

    if ( $Remote == <BravoExport>)
    {
        UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionCompleted>, ~BravoStatus~);
    }
    else
    {
        UpdateStatus(~<$con.DlgData[OrderID]>~, <ConversionCompleted>, ~ProxiesStatus~);
    }
    dlg( END );
    Exit();
}

// RemoteRun indicates if this is an automated dialog.

VOID Init( OrderID, RemoteRun )
{
    Log(Session, ~***********************************************************************~);
    Log(Session, ~     Export Images Dialog Opened (<ExportVersion>)~);
    Log(Session, ~***********************************************************************~);

	if ( !Defined( dlg ) )
	{
		DefineDialog( ~<OrderID>~ );
	}
	
	if ( !Defined( OrderID ) )
	{
		Action = STR ( OnOrderCombo(); );
		QueueContentsAfter( Action,1000 );
	}
	
	if ( DefinedAndNotNULL( RemoteRun ) )
    {
        Log(Session, ~******* ExportImagesDoc Init Remote = <RemoteRun>~);
        Remote = <RemoteRun>;
    }
    
	// get the default input profile and working space profiles
	app( Application );
	Application( GetDefaultInputProfileName,DefaultInputProfile );
	DlgData(SetValues,DefaultInputProfile,~<DefaultInputProfile>~);
	dlg( SetControlValue,InputProfileComboBox,~<DefaultInputProfile>~ );

	Application( GetWorkingSpaceProfileName,WorkingSpaceProfile );
	DlgData(SetValues,WorkingSpaceProfile,~<WorkingSpaceProfile>~);
	dlg( SetControlValue,WorkingSpaceProfileComboBox,~<WorkingSpaceProfile>~ );

	RefreshInputProfilesComboBox(FALSE );
	RefreshOutputProfilesComboBox(FALSE );
	RefreshEmbedProfilesComboBox(FALSE );
	RefreshWorkingSpaceProfilesComboBox(FALSE );

	NewOutputProfileSelected(1);
	NewEmbedProfileSelected();

	UpdateRimageWritersList(TRUE);

	UpdateRimageImageTypeList();

	RefreshQueueComboBox(FALSE);
	
	UpdateSetupsList();

	dlg( SetControlFocus,OrderIDField );

	GetCharacterSets(1);
	GetCharacterSets(2);
	GetInstalledFonts(1);
	GetInstalledFonts(2);
	
	PopulateTextRotationCombo(1);
	PopulateTextRotationCombo(2);
	PopulateJustificationCombo(1);
	PopulateJustificationCombo(2);
	PopulateAlignmentCombo(1);
	PopulateAlignmentCombo(2);
	DlgData(GetValue,TextJustification1,JustV1);
	DlgData(GetValue,TextJustification2,JustV2);
	dlg( SetControlValue,TextJustificationComboBox1,~<JustV1>~);
	dlg( SetControlValue,TextJustificationComboBox2,~<JustV2>~);

	DlgData(GetValue,TextAlignment1,JustV1);
	DlgData(GetValue,TextAlignment2,JustV2);
	dlg( SetControlValue,TextAlignmentComboBox1,~<JustV1>~);
	dlg( SetControlValue,TextAlignmentComboBox2,~<JustV2>~);

	// OnFileTypeChange changes the values in DlgData.  If you want
	// something initialized, it must be before here.
	OnFileTypeChange(TRUE);

	OnSizingChange();

	RefreshQueueStatus();

	PopulateRImageTemplateCombo();

	PopulateRImageTemplateCombo();

	OnEmbedProfileBox();

    if (( $Remote == <BravoExport>) || ( $Remote == <ProxiesExport>))
    {	
        Action = STR ( OnUseSetupButton(FALSE); );
    }
    else
    {
        Action = STR ( OnUseSetupButton(TRUE); );
    }
	QueueContentsAfter( Action,1000 );

	if ( Defined( OrderID ) )
	{
		dlg( SetStrings,OrderID,~<OrderID>~ );

		Action = STR ( AddImagesForOrder(); );
		QueueContentsAfter( Action,1500 );

		Action = STR ( UpdateRollsCombo(FALSE); );
		QueueContentsAfter( Action,1100 );
	}


}

VOID UpdateCharacterSetComboBox(Tab)
{
	dlg( GetControlValue,CharacterSetComboBox<tab>,Charset );
	DlgData(SetValue,CharacterSet<Tab>,~<Charset>~);
	GetInstalledFonts(<Tab>);
}

NUMERIC GetCharacterSets(  Tab)
{
	if ( !StringList( characterSet, GetList, ~CharacterSets~ ) )
	{
		return Warning(Translate(~UpdateCharacterSetCombo: Unable to read character set from Strings~ ) );
	}

	dlg( SetControlFromStringList,CharacterSetComboBox<tab>,characterSet,Selection );

	DlgData(GetValue, CharacterSet<Tab>, CurrentValue);
	dlg( SetControlValue,CharacterSetComboBox<tab>,~<CurrentValue>~);

	return TRUE;
}

NUMERIC GetInstalledFonts(Tab )
{
	dlg( GetControlValue,CharacterSetComboBox<Tab>, CharacterSet);
	if ( SimilarStr( ~<CharacterSet>~,~~ ) )
	{
		CharacterSet = ~Western~;
	}

	if ( !StringList( currentFonts, GetInstalledFonts, ~<CharacterSet>~ ) )
	{
		return Warning(Translate(~Unable to read Fonts from supplied character set: <CharacterSet>.~ ) );
	}

	dlg( SetControlFromStringList,FontComboBox<tab>,currentFonts,Selection );
	DlgData(GetValue, Font<Tab>, CurrentValue);
	dlg( SetControlValue,FontComboBox<tab>,~<CurrentValue>~);

	return TRUE;
}


Thread( aThread);	// ADD THE PARAMETER DEBUG TO RUN AS A SUBROUTINE RATHER THAN A THREAD FOR SOURCE DEBUGGING



//Init(~Test~);  // for testing





