
Include: ~GetFullLayout~;
Include: ~Utilities.txt~;


IncludeClass( BaseHTML );
IncludeClass( BasePDF );

Class( Win,Extends,BaseHTML,
		Member,fHierarchy,Str,~~,
		Member,ViewIsImages,Numeric,TRUE,
		Member,DocumentQuery,Str,~~,
		Member,fImageFrameSize,Numeric,85,
		Member,fSmallSplitterSize,Numeric,14,
		Member,fBigSplitterSize,Numeric,245,
		Member,fMaxLevels,Numeric,5,
		Member,fLowResolutionScreen,Numeric,FALSE );

VOID	Win::Win()
{
	Title = ~Products~;
	fAcceptingDrops = TRUE;
	fDropTypes = ~Products~;
	
	HelpPage = ~Products.htm~;
	
	ScreenWidth = App( thisApp,MainWindow,GetClientWidth );
	fLowResolutionScreen = App( thisApp,MainWindow,GetClientWidth ) <= 1024;
	fImageFrameSize = <fLowResolutionScreen> ? 65 : 85;
}


VOID	Win::DefineMessages()
{
	BaseHTML::DefineMessages();	
	LoadTranslationFile(Products,Navigator,Navigator);
}

VOID	Win::OnLoadComplete()
{
	GetActiveView();
	Private( fHTMLView );
}



NUMERIC Win::RefreshThumbNailView()		{ return RefreshDoc(); }

VOID	RefreshDoc()					{ Obj.RefreshDoc(); }

NUMERIC Win::RefreshDoc()
{
	WaitCursor( Begin );
		
	theQuery = ~<DocumentQuery>~;
	
	if ( !IsNull(~<fHierarchy>~) )
	{
		theQuery = ~Select ProductTree.*,Products.*,'<fHierarchy>' as Category from ProductTree,Products
						Where <DocumentQuery> AND Products.ID = ProductTree.ProductID Order By LabelSequence,LabelSubsequence~;
	}
		
	ReturnOnFailure( !IsNull(~<theQuery>~) );
	
	Start = Ticks();

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<theQuery>~ ) )
	{
		WaitCursor( End );
		List( GetErrorDescription,0,theErr );
		Msg = TR( DBMessages, QueryFailed ,~<theQuery>~, ~<theErr>~);
		return Warning( ~<Msg>~ );
	}
	
	Count = List( NumEntries );
	
	List( SetConnection,~~ );
	
	SetDocumentData( List(GetObject) );
	
	ProductsWindow( DisableFocusChange,TRUE );
	
	ProductsWindow( CreateThumbNailViews,~ProductThumbNailCategory~,~ProductThumbNailImage~,List,Category,Field,~<fHierarchy>~ );
	
	if ( !IsNull(~<fHierarchy>~) )		// IF WE ARE SHOWING LABELS, WE CAN'T LET THEM EDIT THE CATEGORY TAB
	{
		if ( GenCon( ActiveView,GETACTIVEVIEW ) )
		{
			ActiveView( SetAllowCategoryNameChange,FALSE );
		}
	}

	WaitCursor( End );
	
	duration = (Ticks() - <Start>) / 1000;

	StatusBarText( ~<Count> Products read in <duration> seconds~ );

	return TRUE;
}



NUMERIC Win::RefreshAllViews()
{
	Queue( ~<THIS>.RefreshThumbNailView();~ );

	return TRUE;
}


NUMERIC Win::FindProducts()
{
	if ((~<$App.Name>~ !=~DP1.exe~) && (!GetUserPermissions( LayoutEditing ) ))
	{
		return Warning( Translate(UIMessages,NoPermission) );
	}

	msg = Translate( ~Find Products and Drag them to the Products Window~ );

	action = ACTION DOC ( Explorer Open ExplorerDoc "Init( ~<msg>~,~~ );" );

	return QueueContentsOf( action );
}


NUMERIC Win::OnExternalXRef()
{
	action = ACTION DOC ( ProductsXRefDoc OpenOnce ProductsXRefDoc "Init()" );
	return PerformActions( action );
}


NUMERIC Win::CreateNewLayout()
{
	if ( !GenCon( ActiveView,GETACTIVEVIEW,GETNAME,Category ) )
		{ return Warning( ~There was no active view for adding a category~ ); }
		
	if ( String( BeginsWith,~|~,~<Category>~ ) != ~~ )	// Dealing with the Product Hierarchy?
	{
		return Warning( ~You must create new products from a category.  You are in a label.~ );
	}	

	action = ACTION DOC ( LayoutNewDialog OpenOnce LayoutNewDialog "CreateDialog(~<Category>~);" );
	return PerformActions( action );
}


NUMERIC Win::CreateNewGridLayout()
{
	action = ACTION DOC ( GridGeneratorDialog Open GridGeneratorDialog "Init( );" );
	return PerformActions( action );
}


NUMERIC Win::AddCategory()
{
	if ( !GenCon( TheActiveWindow,GetActiveWindow ) )
		{ return Warning( ~There was no active window to add a category to~ ); }

	return TRUE;
}


NUMERIC Win::RenameCategory()
{
	if ( !GenCon( ActiveView,GETACTIVEVIEW,GETNAME,NewCategory,GET,PreviousCategoryName,PrevCategory ) )
		{ return Warning( ~There was no active view for adding a category~ ); }

	Cmd = ~UPDATE Products SET Category = '<NewCategory>' WHERE Category = '<PrevCategory>'~;

	if ( !Ado( dBase,Connect,CMD,~<Cmd>~ ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed: <Cmd>. <theErr>~ ) );
	}
	
	return RefreshAllViews();
}


VOID Win::GetParentDirectory (&x)
{
	if ( !IsNull( String( EndsWith,~\~,~<x>~ ) ) )
	{
		substr( ~<x>~,0,strlen(~<x>~)-1,x );
	}

	x = ~<$Str.$x.Path>~;
}


// Increment all Products (in database) having a sequence == Sequence and subsequence >= Subsequence by the number selected
NUMERIC UpdateSubseqInHierarchy(&dbase,selectedItemsCount,Sequence,Subsequence,Criteria,SequenceField,Sub)
{
	// update the product tree records having a matching sequence number and subsequence greater than or equal to the item dropped onto
	SQLCommand = ~Update ProductTree Set LabelSubsequence = LabelSubsequence + <selectedItemsCount> Where <Criteria> AND LabelSequence = <Sequence> AND LabelSubsequence >= <Subsequence> ~;
	if (!dbase(Cmd, ~<SQLCommand>~))
	{
		dBase(GetErrorDescription, theErr);
		return Warning( ~Unable to update the sequence number for items having an sequence number >= <DroppedOntoSequence>.  <theErr>~ );
	}
	return TRUE;
}

// Increment all Products (in database) having a sequence == Sequence and subsequence >= Subsequence by the number selected
NUMERIC UpdateSubseqInCategory(&dbase,selectedItemsCount,Sequence,Subsequence,Criteria)
{
	// update the product tree records having a matching sequence number and subsequence greater than or equal to the item dropped onto
	SQLCommand = ~Update Products Set Subsequence = Subsequence + <selectedItemsCount> Where <Criteria> AND Sequence = <Sequence> AND Subsequence >= <Subsequence> ~;
	if (!dbase(Cmd, ~<SQLCommand>~))
	{
		dBase(GetErrorDescription, theErr);
		return Warning( ~Unable to update the sequence number for items having an sequence number >= <DroppedOntoSequence>.  <theErr>~ );
	}
	return TRUE;
}


NUMERIC UpdateDraggedProductsTree(&dbase,&SelectedItems,Sequence,Subsequence)
{
	count = 0;
	ItemExists = SelectedItems(GetFirst,Item);
	
	while (<ItemExists>)
	{
		NewSubsequence = <Subsequence> + <count>;
		theID = ~<$con.Item[LabelID]>~;  // the id of an item that was dragged
		SQLCommand = ~Update ProductTree Set LabelSequence=<Sequence>,LabelSubsequence=<NewSubsequence> Where LabelID = <theID>~;
		
		if (!dBase(Cmd, ~<SQLCommand>~))
		{
			dBase(GetErrorDescription, theErr);
			return Warning( ~Unable to update the LabelSequence and LabelSubsequence in he ProductTree table.  <theErr>~ );
		}

		++count;
		Item(SetValue,LabelSequence,~<Sequence>~);
		Item(SetValue,LabelSubsequence,~<Subsequence>~);
		ItemExists = SelectedItems(GetNext,Item);
	}
	
	return TRUE;
}


NUMERIC UpdateDraggedCategory(&dbase,&SelectedItems,Sequence,Subsequence,Category)
{
	count = 0;
	ItemExists = SelectedItems(GetFirst,Item);
	
	while ( <ItemExists> )
	{
		NewSubsequence = <Subsequence> + <count>;
		theID = ~<$con.Item[ID]>~;  // the id of an item that was dragged
		SQLCommand = ~Update Products Set Category='<Category>',Sequence=<Sequence>,Subsequence=<NewSubsequence> Where ID = '<theID>'~;
		
		if (!dBase(Cmd, ~<SQLCommand>~))
		{
			dBase(GetErrorDescription, theErr);
			return Warning( ~Unable to update Product <theID>.  <SQLCommand>.  <theErr>~ );
		}

		++count;
		Item(SetValue,Sequence,~<Sequence>~);
		Item(SetValue,Subsequence,~<Subsequence>~);
		ItemExists = SelectedItems(GetNext,Item);
	}
	
	return TRUE;
}

NUMERIC Win::ResequenceProductInCategory( &View,ToLocation )
{
	View( Get,Text,Category );
	
	ReturnOnFailure( !IsNull(~<Category>~) );
	
	if ( String( BeginsWith,~|~,~<Category>~ ) != ~~ )	// Dealing with the Product Hierarchy?
	{
		Criteria = CreateCriteriaFromLabel(~<Category>~);
		SequenceField = ~LabelSequence~;
		SubSequenceField = ~LabelSubSequence~;
	}
	else	// Dealing with the regular product categories
	{
		Criteria = ~ Category = '<Category>' ~;
		SequenceField = ~Sequence~;
		SubSequenceField = ~SubSequence~;
	}
				
	if ( !View( GetAt, <ToLocation>, ToProduct ) )
	{
		totalItems = View(ChildCount);
		View(GetAt,<totalItems>-1,ToProduct);	
		ToProduct( GetData,ToProductData );		
		DroppedOntoSequence = Numeric(~<$con.ToProductData[<SequenceField>]>~);
		DroppedOntoSubsequence = Numeric(~<$con.ToProductData[<SubSequenceField>]>~) + 1;
	}
	else
	{
		ToProduct( GetData,ToProductData );
		DroppedOntoSequence = ToProductData(GetNumeric,<SequenceField>);
		DroppedOntoSubsequence = ToProductData(GetNumeric,<SubSequenceField>);
	}
		
	View( GetSelected,SelectedItems );
	selectedItemsCount = SelectedItems( ChildCount );
		
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr);
		return Warning( Translate( ~Could not connect to the database.  <theErr>~ ) );
	}

	// Increment all Products (in memory) having a sequence == droppedOntoSequence and subsequence >= DroppedOntoSubsequence by the number selected.
	// Then sets the subsequence number of all selected items to DroppedOntoSubsequence+0,+1,+2, etc. and sequence number to DroppedOntoSequence
	View(UpdateImagesList,<SequenceField>,<DroppedOntoSequence>,<SubSequenceField>,<DroppedOntoSubsequence>,<selectedItemsCount>);

	// Sorts the list by removing each selected item's DDICImageDef GenCon from the list and re-inserting it starting at newPosition 
	View(InsertSelectedAt,<ToLocation>);

	if ( String( BeginsWith, ~|~ , ~<Category>~ ) != ~~ )	// Dealing with the Product Hierarchy?
	{
		// Increment all products (in database) having a sequence == droppedOntoSequence and subsequence >= DroppedOntoSubsequence by the number selected
		UpdateSubseqInHierarchy(dbase,<selectedItemsCount>,<DroppedOntoSequence>,<DroppedOntoSubsequence>,~<Criteria>~);
	
		// Increment selected products (in database and memory) to sequence = droppedOntoSequence and subsequence = DroppedOntoSubsequence, and DroppedOntoSubsequence+ 1, ....etc
		UpdateDraggedProductsTree(dbase,SelectedItems,<DroppedOntoSequence>,<DroppedOntoSubsequence>);
	}
	else	// a regular product category
	{
		// Increment all products (in database) having a sequence == droppedOntoSequence and subsequence >= DroppedOntoSubsequence by the number selected
		UpdateSubseqInCategory(dbase,<selectedItemsCount>,<DroppedOntoSequence>,<DroppedOntoSubsequence>,~<Criteria>~);
	
		// Increment selected products (in database and memory) to sequence = droppedOntoSequence and subsequence = DroppedOntoSubsequence, and DroppedOntoSubsequence+ 1, ....etc
		UpdateDraggedCategory(dbase,SelectedItems,<DroppedOntoSequence>,<DroppedOntoSubsequence>,~<Category>~);
	}
	
	View(FreeCachedImageCorrections);
	return View( RefreshView );
}


NUMERIC Win::MoveProductToNewCategory( &SrcView,&DstView,ToLocation )
{
	DstView( SelectAll,FALSE );
	
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate( ~Could not connect to the database.  <theErr>~ ) );
	}
	
	SrcView( GetSelected,SelectedProducts );
	
	selectedItemsCount = SelectedProducts( ChildCount );
	
	ReturnOnFailure( <selectedItemsCount> > 0 );
	
	totalItems = DstView(ChildCount);
	
	if ( <ToLocation> < 0 )
	{
		ToLocation = <totalItems>;
	}
	
	DstView( Get,Text,Category );
	
	if ( String( BeginsWith,~|~,~<Category>~ ) != ~~ )	// Dealing with the Product Hierarchy?
	{
		Criteria = CreateCriteriaFromLabel(~<Category>~);
		SequenceField = ~LabelSequence~;
		SubSequenceField = ~LabelSubSequence~;
	}
	else	// Dealing with the regular product categories
	{
		Criteria = ~ Category = '<Category>' ~;
		SequenceField = ~Sequence~;
		SubSequenceField = ~SubSequence~;
	}

	if ( !<totalItems> )	// any items in the view?
	{
		DroppedOntoSequence = 0;
		DroppedOntoSubsequence = 0;
	}	
	else if ( !DstView( GetAt, <ToLocation>, ToProduct ) )		// at the end?
	{
		DstView(GetAt,<totalItems>-1,ToProduct);	
		ToProduct( GetData,ToProductData );		
		DroppedOntoSequence = Numeric(~<$con.ToProductData[<SequenceField>]>~);
		DroppedOntoSubsequence = Numeric(~<$con.ToProductData[<SubSequenceField>]>~) + 1;
	}
	else
	{
		ToProduct( GetData,ToProductData );
		DroppedOntoSequence = ToProductData(GetNumeric,<SequenceField>);
		DroppedOntoSubsequence = ToProductData(GetNumeric,<SubSequenceField>);
	}
	
	more = SelectedProducts( GetLast, Product );
	
	while ( <more> )
	{
		ProductID = ~<$con.Product[ID]>~;
		
		if (String(BeginsWith, ~|~ , ~<Category>~) != ~~)
		{
			n = GetTokens( ~<Category>~,~|~ );
			
			i = 0;   Criteria = ~~;  AND = ~~; separator = ~~;
			
			Key = UniqueProductTreeID(dBase);

			Fields = ~LabelID,ProductID~; 
			Values = ~<Key>,'<ProductID>'~;
			
			while ( <++i> <= <n> )
			{
				theValue = String( TrimLeftRight,~<Token<i>>~ );
				
				Fields = ~<Fields>,L<i>~;
				Values = ~<Values>,'<theValue>'~;
				
				Criteria = ~<Criteria> <AND> L<i>='<theValue>' ~;
				AND = ~AND~;
			}

			DstView(UpdateImagesList,<SequenceField>,<DroppedOntoSequence>,<SubSequenceField>,<DroppedOntoSubsequence>,<selectedItemsCount>);

			UpdateSubseqInHierarchy(dbase,<selectedItemsCount>,<DroppedOntoSequence>,<DroppedOntoSubsequence>,~<Criteria>~);

			Fields = ~<Fields>,<SequenceField>,<SubSequenceField>~;
			Values = ~<Values>,<DroppedOntoSequence>,<DroppedOntoSubsequence>~;

			Cmd = ~Insert Into ProductTree(<Fields>) Values(<Values>)~;
			
			if ( !dBase( CMD,~<Cmd>~ ) )
			{
				dBase( GetErrorDescription,theErr );
				return Warning( Translate( ~Database update failed: <Cmd>.  <theErr>~ ) );
			}
			
			UpdateProductsDisplay( dbase,~<ProductID>~,~<fHierarchy>~,SrcView,DstView,<SequenceField>,<DroppedOntoSequence>,<SubSequenceField>,<DroppedOntoSubsequence>,FALSE,<ToLocation> );
		}
		else
		{
			if ( SimilarStr( ~<Category>~,~Proof~ ) )
			{
				if ( Product( GetNumeric,Package ) )
				{
					PopupMsg( ~Product <ProductID> is a package.  It cannot be used for proofing~ );
				}
			}
			
			DstView(UpdateImagesList,<SequenceField>,<DroppedOntoSequence>,<SubSequenceField>,<DroppedOntoSubsequence>,<selectedItemsCount>);

			UpdateSubseqInCategory( dbase,<selectedItemsCount>,<DroppedOntoSequence>,<DroppedOntoSubsequence>,~ Category = '<Category>' ~);
			
			Cmd = ~UPDATE Products SET Category='<Category>',Sequence=<DroppedOntoSequence>,Subsequence=<DroppedOntoSubsequence> Where ID='<ProductID>'~;
			
			if ( !dBase( CMD,~<Cmd>~ ) )
			{
				dBase( GetErrorDescription,theErr );
				return Warning( Translate( ~Database update failed: <Cmd>.  <theErr>~ ) );
			}
	
			UpdateProductsDisplay( dbase,~<ProductID>~,~<Category>~,SrcView,DstView,<SequenceField>,<DroppedOntoSequence>,<SubSequenceField>,<DroppedOntoSubsequence>,TRUE,<ToLocation> );
		}
		
		more = SelectedProducts( GetPrev, Product );
	}
	
	DstView(FreeCachedImageCorrections);
	DstView( RefreshView );

	return TRUE;
}


NUMERIC Win::UpdateProductsDisplay( &dbase,ID,theCategory,&SrcView,&DstView,SequenceField,NextSequence,SubSequenceField,NextSubSequence,RemoveOriginal,ToLocation )
{
	Query = ~Select Products.*,'<theCategory>' as Category from Products LEFT OUTER JOIN ProductTree ON Products.ID = ProductTree.ProductID
						Where Products.ID = '<ID>'~;

	if ( !PGenConList( List,Connection,dBase,Cursor,Static,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
	}
	
	List( SetConnection,~~ );		// DISCONNECT FROM THE DATABASE

	ReturnOnFailure( List( GetFirst,Record ) );
	
	if ( IsNull(String( BeginsWith,~|~,~<Category>~ ) ) )	// Dealing with the regular product categories?
	{
		Record( Set,~<SequenceField>~,~<NextSequence>~ );
		Record( Set,~<SubSequenceField>~,~<NextSubSequence>~ );
	}
	
	GenCon( ThumbNailImage,New,DDICImageDef,SetValues,
			Info1,		~~ ,
			Info3,		~ID: <ID>  Name: <$pcon.Record[LayoutName]>  Type: <$pcon.Record[ProdType]>~,
			Info2,		~<ID>~,
			Path,		~<$pcon.Record[PreviewPath]>~,
			IsDeleted,	FALSE,
			IsSelected,	TRUE, 
			DropTypes,	Products,
			DataType,	Products, 
			Table,		Products,
			Key,		~ID = '<ID>'~ ) ;
			
	
	DstView( InsertThumbNailInView,ThumbNailImage,Product,Record,<ToLocation> );
	
	if ( DefinedAndTRUE(RemoveOriginal) )
	{
		if ( SrcView( FindI,Key,~ID = '<ID>'~,Where,DuplicateImage ) )
		{  
			SrcView( RemoveThumbNailFor,DuplicateImage );
			SrcView( RefreshView );
		}
	}
		
	//DstView(FreeCachedImageCorrections);
	DstView( RefreshView );

	return TRUE;
}


NUMERIC Win::ProcessDraggedFiles( &DraggedFileList,Category )
{
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate( ~Could not connect to the database.  <theErr>~ ) );
	}

	count = 0;
	IsMultipleProduct = FALSE;
	AlreadyAdded = FALSE;

	WaitCursor( Begin );

	success = DraggedFileList( GetFirst,Product );
	while ( <success>)
	{
		DocumentPath = ~<$con.Product[Text]>~;

		if ( !SQLSafe( ~<DocumentPath>~ ) )
		{
			Warning( ~Can't handle a path with a ' in it.  <DocumentPath>~ );
			success = DraggedFileList( GetNext,Product );
			continue;
		}

		if ( !Files( IsUNC,~<DocumentPath>~ ) && NetworkOperation() )
		{
			Msg = Translate( UIMessages,UnsharedFile,~<DocumentPath>~ );

			if ( MessageBox( ~<Msg>~,YESNO ) != YES )
			{ 
				WaitCursor( End );
				return FALSE;
			}
		}
		
		if ( !Files( IsWritable,~<DocumentPath>~) )
		{
			Msg = ~<DocumentPath> is write protected.  Is it okay to make it writeable? ~;
			
			if ( MessageBox( ~<Msg>~,YESNO ) != YES )
			{ 
				WaitCursor( End );
				return FALSE;
			}
			
			Files( ChMod,~<DocumentPath>~,ReadWrite );	 
		}
		
		if ( SimilarStr(~<$str.$DocumentPath.ext>~,~PDF~) )
		{
			AddProductFromPDF( dbase,~<DocumentPath>~,~<Category>~ );
		}
		else if ( GetFileType(~<DocumentPath>~) == TEXT )
		{
			FixCRInFile(~<DocumentPath>~);

			if (IsLayoutFileMultiple(~<DocumentPath>~))
			{
				IsMultipleProduct = TRUE;

				if (!<AlreadyAdded>)
				{
					DocFolder = ~<DocumentPath>~;	
					GetParentDirectory(DocFolder);

					DocumentName = ~<$str.$DocFolder.FileName.WithoutExt>~;

					if ( !AddANewMultipleProduct( dBase,ID,~<DocumentName>~,~<Category>~,~Digital~,~<DocFolder>~,~~,ProductsView,0 ) )
					{ 
						WaitCursor( End );
						return <count>;
					}

					AlreadyAdded = TRUE;
					
				}
			}

			else
			{
				DocumentName = ~<$str.$DocumentPath.FileName.WithoutExt>~;

				if ( !AddANewProduct( dBase,ID,~<DocumentName>~,~<Category>~,~Digital~,~<DocumentPath>~,~~,ProductsView,0 ) )
				{ 
					WaitCursor( End );
					return <count>;
				}

				++count;

			}

			if (<IsMultipleProduct>)
			{
				//  May not result in the CompositeNodes being updated for the layout, 
				//  as the DB may not be flushed yet as function gets different connection.
				if ( !ConvertGridLayoutToDP2(~<DocumentPath>~,~<ID>~) )
				{
					DeleteProduct( connection,~<ID>~ );
					return FALSE;
				}
				++count;

			}
		}
		
		success = DraggedFileList( GetNext,Product );
		IsMultipleProduct = FALSE;
	}

	WaitCursor( End );

	return <count>;
}


NUMERIC Win::AddProductFromPDF(&Connection,DocumentPath,Category )
{	
	ForgetGlobal( aPDF );
	
	BasePDF( new,aPDF );
	
	Global( aPDF );
	
	WaitCursor( Begin );	
	
	ID = ~<$str.$DocumentPath.FileName.WithoutExt>~;
				
	if ( !aPDF.ExtractToProduct( ~<ID>~,~<ID>~,~<Category>~,~<DocumentPath>~ ) )
	{
		err = aPDF.LastErrorMsg();
		ForgetGlobal( aPDF );
		WaitCursor( End );
		return Warning( ~<err>~ );
	}
	
	WaitCursor( End );	
	
	return ForgetGlobal( aPDF );
}


NUMERIC	Win::ProcessProductsDrop(&Item,&SrcView,&DstView,DropLocation)
{
	return warning( ~<$con.Item[ID]>~ );
}


NUMERIC Win::ExternalDrop( &DragDropInfo )
{
	if ( !GenCon( DstView,Is,~<$CON.DragDropInfo[DstView]>~ ) ) 
		{ return Warning( ~The Destination View is invalid~ ); }				

	if ( ~<$con.DstView[ViewDataType]>~ != Products )
		{ return Warning( ~The DstView contains <$con.DstView[ViewDataType]> instead of Products~ ); }

	DstView( Get,Text,Category );

	if (String(BeginsWith, ~|~ , ~<Category>~ ) != ~~)	// IS THIS A LABEL VIEW?
		{ return Warning( ~You dragged an external file into a label.  All new products must be assigned to a category.  You must drag new products into a category.  Only existing products can be assigned a label by dragging into a label window.~ ); }

	if ( ~<Category>~ == ~~  )
		{ return Warning( ~There is no Category~ ); }

	if ( !DragDropInfo( GetDraggedFiles,DraggedFileList ) )
		{ return ~There were no files in the object you dragged~; }

	count = DraggedFileList( ChildCount );
		
	if ( $count <= 0 )
		{ return ~There were no files in the object you dragged~; }

	if ( <count> > 1 )
	{
		if ( DraggedFileList( GetNext,Product ) )
		{
			DocumentPath = ~<$con.Product[Text]>~;
			
			if (!IsLayoutFileMultiple(~<DocumentPath>~))
			{
				SortOrder = CustomMessageBox( Title,~Import Products~,Message,~Sort files by ...~,
											Button1,~File Name~,
											Button2,~Creation Date~,
											Button3,~Cancel~ );
				if ( <SortOrder> == 1 )
				{
					DraggedFileList( SortListBy,~Text~,~CreationTime~ );
				}
				else if ( <SortOrder> == 2 )
				{
					DraggedFileList( SortListBy,~CreationTime~,~Text~ );
				}
				else 
				{
					return FALSE;
				}
			}
		}
	}

	count = ProcessDraggedFiles( DraggedFileList,~<Category>~ );

	RefreshAllViews();

	return TRUE;
}



NUMERIC Win::HandleDrop()
{
	if ( !GenCon( DragDropInfo,GetDropInfo ) )
		{ return FALSE; }
	
	Tree( Location,~[GenCons]~,Name,DragDropInfo,Pluck );		// REMOVE THE DRAG INFO FROM THE TREE

	if ( !GenCon( SrcView,Is,~<$CON.DragDropInfo[SrcView]>~ ) ) 
		{ return Obj.ExternalDrop(DragDropInfo); }			

	if ( !GenCon( DstView,Is,~<$CON.DragDropInfo[DstView]>~ ) ) 
		{ return Warning( ~The Destination View is invalid~ ); }				

	if ( ~<$con.SrcView[ViewDataType]>~ != Products )
		{ return Warning( ~The DstView contains <$con.DstView[ViewDataType]> instead of Products~ ); }
		
	if ( ~<$con.DstView[ViewDataType]>~ != Products )
		{ return BaseHtml::HandleDragDropInfo(DragDropInfo); }

	if ( ~<$con.DstView[ViewDataType]>~ != Products )
		{ return Warning( ~The DstView contains <$con.DstView[ViewDataType]> instead of Products~ ); }

	SrcView( Get,Text,Category );
	DstView( Get,Text,NewCategory );	
	ToLocation = ~<$CON.DragDropInfo[DropLocation]>~;

	if (!GetUserPermissions( ProductResequencing ))
	{
		return TRUE;
	}
	
	if ( ~<Category>~ == ~<NewCategory>~ )		// JUST A RESEQUENCE IN THE CURRENT CATEGORY?
	{
		if ( SrcView(GetObject) == DstView(GetObject) )
		{
			return ResequenceProductInCategory( SrcView,~<ToLocation>~ );
		}
		else	// Dragged from Category A in View 1 to Category A in View 2
		{
			warning( ~If you are just resequencing products in a category than don't drag across multiple windows~ );
			return FALSE;
		} 
	}
	else										// MOVING THIS LAYOUT TO A DIFFERENT CATEGORY
	{
		MoveProductToNewCategory( SrcView,DstView,~<ToLocation>~ );
	}

	return TRUE; // RefreshAllViews();
}


NUMERIC Win::CalcNextSequenceForLabel( &Connection,Criteria )
{
	if ( !Connection( CMD,~Select MAX(LabelSequence) From ProductTree Where <Criteria>~,MaxSequence ) )
	{
		NextSequence = -1;
	}
	else
	{
		NextSequence = ~<$rs.MaxSequence[#0]>~ == ~~ ? ~-1~ : ~<$rs.MaxSequence[#0]>~;
	}

	return $NextSequence + 1;
}

NUMERIC Win::CalcNextSequenceForCategory( &Connection,Table,CategoryField,NewCategory,SequenceField )
{
	if ( !Connection( CMD,~Select MAX(<SequenceField>) From <Table> Where <CategoryField> = '<NewCategory>'~,MaxSequence ) )
	{
		NextSequence = -1;
	}
	else
	{
		NextSequence = ~<$rs.MaxSequence[#0]>~ == ~~ ? ~-1~ : ~<$rs.MaxSequence[#0]>~;
	}

	return $NextSequence + 1;
}


STR Win::MakeUniqueProductID( &connection,ID )
{
	num = 1;
	Question = FALSE;
	OriginalID = ~<ID>~;
	NewID = ~<ID>~;

	while ( TRUE )
	{
		Query = ~Select ID,Category From Products Where ID = '<NewID>'~;

		if ( !connection( GetValuesFor,~<Query>~,Temp,Category ) )
		{
			if (<Question>)
			{
				if ( MessageBox( ~There is already a Product with ID <OriginalID> in Category <Category>.\n\n Is it OK to use <num>.<ID> (You can change it later) ?~,OKCANCEL ) != OK )
				{
					return ~~;
				}
			}
			return ~<NewID>~; 
		}
		else
		{
			NewID = ~<++num>.<ID>~;
			Question = TRUE;
		}
	}
}


NUMERIC Win::DuplicateSelectedProducts()
{
	if ( !GenCon( ProductsView,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductsView( GetSelected,Products ) )
		{ return Warning( ~There were no products selected~ ); }
	
	ProductsView( GetName,Category);

	if ( String( BeginsWith,~|~,~<Category>~ ) != ~~ )	// Dealing with the Product Hierarchy?
	{
		return Warning( ~You must create duplicate products from a category.  You are in a label.~ );
	}	

	count = Products( ChildCount );

	if ( !<count> )
		{ return Warning( Translate( ~There were no products selected~ ) ); }

	Left = 100;  Top = 400;  Count = 0;
	
	while ( Products( GetNext,Product ) )
	{
		//if ( Product(GetNumeric,Package) )
		//{
		//	Warning( Translate( ~<$con.Product[ID]> is a package.  You can't duplicate a package.~ ) );
		//	continue;
		//}  

		Actions = ACTION DOC ( ~DuplicateProductDoc~ Open DuplicateProductDoc "Init( ~<$con.Product[ID]>~,<Left>,<Top>, ~<Category>~);" );
		PerformActions( Actions );

		if ( <++count> >= 10 )
		{
			return Warning( Translate( ~You have selected too many layouts at once.  Opening 10.~ ) );
		}

		Left += 20;  Top += 20;
	}

	return TRUE;
}


NUMERIC Win::ScaleLayouts()
{
	if ( !GenCon( ProductsView,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductsView( GetSelected,Products ) )
		{ return Warning( ~There were no products selected~ ); }
	
	count = Products( ChildCount );

	if ( <count> != 1 )
	{ 
		return Warning( Translate( ~You should select one product.  This function works on one product at a time.~ ) );
	}
	
	if ( !Products( GetNext,Product ) )
	{ 
		return Warning( Translate( ~You should select one product. This function works on one product at a time.~ ) );
	}

	IsMultiple = Product(GetNumeric,Multiple);

	Actions = ACTION Doc ( ~ScaleLayoutDoc~ OpenOnce ScaleLayoutDoc "Init( ~<$con.Product[ID]>~ );" );

	return PerformActions( Actions );
}



NUMERIC Win::DisplayProdTypeMenu()
{
	if ( !GenCon( ProductsView,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductsView( GetSelected,SelectedProducts ) )
		{ return Warning( ~There were no products selected~ ); }
		
	ItemCount = SelectedProducts( ChildCount );

	if ( <ItemCount> <= 0 )
		{ return Warning( ~Nothing selected~ ); }
		
	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );
	
	Query = ~Select BackgroundType From BackgroundTypes Order By BackgroundType~;
	
	if ( !PGenConList( List,Connect,Query,~<Query>~) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
	}
	
	ProdType = ~~;
	
	if ( <ItemCount> == 1 )
	{
		SelectedProducts( GetFirst,Product );
		
		List( GetConnection,dBase );
		
		dBase( GetValuesFor,~Select ProdType From Products Where  ID='<$con.Product[ID]>'~,ProdType );
	}

	Count = 0;
	
	GenCon( ProdType<++Count>,New,DDMenuItemDef,AddTo,ListMenu,SetValues,
				Text,		~<Count>)  None~,
				IsChecked,	SimilarStr( ~~,~<ProdType>~ ) ? ~T~ : ~F~,
				IDText,		~ID~ );

	ActionsText = ACTION Exec ( <THIS>.SetType(~~); );
	ProdType<Count>( SetValuesFrom,ActionsText,ActionsText );

	while ( List( GetNext,Item ) )
	{
		GenCon( ProdType<++Count>,New,DDMenuItemDef,AddTo,ListMenu,SetValues,
				Text,		~<Count>)  <$pcon.Item[BackgroundType]>~,
				IsChecked,	SimilarStr( ~<$pcon.Item[BackgroundType]>~,~<ProdType>~ ) ? ~T~ : ~F~,
				IDText,		~ID~ );

		ActionsText = ACTION Exec ( <THIS>.SetType(~<$pcon.Item[BackgroundType]>~); );

		ProdType<Count>( SetValuesFrom,ActionsText,ActionsText );
	}
	
	return ProductsView( DisplayMenu,ListMenu );
}


NUMERIC Win::SetType( theType )
{
	if ( !GenCon( ProductsView,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductsView( GetSelected,Products ) )
		{ return Warning( ~There were no products selected~ ); }
		
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( ~Could not connect to the database.  <theErr>~ );
	}
	
	WaitCursor( Begin );

	while ( Products( GetNext,Product ) )
	{ 		
		Cmd = ~Update Products Set ProdType = '<theType>' Where ID='<$con.Product[ID]>'~;
		
		if ( !dBase( Cmd,~<Cmd>~ ) )
		{
			dBase( GetErrorDescription,theErr );
			WaitCursor( End );
			return Warning( ~Could not update the database.  <theErr>.  <Cmd>~ );
		}
		
		if ( Product( GetThumbNailInfo,ThumbNail ) )
		{
			ThumbNail( Set,Info3,~ID: <$con.Product[ID]>  Name: <$con.Product[LayoutName]>  Type: <theType>~ );
			
			if ( ThumbNail( GetData,Data ) )
			{
				Data( Set,ProdType,~<theType>~ );
			}

			ProductsView( RedrawThumbNail,ThumbNail,FALSE );
		}
	}
	
	return WaitCursor( End );
}





NUMERIC Win::ConvertToPattern()
{
	if ( !GenCon( ProductsView,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductsView( GetSelected,Products ) )
		{ return Warning( ~There were no products selected~ ); }
	
	count = Products( ChildCount );

	if ( <count> != 1 )
	{ 
		return Warning( Translate( ~You should select one product.  This function works on one product at a time.~ ) );
	}
	
	if ( !Products( GetNext,Product ) )
	{ 
		return Warning( Translate( ~You should select one product. This function works on one product at a time.~ ) );
	}

	if ( !Product(GetNumeric,Multiple) )
	{
		if ( MessageBox( ~You are about to convert the layout for <$con.Product[ID]> to a simple pattern that contains only positional information.  Are you sure you wish to continue?  ~,YESNO ) != YES )
		{ 
			return FALSE;
		}

		if ( MessageBox( ~This operation cannot be undone.  Are you really sure you wish to continue?  ~,YESNO ) != YES )
		{ 
			return FALSE;
		}

		WaitCursor( Begin );

		if ( !ConvertLayoutToPattern( ~<$con.Product[ProductLayoutPath]>~ ) )
		{
			return FALSE;
		}

		WaitCursor( End );

		return FALSE;
	}  

	if ( MessageBox( ~<$con.Product[ID]> has multiple layouts.  You are about to convert all layouts for product <$con.Product[ID]> to simple patterns that contain only positional information.  Are you sure you wish to continue?  ~,YESNO ) != YES )
	{ 
		return FALSE;
	}

	if ( MessageBox( ~This operation cannot be undone.  Are you really sure you wish to continue?  ~,YESNO ) != YES )
	{ 
		return FALSE;
	}

	Count = 0;

    MoreFiles = findfile( aDirectoryEntry,Find,~<$con.Product[ProductLayoutPath]>\*.*~ );

	WaitCursor( Begin );

    while ( $Morefiles )
    {
		WaitCursor( Begin );

        Morefiles = aDirectoryEntry( Next );

        aDirectoryEntry( Get,Path,aPath );
                
        if ( aDirectoryEntry( Dots ) )
                continue;
                
        if ( aDirectoryEntry( Is,aDirectoryEntry(Directory) ) )
			continue;

        aDirectoryEntry( Get,Title,theFileName );

		if ( !ConvertLayoutToPattern( ~<aPath>~ ) )
		{
			WaitCursor( End );
			return FALSE;
		}
    }

	WaitCursor( End );

	return TRUE;
}


NUMERIC Win::ConvertGridLayoutToDP2( Path,ProductID )
{
	StatusBar( ~Converting <Path>~ );

	if ( !Document( theLayout,ParseFile,~<Path>~ ) )
	{
		return Warning( ~An error occured while parsing the job at <Path>~ );
	}

	if ( !theLayout( GetRenderList,0,aRenderList ) )
	{ 
		return Warning( ~There was no render list for <Path>~ );
	}

	aRenderList( AddIPrompts,~Select an Image~,TRUE,FALSE );

	if ( !aRenderList( WriteCompositeNodes,~<ProductID>~))
	{
		return Warning( ~Failed to update Composite Node Names~ );
	}

	if ( !aRenderList( WriteJob,~<Path>~ ) )
	{
		return Warning( ~Failed to write <Path>~ );
	}

	return TRUE;
}


NUMERIC Win::ConvertLayoutToPattern( Path )
{
	StatusBar( ~Converting <Path>~ );

	if ( !Document( theLayout,ParseFile,~<Path>~ ) )
	{
		Warning( ~An error occured while parsing the job at <Path>~ );
		return FALSE;
	}

	if ( !theLayout( GetRenderList,0,aRenderList ) )
	{ 
		return Warning( ~There was no render list for <Path>~ );
	}

	if ( !aRenderList( WritePattern,~<Path>~ ) )
	{
		return Warning( ~Failed to write a pattern for <Path>~ );
	}

	return TRUE;
}

NUMERIC Win::CreateNewNodeStyle()
{
	if ( !Files( UniqueFilename,~<$App.Directory>\Empty~,LayoutPath ) )
	{
		return Warning( Translate( ~Failed to create a unique filename~ ) );
	}

	if ( !CreateEmptyLayout( ~<LayoutPath>~ ) )
	{
		return FALSE;
	}

	if ( !Document( aLayout,Open,~<LayoutPath>~,Layout ) )
	{ 
		return Warning( ~Could not open <LayoutPath>~ );
	}

	Action = STR ( <THIS>.DelayedRemoveAJob( ~<LayoutPath>~ ); );

	QueueContentsAfter( Action,1000 );

	return TRUE;
}


VOID Win::DelayedRemoveAJob( Path )
{
	Files( Delete,~<Path>~ );
}



NUMERIC Win::CreateEmptyLayout( LayoutPath )
{
	if ( !File( aLayout,Open,~<LayoutPath>~,Create,Write ) )	// CREATE AND OPEN THE JOB
	{
		return Warning( ~Could not open the layout file <LayoutPath>~ );
	}

	aLayout( ~FileType: Layout~ );
	aLayout( ~Unitofmeasure:   |Inches|~ );
	aLayout( ~Macros: |Macros.txt|~);
	aLayout( ~Main:~ );
	aLayout( ~  IWidth: 6~ );
	aLayout( ~  IHeight: 6~ );
	aLayout( ~  IColor: 0 255 255 255~ );
	
	aLayout( Close );

	return TRUE;
}



NUMERIC Win::DeleteProduct( &connection,ID )
{
	Count = connection( RecordCountFor,~Select PackageID from Packages Where ProductID = '<ID>'~ );

	if ( <Count> )
	{
		if ( MessageBox( ~<Count> Package(s) use Product <ID>.  Are you sure you want to delete it? ~,YESNO ) != YES )
			{ return FALSE ; }
	}

	cmd = ~Delete FROM Packages WHERE ProductID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed: <cmd>.  <theErr>~) );
	}

	cmd = ~Delete FROM Packages WHERE PackageID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed: <cmd>.  <theErr>~) );
	}

	cmd = ~Delete From Products Where ID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <cmd>. <theErr>~ ) );
	}

	cmd = ~Delete From CompositeNodes Where ProductID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <cmd>. <theErr>~ ) );
	}

	cmd = ~Delete From ProShotsProducts Where CustomerID = 'All' AND ProductID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <cmd>. <theErr>~ ) );
	}

	cmd = ~Delete From DigProductPrintServicesPrices Where ProductID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <cmd>. <theErr>~ ) );
	}

	cmd = ~Delete From BookProductAttributes Where ProductID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <cmd>. <theErr>~ ) );
	}

	cmd = ~Delete From BookProductsForNexpress Where ProductID = '<ID>'~;

	if ( !connection( CMD,~<cmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <cmd>. <theErr>~ ) );
	}
	Log( Session,Translate( ~Deleted Product <ID>~ ) );

	return TRUE;
}


NUMERIC Win::IsLayoutFileMultiple(LayoutPath)
{
	IsMultiple = FALSE;

	aString = FileContainsSimilarStr( ~<LayoutPath>~,~CC:~,TRUE,TRUE );

	IsMultiple = !IsContentsNull(aString);

	if ( !<IsMultiple> )
	{
		aString = FileContainsSimilarStr( ~<LayoutPath>~,~CompositeContent:~,TRUE,TRUE );

		IsMultiple = !IsContentsNull(aString);
	}

	if ( !<IsMultiple> )
	{
		aString = FileContainsSimilarStr( ~<LayoutPath>~,~CL:~,TRUE,TRUE );

		IsMultiple = !IsContentsNull(aString);
	}

	if ( !<IsMultiple> )
	{
		aString = FileContainsSimilarStr( ~<LayoutPath>~,~CompositeLayout:~,TRUE,TRUE );

		IsMultiple = !IsContentsNull(aString);
	}

	return <IsMultiple>;
}


NUMERIC Win::AddANewProduct( &connection,&ID,Name,Category,ProductType,LayoutPath,PreviewPath,&ProductsView,Package )
{

	IsMultiple = FALSE;

	ID = ~<$str.$LayoutPath.FileName.WithoutExt>~;

	ID = MakeUniqueProductID( connection,~<ID>~ ) ;

	if ( IsNULL( ~<ID>~ ) )
	{
		return FALSE;
	}

//	if ( MessageBox( ~Is it OK to add a product with an ID of <ID>? ~,YESNO ) != YES )
//		{ return FALSE ; }

	if ( !DeleteProduct( connection,~<ID>~ ) )
	{
		return FALSE;
	}

	NextSequence = CalcNextSequenceForCategory( connection,Products,Category,~<Category>~,Sequence );

	UpdateCmd = ~INSERT INTO  Products(ID,LayoutName,Category,Sequence,ProductType,Package,ProductLayoutPath,PreviewPath,Multiple)
								Values('<ID>','<Name>','<Category>',<NextSequence>,'<ProductType>',<Package>,'<LayoutPath>','<PreviewPath>',<IsMultiple>)~;

	if ( !connection( CMD,~<UpdateCmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <UpdateCmd>. <theErr>~ ) );
	}

	Query = ~Select * From Products Where ID = '<ID>'~;

	if ( !PGenConList( List,Connection,connection,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Query Failed: <Query>. <theErr>~ );
	}

	if ( !List( GetFirst,Record ) )	// WE ARE TOO SOON???? ... DATABASE HASN'T FLUSHED YET???????????
	{
		return FALSE;
	}

	GenCon( ThumbNailImage,New,DDICImageDef,SetValues,
			Info1,		~~ ,
			Info3,		~ID: <ID> Name: <Name>  Type:~,
			Info2,		~<ID>~,
			Path,		~<PreviewPath>~,
			IsDeleted,	FALSE,
			IsSelected,	TRUE, 
			DropTypes,	Products,
			DataType,	Products, 
			Table,		Products,
			Key,		~ID = '<ID>'~ ) ;

	ProductsWindow( AddThumbNailToExistingView,ThumbNailImage,~<ID>~,Product,Record );

	return TRUE;
}

NUMERIC Win::AddANewMultipleProduct( &connection,&ID,Name,Category,ProductType,LayoutPath,PreviewPath,&ProductsView,Package )
{

	ID = ~<$str.$LayoutPath.FileName.WithoutExt>~;
	ID = MakeUniqueProductID( connection,~<ID>~ ) ;
	IsMultiple = TRUE;

	if ( IsNULL( ~<ID>~ ) )
	{
		return FALSE;
	}

//	if ( MessageBox( ~Is it OK to add a product with an ID of <ID>? ~,YESNO ) != YES )
//		{ return FALSE ; }

	if ( !DeleteProduct( connection,~<ID>~ ) )
	{
		return FALSE;
	}

	NextSequence = CalcNextSequenceForCategory( connection,Products,Category,~<Category>~,Sequence );

	UpdateCmd = ~INSERT INTO  Products(ID,LayoutName,Category,Sequence,ProductType,Package,ProductLayoutPath,PreviewPath,Multiple)
								Values('<ID>','<Name>','<Category>',<NextSequence>,'<ProductType>',<Package>,'<LayoutPath>','<PreviewPath>',<IsMultiple>)~;

	if ( !connection( CMD,~<UpdateCmd>~ ) )
	{
		connection( GetErrorDescription,theErr );
		return Warning( Translate( ~Database update failed <UpdateCmd>. <theErr>~ ) );
	}

	Query = ~Select * From Products Where ID = '<ID>'~;

	if ( !PGenConList( List,Connection,connection,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Query Failed: <Query>. <theErr>~ );
	}

	if ( !List( GetFirst,Record ) )	// WE ARE TOO SOON???? ... DATABASE HASN'T FLUSHED YET???????????
	{
		return FALSE;
	}

	GenCon( ThumbNailImage,New,DDICImageDef,SetValues,
			Info1,		~~ ,
			Info3,		~ID: <ID>  Name: <Name>  Type: ~,
			Info2,		~<ID>~,
			Path,		~<PreviewPath>~,
			IsDeleted,	FALSE,
			IsSelected,	TRUE, 
			DropTypes,	Products,
			DataType,	Products, 
			Table,		Products,
			Key,		~ID = '<ID>'~ ) ;

	ProductsWindow( AddThumbNailToExistingView,ThumbNailImage,~<ID>~,Product,Record );

	return TRUE;
}

STR Win::MakePreviewPathFromPath( Path,CreateDirectory )
{
	if ( $CreateDirectory )
	{ 
		if ( !Directory( Create,~<$str.$Path.Path>\Preview~ ) )
		{
			Warning( ~Could not Create Directory: <$str.$Path.Path>\Preview.  <$Func.GetLastErrorMsg()>~ );
		}
	 }

	AbsolutePath = ~<$str.$Path.Path>\Preview\<$str.$Path.FileName>.jpg~;

	return ~<AbsolutePath>~;
}


NUMERIC Win::UpdateProductPreviewImages( Path )
{
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( ~Could not connect to the database.  <theErr>~ );
	}

	WaitCursor( Begin );

	Index = 0;

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( !Window( GetNext,aView ) )
			continue;

		aView( Get,ViewType,ViewType );

		if ( (~<ViewType>~ == LayoutView) || (~<ViewType>~ == ImageView) || (~<ViewType>~ == PIELayoutView) || (~<ViewType>~ == PIEView))
		{
			aView( GetDocumentPath,DocumentPath );

			if ( ~<Path>~ != ~~ )	// JUST LOOKING FOR A CERTAIN ONE?
			{
				if ( Upper(~<DocumentPath>~) != Upper(~<Path>~) )	// RIGHT ONE?
					{ continue; }
			}

			PreviewPath = MakePreviewPathFromPath( ~<DocumentPath>~,TRUE );
			
			returnVal = aView( MakePreviewImage,3,3,~<PreviewPath>~,JPEG );

			if (<returnVal> == 0)
			{
				// fatal error
				Warning( Translate(~Failed to make preview icon.  <PreviewPath> may be write protected.~) );
				break;
					
			}
			else if (<returnVal> == -1)
			{
				// fatal error
				Warning( Translate(~Image not fully rendered.  Please try again later.~) );
				break;
			}

			aView( GetProductID, ProductID);

			Cmd = ~Update Products Set PreviewPath = '<PreviewPath>' Where ID = '<ProductID>'~;

			//Cmd = ~Update Products Set PreviewPath = '<PreviewPath>' Where ProductLayoutPath = '<DocumentPath>'~;

			if ( !dBase( CMD,~<Cmd>~ ) )
			{
				dBase( GetErrorDescription,theErr );
				return Warning( ~Database update failed: <Cmd>.  <theErr>~ );
			}

			RedrawLayoutIcon( ~<ProductID>~,~<PreviewPath>~ );  // added 11/18/04 to avoid refreshing entire view
		}
	}

//	RefreshAllViews();  // commented 11/18/04 to avoid refreshing entire view

	WaitCursor( End );

	return TRUE;
}


NUMERIC Win::SetProductPreviewImages( Path )		// USUALLY USED FOR PACKAGES AND GRID LAYOUTS, BUT WILL WORK WITH ANY LAYOUT
{
	if ( !GenCon( ProductsView,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductsView( GetSelected,Products ) )
		{ return Warning( ~There were no products selected~ ); }

	if ( Products( ChildCount ) < 1 || Products( ChildCount ) > 1 )
	{
		return Warning( Translate( ~You must select exactly one product to update~ ) );
	}

	Products( GetFirst,Product );

	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( ~Could not connect to the database.  <theErr>~ );
	}

	WaitCursor( Begin );

	Index = 0;

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( !Window( GetNext,aView ) )
			continue;

		aView( Get,ViewType,ViewType );

		if ( (~<ViewType>~ == LayoutView) || (~<ViewType>~ == ImageView) || (~<ViewType>~ == PIELayoutView) || (~<ViewType>~ == PIEView))
		{
			aView( GetDocumentPath,DocumentPath );

			PreviewPath = MakePreviewPathFromPath( ~<DocumentPath>~,TRUE );

			Window( SetWindowOrder,Top );
			Window( GetWindowTitle,Title );

			if ( MessageBox( ~You are about update the icon for product: <$con.Product[ID]>\nwith the image in the window: <Title>.\n\nAre you sure you want to update the icon?  ~,YESNO ) != YES )
				{ return FALSE ; }

			returnVal = aView( MakePreviewImage,3,3,~<PreviewPath>~,JPEG );

			if ( <returnVal> == 0 )
			{
				Warning( Translate(~Failed to make preview icon.  ~<PreviewPath> may be write protected.~) );
				break;
					
			}
			else if (<returnVal> == -1)
			{
				Warning( Translate(~Image not fully rendered.  Please try again later.~) );
				break;
			}

			Cmd = ~Update Products Set PreviewPath = '<PreviewPath>' Where ID = '<$con.Product[ID]>'~;

			if ( !dBase( CMD,~<Cmd>~ ) )
			{
				dBase( GetErrorDescription,theErr );
				return Warning( ~Database update failed: <Cmd>.  <theErr>~ );
			}

			break;
		}
	}

	RefreshAllViews();

	WaitCursor( End );

	return TRUE;
}



NUMERIC Win::ImagesForThisProduct( ID )
{
	if ( ~<ID>~ == ~~ )
	{
		if ( !GenCon( ProductsView,GETACTIVEVIEW ) )
			{ return Warning( ~There is no active view~ ); }
			
		if ( !ProductsView( GetSelected,Products ) )
			{ return Warning( ~There were no products selected~ ); }

		if ( Products( ChildCount ) == 0 )
			{ return Warning( ~There were no products selected~ ); }

		count = 0;

		while ( Products( GetNext,Product ) )
		{
			++count;

			ID = ~<$con.Product[ID]>~;

			OpenMode =  ~Open~;

			Query = STR ( Select * from Images Where OrderID IN ('<ID>','Backgrounds','Frames','Textures','Images','Masks') And ImageType = 1 ) ;
			
			Actions = ACTION Doc ( ~ProductImages~ <OpenMode> ImagesDoc "Init( ~<ID>~,TRUE,~<Query>~,1 );" );
			
			PerformActions( Actions );
		}

		return TRUE;

	}

	Query = STR ( Select * from Images Where OrderID IN ('<ID>','Backgrounds','Frames','Textures','Images','Masks') And ImageType = 1 ) ;
	
	Actions = ACTION Doc ( ~ProductImages~ Open ImagesDoc "Init( ~<ID>~,TRUE,~<Query>~,1 );" );
	
	PerformActions( Actions );
	
	return TRUE;
}

NUMERIC Win::RedrawLayoutIcon( ProductID, PreviewPath )
{
//	RefreshDoc();  <-- Commented 11/18/04 to avoid refreshing entire products window
//	return TRUE;

	more = ProductsWindow( GetFirst,View );

	while ( $more )
	{
			if ( View( FindI,Key,~ID = '<ProductID>'~,position,ThumbNail ) ) 
			{
				ThumbNail( Set, Path, ~<PreviewPath>~);
				View( RedrawThumbNail,ThumbNail,TRUE );
				View( RefreshView );
				return View( SetSelected,ThumbNail,TRUE , FALSE);
			}

		more = ProductsWindow( GetNext,View );
	}

	return 0;

// below  not executed 11/18/04 to avoid refreshing entire products window

	if ( !ProductsWindow( FindI,ViewDataFor,~<ProductID>~,position,View ) )  { return FALSE; }

	if ( !View( FindI,Key,~ID = '<ProductID>'~,position,ThumbNail ) )  { return FALSE; }

	return View( RedrawThumbNail,ThumbNail,TRUE );
}



NUMERIC Win::EditListView()
{
	if ((~<$App.Name>~ !=~DP1.exe~) && (!GetUserPermissions( LayoutEditing ) ))
	{
		return Warning( Translate(UIMessages,NoPermission) );
	}

	if ( !GenCon( ProductCategory,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductCategory( GetSelected,SelectedProducts ) )		
		{ return Warning( Translate( ~There were no products selected~ ) ); }
	
	Count = SelectedProducts( ChildCount );
	
	if ( !<Count> )
	{
		ProductCategory( Get,Text,Category );
		
		if (String(BeginsWith, ~|~ , ~<Category>~ ) != ~~)	// IS THIS A LABEL VIEW?
		{		
			Criteria = CreateCriteriaFromLabel( ~<Category>~ );
			
			Query = STR ( Select * From Products Where ID In (Select ProductID From ProductTree Where <Criteria>) Order By ID  );
		}
		else
		{
			Query = STR ( Select * From Products Where Category = '<Category>' Order By Sequence,Subsequence );
		}
	}
	else if ( <Count> <= 50 )
	{
		if ( SelectedProducts( MakeSQLList,List,TRUE,ID ) )
		{
			if ( ~<List>~ != ~~ ) 
			{
				Query = STR ( Select * From Products Where ID In (<List>) Order By Sequence,Subsequence );
			}
		}
	}
	else
	{
		return Warning( ~Don't select more than 50 products at a time~ );
	}

	Actions = ACTION Doc ( ~ProductsDoc~ Open ProductsDoc "Init( ~~,FALSE,~<Query>~ );" );
	return PerformActions( Actions );
}



NUMERIC Win::OrdersUsingThisProduct( ID )
{
	InUse = FALSE;

	Query = ~Select * from OrderItems Where ProductID = '<ID>'~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{
		List(GetErrorDescription,0,theErr);
		return Warning( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
	}

	if ( !List( Empty ) )
	{ 
		InUse = TRUE;
		
		if ( MessageBox( ~Sorry, you can't delete the product <ID> because there are Order Items that require it. Would you like to see a list?~,YESNO ) == YES )
		{
			Actions = ACTION Doc ( ~OrderItemsDoc~ Open OrderItemsDoc "Init( ~OrderItems Using Product <ID>~,~<Query>~,0 );" );
			PerformActions( Actions );
		}
	}

	Query = ~Select * from RemoteJobDirs Where ProductID = '<ID>'~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{ 
		List(GetErrorDescription,0,theErr);
		return Warning( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
	}

	if ( !List( Empty ) )
	{ 
		InUse = TRUE;
		
		if ( MessageBox( ~Sorry, you can't delete the product <ID> because there are Remote Job Directories that require it. Would you like to see a list?~,YESNO ) == YES )
		{
			Actions = ACTION Doc ( ~RemoteJobServer~ Open RemoteJobServerDoc "Init( ~Using Product <ID>~,~<Query>~);" );
			PerformActions( Actions );
		}
	}

	return <InUse>;
}


NUMERIC Win::SeeOrderItemsForSelectedProducts()
{
	if ( !GenCon( ProductCategory,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }			

	if ( !ProductCategory( GetSelected,Products ) )
		{ return Warning( ~There are no Products to view~ ); }

	Count = Products( ChildCount );

	if ( $Count == 0 )
		{ return Warning( ~There are no Products to view~ ); }

	while ( Products( GETNEXT,Product ) )
	{
		if ( !Product( GetNumeric,Package ) )
		{
			Query = STR ( SELECT * FROM OrderItems WHERE ProductID = '<$Con.Product[ID]>' ORDER BY OrderID,ID ) ;
			
			Title = Translate( ~Which utilize Product <$Con.Product[ID]>~ );

			Actions = ACTION Doc ( ~OrderItems~ Open OrderItemsDoc "Init( ~<Title>~,~<Query>~,0 );" );
			PerformActions( Actions );
		}
		else
		{
			Warning( Translate( ~<$Con.Product[ID]> is a package~ ) );
		}	
	}

	return TRUE;
}


NUMERIC Win::RemoveFromLabels(&ProductCategory,&Products)
{	
	Count = Products( ChildCount );
	
	ProductCategory( GetTabName,theCategory );	

	ReturnOnFailure( MessageBox( ~Do you wish to remove the <Count> selected products from label\n\n<theCategory>~,YESNO ) == YES );
			
	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( ~Could not connect to the database.  <theErr>~ );
	}
	
	while ( Products( GetNext,Product ) )
	{
		Cmd = ~Delete From ProductTree Where LabelID = <$con.Product[LabelID]>~ ;
		
		if ( !dbase( Cmd,~<Cmd>~ ) )
		{
			dBase( GetErrorDescription,theErr );
			return Warning( ~Failed to delete the ProductTree record.  <theErr>.  <Cmd>.~ );
		}
		
		if ( Product( GetThumbNailInfo,ThumbNail ) )
		{
			ProductCategory( ReleaseImageByGenCon,ThumbNail );
		}
	}

	ProductCategory( RefreshView );

	return TRUE;
}



NUMERIC Win::DeleteSelectedProducts()	// CALLED FOR THUMBNAIL VIEW ONLY
{
	if ( !GenCon( ProductCategory,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }
		
	if ( !ProductCategory( IsThumbNailView ) )
	{
		return Warning( ~Call DeleteSelectedProducts() for Thumbnail Views Only!~ );	
	}			

	if ( !ProductCategory( GetSelected,Products ) )
		{ return Warning( ~There are no Products to remove~ ); }

	Count = Products( ChildCount );

	if ( $Count == 0 )
		{ return Warning( ~There are no Products to remove~ ); }
		
	ProductCategory( GetTabName,ThisCategory );	
	
	if (String(BeginsWith, ~|~ , ~<ThisCategory>~ ) != ~~)	// IS THIS A LABEL VIEW?
	{
		RemoveFromLabels(ProductCategory,Products);
		return TRUE;
	}

	if ( MessageBox( ~You are about to remove <Count> product(s) from the database. The layout file(s) associated with the product(s) will not be deleted.\n\nAre you sure you want to delete the selected product(s)?~,YESNO ) != YES )
		{ return FALSE ; }

	if ( MessageBox( ~It is very unusual to remove a product!\n\nAre you sure you want to remove the selected product(s)?~,YESNO ) != YES )
		{ return FALSE ; }

	if ( !Ado( dBase,Connect ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( ~Could not connect to the database.  <theErr>~ );
	}

	while ( Products( GetNext,Product ) )
	{
		if ( OrdersUsingThisProduct( ~<$con.Product[ID]>~ ) )
			break;

		if ( ProductCategory( FindI,Key,~ID = '<$con.Product[ID]>'~,Where,TheIcon ) )
		{  
			if ( !DeleteProduct( dBase,~<$con.Product[ID]>~ ) )
				break;

			ProductCategory( ReleaseImageByGenCon,TheIcon );
		}
	}

	ProductCategory( RefreshView );

	NotifyAffectedDocuments( PackageID );

	return TRUE;
}


NUMERIC Win::CloseWindow( theWindow )
{
	Register( Remove,~<theWindow>~ );
	return TRUE;
}




NUMERIC Win::ChangeRecord()
{
	if ( !ProductsDataView( GetChangedRow,ChangedProduct,OrigProduct,ChangedRow,IsNewRow ) )
		{ return Warning( ~There were no changed rows.~ ); }

	if ( <ChangedRow> <= 0 )
		{ return TRUE; }

	if ( ~<$con.ChangedProduct[ID]>~ == ~~ )
		{ return Warning( Translate( ~Unable to save pending changes.  Product ID cannot be blank.~ ) ); }

	Key = STR ( ID = '<$con.OrigProduct[ID]>' );
	Query = ~Select * From Products Where <Key>~;

	if ( <IsNewRow> )
	{
		if (!AddNew( ChangedProduct,OrigProduct,Query,Key ))
			{ return FALSE; }
	}
	else
	{
		if (!UpdateExisting( ChangedProduct,OrigProduct,Query,Key ))
			{ return FALSE; }
	}

	//Document( doc,THIS,NotifyOtherDocuments,~~,DataContains,~LayoutName~ );
	//doc( NotifyOtherDocuments,~~,DataContains,~ProductID~ );

	return TRUE;
}











STR Win::CreateJob( LayoutPath )
{
	JobPath = ~<$App.ShareDirectory>\OrderlessJobs\<$Date.DateYMD>~;

	if ( !Directory( Create,~<JobPath>~ ) )
		{ return Warning( ~Could not create directory <JobPath>~ ); }

	UniqueJobID = Ticks();

	JobPath = ~<JobPath>\Job_<UniqueJobID>~;

	if ( !file( Job,Open,~<JobPath>~,Create,Write ) )
	{
		Error( ~Could not open the job file <theJob>~ );
	}

	Job( ~FileType: Job~ );
	Job( ~Use: |<LayoutPath>|~ );
	Job( Close );

	return ~<JobPath>~;
}


NUMERIC Win::OpenALayout( LayoutPath,ProductID,LayoutName )
{
	IsMultiple = FALSE;

	LayoutPath = GetFullLayout( ~<LayoutPath>~,IsMultiple );

	if ( IsNull( ~<LayoutPath>~ ) )
		{ return FALSE; }

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( !Window( GetNext,aView ) )
			continue;

		aView( Get,ViewType,ViewType );

		if ( ~<ViewType>~ == LayoutView ||  ~<ViewType>~ == PIELayoutView)
		{
			aView( GetDocumentPath,DocumentPath );

			if ( ~<DocumentPath>~ == ~<LayoutPath>~ )
			{ 
				Window( SetWindowOrder,Top );
				return TRUE;
			}
		}
	}

	if (!GenCon( Info,New,DDDocumentInfo ) )
		{ return Warning( ~Could not create document info for <LayoutPath>~ ); }

	Info( SetValues,ProductID,~<ProductID>~,LayoutName,~<LayoutName>~ );

	if (!Document( aLayout,Open,~<LayoutPath>~,Layout,~~,Info ) )
		{ return Warning( ~Could not open <LayoutPath>~ ); }

	return TRUE;
}


NUMERIC Win::Search()
{
	Actions = ACTIONS ( Doc( ~Search~ Open SearchDoc "Search( Products );" ) );
	return PerformActions( Actions );
}


NUMERIC Win::ViewPackages()
{
	Query = ~Select * From Packages Where PackageID In (Select ID From Products Where Book = 0)~;
	if ( ADO( dBase,Connect,RecordCountFor,~<Query>~ ) == 0 )
	{
		return Warning( ~There are no packages defined~ );
	}

	action = ACTION DOC ( PackagesDoc Open PackagesDoc "Init( ~Packages~, ~<Query> Order By PackageID,Sequence~ );" );
	
	return PerformActions( action );
}


NUMERIC Win::ViewPagesOfTheBook()
{
	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }			

	if ( !View( GetSelected,Products ) )
		{ return Warning( ~There are no selected products~ ); }

	Count = Products( ChildCount );

	if ( <Count> <= 0 )
	{ 
		return Warning( ~You must select a book product~ );
	}

	Products( GetFirst,Product );
	
	if ( !Numeric(~<$con.Product[Book]>~) )
	{ 
		return Warning( ~You must select a book product~ );
	}
	
	Query = ~Select * From Packages Where PackageID = '<$con.Product[ID]>'~;

	action = ACTION DOC ( PackagesDoc Open PackagesDoc "Init( ~Book Pages for <$con.Product[ID]>~, ~<Query> Order By PackageID,Sequence~ );" );
	
	return PerformActions( action );
}


NUMERIC Win::ViewBookProducts()
{
	Query = ~Select * From Packages Where PackageID In (Select ID From Products Where Book <> 0)~;
	if ( ADO( dBase,Connect,RecordCountFor,~Select * From Packages~ ) == 0 )
	{
		return Warning( ~There are no books defined~ );
	}

	action = ACTION DOC ( PackagesDoc Open PackagesDoc "Init( ~Book Products~, ~<Query> Order By PackageID,Sequence~ );" );
	
	return PerformActions( action );
}

NUMERIC Win::AddNewPackage()
{
	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }			

	if ( !View( GetSelected,ProductsForPackage ) )
		{ return Warning( ~There are no selected products to create a package from~ ); }

	Count = ProductsForPackage( ChildCount );

	if ( <Count> <= 0 )
		{ return Warning( ~There are no selected products to create a package from~ ); }

	if ( !ProductsForPackage( MakeSQLList,ListOfProducts,TRUE,ID,RewindList ) )
		{ return Warning( ~Error creating list of products~ ); }

	Query = ~Select ID,LayoutName,Package From Products Where ID In (<ListOfProducts>) AND ((Package <> 0) OR (Multiple <> 0))~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Query Failed: <Query>. <theErr>~ );
	}

	if ( List( GetFirst,Product ) )
	{
		return Warning( Translate( ~Can't specify package or multiple layouts in a package.  Product ID: <$pcon.Product[ID]> '<$pcon.Product[LayoutName]>' cannot be part of a package~ ) ); 
	}

	ProductsForPackage( Hang,~[GenCons]~ );

	action = ACTION DOC ( Packages Open NewPackageDoc "Init();" );
	
	return PerformActions( action );
}

NUMERIC Win::EditBookProduct(Product)
{	
	ID = ~<$con.Product[ID]>~;
	action = ACTION DOC ( Packages Open NewBookDoc "EditProduct(~<ID>~);" );
	
	return PerformActions( action );
}

NUMERIC Win::EditBook()
{
	if ( !GenCon( View,GETACTIVEVIEW,GetName,Category ) )
		{ return Warning( ~There is no active view~ ); }	

	if ( !View( GetSelected,Products ) )
		{ return Warning( ~There are no selected products to create a book from~ ); }

	Count = Products( ChildCount );

	if ( <Count> != 1 )
		{ return Warning( ~Please select one book~ ); }

	if (!Products( GetFirst,Product))
	{
		{ return Warning( ~No products selected~) ; }
	}

	ID = ~<$con.Product[ID]>~;
	action = ACTION DOC ( Packages Open NewBookDoc "EditProduct(~<ID>~);" );
	
	return PerformActions( action );
}


NUMERIC Win::EditBookAttributes()
{
	if ( !GenCon( View,GETACTIVEVIEW,GetName,Category ) )
		{ return Warning( ~There is no active view~ ); }	

	if ( !View( GetSelected,Products ) )
		{ return Warning( ~There are no selected products to create a book from~ ); }

	Count = Products( ChildCount );

	if ( <Count> != 1 )
		{ return Warning( ~Please select one book~ ); }

	if (!Products( GetFirst,Product))
	{
		{ return Warning( ~No products selected~) ; }
	}

	Query = ~Select * from BookProductAttributes Where ProductID = '<$con.Product[ID]>' Order By ProductID,Attribute,Sequence~;

	action = ACTION DOC ( EditTemplateAttributes Open EditTemplateAttributes "Init(~Book Product Attributes - <$con.Product[ID]>~,~<Query>~,~<$con.Product[ID]>~);" );
	
	return PerformActions( action );
}


NUMERIC Win::AddNewBook()
{
	if ( !GenCon( View,GETACTIVEVIEW,GetName,Category ) )
		{ return Warning( ~There is no active view~ ); }	

	if ( !View( GetSelected,ProductsForPackage ) )
		{ return Warning( ~There are no selected products to create a book from~ ); }

	Count = ProductsForPackage( ChildCount );

	if ( <Count> <= 0 )
		{ return Warning( ~There are no selected products to create a book from~ ); }

	if ( !ProductsForPackage( MakeSQLList,ListOfProducts,TRUE,ID,RewindList ) )
		{ return Warning( ~Error creating list of products~ ); }

	Query = ~Select ID,LayoutName,Package From Products Where ID In (<ListOfProducts>) AND ((Package <> 0) OR (Multiple <> 0))~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Query Failed: <Query>. <theErr>~ );
	}

	if ( List( GetFirst,Product ) )
	{
		return Warning( Translate( ~Can't specify a book or multiple layouts in a package.  Product ID: <$pcon.Product[ID]> '<$pcon.Product[LayoutName]>' cannot be part of a package~ ) ); 
	}

	action = ACTION DOC ( Packages Open NewBookDoc "Init();" );
	
	return PerformActions( action );
}

NUMERIC Win::ViewAsText()
{
	if ((~<$App.Name>~ !=~DP1.exe~) && (!GetUserPermissions( LayoutEditing ) ))
	{
		return Warning( Translate(UIMessages,NoPermission) );
	}

	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }			

	if ( !View( GetSelected,SelectedProducts ) )
		{ return Warning( ~There are no Products to view as text~ ); }

	Count = SelectedProducts( ChildCount );

	if ( <Count> <= 0 )
		{ return Warning( ~There are no selected Products to view as text~ ); }

	Program = ~<$Sys.Directory>\Notepad.exe~;

	if ( !Files( FileExists,~<Program>~ ) )
	{
		return Warning( ~Could not find NotePad.exe at <Program>~ );
	}

	while ( SelectedProducts(GetNext,Product) )
	{
		if ( Product( GetNumeric,Package ) )
		{ 
			Query = ~Select * From Packages Where PackageID = '<$Con.Product[ID]>' Order By Sequence~;
			action = ACTION DOC ( Packages Open PackagesDoc "Init( ~Packages~, ~<Query>~ );" );
			PerformActions( action );
			continue;
		}

		IsMultiple = FALSE;

		TheLayout = GetFullLayout( ~<$con.Product[ProductLayoutPath]>~,IsMultiple );

		if ( IsNull( ~<TheLayout>~ ) )
			continue;

		if ( !ViewFileInNotepad( ~<TheLayout>~ ) )
		{
			GetLastError( ErrorString,theErr );
			return Warning( ~Could not open <TheLayout>. <theErr>~ );
		}
	}

	return TRUE;
}


NUMERIC Win::FixCR()
{
	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There is no active view~ ); }			

	if ( !View( GetSelected,SelectedProducts ) )
		{ return Warning( ~There are no Products to view as text~ ); }

	Count = SelectedProducts( ChildCount );

	if ( <Count> <= 0 )
		{ return Warning( ~There are no selected Products to fix the carriage returns for~ ); }

	if ( MessageBox( ~Are you sure you want to convert carriage returns to carriage return/ line feeds for the selected <Count> products?~,YESNO ) != YES )
		{ return FALSE; }

	while ( SelectedProducts(GetNext,Product) )
	{
		if ( Product( GetNumeric,Package ) )	{ continue; }

		IsMultiple = FALSE;

		TheLayout = GetFullLayout( ~<$con.Product[ProductLayoutPath]>~,IsMultiple );

		if ( IsNull( ~<TheLayout>~ ) )
			continue;

		FixCRInFile( ~<TheLayout>~ );
	}

	return TRUE;
}



NUMERIC Win::FixCRInFile(Path)
{

	if ( !Files( FileExists,~<Path>~ ) ) 
	{
		return Warning( Translate( ~Could not find <Path>~ ) );
	}

	if ( !File( fp,OPEN,~<path>~,ReadWrite ) ) 
	{
		return Warning( Translate( ~Could not open <Path>~ ) );
	}


	if ( File( fp,Seek,0,Begin ) != 0 ) 
	{
		return Warning( Translate( ~Seek to beginnging of file failed for <Path>~ ) );
	}

	if ( !fp( ReadTextfile,Buffer ) ) 
	{
		return Warning( Translate( ~<Path> is an empty file~ ) );
	}

	if ( fp( SetLength,0 ) < 0 ) 
	{
		return Warning( Translate( ~Failed to set length to zero for <path>~ ) );
	}

	if ( !fp( UnicodeOutput,WriteContentsOf,Buffer ) ) 
	{
		err = GetLastErrorMsg();
		return Warning( Translate( ~Failed to write <path>.  <err>~ ) );
	}

	ForgetLocal( fp );

	return TRUE;
}

NUMERIC Win::OpenContainingFolder()
{
	if ( !( GenCon(View,GETACTIVEVIEW ) && GenCon(Window,GETACTIVEWINDOW) ) )
		{ return Warning( ~There was no active view~ ); }

	if ( !View( GetSelected,SelectedItems ) )		
		{ return Warning( Translate(~Select one and try again~) ); }

	if ( SelectedItems( GetFirst,Item ) )
	{
		return OpenContainingFolderAndSelect( ~<$con.Item[ProductLayoutPath]>~ ); 
	}

	return Warning( Translate( ~Select one and try again~ ) );
}



NUMERIC Win::OpenLayoutForSelectedProducts()
{
	if ((~<$App.Name>~ !=~DP1.exe~) && (!GetUserPermissions( LayoutEditing ) ))
	{
		return Warning( Translate(UIMessages,NoPermission) );
	}

	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There was no active view~ ); }

	if ( !View( GetSelected,SelectedProducts ) )
		{ return Warning( ~There were no selected Products~ ); }

	Count = SelectedProducts( ChildCount );

	if ( <Count> <= 0 )
		{ return Warning( ~There were no selected Products~ ); }

	CurrentlyOpen = NumWindows( LayoutOrJob );

	MaxOpenJobsOrLayouts = ~<$[Symbols].MaxOpenJobsOrLayouts[Long]>~;

	if ( <MaxOpenJobsOrLayouts> < 1 )
	{ 
		MaxOpenJobsOrLayouts = 1;
	}

	while ( SelectedProducts( GetNext,Product ) )
	{
		if ( Product( GetNumeric,Package ) )
		{
//			Query = ~Select * From Packages Where PackageID = '<$Con.Product[ID]>' Order By Sequence~;
//			action = ACTION DOC ( Packages Open PackagesDoc "Init( ~Packages~, ~<Query>~ );" );
//			PerformActions( action );


			Product(GetValue,Book,Book);

			if (Numeric(~<Book>~) != 0)
			{
				<THIS>.EditBookProduct(Product);
			}
		}
		else
		{
			if ( <++CurrentlyOpen> > <MaxOpenJobsOrLayouts> )
			{
				Warning( Translate( ~You can only have <MaxOpenJobsOrLayouts> jobs or layouts open at a time~ ) );
				break;
			}

			IsMultiple = FALSE;

			TheLayout = GetFullLayout( ~<$con.Product[ProductLayoutPath]>~,IsMultiple );

			if ( IsNull( ~<TheLayout>~ ) )
				continue;

			Operation = STR ( <THIS>.OpenALayout( ~<TheLayout>~,~<$Con.Product[ID]>~,~<$Con.Product[LayoutName]>~ ) );
			QueueContentsOf( Operation );
		}
	}

	return TRUE;
}

NUMERIC Win::DisplayProductCategories()
{
	Query = ~Select Distinct Category From Products Order By Category~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Products table: <Query>. <theErr>~ );
	}

	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	Count = 0;

	while ( List( GetNext,Item ) )
	{
		GenCon( Category<++Count>,New,DDMenuItemDef,AddTo,ListMenu,SetValues,
				Text,		~<Count>)  <$pcon.Item[Category]>~,
				IDText,		~ID~ );

		ActionsText = ACTION EXEC ( <THIS>.WantCategory(~<$pcon.Item[Category]>~); );

		Category<Count>( SetValuesFrom,ActionsText,ActionsText );
	}
	
	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There was no active view~ ); }

	View( DisplayMenu,ListMenu,2,2 );

	return TRUE;
}


NUMERIC Win::WantCategory( which )
{
	ProductsWindow( ChangeView,~<which>~ );

	if ( Document( Doc,FindByName,~OrderItemsDoc~ ) )
	{
		return DisplayProductListMenu( ~<Which>~ );
	}

	return TRUE;
}



NUMERIC Win::DisplayCurrentProductListMenu()
{
	if ( GenCon( View,GETACTIVEVIEW,GETNAME,Category ) )
	{ 
		return DisplayProductListMenu( ~<Category>~ );
	}

	return DisplayProductCategories();
}


NUMERIC	Win::NavigatorWarning(Msg)
{
	fHTMLView( SetInnerHTML,UserWarning,0,~<Msg>~ );
	return fHTMLView( SetStyle,UserWarning,0,Display,Block );
}


NUMERIC	Win::GetTheFocus()
{
	return TRUE;  //   View( SetFocus );		// TBD this might be causing an exception
}



VOID	Win::OnCategories()
{
	SetDocumentQuery(~Select * From Products Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	RefreshDoc();
	GetTheFocus();
}


NUMERIC	Win::OnViewCategory()
{
	ReturnOnFailure( fHtmlView( CreateStringListFromOptions,CategoryList,0,theCategories,TRUE ) );
	ReturnOnFailure( theCategories(NumEntries) > 0 );
	theCategories(MakeSQLList,Categories,TRUE);
	SetDocumentQuery(~Select * From Products Where Category In (<Categories>) Order By Category,Sequence,Subsequence~);
	SetTitle(~For Category(s) <Categories>~);
	SetHierarchy( ~~ );
	RefreshDoc();
	return GetTheFocus();
}


NUMERIC	Win::OnFind()
{
	fHtmlView( SetStyle,FindMenu,0,Display,Block );
	return fHtmlView( Execute,~ProductID.focus()~ );
}


NUMERIC	Win::OnFindButton()
{
	fHtmlView( Get,ProductID,0,value,ProductID );
	Count = ADO( dbase,Connect,RecordCountFor,~Select * From Products Where ID Like '<ProductID>%'~ );
	
	if ( <Count> == 0 )
	{
		return fHtmlView( SetInnerText,NumProductsMsg,0,~No products begin with <ProductID>~ );
	}
	
	fHtmlView( SetInnerText,NumProductsMsg,0,~<Count> products begin with <ProductID>~ );
	
	SetDocumentQuery(~Select * From Products Where ID Like '<ProductID>%' Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	RefreshDoc();
	return GetTheFocus();
}


NUMERIC	Win::OnCategory()
{
	fHtmlView( SetSelectOptionsLength,CategoryList, 0, 0 );
	
	Query = ~Select Distinct Category From Products Order By Category~;
	
	if ( !PGenConList( List,Connect,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to read the Products from the database.  <Query>.  <theErr>~ );
	}
	
	fHtmlView( SetStyle,CategoryMenu,0,Display,Block );
	fHtmlView( CreateOptionsFromGenConList,CategoryList,0,List,Category );
	fHtmlView( SetSelectedOptionByIndex,CategoryList,0,0 );
	return fHtmlView( Execute,~CategoryList.focus()~ );
}


NUMERIC	Win::OnViewCustomers()
{
	if ( ado( dbase,Connect,RecordCountFor,~Select count(*) From Products Where CustomerID Is Not NULL~ ) <= 0 )
	{
		return NavigatorWarning(~You have not defined any customer unique products.~);
	}

	fHtmlView( SetSelectOptionsLength,CustomersList, 0, 0 );
	
	if ( !PGenConList( List,Connect,Query,~Select Distinct CustomerID From Products Where CustomerID Is Not NULL Order By CustomerID~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to read the Customers from the database.  <theErr>~ );
	}
	
	fHtmlView( SetStyle,CustomersMenu,0,Display,Block );
	
	OnViewMainMenu();
	
	fHtmlView( CreateOptionsFromGenConList,CustomersList,0,List,CustomerID );
	fHtmlView( SetSelectedOptionByIndex,CustomersList,0,0 );
	return fHtmlView( Execute,~CustomersList.focus()~ );
}

NUMERIC	Win::OnViewCustomerProducts()
{
	ReturnOnFailure( fHtmlView( CreateStringListFromOptions,CustomersList,0,theCustomers,TRUE ) );
	ReturnOnFailure( theCustomers(NumEntries) > 0 );
	theCustomers(MakeSQLList,Customers,TRUE,ID);
	SetDocumentQuery(~Select * From Products Where CustomerID IN (<Customers>) Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	SetTitle(~For Customer(s) <Customers>~);
	RefreshDoc();
	return GetTheFocus();
}


NUMERIC	Win::OnViewBooks()
{	
	if ( ado( dbase,Connect,RecordCountFor,~Select count(*) From Products Where Book > 0~ ) <= 0 )
	{
		return NavigatorWarning( ~None of your products are books~ );
	}
	
	SetDocumentQuery(~Select * From Products Where Book > 0 Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	SetTitle(~Books~);
	RefreshDoc();
	return GetTheFocus();
}


NUMERIC	Win::OnViewPackages()
{	
	if ( ado( dbase,Connect,RecordCountFor,~Select count(*) From Products Where Package > 0 AND Book = 0~ ) <= 0 )
	{
		return NavigatorWarning( ~None of your products are packages~ );
	}
	
	SetDocumentQuery(~Select * From Products Where Package > 0 AND Book = 0 Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	SetTitle(~Packages~);
	RefreshDoc();
	return GetTheFocus();
}

NUMERIC	Win::OnViewStyles()
{	
	if ( ado( dbase,Connect,RecordCountFor,~Select count(*) From Products Where Style > 0~ ) <= 0 )
	{
		return NavigatorWarning( ~None of your products are styles.~ );
	}
	
	SetDocumentQuery(~Select * From Products Where Style > 0 Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	SetTitle(~Styles~);
	RefreshDoc();
	return GetTheFocus();
}


NUMERIC	Win::OnViewComposites()
{	
	if ( ado( dbase,Connect,RecordCountFor,~Select count(*) From Products Where Multiple > 0~ ) <= 0 )
	{
		return NavigatorWarning( ~None of your products are variable node products.~ );
	}
	
	SetDocumentQuery(~Select * From Products Where Multiple > 0 Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	SetTitle(~Class Picture~);
	RefreshDoc();
	return GetTheFocus();
}

VOID	Win::OnViewOther()
{
	fHTMLView( SetStyle,OtherMenu,0,display,block );
}

VOID	Win::OnViewMainMenu()
{
	fHTMLView( SetStyle,OtherMenu,0,display,none );
}


NUMERIC	Win::OnPrevProductWindow()
{
	action = ACTION DOC ( ProductsDoc Open ProductsDoc "Init( ~~,TRUE,~Select * From Products Order By Category,Sequence,Subsequence~ );" );
	return PerformActions( action );
}



NUMERIC	Win::OnViewUsers()
{
	fHtmlView( SetSelectOptionsLength,UsersList, 0, 0 );

	if ( ado( dbase,Connect,RecordCountFor,~Select count(*) From Products Where UserName Is NOT NULL~ ) <= 0 )
	{
		return NavigatorWarning( ~None of your products are assigned to a user~ );
	}

	if ( !PGenConList( List,Connect,Query,~Select Distinct UserName From Products Where UserName Is NOT NULL Order By UserName~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to read the Users from the database.  <theErr>~ );
	}
	
	fHtmlView( SetStyle,UsersMenu,0,Display,Block );
	
	OnViewMainMenu();
	
	fHtmlView( CreateOptionsFromGenConList,UsersList,0,List,UserName );
	fHtmlView( SetSelectedOptionByIndex,UsersList,0,0 );
	return fHtmlView( Execute,~UsersList.focus()~ );
}


NUMERIC	Win::OnViewUser()
{
	ReturnOnFailure( fHtmlView( CreateStringListFromOptions,UsersList,0,theUsers,TRUE ) );
	ReturnOnFailure( theUsers(NumEntries) > 0 );
	theUsers(MakeSQLList,Users,TRUE,UserName);
	SetDocumentQuery(~Select * From Products Where UserName IN (<Users>) Order By Category,Sequence,Subsequence~);
	SetHierarchy( ~~ );
	SetTitle(~For User(s) <Users>~);
	RefreshDoc();
	return GetTheFocus();
}



NUMERIC Win::OnLabels()
{
	ReturnOnFailure( fHtmlView( SetSelectOptionsLength,Label1List,0,0 ) );
	
	PGenConList( List,Connect,Query,~Select Distinct L1 from ProductTree Order By L1~ );
	
	Count = List(NumEntries);
		
	if ( !<Count> )
	{
		fHTMLView( SetStyle,Label1Menu,0,Display,None );
		fHTMLView( SetStyle,Label1New,0,Display,Block );
		return TRUE;
	}
		
	fHtmlView( CreateOptionsFromGenConList,Label1List,0,List,L1);
	
	fHTMLView( SetStyle,Label1List,0,Display,Block );
	fHtmlView( SetStyle,Label1Menu,0,Display,Block );
	fHtmlView( Execute,~Label1List.focus()~ );
	return fHtmlView( SetSelectedOptionByIndex,~Label1List~,0,0 );
}


NUMERIC Win::AddNewLabel(Level)
{
	L1 = ~~;  L2 = ~~;  L3 = ~~; L4 = ~~; L5 = ~~;
	
	i = 0;
			
	while ( <++i> <= <Level> )
	{
		fHTMLView( Get,Label<i>List,0,value,SelectedItem );	
		L<i> = ~<SelectedItem>~;
	}
	
	fHTMLView( Get,Label<Level>Field,0,value,L<Level> );
	
	fHTMLView( SetStyle,Label<Level>Menu,0,Display,None );	
	
	Query = ~Select * from ProductTree Where L1='<L1>' AND L2='<L2>' AND L3='<L3>' AND L4='<L4>' AND L5='<L5>'~;
	
	if ( !PGenConList( List,connect,GetExistingRecordFor,~<Query>~,Rec ) )
	{	
		List( AddNew,Rec );
		List( GetConnection,Connection );
		
		Rec( Set,LabelID,UniqueProductTreeID(Connection) );
		Rec( Set,L1,~<L1>~ );
		Rec( Set,L2,~<L2>~ );
		Rec( Set,L3,~<L3>~ );
		Rec( Set,L4,~<L4>~ );
		Rec( Set,L5,~<L5>~ );
		
		List( Update );
		
		fHTMLView( Set,Label<Level>Field,0,value,~~ );
		LevelCriteria = CreateLevelQuery(<Level>-1,FALSE);
		i = RefreshLabelList(<Level>,~<LevelCriteria>~);
	}
	
	return TRUE;
}


NUMERIC Win::AddNewChildLabel(Level)
{
	L1 = ~~;  L2 = ~~;  L3 = ~~; L4 = ~~; L5 = ~~;
	
	i = 0;
	
	Criteria = ~~;  AND = ~~;
	
	while ( <++i> <= <Level> )
	{
		fHTMLView( Get,Label<i>List,0,value,SelectedItem );	
		
		if ( IsNull(~<SelectedItem>~) )
		{
			return Warning( ~You must select the label you are adding the child to first.~ );
		}
		
		L<i> = ~<SelectedItem>~;
		
		if ( !IsNull(~<SelectedItem>~) )
		{
			Criteria = ~<Criteria> <AND> L<i>='<L<i>>' ~;
			AND = ~AND~;
		}
	}
	
	NextLevel = <Level> + 1;
	
	if ( <NextLevel> > <fMaxLevels> )
	{
		return TRUE;
	}
	
	fHTMLView( Get,Label<Level>Field,0,value,L<NextLevel> );
	
	Criteria = ~ <Criteria> AND L<NextLevel>='<L<NextLevel>>' ~;

	fHTMLView( SetStyle,Label<Level>Menu,0,Display,None );	
	
	Query = ~Select * from ProductTree Where <Criteria>~;
	
	if ( !PGenConList( List,connect,GetExistingRecordFor,~<Query>~,Rec ) )
	{	
		List( AddNew,Rec );
		List( GetConnection,Connection );
		
		Rec( Set,LabelID,UniqueProductTreeID(Connection) );
		Rec( Set,L1,~<L1>~ );
		Rec( Set,L2,~<L2>~ );
		Rec( Set,L3,~<L3>~ );
		Rec( Set,L4,~<L4>~ );
		Rec( Set,L5,~<L5>~ );
		
		List( Update );
		
		fHTMLView( Set,Label<Level>Field,0,value,~~ );
	}
	
	return TRUE;
}


NUMERIC Win::UniqueProductTreeID(&connection)
{
	NextID = 0;

	if ( connection( CMD,~Select MAX(LabelID) From ProductTree~,MaxID ) )
	{ 
		NextID = ~<$rs.MaxID[#0]>~ == ~~ ? ~0~ : ~<$rs.MaxID[#0]>~; 
	}

	return <++NextID>;
}



VOID	Win::CreateANewLabel(Level)
{
	i = 0;
	
	Tag = ~~;
	
	while ( <++i> <= <level> )
	{
		fHTMLView( SetStyle,Label<i>List,0,Display,None );
	}
	
	Tag = GetTag( ~<Level>~ );
	
	fHTMLView( SetStyle,Label<Level>New,0,Display,Block );
	fHTMLView( Set,Label<Level>Field,0,value,~~ );
	//fHTMLView( SetInnerText,LabelName,<Level>-1,~<Tag>~ );
	fHTMLView( execute,~Label<Level>Field.focus()~ );
	fHTMLView( execute,~OnLabelFieldChange('Label<Level>Field',<level>)~ );
	fHTMLView( Set,AddChildLabelButton,<Level>-1,Title,~Add the child to <Tag>~ );
}


VOID	Win::OnLeaveLabelMenu(Level)
{
	fHTMLView( SetStyle,Label<Level>New,0,Display,None );
	
	i = 0;
	
	while ( <++i> <= <level> )
	{
		fHTMLView( SetStyle,Label<i>Menu,0,Display,Block );
		fHTMLView( SetStyle,Label<i>List,0,Display,Block );
	}
	
	fHTMLView( Execute,~FocusOnTopLabel()~ );
}


STR		Win::CreateLevelQuery(Level,IgnoreBelow)
{
	LevelCriteria = ~~;		AND = ~~;		i = <Level>;
	
	if ( <i> < 5 && <IgnoreBelow> )
	{
		j = <i> + 1;
		LevelCriteria = ~ (L<j> Is NULL) ~;
		AND = ~AND~;
	}
	
	while ( <i> > 0 )
	{
		fHTMLView( Get,Label<i>List,0,value,SelectedItem );	
		if ( !IsNull(~<SelectedItem>~) )
		{
			LevelCriteria = ~<LevelCriteria> <AND> L<i> = '<SelectedItem>' ~;
			AND = ~AND~;
		}
		--i;
	}
	
	return ~<LevelCriteria>~;
}


NUMERIC Win::RefreshLabelList(NextLevel,LevelCriteria)
{
	LevelCriteria = IsNull(~<LevelCriteria>~) ? ~~ : ~ Where <LevelCriteria> ~;
	
	Query = ~Select Distinct L<NextLevel> From ProductTree <LevelCriteria> Order By L<NextLevel>~;

	PGenConList( List,Connect,Query,~<Query>~ );	
	Count = List(NumEntries);
	
	if ( !List(NumEntries) )
	{
		return TRUE; //NavigatorWarning( ~You have not defined any labels yet.~ );
	}
		
	i = -1;
	
	fHTMLView( SetSelectOptionsLength,Label<NextLevel>List, 0, 0 );
	
	while ( List( GetNext,Rec ) )
	{
		if ( !IsNull(~<$pcon.Rec[L<NextLevel>]>~) )
		{
			fHTMLView( SetSelectOptionsLength,Label<NextLevel>List, 0, <++i> + 1 );
			fHTMLView( SetSelectOption,Label<NextLevel>List,0,<i>,~<$pcon.Rec[L<NextLevel>]>~,~<$pcon.Rec[L<NextLevel>]>~ );	
		}
	}
		
	return <i>;
}


NUMERIC Win::OnLevelSelected(Level)
{	
	fHTMLView( Get,Label<Level>List,0,value,SelectedItem );	
	ReturnOnSuccess( IsNULLOrWhite(~<SelectedItem>~) );	
		
	LevelCriteria = CreateLevelQuery(<Level>,TRUE);
		
	NextLevel = <Level> + 1;
	
	if ( <NextLevel> > <fMaxLevels> )
	{
		return ShowLabelProducts( ~<Level>~,~<LevelCriteria>~ );
	}
	
	ShowLabelProducts( ~<Level>~,~<LevelCriteria>~ );

	LevelCriteria = CreateLevelQuery(<Level>,FALSE);
	
	i = RefreshLabelList(<NextLevel>,~<LevelCriteria>~);
		
	if ( <i> >= 0 )
	{
		fHTMLView( SetSelectedOptionByIndex,Label<NextLevel>List,0,-1 );
		fHTMLView( SetStyle,Label<NextLevel>List,0,Display,Block );
		fHTMLView( SetStyle,Label<NextLevel>Menu,0,Display,Block );
		fHtmlView( Execute,~Label<NextLevel>List.focus()~ );
		fHtmlView( SetSelectedOptionByIndex,~Label<NextLevel>List~,0,0 );
	}
	
	return GetTheFocus();
}


NUMERIC Win::ShowLabelProducts( Level,ProductQuery )
{
	Tag = GetTag( ~<Level>~ );
	SetHierarchy(~<Tag>~);
	ShowNewProducts(~Label~,~<ProductQuery>~);
	return TRUE;
}


STR		Win::GetTag( Level )
{
	i = 0;  Tag = ~~;	separator = ~~;
	
	while ( <++i> <= <Level> )
	{
		fHTMLView( Get,Label<i>List,0,value,SelectedItem );	
		Tag = ~<Tag><separator><SelectedItem>~;
		separator = ~ | ~;
	}
	
	return ~|  <Tag>  |~;
}


STR		Win::CreateCriteriaFromLabel( Label )
{
	i = 0;  Criteria = ~~;	AND = ~~;
	
	N = GetTokens( ~<Label>~,~|~ );
	
	while ( <++i> <= <N> )
	{
		theValue = String( TrimLeftRight,~<Token<i>>~ );
		Criteria = ~<Criteria> <AND> L<i>='<theValue>'~;
		AND = ~AND~;
	}
	
	return ~<Criteria>~;
}


NUMERIC Win::ViewProductTree()
{
	action = ACTION DOC ( ProductTreeDoc Open ProductTreeDoc "Init(~Product Hierarchy - All~,~Select * from ProductTree Order By L1,L2,L3,L4,L5,LabelSequence,LabelSubSequence~);" );
	return PerformActions( action );
}



NUMERIC Win::DeleteTreeFrom(Level)
{
	SelectedItem = ~~;
	
	fHTMLView( Get,Label<Level>List,0,value,SelectedItem );
	
	if ( IsNull(~<SelectedItem>~) )
	{
		return Warning( ~You did not select an item prior to right clicking~ );
	}
	
	Criteria = CreateLevelQuery(<Level>,FALSE);
	
	if ( IsNull(~<Criteria>~) )
	{
		return Warning( ~There is nothing to delete~);
	}
	
	Tag = GetTag( ~<Level>~ );
	
	ReturnOnFailure( MessageBox( ~Are you sure you want to delete\n\n <Tag>\n\n and all child labels below it?~,YESNO ) == YES );
	
	Cmd = ~Delete from ProductTree Where <Criteria>~;
	
	if ( !ADO( dbase,Connect,Cmd,~<Cmd>~ ) )
	{
		dbase( GetErrorDescription,theErr );
		return Warning( ~Failed to delete the label <SelectedItem> from the Product Tree. <theErr>. <Cmd>~ );
	}
	
	
	fHTMLView( Execute,~HideElevatedDivs()~ );
	
	return TRUE;
}


NUMERIC Win::ViewProductTreeByLevel(Level)
{
	SelectedItem = ~~;
	
	fHTMLView( Get,Label<Level>List,0,value,SelectedItem );
	
	if ( IsNull(~<SelectedItem>~) )
	{
		return Warning( ~You did not select an item prior to right clicking~ );
	}
	
	Criteria = CreateLevelQuery(<Level>,FALSE);
	Criteria = IsNull(~<Criteria>~) ? ~~ : ~Where <Criteria>~;
	
	Query = ~Select * from ProductTree <Criteria> Order By L1,L2,L3,L4,L5~;
	theTitle = GetTag( ~<Level>~ );

	action = ACTION DOC ( ProductTreeDoc Open ProductTreeDoc "Init(~Product Hierarchy <theTitle>  *~,~<Query>~);" );
	return PerformActions( action );
}


NUMERIC Win::ViewProductTreeOfLabel()
{
	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There was no active view~ ); }

	View( Get,Text,Label );
	
	ReturnOnFailure( !IsNull(~<Label>~) );

	if ( IsNull(String( BeginsWith,~|~,~<Label>~ )) )	// Dealing with the Product Hierarchy?
	{
		return Warning(~You are currently looking at a product category.  This is not a set of labeled products.~);
	}

	Criteria = CreateCriteriaFromLabel( ~<Label>~ );
	Criteria = IsNull(~<Criteria>~) ? ~~ : ~Where <Criteria>~;
	
	Query = ~Select * from ProductTree <Criteria> Order By L1,L2,L3,L4,L5,LabelSequence,LabelSubsequence~;

	action = ACTION DOC ( ProductTreeDoc Open ProductTreeDoc "Init(~Product Hierarchy <Label>  *~,~<Query>~);" );
	return PerformActions( action );
}


NUMERIC Win::DisplayProductListMenu( WhichCategory )
{
	Query = ~Select ID,LayoutName From Products~;
	
	if ( ~<WhichCategory>~ != ~~ )
	{
		 Query = ~<Query> Where Category = '<WhichCategory>'~;
	}

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Products table: <Query>. <theErr>~ );
	}

	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	GenCon( Product0,New,DDMenuItemDef,AddTo,ListMenu,SetValues,
			Text,			~&0   Categories~,
			ActionsText,	ACTION Exec ( <THIS>.DisplayProductCategories() ),
			IDText,			~ID~ );

	Count = 0;

	while ( List( GetNext,Product ) )
	{
		GenCon( Product<++Count>,New,DDMenuItemDef,AddTo,ListMenu,SetValues,
				Text,		~&<Count>   Create OrderItem for <$pcon.Product[ID]>,  (<$pcon.Product[LayoutName]>)~,
				IDText,		~ID~ );

		ActionsText = ACTION Exec ( <THIS>.WantProduct(~<$pcon.Product[ID]>~,~<$pcon.Product[LayoutName]>~) );

		Product<Count>( SetValuesFrom,ActionsText,ActionsText );
	}
		

	if ( GenCon( View,GetActiveView ) )
	{
		View( DisplayMenu,ListMenu,2,2 );
	}

	return TRUE;
}


NUMERIC Win::WantProduct( ProductID,LayoutName )
{
	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return Warning( ~There was no active view~ ); }

	msg = STR ( AddItemForProduct(~<ProductID>~); );

	action = ACTION DOC ( OrderItemsDoc "<msg>" );

	return PerformActions( action );
}


NUMERIC Win::CloseAllLayouts()
{
	StatusBar( ~Closing all open products~ );

	Count = Index = 0;

	app( ThisApp,MessagePump,3 );

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( Window( GETNEXT,aView ) )
		{
			aView( GET,ViewType,ViewType );

			if ( ~<ViewType>~ == ~LayoutView~ || ~<ViewType>~ == ~PIELayoutView~)
			{
				aView( GetDocumentPath,DocumentPath );
				Window( CloseWindow );
				++Count;
			}
		}
	}

	ThisApp( MessagePump,0 );

	return StatusBar( Translate(~<Count> products closed~) );
}


NUMERIC Win::FindLayouts()
{
	Define: ExplorerWindow Using DDWinDef		
		Fields:         
			Title						~Find Layouts and Drag them to the main window~
			TypeName					~ExplorerWnd~
			Position					0 0 50 50
			IsPositionPercent			T
			IsCenteredVertical			F
			IsCenteredHorizontal		F
			IsMaximized					F ;

	return ExplorerWindow( CreateWindow,aWindow );
}


NUMERIC Win::CreateCategory()
{
	ProductsWindow(CreateCategory);
	return TRUE;
}


VOID Win::RememberWindowLocation( &theWindow,Item )
{
	theWindow( SaveWindowLocation,WindowLocation,~<Item>~ );
}


NUMERIC Win::RightClickInImageView()
{
	if ( !GenCon( ActiveView,GetActiveView ) )
		{ return Warning( ~There was no active view~ ); }
		
	ActiveView( DisplayMenu,EditProductImageViewMenu );

	return TRUE;
}


NUMERIC Win::NotImplementedYet( what )
{
	MessageBox( ~<what> is not implemented yet!~ );
	return TRUE;
}

NUMERIC ThumbnailKeydownHook(&Key,&KeyString,&View)	{ return FALSE; }	// Override. return TRUE if the key was handled FALSE if it was not.

NUMERIC Win::OnKeyDown()
{
	if ( !GenCon( View,GETACTIVEVIEW ) )
		{ return FALSE; }

	if ( !View( IsThumbNailView ) )
		{ return FALSE; }
		
	key = View( GetLastKeyStateless,KeyString );
	
	if ( ThumbnailKeydownHook(key,KeyString,View) )				{ return TRUE; }

	if ( <key> > 32 && <key> <= 40 )			// Arrow keys,Home,End,PageUp&Dn
		{ return TRUE ; }

	if ( <key> == 0x74 )	// F5
		{ return RefreshThumbNailView(TRUE); }

	if ( <key> == 0x2E )	// Delete
		{ return DeleteSelectedProducts(); }

	if ( ~<KeyString>~ == ~0~ )	
		{ return DisplayCurrentProductListMenu(); }

	if ( SimilarStr(~<KeyString>~,~L~ ) )	
		{ return DisplayProductCategories(); }

	if ( KeyState( CONTROL ) )
	{
		if (  View( PerformMenuAction,EditProductImageViewMenu,~<KeyString>~ ) )
		{
			return TRUE;
		}
	}

	return View( DisplayMenu,EditProductImageViewMenu,2,2 );
}


Include: ~ExportSelectedToFile~;



NUMERIC Win::SelectProduct( ID )
{
	more = ProductsWindow( GetFirst,View );

	while ( $more )
	{
		if ( View( FindI,Key,~ID = '<ID>'~,Where,TheProduct ) )
		{ 
			View( GetName,ViewName );
			View( SetSelected,TheProduct,TRUE,TRUE );
			View( ScrollIntoView );
			return ProductsWindow( ChangeView,~<ViewName>~ );
		}

		more = ProductsWindow( GetNext,View );
	}

	return FALSE;
}

NUMERIC Win::SelectCategory( Name )
{
	more = ProductsWindow( GetFirst,View );

	while ( $more )
	{
		View( GetName,ViewName );

		if ( SimilarStr( ~<ViewName>~,~<Name>~ ) )
		{
			return ProductsWindow( ChangeView,~<ViewName>~ );
		}

		more = ProductsWindow( GetNext,View );
	}

	return FALSE;
}

VOID Win::WindowDefinition()
{
	Fields:	TypeName			SplitterWnd2
			SplitterRows		~1~
			SplitterColumns		~2 2 98~	
			HideSplitterBars	TRUE
			EnableStatusBar		F
			Position			0 75 100 22
}


VOID	Win::DefineViews()
{ 
	DefineView();						// HTML View for Navigation		
	DefineProductWnd();					// ICView for Product Icon Display		
}



VOID	Win::DefineProductWnd()
{
	Define: ProductsWindow Using DDWinDef AsSymbol ProductsWindow Permanent Private
		Fields:	Title				~Products~
				TypeName			~ImageWnd~
				Position			0 0 100 22
				IsPositionPercent	T
				AllowNoViews		1
				EnableStatusBar		F
				ImageFrameSize		<fImageFrameSize>;
}


VOID	Win::ViewDefinition()	{ }	// Overrides for the HTML View

NUMERIC	Win::ToggleSplitterWidth()
{	
	ReturnOnFailure( fHTMLView( Get,CloseArrow,0,src,WhichImage ) );
	
	if ( SimilarStr(~<WhichImage>~,~<$App.HTTPServer>/Artwork/Arrow-Left.gif~ ) )
	{
		fHTMLView( Set,CloseArrow,0,src,~/Artwork/Arrow-right.gif~ );
		fHTMLView( Set,CloseArrow,0,title,~Open~ );
		SetSplitterWidth(<fSmallSplitterSize>);
	}
	else
	{
		fHTMLView( Set,CloseArrow,0,src,~/Artwork/Arrow-Left.gif~ );
		fHTMLView( Set,CloseArrow,0,title,~Close~ );
		SetSplitterWidth(<fBigSplitterSize>);
	}
	
	return TRUE;
}


VOID	Win::SetSplitterWidth(width)		{ DataWindow( SplitterWindow,SetColInfo,0,~<width>~,0,RecalcLayout); }

VOID	Win::HelpRoutine()	
{ 
	TheAction = ACTION ShowHelpPage ( KPISHelpFile "<HelpPage>" );
	PerformActions( TheAction );	
	
	//OpenHelpPage(~/Products/Navigator.kpl~,TR(Navigator,NavigatorHelp));
}


VOID	Win::EditProductImageViewMenu()
{	
	Define:	EditProductImageViewMenu Using DDMenuDef AsSymbol EditProductImageViewMenu Private
		Fields:	Title		~Choose Something~
				Position	(-1)
		Contains:	INLISTORDER
		{	
		
			allowEditing = ((~<$App.Name>~ !=~DP1.exe~) && (GetUserPermissions( LayoutEditing ) )) ? T : F;
		
			Define:	OpenSelected using	DDMenuItemDef
				Fields:	Text		~&Open~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.OpenLayoutForSelectedProducts() )

			Define:	OpenContainingFolder using	DDMenuItemDef
				Fields:	Text		~Open Containing Folder~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.OpenContainingFolder() )

			Define:	NewLayout	using	DDMenuItemDef
				Fields:	Text		~&New Product~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.CreateNewLayout() )

			Define:	NewGridLayout	using	DDMenuItemDef
				Fields:	Text		~New Composite~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.CreateNewGridLayout() )

			Define:	Duplicate	using	DDMenuItemDef
				Fields:	Text		~Du&plicate~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.DuplicateSelectedProducts(); )

			Define:	ConvertToPattern	using	DDMenuItemDef
				Fields:	Text		~Convert Layout(s) To Simple Layout(s)~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ConvertToPattern() )

			Define:	ScaleTheLayout	using	DDMenuItemDef
				Fields:	Text		~Scale Layout(s) to a New Size~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ScaleLayouts() )

			Define:	DeleteProducts	using	DDMenuItemDef
				Fields:	Text		~&Remove~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.DeleteSelectedProducts(); )

			Define:	ListOfCategories	using	DDMenuItemDef
				Fields:	Text		~&List Of Categories~
						IDText		ID
						ActionsText  ACTION Exec ( <THIS>.DisplayProductCategories(); )

			Define:	UpdateIcons	using	DDMenuItemDef
				Fields:	Text		~&Update Open Product Icons~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.UpdateProductPreviewImages(~~); )

			Define:	SetIcons	using	DDMenuItemDef
				Fields:	Text		~Set Product Icon for a Specific Product~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.SetProductPreviewImages(~~); )

			Define:	CloseProduct	using	DDMenuItemDef
				Fields:	Text		~&Close Open Products~
						IDText		ID
						ActionsText  ACTION Exec ( <THIS>.CloseAllLayouts(); )

			Define:	RefreshProduct	using	DDMenuItemDef
				Fields:	Text		~Refresh  (F5)~
						IDText		ID
						ActionsText  ACTION Exec ( <THIS>.RefreshThumbNailView(TRUE); )

			Define:	LayoutsNULL0S using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~
						
			Define:	ViewGridData using	DDMenuItemDef
				Fields:	Text		~&Edit~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.EditListView() )
						
			Define:	ViewLabelData using	DDMenuItemDef
				Fields:	Text		~Edit Label Hierarchy~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ViewProductTreeOfLabel() )

			Define:	Search using	DDMenuItemDef
				Fields:	Text		Translate( UIMenuText,MenuFind )
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.Search() )

			Define:	ViewOrderItems	using	DDMenuItemDef
				Fields:	Text		~View Order &Items Data For Selected Products~
						IDText		ID
						ActionsText  ACTION Exec ( <THIS>.SeeOrderItemsForSelectedProducts(); )

			Define:	LayoutsNULL1S using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~

			Define:	CreateLayoutCategories using DDMenuItemDef
				Fields:	Text		~Create Category~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText	ACTION Exec ( <THIS>.CreateCategory(); )
						
			Define:	SetType using DDMenuItemDef
				Fields:	Text		~Set Product Type~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText	ACTION Exec ( <THIS>.DisplayProdTypeMenu(); )

			Define:	LayoutsNULL2 using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~

			Define:	ImagesForProduct	using	DDMenuItemDef
				Fields:	Text		~View I&mages For This Product~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ImagesForThisProduct(~~); )

			Define:	LayoutsNULL2 using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~

			Define:	ViewProductAsText	using	DDMenuItemDef
				Fields:	Text		~View As &Text~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ViewAsText(); )

			Define:	FixCarriageReturns	using	DDMenuItemDef
				Fields:	Text		~Fix Carriage Returns~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.FixCR(); )

			Define:	LayoutsNULL3 using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~

			Define:	ViewPackages using	DDMenuItemDef
				Fields:	Text		~Packages~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ViewPackages(); )


			Define:	NewPackage	using	DDMenuItemDef
				Fields:	Text		~New Package~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.AddNewPackage(); )
						
			Define:	LayoutsNULL3a using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~

	
			Define:	NewBook	using	DDMenuItemDef
				Fields:	Text		~Create a Book Product~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.AddNewBook(); )
	
			Define:	EditBook	using	DDMenuItemDef
				Fields:	Text		~Edit a Book Product~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.EditBook(); )
						
			Define:	EditBookAttributes	using	DDMenuItemDef
				Fields:	Text		~Edit Book Product Attributes~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.EditBookAttributes(); )
						
			Define:	ViewPagesOfBook using	DDMenuItemDef
				Fields:	Text		~View Pages of a Book Product~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ViewPagesOfTheBook(); )
						
						Define:	ViewBooks using	DDMenuItemDef
				Fields:	Text		~All Book Pages~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.ViewBookProducts(); )


	
			Define:	LayoutsNULL4 using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~

	
			Define:	NewSetup	using	DDMenuItemDef
				Fields:	Text		~New Node Style~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText  ACTION Exec ( <THIS>.CreateNewNodeStyle() )

			Define:	LayoutsNULL8 using DDMenuItemDef
				Fields:	Text		~~
						IDText		~NULL~

			Define:	Explorer	using	DDMenuItemDef
				Fields:	Text		~&Find Products To Import~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText ACTION Exec ( <THIS>.FindProducts() )

			/* DPT - Commented out on 7/1/03 because it's not used
			Define:	ExternalXRef	using	DDMenuItemDef
				Fields:	Text		~External System Product XRef~
						IDText		ID
						IsEnabled	<allowEditing>
						ActionsText ACTION Exec ( <THIS>.OnExternalXRef() )
			*/
		}
}

// THIS IS NEEDED SO THAT NOTIFYAFFECTEDDOCUMENTS KNOW ABOUT THE PRODUCT FIELDS
if ( !GenCon( ProductsTableDefinition,GetFrom,Products,~[DATABASE TableDefinitions]~ ) )
	{ Error( ~The Products Table is not properly defined~ ); }



VOID	Win::ProductThumbNailCategory()
{
	MACROSOFF

	Define: ProductThumbNailCategory Using DDViewDef AsSymbol ProductThumbNailCategory  Private
		Fields:	Text						~<Category>~
				ViewType					~ThumbnailView~
				IsModifiable				~T~
				IsNameModifiable			~T~
				DoubleClickActionsText		ACTION Exec ( <THIS>.OpenLayoutForSelectedProducts() )
				IActionsText				~~
				OActionsText				~~
				DropTypes					~Products~
				ViewDataType				~Products~
				ViewDataFor					~<Category>~
				DropActionsText				ACTION Exec ( <THIS>.HandleDrop() )
				AddCategoryActionsText		ACTION Exec ( <THIS>.AddCategory() )
				RenameCategoryActionsText	ACTION Exec ( <THIS>.RenameCategory() )
				RClickUpActionsText			ACTION Exec ( <THIS>.RightClickInImageView() ) 
				KeyboardActionsText			ACTION Exec ( <THIS>.OnKeydown() ) 
				HActionsText				ACTION SHOWHELPPAGE ( KPISHelpFile "Products.htm" )
				ImageOpenFailedMsg			~No Product Icon~
				NoSamplePreviewMsg			~No Product Icon~;
	MACROSON
}



VOID Win::InitWindow()
{
	ProductsThumbNailDefinition();
	ProductThumbNailCategory();
	EditProductImageViewMenu();
	ReturnOnFailure( DefineWindow() );
	Init();
	SetSplitterWidth(<fSmallSplitterSize>);
	AllowEditing = GetUserPermissions( LayoutEditing );
	Open( ~<$App.HTTPServer>/Products/Navigator.kpl~ );
}

VOID Win::NewCategory( theTabTitle,theCategory )
{
	SetDocumentQuery(~Select * From Products where Category='<theCategory>' Order By Sequence,Subsequence~);
	SetHierarchy( ~<theTabTitle>~ );
	RefreshDoc();
	GetTheFocus();
}


VOID Win::SetDocumentQuery(Query)	{ DocumentQuery = IsNull(~<Query>~)? ~Select * From Products Order By Sequence,Subsequence~ : ~<Query>~; }
VOID Win::SetHierarchy(hierarchy)	{ fHierarchy = ~<hierarchy>~; }


VOID Win::SetTitle(Title)
{
	SetWindowTitle(~<Title>~ == ~~ ? ~Products~ : ~Products - <Title>~);
}


VOID Win::ShowNewProducts(Title,Query)
{
	SetTitle(~<Title>~);
	SetDocumentQuery(~<Query>~);
	RefreshDoc();
}


VOID InitDoc( WhichProducts,ViewIsImages,Query )
{
	if ( !ObjectAlreadyExists( obj ) )
	{
		Win( New,Obj );
		Obj( Global );
		Obj.InitWindow();
		
	}
	else
	{
		Obj.BringToFront();
		Obj.SetHierarchy(~~);
	}
	
	Obj.ShowNewProducts(~<WhichProducts>~,~<Query>~);
}


VOID Init( WhichProducts,ViewIsImages,DocumentQuery )	// ENTRY POINT FROM OTHER SCRIPTS
{
	InitDoc(~<WhichProducts>~,~<ViewIsImages>~,~<DocumentQuery>~);
}

OptionalInclude( ~<$App.ShareDirectory>\Scripts\ScriptOverrides\ProductsDoc.txt~ );
OptionalInclude( ~<$App.ShareDirectory>\Scripts\ScriptOverrides\ProductsDoc2.txt~ );


// remind Dave to fix Create Category
