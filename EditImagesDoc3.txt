Debugging = FALSE ;

/*
VK_LBUTTON  =      0x01;
VK_RBUTTON    =    0x02;
VK_CANCEL   =      0x03;
VK_MBUTTON  =      0x04;
VK_BACK  =         0x08;
VK_TAB   =         0x09;
VK_CLEAR   =       0x0C;
VK_RETURN   =      0x0D;
VK_SHIFT    =      0x10;
VK_CONTROL  =      0x11;
VK_MENU    =       0x12;
VK_PAUSE    =      0x13;
VK_CAPITAL  =      0x14;
VK_ESCAPE     =    0x1B;
VK_CONVERT     =   0x1C;
VK_NONCONVERT  =   0x1D;
VK_ACCEPT      =   0x1E;
VK_MODECHANGE  =   0x1F;
VK_SPACE    =      0x20;
VK_PRIOR    =      0x21;
VK_NEXT     =      0x22;
VK_END      =      0x23;
VK_HOME      =     0x24;
VK_LEFT       =    0x25;
VK_UP        =     0x26;
VK_RIGHT     =     0x27;
VK_DOWN      =     0x28;
VK_SELECT    =     0x29;
VK_PRINT     =     0x2A;
VK_EXECUTE    =    0x2B;
VK_SNAPSHOT   =    0x2C;
VK_INSERT    =     0x2D;
VK_DELETE    =     0x2E;
VK_HELP    =       0x2F;
VK_0  =			   0x30;
VK_1  =			   0x31;
VK_2  =			   0x32;
VK_3  =			   0x33;
VK_4  =			   0x34;
VK_5  =			   0x35;
VK_6  =			   0x36;
VK_7  =			   0x37;
VK_8  =			   0x38;
VK_9  =			   0x39;
VK_A  =			   0x41;
VK_B  =			   0x42;
VK_C  =			   0x43;
VK_D  =			   0x44;
VK_E  =			   0x45;
VK_F  =			   0x46;
VK_G  =			   0x47;
VK_H  =			   0x48;
VK_I  =			   0x49;
VK_J  =			   0x4A;
VK_K  =			   0x4B;
VK_L  =			   0x4C;
VK_M  =			   0x4D;
VK_N  =			   0x4E;
VK_O  =			   0x4F;
VK_P  =			   0x50;
VK_Q  =			   0x51;
VK_R  =			   0x52;
VK_S  =			   0x53;
VK_T  =			   0x54;
VK_U  =			   0x55;
VK_V  =			   0x56;
VK_W  =			   0x57;
VK_X  =			   0x58;
VK_Y  =			   0x59;
VK_Z  =			   0x5A;
VK_LWIN    =       0x5B;
VK_RWIN    =       0x5C;
VK_APPS    =       0x5D;
VK_NUMPAD0   =     0x60;
VK_NUMPAD1  =      0x61;
VK_NUMPAD2  =      0x62;
VK_NUMPAD3  =      0x63;
VK_NUMPAD4  =      0x64;
VK_NUMPAD5  =      0x65;
VK_NUMPAD6  =      0x66;
VK_NUMPAD7  =      0x67;
VK_NUMPAD8   =     0x68;
VK_NUMPAD9  =      0x69;
VK_MULTIPLY  =     0x6A;
VK_ADD    =        0x6B;
VK_SEPARATOR  =    0x6C;
VK_SUBTRACT  =     0x6D;
VK_DECIMAL  =      0x6E;
VK_DIVIDE  =       0x6F;
VK_F1    =         0x70;
VK_F2    =         0x71;
VK_F3    =         0x72;
VK_F4    =         0x73;
VK_F5    =         0x74;
VK_F6   =          0x75;
VK_F7   =          0x76;
VK_F8  =           0x77;
VK_F9  =           0x78;
VK_F10   =         0x79;
VK_F11   =         0x7A;
VK_F12   =         0x7B;
VK_F13   =         0x7C;
VK_F14   =         0x7D;
VK_F15   =         0x7E;
VK_F16    =        0x7F;
VK_F17   =         0x80;
VK_F18    =        0x81;
VK_F19   =         0x82;
VK_F20    =        0x83;
VK_F21     =       0x84;
VK_F22    =        0x85;
VK_F23     =       0x86;
VK_F24     =       0x87;
VK_NUMLOCK    =    0x90;
VK_SCROLL   =      0x91;
*/

Include: ~DcSbaDoc~;
IncludeClass( ~BaseEnterText~ );
Include: ~DeleteOrder~;


Define: ImageEditData Using DDImageEdit 
	Fields:	orgD			64
			orgGamma		1.0		// all other fields default to 0 or NULL
			orgGammaRed		1.0	
			orgGammaGreen	1.0	
			orgGammaBlue	1.0
			orgPSGamma		1.0
			LutDrawingMode	~Curves~
			LutChannel		0
			SBALevel		0 
			AutoBalanceDone 0 ;

Define: SavedImageEditData Using DDLong 

Define: ImageEditData0	Using DDImageEdit ;
Define: ImageEditData1	Using DDImageEdit ;
Define: ImageEditData2	Using DDImageEdit ;
Define: ImageEditData3	Using DDImageEdit ;
Define: ImageEditData4	Using DDImageEdit ;
Define: ImageEditData5	Using DDImageEdit ;
Define: ImageEditData6	Using DDImageEdit ;
Define: ImageEditData7	Using DDImageEdit ;
Define: ImageEditData8	Using DDImageEdit ;
Define: ImageEditData9	Using DDImageEdit ;

Define: ImageEditDataZero Using DDImageEdit ;

Define: CurvesData Using DDReference
	Fields:	Reference		0;

ImageEditDataCount = -1;
MaxImageEditDataCount = 9;
NextPrevButtonPressed = FALSE;

HelpPage = ~Adjust_Images.htm~;

hGap = 1; vGap = 1;
PromptHeight = 20;		PromptWidth = 60;		ValueWidth = 30;
ButtonWidth = 70;		ButtonHeight = 20;		SliderWidth = 233;
LeftX = $hGap+4;		CurrentY = $vGap+2;		CurrentRight = 0;
PlusMinusWidth = 23;


VOID DefineImageEditLine( Type,Name,Increment,Prompt,ToolTip,ShowControl,MinusText,PlusText,R,G,B )
{
	Define: <Type>Prompt Using DDWinCtrlDef AsSymbol <Type>Prompt
		Fields:	POSITION		$LeftX $CurrentY $PromptWidth $PromptHeight
				TEXT			~<Prompt>~
				TOOLTIP			~<ToolTip>~
				Fields:			DACTIONSTEXT	ACTION EXEC ( AdjustValue(<Name>,KeyState(Shift) ? -<Increment> : <Increment>) )
				TYPENAME		Button
				BGColorRed		Defined(R) ? ~<R>~ : ~190~
				BGColorGreen	Defined(G) ? ~<G>~ : ~190~
				BGColorBlue		Defined(B) ? ~<B>~ : ~190~


	Define: <Type>Field Using DDWinCtrlDef AsSymbol <Type>Field
		Fields:	//DACTIONSTEXT	ACTIONS ( Save Update(<Name>Slider) DialogTimer(0 1000) )
				GENCONFIELD		~<Name>~
				GENCONNAME		THIS
				IACTIONSTEXT	ACTIONS ( Get )
				//DACTIONSTEXT	ACTIONS ( Save )
				OACTIONSTEXT	ACTIONS ( Save )
				POSITION		(<Type>Prompt(GetRight,Position) + $hGap*2) $CurrentY+3 $ValueWidth $PromptHeight
				TEXT			~~
				TOOLTIP			~<ToolTip>~
				TYPENAME		StaticText //MaskedEditText
				Mask			(SimilarStr(~<Prompt>~,~Angle~,~Saturation~) || SimilarStr(~<Prompt>~,~Gamma~,~Saturation~)) ? ~######~ : ~####~
				PromptChar		~ ~ 
				AllowedChars	(SimilarStr(~<Prompt>~,~Angle~) || SimilarStr(~<Prompt>~,~Gamma~)) ? ~-.~ : ~-~

	Define: <Type>Slider Using DDWinCtrlDef AsSymbol <Type>Slider
		Fields:	DACTIONSTEXT	ACTIONS ( Save Update(<Name>Field) DialogTimer(0 250) )
				GENCONFIELD		~<Name>~
				GENCONNAME		THIS
				IACTIONSTEXT	~[Get]~
				//DACTIONSTEXT	ACTIONS ( Save )
				OACTIONSTEXT	~[Save]~
				POSITION		(<Type>Field(GetRight,Position) + $hGap) $CurrentY $SliderWidth $PromptHeight
				TOOLTIP			~<ToolTip>~
				TYPENAME		~SLIDER~ 
				UNITS			($Increment);

	Global( <Type>Slider );

	Define: <Type>ZeroButton Using DDWinCtrlDef AsSymbol <Type>ZeroButton
		Fields:	DACTIONSTEXT	ACTION EXEC ( ZeroValue(<Name>) )
				POSITION		(<Type>Slider(GetRight,Position) + $hGap)+2 $CurrentY $PlusMinusWidth $PromptHeight
				TOOLTIP			~Reset the amount to zero~
				TYPENAME		~Button~ 
				TEXT			~0~
				BGColorRed		Defined(R) ? ~<R>~ : ~190~
				BGColorGreen	Defined(G) ? ~<G>~ : ~190~
				BGColorBlue		Defined(B) ? ~<B>~ : ~190~;


	Define: <Type>Minus Using DDWinCtrlDef AsSymbol <Type>Minus
		Fields:	POSITION		<Type>ZeroButton(GetRight,Position)+1 $CurrentY $PlusMinusWidth $PromptHeight
				TEXT			~-~
				TOOLTIP			~Decrease the amount~
				Fields:			DACTIONSTEXT	ACTION EXEC ( IncrementValue(<Name>,-<Increment>) )
				TYPENAME		Button
				BGColorRed		Defined(R) ? ~<R>~ : ~190~
				BGColorGreen	Defined(G) ? ~<G>~ : ~190~
				BGColorBlue		Defined(B) ? ~<B>~ : ~190~;


	Define: <Type>Plus Using DDWinCtrlDef AsSymbol <Type>Plus
		Fields:	POSITION		<Type>Minus(GetRight,Position)+1 $CurrentY $PlusMinusWidth $PromptHeight
				TEXT			~+~
				TOOLTIP			~Increase the amount~
				Fields:			DACTIONSTEXT	ACTION EXEC ( IncrementValue(<Name>,<Increment>) )
				TYPENAME		Button
				BGColorRed		Defined(R) ? ~<R>~ : ~190~
				BGColorGreen	Defined(G) ? ~<G>~ : ~190~
				BGColorBlue		Defined(B) ? ~<B>~ : ~190~;


	CurrentY = <Type>ZeroButton(GetBottom,Position) + $vGap;
	CurrentRight = <Type>ZeroButton(GetRight,Position) + $hGap + $hGap;
	
}


VOID SelectATab( num )
{
	if ( Defined( dlg ) )
	{
		dlg( SelectTab,TabWindow,~<num>~ );
	}
}

VOID InitializeLut()
{
	EditDialog( ToneScale,LutControl,GetLUT,ImageEditData,~cLut~,TRUE );
	EditDialog( ToneScale,LutControl,GetIdentityLUT,ImageEditDataZero,~cLut~,TRUE );
}

VOID InitApplyShasta()
{
	DocName = ~~;
	if ( Document( Doc,FindByName,~ImagesDoc~ ) )
	{
		DocName = ~ImagesDoc~;
	}
	else if ( Document( Doc,FindByName,~GreenScreenDoc~ ) )
	{
		DocName = ~GreenScreenDoc~;
	}

	if ( !SimilarStr(~<DocName>~,~~) )
	{
		Action = STR ( <DocName> "SetApplyShasta(FALSE);" );
		PerformDocActions( Action );
	}
}

VOID NudgeButton( which )
{
	EditDialog( ToneScale,LutControl,MoveActiveControlPoint,<which> );	
}

VOID UpdateInputDevice( which )
{
	// which could be -1
	if ( ( <which> != 1 ) && ( <which> != 2 ) )
	{
		which = 0;
	}
	
	Channel0 = InputDeviceNoneRadio;
	Channel1 = InputDeviceColorProRadio;
	Channel2 = InputDeviceWheelmanRadio;

	EditDialog( SetCheck, FALSE, InputDeviceNoneRadio );
	EditDialog( SetCheck, FALSE, InputDeviceColorProRadio );
	EditDialog( SetCheck, FALSE, InputDeviceWheelmanRadio );

	EditDialog( SetCheck, TRUE, <Channel<which>> );
	
	if ( <which> == 0 )
	{
		EditDialog(EnableControls,FALSE,PortStaticText,PortListComboBox,DiagnosticsCheckBox);

		CloseColorPro();
		CloseInputDevice();
	}
	else if ( <which> == 1 )
	{
		EditDialog(EnableControls,FALSE,PortStaticText,PortListComboBox,DiagnosticsCheckBox);

		CloseInputDevice();
		OpenColorPro();
	}
	else
	{
		EditDialog(EnableControls,TRUE,PortStaticText,PortListComboBox,DiagnosticsCheckBox);
		
		CloseColorPro();
		OnPortChange();
	}
}

VOID UpdateLutColor( which )
{
	Channel0 = Density;
	Channel1 = Red;
	Channel2 = Green;
	Channel3 = Blue;

	EditDialog( SetCheck, FALSE, DensityRadio );
	EditDialog( SetCheck, FALSE, RedRadio );
	EditDialog( SetCheck, FALSE, GreenRadio );
	EditDialog( SetCheck, FALSE, BlueRadio );

	EditDialog( ToneScale,LutControl,SetActiveChannel,<Which> );	

	EditDialog( SetCheck, TRUE, <Channel<which>>Radio );
}

VOID SetGridLines( Value )	{ EditDialog( ToneScale,LutControl,SetGridLines,<Value> ); }		

VOID OnLutResetButton(updateImages)
{
	EditDialog( ToneScale,LutControl,Reset,FALSE );
	EditDialog( ToneScale,LutControl,GetLUT,ImageEditData,~cLut~,TRUE );

	EditDialog( ToneScale,LutControlRed,RefreshControl );
	EditDialog( ToneScale,LutControlGreen,RefreshControl );
	EditDialog( ToneScale,LutControlBlue,RefreshControl );	

	if ( <updateImages> )
	{
		UpdateAffectedImages();
	}
}

VOID OnLutResetRedButton()
{
	EditDialog( ToneScale,LutControlRed,Reset,TRUE );
	EditDialog( ToneScale,LutControl,GetLUT,ImageEditData,~cLut~,TRUE );

	EditDialog( ToneScale,LutControl,RefreshControl );
	EditDialog( ToneScale,LutControlGreen,RefreshControl );
	EditDialog( ToneScale,LutControlBlue,RefreshControl );	

	UpdateAffectedImages();
}

VOID OnLutResetGreenButton()
{
	EditDialog( ToneScale,LutControlGreen,Reset,TRUE );
	EditDialog( ToneScale,LutControl,GetLUT,ImageEditData,~cLut~,TRUE );

	EditDialog( ToneScale,LutControl,RefreshControl );
	EditDialog( ToneScale,LutControlRed,RefreshControl );
	EditDialog( ToneScale,LutControlBlue,RefreshControl );	

	UpdateAffectedImages();
}

VOID OnLutResetBlueButton()
{
	EditDialog( ToneScale,LutControlBlue,Reset,TRUE );
	EditDialog( ToneScale,LutControl,GetLUT,ImageEditData,~cLut~,TRUE );

	EditDialog( ToneScale,LutControl,RefreshControl );
	EditDialog( ToneScale,LutControlRed,RefreshControl );
	EditDialog( ToneScale,LutControlGreen,RefreshControl );

	UpdateAffectedImages();
}

VOID OnLutResetDenButton()
{
	EditDialog( ToneScale,LutControl,Reset,TRUE );
	EditDialog( ToneScale,LutControl,GetLUT,ImageEditData,~cLut~,TRUE );

	EditDialog( ToneScale,LutControlRed,RefreshControl );
	EditDialog( ToneScale,LutControlGreen,RefreshControl );
	EditDialog( ToneScale,LutControlBlue,RefreshControl );	

	UpdateAffectedImages();
}

VOID OnLutSmoothButton()
{ 
	OnLutSmoothDenButton();
	OnLutSmoothRedButton();
	OnLutSmoothGreenButton();
	OnLutSmoothBlueButton();
}


VOID OnLutSmoothDenButton()		{ EditDialog( ToneScale,LutControl,SmoothCurve ); }
VOID OnLutSmoothRedButton()		{ EditDialog( ToneScale,LutControlRed,SmoothCurve ); }
VOID OnLutSmoothGreenButton()	{ EditDialog( ToneScale,LutControlGreen,SmoothCurve ); }
VOID OnLutSmoothBlueButton()	{ EditDialog( ToneScale,LutControlBlue,SmoothCurve ); }


VOID OnDrawModeComboBox()	
{ 
	ModeCurves = 1; ModeLinear = 2; ModeDraw = 3;
	EditDialog( GetInput );
	DrawMode = ~<$con.ImageEditData[LutDrawingMode]>~;
	EditDialog( ToneScale,LutControl,SetDrawMode,~<Mode<DrawMode>>~);

	EditDialog( ToneScale,LutControl,SetShowAllCurves,TRUE );
	EditDialog( SetStatus,1,~Mode is <DrawMode>~ );
}

VOID ActivePoint(x,y)	{ EditDialog( SetControlValue,InputOutputField,~<$str.$x.%03ld> ---> <$str.$y.%03ld>~); }

VOID LutChange()
{
	EditDialog( ToneScale,LutControl,GetLUT,ImageEditData,~cLut~,TRUE );
	EditDialog( ToneScale,LutControl,GetControlPoints,ImageEditData,~LUTControlPoints~ );
}

VOID RefreshLut()
{
	EditDialog( ToneScale,LutControl,SetLUT,ImageEditData,~cLut~ );
	EditDialog( ToneScale,LutControl,SetControlPoints,ImageEditData,~LUTControlPoints~ );
	
	EditDialog( ToneScale,LutControl,RefreshControl	);
	EditDialog( ToneScale,LutControlRed,RefreshControl	);
	EditDialog( ToneScale,LutControlGreen,RefreshControl	);
	EditDialog( ToneScale,LutControlBlue,RefreshControl	);	

}


VOID InitTSNeutral()
{
	EditDialog( Tonescale, LutControl, RefreshControl );
}


VOID InitTSRed()
{
	EditDialog( Tonescale, LutControlRed, RefreshControl );
}


VOID InitTSGreen()
{
	EditDialog( Tonescale, LutControlGreen, RefreshControl );
}


VOID InitTSBlue()
{
	EditDialog( Tonescale, LutControlBlue, RefreshControl );
}

VOID DefineImageEditDialog()
{
	WaitCursor( Begin );

	Tab = 0;

	TabTop = CurrentY = 26;  TabWidth = 407; TabHeight = 225;
    EditTextWidth = 40;	EditTextHeight = 22;

	Define: ImageEditDialog Using DDWinDef
		Fields:	POSITION			 100, 100, 600, 620 
				TITLE				 ~Adjust Images~
				TYPENAME			 ~Dialog~ 
				WANTSMINIMIZEBOX	 TRUE
				STATUSBAR			 ~3 17 63 10~
				OACTIONSTEXT		 ACTION EXEC ( CloseImageEditDialog() )
				HACTIONSTEXT		 ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" ) 
				RETURNKEYACTIONSTEXT ACTION EXEC ( OnNextButton() )
				KEYBOARDACTIONSTEXT	 ACTION EXEC ( OnKeyDown() )
				ACTIVATEACTIONSDELAY 20
				STEALMULTIPLY		 TRUE
				ACTIVATEACTIONSTEXT		<Debugging> ? ~~ : ACTION EXEC ( OnActivate() )
				DEACTIVATEACTIONSTEXT	<Debugging> ? ~~ : ACTION EXEC ( OnDeactivate() )

			

		Contains: INLISTORDER
		{
			Define: TabWindow Using DDWinCtrlDef AsSymbol TabWindow
                Fields: Position	2 2 <TabWidth> <TabHeight>
                        TypeName	TabCtrl
                        Text		~TCS_HOTTRACK | TCS_MULTILINE | TCS_TOOLTIPS | TCS_FOCUSNEVER~

			Contains: InListOrder
			{
			    Define: Tab<++Tab> Using DDWinCtrlDef
					Fields: Text			~Adjust~
							TypeName		Tab
							Tooltip			~Normal tab for adjusting~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					DefineImageEditLine( cDensity,	cDensity,	1,	~Density~,	~Make the image Lighter (Shift-d) or Darker (d)~, 1,~~,~~,170,170,170 );
					DefineImageEditLine( cRed,		cRed,		1,	~Red~,		~Make the image more Cyan (Shift-r) or more Red (r)~, 1,~~,~~,190,170,170 );
					DefineImageEditLine( cGreen,	cGreen,		1,	~Green~,	~Make the image more Magenta (Shift-g) or more Green (g)~, 1,~~,~~,170,190,170 );
					DefineImageEditLine( cBlue,		cBlue,		1,	~Blue~,		~Make the image more Yellow (Shift-b) or more Blue (b)~, 1,~~,~~,170,170,190 );

					CurrentY += $vGap + $vGap;

					DefineImageEditLine( cContrast,	cContrast,	1,	~Contrast~,	~Decrease (Shift-t) or increase (t) the Contrast of the image~, 1,~~,~~,190,190,190 );
					DefineImageEditLine( cGamma,	cGamma,	 0.05,	~Gamma~,	~Decrease (Shift-m) or increase (m) the Gamma of the image~, 1,~~,~~,170,170,170 );
					
					CurrentY += $vGap + $vGap;

					DefineImageEditLine( cSaturation,cSaturation,1,	~Saturation~,	~Decrease (Shift-u) or increase (u) the Saturation of the image~, 1,~~,~~,190,190,190 );
					DefineImageEditLine( cSharpen,	 cSharpen,	 1,	~Sharpen~,		~Decrease (Shift-h) or increase (h) the Sharpening for this image~, 1,~~,~~,170,170,170);
					DefineImageEditLine( cArbitraryRotation,cArbitraryRotation,0.05,~Angle~,~Decrease (Shift-a) or increase (a) the horizontal angle of the image~, 1,~~,~~,190,190,190 );

				}

			    Define: Tab<++Tab> Using DDWinCtrlDef
					Fields: Position	2 2 <TabWidth> <TabHeight>
							Text			~Contrast~
							TypeName		Tab
							Tooltip			~Contrast controls~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					TabTop = CurrentY = 26;

					DefineImageEditLine( cShadowContrast,	 cShadowContrast,	 1,	~S Con~, ~Decrease or increase the Contrast of the Shadows in the image~, 1,~~,~~,170,170,170 );
					DefineImageEditLine( cMidtoneContrast,	 cMidtoneContrast,	 1,	~M Con~, ~Decrease or increase the Contrast of the Midtones in the image~, 1,~~,~~,180,180,180 );
					DefineImageEditLine( cHighlightContrast, cHighlightContrast, 1,	~H Con~, ~Decrease or increase the Contrast of the Highlights in the image~, 1,~~,~~,190,190,190 );

					CurrentY = $TabHeight ;
				}

			    Define: Tab<++Tab> Using DDWinCtrlDef
					Fields: Position	2 2 <TabWidth> <TabHeight>
							Text			~Auto Enhancement~
							TypeName		Tab
							Tooltip			~Auto Contrast Enhancement~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					TabTop = CurrentY = 26;
			
					DefineImageEditLine( cPSDensity, cPSDensity,1,	~Den AE~,	~Make the image Lighter (Shift-d) or Darker (d)~, 1,~&D~,~&d~,170,170,170 );
					DefineImageEditLine( cPSRed,	 cPSRed,	1,	~Red AE~,	~Make the image more Cyan (Shift-r) or more Red (r)~, 1,~&R~,~&r~,190,170,170 );
					DefineImageEditLine( cPSGreen,	 cPSGreen,	1,	~Grn AE~,	~Make the image more Magenta (Shift-g) or more Green (g)~, 1,~&G~,~&g~,170,190,170 );
					DefineImageEditLine( cPSBlue,	 cPSBlue,	1,	~Blu AE~,	~Make the image more Yellow (Shift-b) or more Blue (b)~, 1,~&B~,~&b~,170,170,190 );

					CurrentY += $vGap + $vGap;

					DefineImageEditLine( cPSContrast,cPSContrast,1,	~Con AE~,	~Decrease (Shift-t) or increase (t) the Contrast of the image~, 1,~&T~,~&t~,190,190,190 );
					DefineImageEditLine( cPSGamma,   cPSGamma,	 0.05, ~Gam AE~,~Decrease (Shift-m) or increase (m) the Gamma of the image~,    1,   ~&M~,~&m~,170,170,170 );
					
					CurrentY += $vGap + $vGap;
					
					DefineImageEditLine( cShastaHighlight,cShastaHighlight,	1,	~Highlight~,	~Adjust amount of Highlight Contrast~, 1,~~,~~,200,200,170 );
					DefineImageEditLine( cShastaMidTone,cShastaMidTone,		1,	~MidTone~,		~Adjust amount of Mid Tone Contrast~, 1,~~,~~,200,200,170);
					DefineImageEditLine( cShastaShadow,cShastaShadow,		1,	~Shadow~,		~Adjust amount of Shadow Contrast~, 1,~~,~~,200,200,170 );
					CurrentY = $TabHeight ;

				}

			    Define: Tab<++Tab> Using DDWinCtrlDef
					Fields: Position	2 2 <TabWidth> <TabHeight>
							Text			~Curves~
							TypeName		Tab
							Tooltip			~Adjust balance curves~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					Define: LutControl Using DDWinCtrlDef AsSymbol LutControl 
						Fields: TypeName				ToneScale 
								GENCONFIELD				~cLut~
								GENCONNAME				THIS
								TSNumGridLines			180/20
								TSShowAllCurves			T
								TSShowGrid				T
								TSData					~CurvesData~
								TSShowTonalSliders		F
								IActionsText			ACTIONS ( "Exec(InitTSNeutral())" )
								ActivePtActionsText		ACTION EXEC ( ActivePoint(%ld,%ld) )
								DActionsText			ACTIONS ( "Exec(LUTChange())" DialogTimer(0 250) Update(LutControlRed) Update(LutControlGreen) Update(LutControlBlue) )
								POSITION				$LeftX,$TabTop, 186 184 // 262 260

					Define: DensityRadio Using DDWinCtrlDef AsSymbol DensityRadio 
						Fields: TypeName		RadioButton
								Position		LutControl( GetRight,Position)+6 LutControl( GetTop,Position ) 58 $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	~[ "Exec(UpdateLutColor(0))" ]~
								OActionsText	~[Save]~
								GenConName		THIS
								GenConField		~LutChannel~
								RadioTrueValue	0
								TextColorRed	0,	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~200~ BGColorBlue ~200~
								Text			Translate(~Density~)
								Tooltip			~Manipulate the density~;

					Define: ResetLutDenButton Using DDWinCtrlDef AsSymbol ResetLutDenButton 
						Fields: TypeName		Button
								Position		DensityRadio( GetRight,Position)+4 DensityRadio( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutResetDenButton() )
								OActionsText	~[Save]~
								Text			Translate(~Reset~)
								TextColorRed	0,	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~200~ BGColorBlue ~200~
								Tooltip			~Reset the density curve~;

					Define: SmoothLutDenButton Using DDWinCtrlDef AsSymbol SmoothLutDenButton 
						Fields: TypeName		Button
								Position		ResetLutDenButton( GetRight,Position)+4 ResetLutDenButton( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutSmoothDenButton() )
								OActionsText	~[Save]~
								Text			Translate(~Smooth~)
								TextColorRed	0,	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~200~ BGColorBlue ~200~
								Tooltip			~Smooth the density curve~;

					Define: RedRadio Using DDWinCtrlDef AsSymbol RedRadio 
						Fields: TypeName		RadioButton
								Position		DensityRadio( GetLeft,Position) DensityRadio( GetBottom,Position )+$vGap DensityRadio(GetWidth,Position) $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	~[ "Exec(UpdateLutColor(1))" ]~
								OActionsText	~[Save]~
								GenConName		THIS
								GenConField		~LutChannel~
								RadioTrueValue	1
								TextColorRed	0	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~255~ BGColorGreen	~200~ BGColorBlue ~200~
								Text			Translate(~Red~)
								Tooltip			~Manipulate Red~;
					
					Define: ResetLutRedButton Using DDWinCtrlDef AsSymbol ResetLutRedButton 
						Fields: TypeName		Button
								Position		RedRadio( GetRight,Position)+4 RedRadio( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutResetRedButton() )
								OActionsText	~[Save]~
								Text			Translate(~Reset~)
								TextColorRed	0	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~255~ BGColorGreen	~200~ BGColorBlue ~200~
								Tooltip			~Reset the red curve~;

					Define: SmoothLutRedButton Using DDWinCtrlDef AsSymbol SmoothLutRedButton 
						Fields: TypeName		Button
								Position		ResetLutRedButton( GetRight,Position)+4 ResetLutRedButton( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutSmoothRedButton() )
								OActionsText	~[Save]~
								Text			Translate(~Smooth~)
								TextColorRed	0	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~255~ BGColorGreen	~200~ BGColorBlue ~200~
								Tooltip			~Smooth the red curve~;

					Define: GreenRadio Using DDWinCtrlDef AsSymbol GreenRadio 
						Fields: TypeName		RadioButton
								Position		RedRadio( GetLeft,Position) RedRadio( GetBottom,Position )+$vGap DensityRadio(GetWidth,Position) $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	~[ "Exec(UpdateLutColor(2))" ]~
								OActionsText	~[Save]~
								GenConName		THIS
								GenConField		~LutChannel~
								RadioTrueValue	2
								TextColorRed	0,	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~255~ BGColorBlue ~200~
								Text			Translate(~Green~)
								Tooltip			~Manipulate Green~;

					Define: ResetLutGreenButton Using DDWinCtrlDef AsSymbol ResetLutGreenButton 
						Fields: TypeName		Button
								Position		GreenRadio( GetRight,Position)+4 GreenRadio( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutResetGreenButton() )
								OActionsText	~[Save]~
								Text			Translate(~Reset~)
								TextColorRed	0	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~255~ BGColorBlue ~200~
								Tooltip			~Reset the green curve~;

					Define: SmoothLutGreenButton Using DDWinCtrlDef AsSymbol SmoothLutGreenButton 
						Fields: TypeName		Button
								Position		ResetLutGreenButton( GetRight,Position)+4 ResetLutGreenButton( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutSmoothGreenButton() )
								OActionsText	~[Save]~
								Text			Translate(~Smooth~)
								TextColorRed	0	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~255~ BGColorBlue ~200~
								Tooltip			~Smooth the green curve~;

					
					Define: BlueRadio Using DDWinCtrlDef AsSymbol BlueRadio 
						Fields: TypeName		RadioButton
								Position		GreenRadio( GetLeft,Position) GreenRadio( GetBottom,Position )+$vGap DensityRadio(GetWidth,Position) $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	~[ "Exec(UpdateLutColor(3))" ]~
								OActionsText	~[Save]~
								GenConName		THIS
								GenConField		~LutChannel~
								RadioTrueValue	3
								TextColorRed	0	TextColorGreen 0	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~200~ BGColorBlue ~255~
								Text			Translate(~Blue~)
								Tooltip			~Manipulate Blue~;

					Define: ResetLutBlueButton Using DDWinCtrlDef AsSymbol ResetLutBlueButton 
						Fields: TypeName		Button
								Position		BlueRadio( GetRight,Position)+4 BlueRadio( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutResetBlueButton() )
								OActionsText	~[Save]~
								Text			Translate(~Reset~)
								TextColorRed	0	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~200~ BGColorBlue ~255~
								Tooltip			~Reset the blue curve~;

					Define: SmoothLutBlueButton Using DDWinCtrlDef AsSymbol SmoothLutBlueButton 
						Fields: TypeName		Button
								Position		ResetLutBlueButton( GetRight,Position)+4 ResetLutBlueButton( GetTop,Position ) 45  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutSmoothBlueButton() )
								OActionsText	~[Save]~
								Text			Translate(~Smooth~)
								TextColorRed	0	TextColorGreen 0,	TextColorBlue 0
								BGColorRed		~200~ BGColorGreen	~200~ BGColorBlue ~255~
								Tooltip			~Smooth the blue curve~;


					Define: ResetLutButton Using DDWinCtrlDef AsSymbol ResetLutButton 
						Fields: TypeName		Button
								Position		DensityRadio( GetLeft,Position) BlueRadio( GetBottom,Position )+$vGap BlueRadio(GetWidth,Position)+19  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutResetButton(TRUE) )
								OActionsText	~[Save]~
								Text			Translate(~Reset All~)
								Tooltip			~Reset all curves~;

					Define: SmoothLutButton Using DDWinCtrlDef AsSymbol SmoothLutButton 
						Fields: TypeName		Button
								Position		ResetLutButton( GetRight,Position)+1 ResetLutButton( GetTop,Position ) ResetLutButton( GetWidth,Position )  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( OnLutSmoothButton() )
								OActionsText	~[Save]~
								Text			Translate(~Smooth All~)
								Tooltip			~Smooth all curves~;

					Define: NudgeUpButton Using DDWinCtrlDef AsSymbol NudgeUpButton 
						Fields: TypeName		Button
								Position		BlueRadio( GetRight,Position)-10 SmoothLutButton( GetBottom,Position )+5 40  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( NudgeButton(1) )
								OActionsText	~[Save]~
								Text			Translate(~Up~)
								IsHidden		T				// NOT SUPPORTED AT THIS TIME
								Tooltip			~Nudge the active point up~;

					Define: NudgeLeftButton Using DDWinCtrlDef AsSymbol NudgeLeftButton 
						Fields: TypeName		Button
								Position		NudgeUpButton( GetLeft,Position)-NudgeUpButton(GetWidth,Position) NudgeUpButton( GetBottom,Position ) NudgeUpButton(GetWidth,Position)  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( NudgeButton(4) )
								OActionsText	~[Save]~
								Text			Translate(~Left~)
								IsHidden		T				// NOT SUPPORTED AT THIS TIME
								Tooltip			~Nudge the active point to the left~;

					Define: NudgeTextField Using DDWinCtrlDef AsSymbol NudgeTextField 
						Fields: TypeName		StaticText
								Position		NudgeLeftButton( GetRight,Position)+1 NudgeLeftButton( GetTop,Position )+3 NudgeUpButton(GetWidth,Position)  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( NudgeButton(3) )
								OActionsText	~[Save]~
								Text			Translate(~ Nudge ~)
								TextColorRed	150,	TextColorGreen 150,	TextColorBlue 150
								IsHidden		T				// NOT SUPPORTED AT THIS TIME
								Tooltip			~Nudge the active point~;

					Define: NudgeRightButton Using DDWinCtrlDef AsSymbol NudgeRightButton 
						Fields: TypeName		Button
								Position		NudgeTextField( GetRight,Position) NudgeLeftButton( GetTop,Position ) NudgeUpButton(GetWidth,Position)  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( NudgeButton(3) )
								OActionsText	~[Save]~
								Text			Translate(~Right~)
								IsHidden		T				// NOT SUPPORTED AT THIS TIME
								Tooltip			~Nudge the active point to the right~;
	
					Define: NudgeDownButton Using DDWinCtrlDef AsSymbol NudgeDownButton 
						Fields: TypeName		Button
								Position		NudgeUpButton( GetLeft,Position) NudgeLeftButton( GetBottom,Position ) NudgeUpButton(GetWidth,Position)  $ButtonHeight
								IActionsText	~[Get]~
								DActionsText	ACTION EXEC  ( NudgeButton(2) )
								OActionsText	~[Save]~
								Text			Translate(~Down~)
								IsHidden		T				// NOT SUPPORTED AT THIS TIME
								Tooltip			~Nudge the active point down~;

					Define: InputOutputField Using DDWinCtrlDef AsSymbol InputOutputField 
						Fields: TypeName		StaticText
								Position		LutControl( GetLeft,Position)+LutControl( GetWidth,Position)/2- 65/2 LutControl( GetBottom,Position) 65  15
								IActionsText	~[Get]~
								DActionsText	~[Save]~
								OActionsText	~[Save]~
								FontSize		12
								Tooltip			~Input/Output values of the mouse~;

					Define: DrawModeStatic Using DDWinCtrlDef AsSymbol DrawModeStatic 
						Fields: TypeName		StaticText 
								Text			~Draw Mode~
								RightJustified	T
								IsHidden		T				// NOT SUPPORTED AT THIS TIME
								POSITION		DensityRadio(GetLeft,Position)+15, InputOutputField(GetTop,Position)-5, 60, $ButtonHeight

					Define: DrawModeComboBox Using DDWinCtrlDef AsSymbol DrawModeComboBox 
						Fields: TypeName		SComboBox  
								POSITION		DrawModeStatic(GetRight,Position), DrawModeStatic(GetTop,Position)-2, 80, $ButtonHeight * 4
								IActionsText    ~[GetList(ToneScaleDrawModes) Get]~
								DActionsText	~[Save Exec("OnDrawModeComboBox()")]~
								OActionsText    ~[Save]~
								GenConName       THIS
								GenConField      ~LutDrawingMode~
								IsHidden		T				// NOT SUPPORTED AT THIS TIME
								Tooltip          ~Select drawing mode~ ;
				}

			    Define: Tab<++Tab> Using DDWinCtrlDef
					Fields: Position	2 2 <TabWidth> <TabHeight>
							Text			~Misc~
							TypeName		Tab
							Tooltip			~Miscellaneous settings~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					Define: InputDeviceNoneRadio Using DDWinCtrlDef AsSymbol InputDeviceNoneRadio 
						Fields: TypeName		RadioButton
								Position		25,$TabTop+20,120,$ButtonHeight
								IActionsText	~[Get]~
								DActionsText	~[ "Exec(UpdateInputDevice(0))" ]~
								OActionsText	~[Save]~
								GenConName		THIS
								GenConField		~ColorCorrectionInputDevice~
								RadioTrueValue	0
								Text			~None~
								Tooltip			~Select this radio if not using the wheelman or Color Pro II input device~;

					Define: InputDeviceColorProRadio Using DDWinCtrlDef AsSymbol InputDeviceColorProRadio 
						Fields: TypeName		RadioButton
								Position		InputDeviceNoneRadio(GetLeft,Position),InputDeviceNoneRadio(GetBottom,Position)+$vGap,InputDeviceNoneRadio(GetWidth,Position),$ButtonHeight
								IActionsText	~[Get]~
								DActionsText	~[ "Exec(UpdateInputDevice(1))" ]~
								OActionsText	~[Save]~
								GenConName		THIS
								GenConField		~ColorCorrectionInputDevice~
								RadioTrueValue	1
								Text			~Color Pro II~
								Tooltip			~Select this radio if using the Color Pro II input device~;

					Define: InputDeviceWheelmanRadio Using DDWinCtrlDef AsSymbol InputDeviceWheelmanRadio 
						Fields: TypeName		RadioButton
								Position		InputDeviceColorProRadio(GetLeft,Position),InputDeviceColorProRadio(GetBottom,Position)+$vGap,InputDeviceNoneRadio(GetWidth,Position),$ButtonHeight
								IActionsText	~[Get]~
								DActionsText	~[ "Exec(UpdateInputDevice(2))" ]~
								OActionsText	~[Save]~
								GenConName		THIS
								GenConField		~ColorCorrectionInputDevice~
								RadioTrueValue	2
								Text			~Wheelman~
								Tooltip			~Select this radio if using the Wheelman input device~;

					Define: PortStaticText Using DDWinCtrlDef AsSymbol PortStaticText 
						Fields: TypeName        StaticText
								Text            ~Serial Port~
								RightJustified	FALSE
								Position		InputDeviceWheelmanRadio(GetLeft,Position)+20,InputDeviceWheelmanRadio(GetBottom,Position)+$vGap*3,65,$ButtonHeight

					Define: PortListComboBox Using DDWinCtrlDef AsSymbol PortListComboBox 
						Fields: TypeName		SComboBox  
								POSITION		PortStaticText(GetRight,Position)+$hGap*2,PortStaticText(GetTop,Position)-2,60,$ButtonHeight * 4
								IActionsText    ~[GetList(PortList) Get]~
								DActionsText	~[Save Exec("OnPortChange()")]~
								OActionsText    ~[Save]~
								GenConName       THIS
								IsEnabled		T
								GenConField      ~SerialInputPort~
								Tooltip          ~Select the serial port that the Wheelman input device is connected to~ ;

					Define: DiagnosticsCheckBox Using DDWinCtrlDef AsSymbol DiagnosticsCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		PortStaticText(GetLeft,Position),PortStaticText(GetBottom,Position)+$vGap*3, 190, $ButtonHeight
								IActionsText    ~[Get]~
								DActionsText    ~[Save]~
								OActionsText    ~[Save]~
								IsEnabled		T
								GenConName       THIS
								GenConField      ~Diagnostics~
								Text			 ~Diagnostic~
								Tooltip          ~Show the data received from the Wheelman input device~ ;

					Define: InputDeviceGroupBox Using DDWinCtrlDef AsSymbol InputDeviceGroupBox
						Fields:	TypeName		GroupBox
								Text			~Input Device~
								Position		15, $TabTop+5, 280, 125;
								
					Define: UseNumlockCheckBox Using DDWinCtrlDef AsSymbol UseNumlockCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		InputDeviceGroupBox(GetLeft,Position), InputDeviceGroupBox(GetBottom,Position)+$vGap*3, 190, $ButtonHeight
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(SetUseNumlock())"]~
								OActionsText    ~[Save]~
								GenConName       THIS
								GenConField      ~UseNumlock~
								Text			 ~Numlock Is Density~
								Tooltip          ~Use the numlock key as a density key~ ;

					Define: IndependentAdjustmentsBox Using DDWinCtrlDef AsSymbol IndependentAdjustmentsBox 
						Fields: TypeName		CheckBox  
								POSITION		UseNumlockCheckBox(GetLeft,Position), UseNumlockCheckBox(GetBottom,Position)+$vGap, 190, $ButtonHeight
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(SetUseNumlock())"]~
								OActionsText    ~[Save]~
								GenConName       THIS
								GenConField      ~IndependentAdjustments~
								Text			 ~Independent Adjustments~
								Tooltip          ~If checked balance adjustments with the keyboard or Wheelman will cause density changes.  This does not apply to adjustments made with the slider.~ ;

					Define: SavedAdjustmentsButton Using DDWinCtrlDef AsSymbol SavedAdjustmentsButton 
						Fields: TypeName		Button  
								POSITION		IndependentAdjustmentsBox(GetLeft,Position), IndependentAdjustmentsBox(GetBottom,Position)+$vGap, 190, $ButtonHeight
								DActionsText    ACTION EXEC ( OnSavedAdjustments() )
								Text			~Saved Adjustments~
								Tooltip         ~View and edit saved adjustments~ ;

				}

			    Define: Tab<++Tab> Using DDWinCtrlDef
					Fields: Position	2 2 <TabWidth> <TabHeight>
							Text			~Auto Bal~
							TypeName		Tab
							Tooltip			~Auto Balance settings~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					Define: PreferenceStaticText Using DDWinCtrlDef AsSymbol PreferenceStaticText 
						Fields: TypeName        StaticText
								Text            ~Preferences~
								RightJustified	FALSE
								POSITION		$LeftX + $hGap*3,$TabTop+10, 120 $ButtonHeight

					Define: AutoBalComboBox Using DDWinCtrlDef AsSymbol AutoBalComboBox 
						Fields: TypeName		SComboBox  
								POSITION		PreferenceStaticText(GetRight,Position) + $hGap*3, PreferenceStaticText(GetTop,Position)-2, 200, $ButtonHeight * 4
								DropDownActionsText	ACTION EXEC ( UpdateAutoBalList( FALSE ) )
								IActionsText	ACTION EXEC ( UpdateAutoBalList( TRUE ) )
								DActionsText	~[Save]~
								OActionsText	~[Save]~
								GenConName       THIS
								IsEnabled		T
								GenConField      ~AutoBalanceSetup~
								Tooltip          ~Select the preferences file for Auto Balance~ ;

					Define: PrefsSetupButton Using DDWinCtrlDef AsSymbol PrefsSetupButton 
						Fields: TypeName			Button
								Text				Translate(~?~)
								Position			AutoBalComboBox(GetRight,Position) + $hGap*2,AutoBalComboBox(GetTop,Position), 20,<ButtonHeight>
								DActionsText		ACTION EXEC ( OnViewSbaPreferences() )
								Tooltip				Translate(~View the Auto Balance Preferences table.~ );

					Define: AutoBalCheckBox Using DDWinCtrlDef AsSymbol AutoBalCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		PreferenceStaticText(GetLeft,Position), PreferenceStaticText(GetBottom,Position)+$vGap*10, 190, $ButtonHeight
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(OnAutoAutoBal())"]~
								OActionsText    ~[Save]~
								IsEnabled		T
								GenConName       THIS
								GenConField      ~AutomaticAutoBal~
								Text			 ~Always run Auto Balance first~
								Tooltip          ~Automatically run Auto Balance when Next or Prev image is selected~ ;

					Define: TrackAutoBalCheckBox Using DDWinCtrlDef AsSymbol TrackAutoBalCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		AutoBalCheckBox(GetLeft,Position), AutoBalCheckBox(GetBottom,Position)+$vGap, 190, $ButtonHeight
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(OnTrackAutoBalData())"]~
								OActionsText    ~[Save]~
								IsEnabled		T
								GenConName       THIS
								GenConField      ~TrackAutoBalData~
								Text			 ~Track Auto Balance Data~
								Tooltip          ~Save the Auto Balance analysis data for each image in the DSBAImages table~ ;

				}
			}

			Define: RotateCCWButton Using DDWinCtrlDef AsSymbol RotateCCWButton
				Fields:	DACTIONSTEXT	ACTION EXEC ( IncrementRotateFromDisk(-90) )
						POSITION		$LeftX, $CurrentY+5, 40, $ButtonHeight
						TOOLTIP			~Rotate the image left by 90 degrees.  Shift key rotates right 90 degrees~
						TYPENAME		~Button~ 
						TEXT			~CC&W~

			Define: RotateCWButton Using DDWinCtrlDef AsSymbol RotateCWButton
				Fields:	DACTIONSTEXT	ACTION EXEC ( IncrementRotateFromDisk(90) )
						POSITION		RotateCCWButton(GetRight,Position) + $hGap RotateCCWButton(GetTop,Position),
										RotateCCWButton(GetWidth,Position), $ButtonHeight
						TOOLTIP			~Rotate the image right by 90 degrees~
						TYPENAME		~Button~ 
						TEXT			~CW~;


			Define: CropButton Using DDWinCtrlDef AsSymbol CropButton
				Fields:	DACTIONSTEXT	ACTION EXEC ( SetCrop() )
						POSITION		RotateCWButton(GetRight,Position) + $hGap RotateCWButton(GetTop,Position),
										35, $ButtonHeight
						TOOLTIP			~Use a predefined crop~
						TYPENAME		~Button~ 
						TEXT			~&Crop~;

			Global( CropButton );

			Define: RefButton Using DDWinCtrlDef AsSymbol RefButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( OpenLabReference()  )
						POSITION		CropButton(GetRight,Position) + $hGap, CropButton(GetTop,Position), CropButton(GetWidth,Position), $ButtonHeight
						TEXT			~Re&f~
						TOOLTIP			~Display the Lab reference image~
						TYPENAME		BUTTON;

			xpos = cRedSlider(GetLeft,Position) + cRedSlider(GetWidth,Position) / 2 - 20 / 2;

			Define: CancelButton Using DDWinCtrlDef AsSymbol CancelButton
				Fields:	GENCONNAME		This
						DACTIONSTEXT	ACTION EXEC ( CancelImageEdits(TRUE,FALSE) )
						POSITION		<xpos>, $CurrentY+5, 20, $ButtonHeight
						TEXT			~&Z~
						TOOLTIP			~Cancel the changes you have been making without affecting the database~
						TYPENAME		BUTTON;

			Define: WorkButton Using DDWinCtrlDef AsSymbol WorkButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( SelectOrders()  )
						POSITION		CancelButton(GetLeft,Position) - 40 - $hGap ,RefButton(GetTop,Position), 40, $ButtonHeight
						TEXT			~Wor&k~
						TOOLTIP			~Find the top 10 highest priority orders that need image adjustment~
						TYPENAME		BUTTON;

			Global( WorkButton );


	CurrentY = WorkButton(GetBottom,Position) + $vGap*3;

			Define: AutoBalDRGBButton Using DDWinCtrlDef AsSymbol AutoBalDRGBButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( SetAutoBalMode(0,0,0,TRUE); AutoBalance(TRUE,FALSE)  )
						POSITION		$LeftX, $CurrentY, 40, $ButtonHeight
						TEXT			~DRGB~
						TOOLTIP			~Auto Balance the image for color and density.~
						TYPENAME		BUTTON;

			Define: AutoBalDenButton Using DDWinCtrlDef AsSymbol AutoBalDenButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( SetAutoBalMode(16,0,0,TRUE); AutoBalance(TRUE,FALSE)  )
						POSITION		AutoBalDRGBButton(GetRight,Position) + $hGap, $CurrentY, 39, $ButtonHeight
						TEXT			~Den~
						TOOLTIP			~Auto Balance the image for density only.~
						TYPENAME		BUTTON;


			Define: AutoBalRGBButton Using DDWinCtrlDef AsSymbol AutoBalRGBButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( SetAutoBalMode(1,0,0,TRUE); AutoBalance(TRUE,FALSE)  )
						POSITION		AutoBalDenButton(GetRight,Position) + $hGap, $CurrentY, 40, $ButtonHeight
						TEXT			~RGB~
						TOOLTIP			~Auto Balance the image for color only.~
						TYPENAME		BUTTON;

			Define: ApplyShastaButton Using DDWinCtrlDef AsSymbol ApplyShastaButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	~[Save "Exec(SetApplyShasta( 1, 1 ))"]~
						POSITION		AutoBalRGBButton(GetRight,Position) + $hGap*5, $CurrentY, 40, $ButtonHeight
						TEXT			~AE~
						TOOLTIP			~Apply Automatic Image Enhancement.~
						TYPENAME		BUTTON;

			Define: NoApplyShastaButton Using DDWinCtrlDef AsSymbol NoApplyShastaButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	~[Save "Exec(SetApplyShasta( 0, 1 ))"]~
						POSITION		ApplyShastaButton(GetRight,Position) + $hGap, $CurrentY, 40, $ButtonHeight
						TEXT			~No AE~
						TOOLTIP			~Cancel Automatic Image Enhancement.~
						TYPENAME		BUTTON;

			Define: ReconverRawButton Using DDWinCtrlDef AsSymbol ReconverRawButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( ReconvertRaw(); )
						POSITION		NoApplyShastaButton(GetRight,Position) + $hGap, $CurrentY, 60, $ButtonHeight
						TEXT			~Reconvert~
						TOOLTIP			~Reconvert raw images.~
						TYPENAME		BUTTON;


			ButtonW = 50;

			Define: PrevButton Using DDWinCtrlDef AsSymbol PrevButton
				Fields:	DACTIONSTEXT	ACTION EXEC ( OnPrevButton() )
						POSITION		CancelButton(GetRight,Position)+$hGap*2, RotateCCWButton(GetTop,Position), RotateCCWButton(GetWidth,Position), $ButtonHeight
						TOOLTIP			~See the previous image~
						TYPENAME		~Button~ 
						TEXT			~&Prev~

			Define: NextButton Using DDWinCtrlDef AsSymbol NextButton
				Fields:	DACTIONSTEXT	ACTION EXEC ( OnNextButton() )
						POSITION		(PrevButton(GetRight,Position) + $hGap), RotateCCWButton(GetTop,Position), PrevButton(GetWidth,Position), $ButtonHeight
						TOOLTIP			~See the next image.  The Enter key on the numeric keypad is a convenient shortcut for Next~
						TYPENAME		~DefaultButton~ 
						TEXT			~&Next~

			Define: RememberButton Using DDWinCtrlDef AsSymbol RememberButton
				Fields:	GENCONNAME		This
						DACTIONSTEXT	ACTION EXEC ( OnRememberColorBalance() )
						POSITION		(NextButton(GetRight,Position) + $hGap), RotateCCWButton(GetTop,Position), 50, $ButtonHeight
						TEXT			~Sa&ve Bal~
						TOOLTIP			~Remember these settings so that you may 'Recall' them later~
						TYPENAME		BUTTON;
	
			Define: DontResetOnSaveCheckBox Using DDWinCtrlDef AsSymbol DontResetOnSaveCheckBox 
				Fields: TypeName		CheckBox  
						POSITION		300, RotateCCWButton(GetBottom,Position)+$vGap*3, 40, $ButtonHeight
						IActionsText    ~[Get]~
						DActionsText    ~[Save "Exec(OnHold())"]~
						OActionsText    ~[Save]~
						GenConName       THIS
						GenConField      ~DontResetOnSave~
						Text			 ~Hold~
						Tooltip          ~If checked, the balance controls are not reset to zero when corrections are saved~ ;
	
	CurrentY = AutoBalDRGBButton(GetBottom,Position) + $vGap*3;
			
			Define: RecallButton Using DDWinCtrlDef AsSymbol RecallButton
				Fields:	GENCONNAME		This
						DACTIONSTEXT	ACTION EXEC ( DisplayRecallMenu(~~) )
						POSITION		$LeftX, $CurrentY, 40, $ButtonHeight
						TEXT			~R&ecall~
						TOOLTIP			~Recall saved color settings~
						TYPENAME		BUTTON;

			Global( RecallButton );

			Define: ApplyButton Using DDWinCtrlDef AsSymbol ApplyButton
				Fields:	GENCONNAME		This
						DACTIONSTEXT	ACTION EXEC ( ApplyUpdates() )
						POSITION		(RecallButton(GetRight,Position) + $hGap), $CurrentY, $ButtonW-15, $ButtonHeight
						TEXT			~Apply~
						TOOLTIP			~Apply current settings to newly selected images~
						TYPENAME		BUTTON

			Define: GoButton Using DDWinCtrlDef AsSymbol GoButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( AcceptImageEdits(-1,0,FALSE) )
						POSITION		(ApplyButton(GetRight,Position) + $hGap) ,$CurrentY, $ButtonW-15, $ButtonHeight
						TEXT			~&Save~
						TOOLTIP			~Save these changes in the database and optionally reset the deltas to their nominal values~
						TYPENAME		BUTTON;

			Define:  ResetButton Using DDWinCtrlDef AsSymbol ResetButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( ResetImageEdits() )
						POSITION		(GoButton(GetRight,Position) + $hGap) ,$CurrentY, $ButtonW-15, $ButtonHeight
						TEXT			~Reset~
						TOOLTIP			~Forget all image edits including previous edit stored in the database.  Crops will not be reset.~
						TYPENAME		BUTTON;

			Define: KeysButton Using DDWinCtrlDef AsSymbol KeysButton
				Fields:	GENCONNAME		THIS
						DACTIONSTEXT	ACTION EXEC ( AllOptions()  )
						POSITION		ResetButton(GetRight,Position) + $hGap ,ResetButton(GetTop,Position),
										28, $ButtonHeight
						TEXT			~Ke&ys~
						TOOLTIP			~See all the keyboard shortcuts at once.  On Windows 2000 systems, press and release Alt to see the keyboard shortcuts~
						TYPENAME		BUTTON;

			Define: RunButton Using DDWinCtrlDef AsSymbol RunButton
				Fields:	DACTIONSTEXT	ACTION EXEC ( OnRunButton() )
						TYPENAME		~Button~ 
						TOOLTIP			~Print all the order items for this order~
						POSITION		KeysButton(GetRight,Position) + $hGap ,ResetButton(GetTop,Position),
										$ButtonW -20, $ButtonHeight
						TEXT			~Pr&int~;

			Define: TopCheckBox Using DDWinCtrlDef AsSymbol TopCheckBox 
				Fields: TypeName		CheckBox  
						POSITION		300,  RunButton(GetTop,Position), 38, $ButtonHeight
						IActionsText    ~[Get]~
						DActionsText    ~[Save]~
						OActionsText    ~[Save]~
						GenConName       THIS
						GenConField      ~KeepKeyboardFocus~
						Text			 ~Top~
						Tooltip          ~Do not let other windows take the keyboard focus~ ;

			Define: SeeOtherBox Using DDWinCtrlDef AsSymbol SeeOtherBox
				Fields:	GENCONNAME		This
						DACTIONSTEXT	ACTION EXEC ( OnSeeOtherBox() )
						POSITION		390, TopCheckBox(GetTop,Position),18,20
						TEXT			~->~
						TOOLTIP			~See independent channels simulaneously~
						TYPENAME		Button;

			Global( WorkButton,KeysButton );

			Define: TabWindowB Using DDWinCtrlDef AsSymbol TabWindowB
                Fields: Position	TabWindow(GetRight,Position)+5, 2, <TabWidth>+162, <TabHeight>+55
                        TypeName	TabCtrl
						TabChangeActionsText ACTION EXEC ( OnTabChange() )
                        Text		~TCS_HOTTRACK | TCS_MULTILINE | TCS_TOOLTIPS | TCS_FOCUSNEVER~

			Contains: InListOrder
			{
			    Define: TabB<++Tab> Using DDWinCtrlDef
					Fields: Text			~Click Balance~
							TypeName		Tab
							Tooltip			~Click balance~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					Define: NeutralizeCheckBox Using DDWinCtrlDef AsSymbol NeutralizeCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		SeeOtherBox(GetRight,Position)+20,30,40,40
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(OnNeutralizeCheckBox())"]~
								OActionsText    ~[Save]~
								GenConName      THIS
								GenConField     ~Neutralize~
								Text			~Neutralize~
								Tooltip         ~Click balance neutral~
								Icon			~CLICKBALANCENEUTRAL~
								IsPushButton	TRUE;

					Define: ClickWhiteCheckBox Using DDWinCtrlDef AsSymbol ClickWhiteCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		NeutralizeCheckBox(GetRight,Position)+5,30,40,40
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(OnClickWhiteCheckBox())"]~
								OActionsText    ~[Save]~
								GenConName       THIS
								GenConField      ~ClickWhite~
								Text			 ~Click White~
								Tooltip          ~Click balance white~
								Icon			~CLICKBALANCEWHITE~
								IsPushButton	TRUE;

					Define: ClickBlackCheckBox Using DDWinCtrlDef AsSymbol ClickBlackCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		ClickWhiteCheckBox(GetRight,Position)+5,30,40,40
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(OnClickBlackCheckBox())"]~
								OActionsText    ~[Save]~
								GenConName       THIS
								GenConField      ~ClickBlack~
								Text			 ~Click Black~
								Tooltip          ~Click balance black~
								Icon			~CLICKBALANCEBLACK~
								IsPushButton	TRUE;

					Define: BalanceToAimCheckBox Using DDWinCtrlDef AsSymbol BalanceToAimCheckBox 
						Fields: TypeName		CheckBox  
								POSITION		ClickBlackCheckBox(GetRight,Position)+5,30,40,40
								IActionsText    ~[Get]~
								DActionsText    ~[Save "Exec(OnBalanceToAimCheckBox())"]~
								OActionsText    ~[Save]~
								GenConName      THIS
								GenConField     ~BalanceToAim~
								Text			~Balance To aim~
								Tooltip         ~Click balance to aim~
								Icon			~CLICKBALANCETOAIM~
								IsPushButton	TRUE;
	
					Define: AimComboBox Using DDWinCtrlDef AsSymbol AimComboBox 
						Fields: TypeName		SComboBox  
								POSITION		NeutralizeCheckBox(GetLeft,Position)+20,NeutralizeCheckBox(GetBottom,Position)+10,200,200
								DropDownActionsText	ACTION EXEC ( UpdateAimList( FALSE ) )
								IActionsText	ACTION EXEC ( UpdateAimList( TRUE ) )
								DActionsText	~[Save "Exec(OnAimSelChange())"]~
								OActionsText	~[Save]~
								GenConName      THIS
								GenConField     ~AimSetup~
								IsEnabled		F
								Tooltip         ~Select the desired aim~ ;

					Define: AimSetupButton Using DDWinCtrlDef AsSymbol AimSetupButton 
						Fields: TypeName		Button
								Text			Translate(~?~)
								Position		AimComboBox(GetRight,Position)+$hGap*2,AimComboBox(GetTop,Position),20,<ButtonHeight>
								DActionsText	ACTION EXEC ( OnViewAims() )
								IsEnabled		F
								Tooltip			Translate(~View the Aims table.~ );

					Define: AimRedLabel Using DDWinCtrlDef AsSymbol AimRedLabel 
						Fields: TypeName        StaticText
								Text            ~R~
								RightJustified	FALSE
								IsEnabled		F
								POSITION		AimComboBox(GetLeft,Position),AimComboBox(GetTop,Position)+35,8,<EditTextHeight> 

					Define: AimRedField Using DDWinCtrlDef AsSymbol AimRedField 
						Fields: TypeName		MaskedEditText  
								Position		AimRedLabel(GetRight,Position)+5,AimComboBox(GetTop,Position)+33,<EditTextWidth>,<EditTextHeight> 
								IActionsText	ACTIONS ( Get )
								DActionsText	~[Save "Exec(OnAimValueChange())"]~
								OActionsText	ACTIONS ( Save )
								GenConName       THIS
								GenConField		~AimRedField~
								IsEnabled		F
								Mask			~###~
								Tooltip         ~Red value to balance aim to~;

					Define: AimGreenLabel Using DDWinCtrlDef AsSymbol AimGreenLabel 
						Fields: TypeName        StaticText
								Text            ~G~
								RightJustified	FALSE
								IsEnabled		F
								POSITION		AimRedField(GetRight,Position)+6,AimComboBox(GetTop,Position)+35,8,<EditTextHeight> 

					Define: AimGreenField Using DDWinCtrlDef AsSymbol AimGreenField 
						Fields: TypeName		MaskedEditText  
								Position		AimGreenLabel(GetRight,Position)+5,AimComboBox(GetTop,Position)+33,<EditTextWidth>,<EditTextHeight> 
								IActionsText	ACTIONS ( Get )
								DActionsText	~[Save "Exec(OnAimValueChange())"]~
								OActionsText	ACTIONS ( Save )
								GenConName       THIS
								GenConField		~AimGreenField~
								IsEnabled		F
								Mask			~###~
								Tooltip         ~Green value to balance aim to~;

					Define: AimBlueLabel Using DDWinCtrlDef AsSymbol AimBlueLabel 
						Fields: TypeName        StaticText
								Text            ~B~
								RightJustified	FALSE
								IsEnabled		F
								POSITION		AimGreenField(GetRight,Position)+6,AimComboBox(GetTop,Position)+35,8,<EditTextHeight> 

					Define: AimBlueField Using DDWinCtrlDef AsSymbol AimBlueField 
						Fields: TypeName		MaskedEditText  
								Position		AimBlueLabel(GetRight,Position)+5,AimComboBox(GetTop,Position)+33,<EditTextWidth>,<EditTextHeight> 
								IActionsText	ACTIONS ( Get )
								DActionsText	~[Save "Exec(OnAimValueChange())"]~
								OActionsText	ACTIONS ( Save )
								GenConName       THIS
								GenConField		~AimBlueField~
								IsEnabled		F
								Mask			~###~
								Tooltip         ~Blue value to balance aim to~;

					Define: AimColorPatch Using DDWinCtrlDef AsSymbol AimColorPatch 
						Fields:	TypeName		StaticText
								Position		AimBlueField(GetRight,Position)+5,AimBlueField(GetTop,Position),25,25
								BGColorRed		0
								BGColorGreen	0
								BGColorBlue		0;

					Define: SampledValuesLabel Using DDWinCtrlDef AsSymbol SampledValuesLabel 
						Fields: TypeName        StaticText
								Text            ~Sampled Values~
								RightJustified	FALSE
								POSITION		NeutralizeCheckBox(GetLeft,Position),AimRedLabel(GetBottom,Position)+22,90,<EditTextHeight> 

					Define: SampledValueRedLabel Using DDWinCtrlDef AsSymbol SampledValueRedLabel 
						Fields: TypeName        StaticText
								Text            ~R~
								RightJustified	FALSE
								POSITION		SampledValuesLabel(GetRight,Position)+5,AimRedLabel(GetBottom,Position)+22,8,<EditTextHeight> 

					Define: SampledValueRedField Using DDWinCtrlDef AsSymbol SampledValueRedField 
						Fields: TypeName		MaskedEditText  
								Position		SampledValueRedLabel(GetRight,Position)+5,AimRedLabel(GetBottom,Position)+20,<EditTextWidth>,<EditTextHeight> 
								IActionsText	ACTIONS ( Get )
								DActionsText	~[Save "Exec(OnSampleValueChange())"]~
								OActionsText	ACTIONS ( Save )
								GenConName       THIS
								GenConField		~SampledValueRedField~
								Mask			~###~
								Tooltip         ~Sampled red value~;

					Define: SampledValueGreenLabel Using DDWinCtrlDef AsSymbol SampledValueGreenLabel 
						Fields: TypeName        StaticText
								Text            ~G~
								RightJustified	FALSE
								POSITION		SampledValueRedField(GetRight,Position)+6,AimRedLabel(GetBottom,Position)+22,8,<EditTextHeight> 

					Define: SampledValueGreenField Using DDWinCtrlDef AsSymbol SampledValueGreenField 
						Fields: TypeName		MaskedEditText  
								Position		SampledValueGreenLabel(GetRight,Position)+5,AimRedLabel(GetBottom,Position)+20,<EditTextWidth>,<EditTextHeight> 
								IActionsText	ACTIONS ( Get )
								DActionsText	~[Save "Exec(OnSampleValueChange())"]~
								OActionsText	ACTIONS ( Save )
								GenConName       THIS
								GenConField		~SampledValueGreenField~
								Mask			~###~
								Tooltip         ~Sampled green value~;

					Define: SampledValueBlueLabel Using DDWinCtrlDef AsSymbol SampledValueBlueLabel 
						Fields: TypeName        StaticText
								Text            ~B~
								RightJustified	FALSE
								POSITION		SampledValueGreenField(GetRight,Position)+6,AimRedLabel(GetBottom,Position)+22,8,<EditTextHeight> 

					Define: SampledValueBlueField Using DDWinCtrlDef AsSymbol SampledValueBlueField 
						Fields: TypeName		MaskedEditText  
								Position		SampledValueBlueLabel(GetRight,Position)+5,AimRedLabel(GetBottom,Position)+20,<EditTextWidth>,<EditTextHeight> 
								IActionsText	ACTIONS ( Get )
								DActionsText	~[Save "Exec(OnSampleValueChange())"]~
								OActionsText	ACTIONS ( Save )
								GenConName       THIS
								GenConField		~SampledValueBlueField~
								Mask			~###~
								Tooltip         ~Sampled blue value~;

					Define: SampledValueColorPatch Using DDWinCtrlDef AsSymbol SampledValueColorPatch 
						Fields:	TypeName		StaticText
								Position		SampledValueBlueField(GetRight,Position)+5,SampledValueBlueField(GetTop,Position),25,25
								BGColorRed		0
								BGColorGreen	0
								BGColorBlue		0;
				}

				Define: TabB<++Tab> Using DDWinCtrlDef
					Fields: Text			~Curve/Gamma Channels~
							TypeName		Tab
							Tooltip			~Normal tab for curve and gamma channels~
							HActionsText	ACTION SHOWHELPPAGE ( KPISHelpFile "Adjust_Images.htm" )

				Contains: INLISTORDER
				{
					Define: LutControlRed Using DDWinCtrlDef AsSymbol LutControlRed 
						Fields: TypeName				ToneScale
								GENCONFIELD				~cLut~
								GENCONNAME				THIS
								TSNumGridLines			180/20
								TSShowAllCurves			F
								TSShowGrid				T
								TSData					~CurvesData~
								TSShowTonalSliders		F
								TSActiveChannel			1
								ActivePtActionsText		ACTION EXEC ( ActivePoint(%ld,%ld) )
								IActionsText			ACTIONS ( "Exec(InitTSRed())" )
								DActionsText			ACTIONS ( "Exec(LUTChange())" DialogTimer(0 250) Update(LutControl) Update(LutControlGreen) Update(LutControlBlue) )
								POSITION				SeeOtherBox(GetRight,Position)+10,26, 186 184;

					Define: LutControlGreen Using DDWinCtrlDef AsSymbol LutControlGreen 
						Fields: TypeName				ToneScale 
								GENCONFIELD				~cLut~
								GENCONNAME				THIS
								TSNumGridLines			180/20
								TSShowAllCurves			F
								TSShowGrid				T
								TSData					~CurvesData~
								TSShowTonalSliders		F
								TSActiveChannel			2
								ActivePtActionsText		ACTION EXEC ( ActivePoint(%ld,%ld) )
								IActionsText			ACTIONS ( "Exec(InitTSGreen())" )
								DActionsText			ACTIONS ( "Exec(LUTChange())" DialogTimer(0 250) Update(LutControl) Update(LutControlRed) Update(LutControlBlue) )
								POSITION				LutControlRed(GetRight,Position)+3,LutControlRed(GetTop,Position), LutControlRed(GetWidth,Position) LutControlRed(GetLength,Position);

					Define: LutControlBlue Using DDWinCtrlDef AsSymbol LutControlBlue 
						Fields: TypeName				ToneScale 
								GENCONFIELD				~cLut~
								GENCONNAME				THIS
								TSNumGridLines			180/20
								TSShowAllCurves			F
								TSShowGrid				T
								TSData					~CurvesData~
								TSShowTonalSliders		F
								TSActiveChannel			3
								ActivePtActionsText		ACTION EXEC ( ActivePoint(%ld,%ld) )
								IActionsText			ACTIONS ( "Exec(InitTSBlue())" )
								DActionsText			ACTIONS ( "Exec(LUTChange())" DialogTimer(0 250) Update(LutControl) Update(LutControlRed) Update(LutControlGreen) )
								POSITION				LutControlGreen(GetRight,Position)+3,LutControlGreen(GetTop,Position), LutControlGreen(GetWidth,Position) LutControlGreen(GetLength,Position);


					LeftX = LutControlRed(GetLeft,Position);  CurrentY = LutControlRed(GetBottom,Position)+5;
					SliderWidth = 390 ;
					DefineImageEditLine( cGammaRed,cGammaRed,	.01,~R Gamma~,	~Decrease (Shift-Alt-R) or increase (Alt-R) the Red Gamma of the image~, 1,~&R~,~&r~,190,170,170 );
					DefineImageEditLine( cGammaGreen,cGammaGreen,.01,~G Gamma~,	~Decrease (Shift-Alt-G) or increase (Alt-G) the Green Gamma of the image~, 1,~&G~,~&g~,170,190,170 );
					DefineImageEditLine( cGammaBlue,cGammaBlue,	.01,~B Gamma~,	~Decrease (Shift-Alt-B) or increase (Alt-B) the Blue Gamma of the image~, 1,~&B~,~&b~,170,170,190 );
				}
			}

			CurrentY = ResetButton(GetBottom,Position) + $vGap;

			Define: ShiftCropLeftButton Using DDWinCtrlDef AsSymbol ShiftCropLeftButton 
					Fields: TypeName		Button
							Text			Translate( ~&[~ )
							TOOLTIP			~Shift the crop left.~
							DActionsText	ACTION EXEC ( OpenImageToCrop(ShiftCropLeft) ) ;

			Define: ShiftCropRightButton Using DDWinCtrlDef AsSymbol ShiftCropRightButton 
					Fields: TypeName		Button
							Text			Translate( ~&]~ )
							TOOLTIP			~Shift the crop right.~
							DActionsText	ACTION EXEC ( OpenImageToCrop(ShiftCropRight) ) ;

			Define: ShiftCropUpButton Using DDWinCtrlDef AsSymbol ShiftCropUpButton 
					Fields: TypeName		Button
							Text			Translate( ~&{~ )
							TOOLTIP			~Shift the crop up.~
							DActionsText	ACTION EXEC ( OpenImageToCrop(ShiftCropUp) ) ;

			Define: ShiftCropDownButton Using DDWinCtrlDef AsSymbol ShiftCropDownButton 
					Fields: TypeName		Button
							Text			Translate( ~&}~ )
							TOOLTIP			~Shift the crop down.~
							DActionsText	ACTION EXEC ( OpenImageToCrop(ShiftCropDown) ) ;

			Define: ShrinkCropButton Using DDWinCtrlDef AsSymbol ShrinkCropButton 
					Fields: TypeName		Button
							Text			Translate( ~&\~ )
							TOOLTIP			~Shrink the crop.~
							DActionsText	ACTION EXEC ( OpenImageToCrop(ShrinkCrop) ) ;

			Define: ExpandCropButton Using DDWinCtrlDef AsSymbol ExpandCropButton 
					Fields: TypeName		Button
							Text			Translate( ~&|~ )
							TOOLTIP			~Expand the crop.~
							DActionsText	ACTION EXEC ( OpenImageToCrop(ExpandCrop) ) ;

			Define: UseLastCropButton Using DDWinCtrlDef AsSymbol UseLastCropButton 
					Fields: TypeName		Button
							Text			Translate( ~&'~ )
							TOOLTIP			~Use the last crop.~
							DActionsText	ACTION EXEC ( OpenImageToCrop(OnUseLastCrop) ) ;

			Define: SwitchModesButton Using DDWinCtrlDef AsSymbol SwitchModesButton 
					Fields: TypeName		Button
							Text			Translate( ~&;~ )
							TOOLTIP			~Switch between color balancing and cropping~
							DActionsText	ACTION EXEC ( OnSwitchModesButton() ) ;


			Define: ViewChangesButton Using DDWinCtrlDef AsSymbol ViewChangesButton 
					Fields: TypeName		Button
							Text			Translate( ~&Q~ )
							TOOLTIP			~Temporarily see the image without color changes~
							DActionsText	ACTION EXEC ( ViewChanges() ) ;

			Define: AutoBalShortcutButton Using DDWinCtrlDef AsSymbol AutoBalShortcutButton 
					Fields: TypeName		Button
							Text			Translate( ~&x~ )
							TOOLTIP			~Auto Balance the image for DRGB (x), Density only (Shift-X) or Color Only (Alt-X).~
							DActionsText	ACTION EXEC ( SetAutoBalMode(0,KeyState( SHIFT ) ? 1 : 0, KeyState( ALT ) ? 1 : 0, FALSE); AutoBalance(TRUE,TRUE) ) ;


			which = 0;
			while ( <which> < 10 )
			{
				Define: Num<Which>Button Using DDWinCtrlDef AsSymbol Num<Which>Button 
						Fields: TypeName		Button
								Text			Translate( ~&<Which>~ )
								DActionsText	ACTION EXEC ( OnNumber(<Which>) ) ;

				++which;
			}

//	START CREATE BUTTONS TO TRAP THE DRGB KEYS
			Define: HDensityButton Using DDWinCtrlDef AsSymbol HDensityButton 
					Fields: TypeName		Button
							Text			Translate( ~&D~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cDensity~, Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;
							
			Define: HRedButton Using DDWinCtrlDef AsSymbol HRedButton 
					Fields: TypeName		Button
							Text			Translate( ~&R~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cRed~,  Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;
							
			Define: HGreenButton Using DDWinCtrlDef AsSymbol HGreenButton 
					Fields: TypeName		Button
							Text			Translate( ~&G~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cGreen~,  Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;

			Define: HBlueButton Using DDWinCtrlDef AsSymbol HBlueButton 
					Fields: TypeName		Button
							Text			Translate( ~&B~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cBlue~,  Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;

			Define: HContrastButton Using DDWinCtrlDef AsSymbol HContrastButton 
					Fields: TypeName		Button
							Text			Translate( ~&T~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cContrast~,  Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;

			Define: HGammaButton Using DDWinCtrlDef AsSymbol HGammaButton 
					Fields: TypeName		Button
							Text			Translate( ~&M~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cGamma~,  Numeric(KeyState(Shift) ? -0.05 : 0.05 ) ) ) ;

			Define: HSaturationButton Using DDWinCtrlDef AsSymbol HSaturationButton 
					Fields: TypeName		Button
							Text			Translate( ~&U~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cSaturation~,  Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;
							
			Define: HSharpenButton Using DDWinCtrlDef AsSymbol HSharpenButton 
					Fields: TypeName		Button
							Text			Translate( ~&H~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cSharpen~,  Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;
							
			Define: HAngleButton Using DDWinCtrlDef AsSymbol HAngleButton 
					Fields: TypeName		Button
							Text			Translate( ~&A~ )
							DActionsText	ACTION EXEC ( AdjustValue( ~cArbitraryRotation~,  Numeric(KeyState(Shift) ? -1 : 1 ) ) ) ;
							
//	END CREATE BUTTONS TO TRAP THE DRGB KEYS

		// just way to get DialogTimer executed from the script
			Define: DummyButton Using DDWinCtrlDef AsSymbol DummyButton 
					Fields: TypeName		Button
							Text			~a~
							DActionsText	~[DialogTimer(0 250)]~

			Define: NumPeriodButton Using DDWinCtrlDef AsSymbol NumPeriodButton 
				Fields: TypeName		Button
						Text			Translate( ~&.~ )
						ToolTip			~On the numeric keypad.  Delete the last entered number~
						DActionsText	ACTION EXEC ( OnNumber(~.~) ) ;

			Define: MinusButton Using DDWinCtrlDef AsSymbol MinusButton 
				Fields: TypeName		Button
						Text			Translate( ~&-~ )
						ToolTip			~On the numeric keypad.  Delete the last entered number~
						DActionsText	ACTION EXEC ( OnMinus() ) ;

			Define: ForwardSlashButton Using DDWinCtrlDef AsSymbol ForwardSlashButton 
				Fields: TypeName		Button
						Text			Translate( ~&/~ )
						ToolTip			~on the Numeric keypad. Make the image more Red or Cyan (Shift-/)~
						DActionsText	ACTION EXEC ( AdjustValue(cRed,KeyState(Shift) ? -1 : 1) ) ;

			Define: AsterickButton Using DDWinCtrlDef AsSymbol AsterickButton 
				Fields: TypeName		Button
						Text			Translate( ~&*~ )
						ToolTip			~on the Numeric keypad. Make the image more Green or Magenta (Shift-*)~
						DActionsText	ACTION EXEC ( AdjustValue(cGreen,KeyState(Shift) ? -1 : 1) ) ;

			Define: PlusButton Using DDWinCtrlDef AsSymbol PlusButton 
				Fields: TypeName		Button
						Text			Translate( ~&+~ )
						ToolTip			~on the Numeric keypad. Make the image more Blue or Yellow (Shift-+)~
						DActionsText	ACTION EXEC ( OnPlus() ) ;

			Define: CloseAllButton Using DDWinCtrlDef AsSymbol CloseAllButton 
				Fields: TypeName		Button
						Text			Translate( ~&l~ )
						TOOLTIP			~Close all image windows~
						DActionsText	ACTION EXEC ( CloseAllOpenImages() ) ;


		
		}

	DialogHeight = <CurrentY> + 35;

	x = 0;
	y = App( thisApp,MainWindow,GetClientHeight ) - 80 - <currentY>; 	

	if ( !GetUserSettings( ~<$Job.Title>~,WindowPosition,WindowPosition,Enabled ) )
	{
		WindowPosition = ~<x> <y>~;
	}

	GetTokens( ~<WindowPosition>~,~ ~,x,y );

	//PinOnScreen( 0,x,y,<DialogWidth>,<CurrentY> );

	WindowPosition = ~<x> <y>~;

	DialogWidth = ImageEditDialog(GetMaxRight,Position) + $hGap * 7;

	DialogWidth = <TabWidth> + $hGap * 10;

	ImageEditDialog( Set,Position,~<WindowPosition>  <DialogWidth>  <DialogHeight>~ );
	
	Global( ImageEditDialog,DialogWidth,DialogHeight );

	WaitCursor( End );
}




NUMERIC UpdateUserCounts( Which,Amount )
{
	return TRUE;

	PreviousValue = 0;

	GetWorkStationSettings( ~AdjustImages~,~<Which>~,PreviousValue,Enabled );

	NewAmount = <PreviousValue> + <Amount>;

	return SetWorkStationSettings( ~AdjustImages~,~<Which>~,<NewAmount>,TRUE );
}


VOID AddOption( &ListMenu,&Count,Key,theText,theButton,enableMenuItem )
{
	ID = IsNull( ~<TheText>~ ) ? NULL : ID;

	Key = Upper( ~<Key>~ );

	GenCon( All<++Count>,New,DDMenuItemDef,SetValues,Text,~<key>  <theText>~,IDText,~<ID>~,IsEnabled,<enableMenuItem> );
	
	if ( <enableMenuItem> )
	{
		All<Count>( SetValues,IsEnabled,~T~ );
	}
	else
	{
		All<Count>( SetValues,IsEnabled,~F~ );
	}

	if ( !IsNull( theButton ) )
	{
		theAction  = ACTION EXEC ( ControlAction(~<theButton>~) );

		All<Count>( SetValuesFrom,ActionsText,theAction );
	}

	ListMenu( InsertBack,All<Count> );
}


VOID AllOptions()
{
	Count = 0;

	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	more = ImageEditDialog( GetFirst,Item );

	while ( <more> )
	{
		Item(GetName,ControlName);

		ControlKey = String( StringInString,~&~,~<$con.ImageEditDialog:<ControlName>[Text]>~ );

		if ( !IsNull(~<ControlKey>~) )
		{
			substr( ~<ControlKey>~,1,1,ControlKey );
			
			enableMenuItem = TRUE;
			if ( SimilarStr( ~<ControlKey>~, ~W~ ) || SimilarStr( ~<ControlKey>~, ~V~ ) ||
				 SimilarStr( ~<ControlKey>~, ~E~ ) || SimilarStr( ~<ControlKey>~, ~X~ ) )
			{
				if ( <gCurrentTab> == 1 )
				{
					enableMenuItem = FALSE;
				}
			}

			AddOption( ListMenu,Count,~ <ControlKey> - ~,~<$con.ImageEditDialog:<ControlName>[ToolTip]>~,~<ControlName>~,<enableMenuItem> );
		}
	
		more = ImageEditDialog( GetNext,Item );
	}

	EditDialog( DisplayMenu,ListMenu,KeysButton(GetLeft,Position),KeysButton(GetTop,Position) );
}

CurrentNumber = ~~;

NUMERIC OnNumber( Num )
{
	EditDialog( SetStatus,1,~~ );

	if ( CurrentlyCropping() )
	{
		OnStr(~<Num>~,~4~,~ControlAction(ShiftCropLeftButton)~,~6~,~ControlAction(ShiftCropRightButton)~,
				 ~8~,~ControlAction(ShiftCropUpButton)~,~2~,~ControlAction(ShiftCropDownButton)~,
				 ~7~,~ControlActions(ShiftCropLeftButton,ShiftCropUpButton)~,
				 ~9~,~ControlActions(ShiftCropRightButton,ShiftCropUpButton)~,
				 ~1~,~ControlActions(ShiftCropLeftButton,ShiftCropDownButton)~,
				 ~3~,~ControlActions(ShiftCropRightButton,ShiftCropDownButton)~,
				 ~0~,~ControlAction(ShrinkCropButton)~,~.~,~ControlAction(ExpandCropButton)~,
				 ~5~,~ControlAction(UseLastCropButton)~
			 );

		return TRUE;
	}

	if ( ~<Num>~ == ~.~ )
	{
		substr( ~<CurrentNumber>~,0,strlen(~<CurrentNumber>~)-1,NewNumber );
		CurrentNumber = ~<NewNumber>~;
		return EditDialog( SetStatus,0,~<CurrentNumber>~ );
	}

	CurrentNumber = ~<CurrentNumber><Num>~;

	return EditDialog( SetStatus,0,~<CurrentNumber>~ );
}


NUMERIC OnMinus()
{
	if ( ~<CurrentNumber>~ != ~~ )
	{
		return AdjustValue( cBlue,Keystate( Shift ) ? -1 : 1 );
	}

	CurrentNumber = ~-~;

	return EditDialog( SetStatus,0,~<CurrentNumber>~ );
}


NUMERIC OnPrevButton()
{
	// The following line forces the focus to this button so that if the previous image causes
	// any other buttons to be disabled, the focus won't be left on a disabled button which will
	// cause keyboard input to be disabled.  The HasKeyboardFocus function checks to make sure
	// that the keyboard focus is in the adjust images dialog first so that the keyboard focus
	// doesn't get taken away if it is currently somewhere else.
	if ( EditDialog( HasKeyboardFocus ) )
	{
		EditDialog( SetControlFocus,PrevButton );
	}

	ImageCorrections( GetCrop,GetOpenImagePath(),lastCropX,lastCropY,lastCropWidth,lastCropLength );
	HoldCorrections = NUMERIC( ~<$con.ImageEditData[DontResetOnSave]>~ );

	if ( ~<$con.ImageEditData[AutomaticAutoBal]>~ == ~1~ )
	{
		Action = ~AutoBalance(FALSE,TRUE);~;	
		QueueContentsAfter( Action,1500 );
	}
	else if ( <HoldCorrections> )
	{
		Action = ~ApplyUpdates();~;	
		QueueContentsAfter( Action,1500 );

		NextPrevButtonPressed = TRUE;
	}

	if ( Document( Doc,FindByName,~FrameSelectorDoc~ ) )
	{
		AcceptImageEdits(-1,TRUE,!<HoldCorrections>);
		Action = ACTION DOC ( FrameSelectorDoc "SelectPrev(FALSE);" );
		return PerformActions( Action );
	}

	if ( GenCon( View,FindActiveImageThumbnailView ) )
	{
		if ( ! View( GetPrevImageCorrections, PrevCorrections ) )
		{
			return FALSE ;
		}
		
		colorType	= Numeric(~<$con.PrevCorrections[ColorType]>~ );
		orgApplyShasta = Numeric(~<$con.PrevCorrections[orgApplyShasta]>~) ;
		applyShasta = Numeric(~<$con.PrevCorrections[ApplyShasta]>~) ;
		WantAETab = (<orgApplyShasta> || <applyShasta>) && (<colorType> <= 2);
		UpdateImages = <orgApplyShasta> != <applyShasta> ;
		
		AcceptImageEdits( <WantAETab>, <UpdateImages>, !<HoldCorrections> ) ;

		EditDialog( SetStatus,1,~Previous Image~ );

		View( DoKeyDown,0x25,0,0 );
		return TRUE;
	}

	return FALSE;
}

NUMERIC ControlActions(Action1,Action2)
{
	ControlAction(~<Action1>~);
	return ControlAction(~<Action2>~);
}


// OnKeyDown is only executed when a control is not in focus to accept the keystroke.  In this case,
// the dialog accepts the key and calls this routine. PDF 10/6/00
NUMERIC ControlAction( which)
{
	return EditDialog( TriggerControlActions , <which>, DActionsText );
}

NUMERIC OnKeyDown()
{
	Key = EditDialog(GetLastKey, Keyname);

	OnSimilarStr( ~<Keyname>~, 
		~w~, ~ControlAction(RotateCCWButton)~, 
		~o~, ~ControlAction(OpenButton)~, 
		~f~, ~ControlAction(RefButton)~,
		~p~, ~ControlAction(PrevButton)~,
		~e~, ~ControlAction(CancelButton)~,
		~-~, ~ControlAction(MinusButton)~,
		~+~, ~ControlAction(PlusButton)~,
		~n~, ~ControlAction(NextButton)~,
		~*~, ~ControlAction(AsterickButton)~,
		~.~, ~ControlAction(NumPeriodButton)~,
		~1~, ~ControlAction(Num1Button)~,
		~2~, ~ControlAction(Num2Button)~,
		~3~, ~ControlAction(Num3Button)~,
		~4~, ~ControlAction(Num4Button)~,
		~5~, ~ControlAction(Num5Button)~,
		~6~, ~ControlAction(Num6Button)~,
		~7~, ~ControlAction(Num7Button)~,
		~8~, ~ControlAction(Num8Button)~,
		~9~, ~ControlAction(Num9Button)~,
		~0~, ~ControlAction(Num0Button)~,
		~l~, ~ControlAction(CloseAllButton)~,
		~d~, ~ControlAction(cDensityPrompt)~,
		~r~, ~ControlAction(cRedPrompt)~,
		~g~, ~ControlAction(cGreenPrompt)~,
		~b~, ~ControlAction(cBluePrompt)~,
		~t~, ~ControlAction(cContrastPrompt)~,
		~m~, ~ControlAction(cGammaPrompt)~,
		~u~, ~ControlAction(cSaturationPrompt)~,
		~h~, ~ControlAction(cSharpenPrompt)~,
		~a~, ~ControlAction(cArbitraryRotationPrompt)~,
		~[~, ~ControlAction(ShiftCropLeftButton)~,
		~]~, ~ControlAction(ShiftCropRightButton)~,
		~{~, ~ControlAction(ShiftCropUpButton)~,
		~}~, ~ControlAction(ShiftCropDownButton)~,
		~|~, ~ControlAction(ExpandCropButton)~,
		~\~, ~ControlAction(ShrinkCropButton)~,
		~'~, ~ControlAction(UseLastCropButton)~,
		~/~, ~ControlAction(ForwardSlashButton)~,
		~x~, ~ControlAction(AutoBalShortcutButton)~ 
		);

	return TRUE;
}


// Prompt values
pNum0		= ~0~;
pNum1		= ~1~;
pNum2		= ~2~;
pNum3		= ~3~;
pNum4		= ~4~;
pNum5		= ~5~;
pNum6		= ~6~;
pNum7		= ~7~;
pNum8		= ~8~;
pNum9		= ~9~;
pNum0_2		= ~)~;
pNum1_2		= ~!~;
pNum2_2		= ~@~;
pNum3_2		= ~#~;
pNum4_2		= ~$~;
pNum5_2		= ~%~;
pNum6_2		= ~^~;
pNum7_2		= ~&~;
pNum8_2		= ~*~;
pNum9_2		= ~(~;
pDensity	= ~.~;
pDensity2	= ~,~;
pThumbUp	= ~>~;
pThumbDown	= ~<~;
pRed		= ~R~;
pRed2		= ~I~;
pGreen		= ~G~;
pGreen2		= ~J~;
pBlue		= ~B~;
pBlue2		= ~K~;
pPrint		= ~`~;
pNoPrint	= ~;~;
pNext		= ~\~;
pNext2		= ~|~;
pPrev		= ~/~;
pPrev2		= ~?~;
pMode		= ~]~;
pViewMode	= ~}~;
pMakeRef	= ~E~;
pRecallRef	= ~F~;
pRotate90	= ~W~;
pRotate180	= ~V~;
pRotate270	= ~U~;
pStore		= ~S~;
pRecall		= ~C~;
pRecallLast	= ~L~;
pApplyAll	= ~A~;
pOpen		= ~O~;
pZero		= ~Z~;
pPlus		= ~+~;
pMinus		= ~-~;
pAutoBal	= ~X~;


NUMERIC OnNextButton()
{
	// The following line forces the focus to this button so that if the next image causes
	// any other buttons to be disabled, the focus won't be left on a disabled button which will
	// cause keyboard input to be disabled.  The HasKeyboardFocus function checks to make sure
	// that the keyboard focus is in the adjust images dialog first so that the keyboard focus
	// doesn't get taken away if it is currently somewhere else.
	if ( EditDialog( HasKeyboardFocus ) )
	{
		EditDialog( SetControlFocus,NextButton );
	}

	ImageCorrections( GetCrop,GetOpenImagePath(),lastCropX,lastCropY,lastCropWidth,lastCropLength );

	Backwards = KeyState(Control);
	HoldCorrections = NUMERIC( ~<$con.ImageEditData[DontResetOnSave]>~ );

	if ( ~<$con.ImageEditData[AutomaticAutoBal]>~ == ~1~ )
	{
		Action = ~AutoBalance(FALSE,TRUE);~;	
		QueueContentsAfter( Action,1500 );
	}
	else if ( <HoldCorrections>  )
	{
		Action = ~ReApplyUpdates();~;	
		QueueContentsAfter( Action,1500 );
		
		NextPrevButtonPressed = TRUE;
	}

	if ( Document( Doc,FindByName,~FrameSelectorDoc~ ) )
	{
		AcceptImageEdits(-1, TRUE, !<HoldCorrections> );
		Direction = $Backwards ? Prev : Next;
		
		Action = ACTION DOC  ( FrameSelectorDoc "Select<Direction>(FALSE);" );
		return PerformActions( Action );
	}

	if ( GenCon( View,FindActiveImageThumbnailView ) )
	{
		if ( <Backwards> )
		{
			if ( ! View( GetPrevImageCorrections, theCorrections ) )
			{
				return FALSE ;
			}
		}
		else
		{
			if ( ! View( GetNextImageCorrections, theCorrections ) )
			{
				return FALSE ;
			}
		}
		
		orgApplyShasta = Numeric(~<$con.theCorrections[orgApplyShasta]>~) ;
		applyShasta = Numeric(~<$con.theCorrections[ApplyShasta]>~) ;
		WantAETab = <orgApplyShasta> || <applyShasta> ;
		UpdateImages = <orgApplyShasta> != <applyShasta> ;
		
		AcceptImageEdits( <WantAETab>, <UpdateImages>, !<HoldCorrections> ) ;

		EditDialog( SetStatus,1,~Next Image~ );
		
		Direction = $Backwards ? 0x025 : 0x027;

		View( DoKeyDown,<Direction>,0,0 );
		return TRUE;
	}

	return FALSE;
}

VOID UpdateColorTypeOptions( colorType, shastaApplied )
{
	if ( !<shastaApplied> )
	{
		if ( <colorType> <= 1 )			// Color
		{
			EditDialog( EnableControls,TRUE,ApplyShastaButton,AutoBalDenButton,AutoBalDRGBButton,AutoBalRGBButton );
			EditDialog( SetStatus,1,Translate( ~Color image~ ) );
		}
		else if ( <colorType> == 2 )	// BW
		{
			EditDialog( EnableControls,FALSE,AutoBalDRGBButton,AutoBalRGBButton );
			EditDialog( EnableControls,TRUE,AutoBalDenButton );
			EditDialog( EnableControls,TRUE,ApplyShastaButton );
			EditDialog( SetStatus,1,Translate( ~BW image~ ) );
		}
		else							// BW + Spot, Sepia, Sepia + Spot
		{
			EditDialog( EnableControls,FALSE,ApplyShastaButton,AutoBalDenButton,AutoBalDRGBButton,AutoBalRGBButton );

			if ( <colorType> == 3 )
			{
				EditDialog( SetStatus,1,Translate( ~BW image with spot color~ ) );
			}
			else if ( <colorType> == 4 )
			{
				EditDialog( SetStatus,1,Translate( ~Sepia image~ ) );
			}
			else if ( <colorType> == 5 )
			{
				EditDialog( SetStatus,1,Translate( ~Sepia image with spot color~ ) );
			}
		}
	}
}

NUMERIC OnPlus()
{
	return AdjustValue(cBlue,KeyState(Shift) ? -1 : 1);
}


SkipActivate = 0;

NUMERIC OnDeactivate()	// YOU MAY WANT TO DISABLE THESE ACTIONS WHEN DEBUGGING
{
	SetUseNumlock();

	if ( Numeric(~<$con.ImageEditData[KeepKeyboardFocus]>~) && !Defined(EnterTextDialog) && !<SkipActivate> )
	{
		Action = STR ( GrabTheFocus(); );
		QueueContentsAfter( Action,1000 );
	}

	SkipActivate = 0;

	return TRUE;
}


VOID SetUseNumlock()
{
	EditDialog( GetInput );

	if ( ImageEditData(GetNumeric,UseNumLock) )
	{
		Keyboard( Hook );
		Keyboard( NoNumlock,NumlockSubstitute,0x44 );
		Keyboard( SetNumLock );
	}
	else
	{
		Keyboard( UnHook,AllowNumlock );
	}
}

NUMERIC OnActivate()	// YOU MAY WANT TO DISABLE THESE ACTIONS WHEN DEBUGGING
{
	SetUseNumlock();

	return TRUE;
}	

NUMERIC SendAKey(Key)	
{
	PostThreadMessage(-1, 0x0100,9,0 );
	return PostThreadMessage(-1, 0x0100,<Key>,0 );
	return PostThreadMessage(-1, 0x0101,<Key>,0 );
}

NUMERIC OnRunButton()
{
	return AskForCurrentOrderID(GetCurrentOrderID);
}


NUMERIC AskForCurrentOrderID(Handler)
{
	OrderID = ~~;

	DocName = ~~;
	if ( Document( Doc,FindByName,~FrameSelectorDoc~ ) )
	{
		DocName = ~FrameSelectorDoc~;
	}
	else if ( Document( Doc,FindByName,~ImagesDoc~ ) )
	{
		DocName = ~ImagesDoc~;
	}
	else if ( Document( Doc,FindByName,~GreenScreenDoc~ ) )
	{
		DocName = ~GreenScreenDoc~;
	}

	if ( !SimilarStr(~<DocName>~,~~) )
	{
		Action = STR ( <DocName> "SendOrderID(EditImagesDoc3,<Handler>);" );
		return PerformDocActions( Action );
	}

	return FALSE;
}

NUMERIC AskForCurrentImageData(Handler,Arg1)
{
	OrderID = ~~;

	DocName = ~~;
	if ( Document( Doc,FindByName,~FrameSelectorDoc~ ) )
	{
		DocName = ~FrameSelectorDoc~;
	}
	else if ( Document( Doc,FindByName,~ImagesDoc~ ) )
	{
		DocName = ~ImagesDoc~;
	}
	else if ( Document( Doc,FindByName,~GreenScreenDoc~ ) )
	{
		DocName = ~GreenScreenDoc~;
	}

	if ( !SimilarStr(~<DocName>~,~~) )
	{ 
		Action = STR ( <DocName> "SendImageData(EditImagesDoc3,<Handler>,<Arg1>);" );
		return PerformDocActions( Action );
	}

	return FALSE;
}

NUMERIC OnSavedAdjustments()
{
	Actions = ACTION DOC ( ImageAdjustmentsDoc OpenOnce ImageAdjustmentsDoc "Init(~All~,~Select * From ImageAdjustments Order By ID~);" );
	return PerformActions( Actions );
}

NUMERIC ChangeLabRef( OrderID )
{
	SkipActivate = TRUE;

	Actions = ACTION DOC ( LabReferenceImage "ChangeReferenceImage(~<OrderID>~);" );
	return PerformActions( Actions );
}


NUMERIC GetCurrentOrderID( OrderID )
{
	SkipActivate = TRUE;

	Action = STR ( OrderItemsDoc OpenOnce OrderItemsDoc "Init( ~<OrderID>~,~Select * From OrderItems Where OrderID = '<OrderID>' Order By Sequence,Subsequence~,TRUE )" );
//	Action = STR ( OrderItemsDoc OpenOnce OrderItemsDoc "Init( ~<OrderID>~,~Select * From OrderItems Where OrderID = '<OrderID>' Order By ID~,TRUE )" );
	PerformDocActions( Action );
	

	Action = STR ( OrderItemsDoc "InitRunPropertiesDialog( ~Print all Items for Order <OrderID>~,TRUE,~<OrderID>~ );" );
	return PerformDocActions( Action );
}



NUMERIC OnOpenButton()
{
	if ( NumSelectedImages() < 1 )
	{
		return NoSelectedImages();
	}
	
	if ( GenCon( View,FindActiveImageThumbnailView ) )
	{
		EditDialog( SetStatus,1,~Open selected image(s)~ );
		Action = STR ( GrabTheFocus(); );
		QueueContentsAfter( Action,500 );
		View( PostViewMessage,0x0100,0x4F,0 );
		return View( PostViewMessage,0x0101,0x4F,0 );
	}
}


NUMERIC CloseAllOpenImages()
{
	if ( !GenCon( View,FindActiveImageThumbnailView ) )
		{ return NoSelectedImages(); }

	Count = Index = 0;

	app( ThisApp,MessagePump,3 );

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( Window( GETNEXT,aView ) )
		{
			aView( GET,ViewType,ViewType );

			if ( ~<ViewType>~ == ~ImageEditView~ )
			{
				aView( GetDocumentPath,DocumentPath );
				Window( CloseWindow );
				ThisApp( MessagePump,3 );
				++Count;
				Index = 0;
			}
		}
	}

	ThisApp( MessagePump,0 );

	return TRUE;
}


NUMERIC OpenImageToCrop( WhichFunction )
{
	if ( NumOpenImages() < 1 )
	{
		return OnOpenButton();
	}

	//if ( NumSelectedImages() < 1 )
	//{
	//	return NoSelectedImages();
	//}

	return <WhichFunction>();
}


NUMERIC NumOpenImages()
{
	Count = 0;

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( Window( GETNEXT,aView ) )
		{
			aView( GET,ViewType,ViewType );

			if ( ~<ViewType>~ == ~ImageEditView~ )
			{
				++Count;
			}
		}
	}

	return <Count>;
}



VOID GrabTheFocus()
{
	EditDialog( SetWindowOrder,Top );
}


SeeOther = FALSE;

VOID OnSeeOtherBox()
{
	SeeOther = !<SeeOther>;

	if ( <SeeOther> )
	{
		EditDialog( SetControlTitle,SeeOtherBox,~<-~ );
		OnTabChange();
	}
	else
	{
		EditDialog( SetControlTitle,SeeOtherBox,~->~ );
		EditDialog( SetWindowSize,<DialogWidth>,$DialogHeight );
	}
}


VOID IncrementRotateFromDisk( RotateFromDisk )
{
	RotateFromDisk = KeyState( SHIFT ) ? (0 - <RotateFromDisk>) : <RotateFromDisk>;

	NewRotateFromDisk = $RotateFromDisk + EditDialog( GetValue,cRotateFromDisk );

	while ( $NewRotateFromDisk >= 360 )
		{ NewRotateFromDisk -= 360; }

	while ( $NewRotateFromDisk < 0 )
		{ NewRotateFromDisk += 360; }

	EditDialog( SetStatus,1,~Rotate <NewRotateFromDisk>~ );

	ImageEditData( SetValue,cRotateFromDisk,$NewRotateFromDisk );
	EditDialog( SetString,RotateFromDiskField,$NewRotateFromDisk );
	EditDialog( Update );
	UpdateAffectedImages();
}


VOID ZeroValue( which )
{
	<which>Total = 0;
	EditDialog( SetString,~0~,<which> );
	UpdateAffectedImages();
	ShowNormalized();
}

NUMERIC ChangeValue( which,amount )
{
	CurrentValue = MakeNumber(EditDialog(GetValue,<which>)) + <amount>;

	EditDialog( SetString,~<CurrentValue>~,<which> );

	return ShowNormalized();
}


cDensity_STR			= ~Density~;
cRed_STR				= ~Red~;
cGreen_STR				= ~Green~;
cBlue_STR				= ~Blue~;
cContrast_STR			= ~Contrast~;
cGamma_STR				= ~Gamma~;
cGammaRed_STR			= ~Red Gamma~;
cGammaGreen_STR			= ~Green Gamma~;
cGammaBlue_STR			= ~Blue Gamma~;
cSaturation_STR			= ~Saturation~;
cSharpen_STR			= ~Sharpen~;
cArbitraryRotation_STR	= ~Rotation~;

cShadowContrast_STR		= ~Shadow Contrast~;
cMidtoneContrast_STR	= ~Midtone Contrast~;
cHighlightContrast_STR	= ~Highlight Contrast~;

cPSDensity_STR			= ~AEDensity~;
cPSRed_STR				= ~AERed~ ;
cPSGreen_STR			= ~AEGreen~ ;
cPSBlue_STR				= ~AEBlue~ ;
cPSContrast_STR			= ~AEContrast~ ;
cPSGamma_STR			= ~AEGamma~ ;

cShastaHighlight_STR	= ~Highlight~;
cShastaMidTone_STR		= ~MidTone~;
cShastaShadow_STR		= ~Shadow~;

gCurrentTab				= -1 ;

NUMERIC IncrementValue( which,amount )
{
	KillTimer( 0 );

	if ( ~<CurrentNumber>~ == ~~ )
	{
		CurrentNumber = ~1~;
	}
	else if ( ~<CurrentNumber>~ == ~-~ )
	{
		return EditDialog( SetStatus,1,~You are still entering a negative number~ );
	}

	CurrentValue = MakeNumber(EditDialog(GetValue,<which>)) + (<amount> * <CurrentNumber>);

	if ( ~<CurrentNumber>~ == ~0~ )
	{
		CurrentValue = 0;
	}

	EditDialog( SetString,~<CurrentValue>~,<which> );

	Delta = <CurrentNumber> * <amount>;

	//Substr(<which>,1,1,operation);
	EditDialog( SetStatus,0,~<Delta> <<which>_STR>~ );
	CurrentNumber = ~~;

	// to process image edits on each keystroke, uncomment the following line.
	UpdateAffectedImages();

	return ShowNormalized();
}


NUMERIC ShowNormalized()
{
	cD = Numeric(~<$con.ImageEditData[cDensity]>~);
	cR = Numeric(~<$con.ImageEditData[cRed]>~);
	cG = Numeric(~<$con.ImageEditData[cGreen]>~);
	cB = Numeric(~<$con.ImageEditData[cBlue]>~);

	//NormalizeDRGB( cD,cR,cG,cB );

	return EditDialog( SetStatus,1,~DRGB  <cD> <cR> <cG> <cB>~ );
}

NUMERIC AcceptImageEdits( WantAETab, UpdateImages, ResetAESettings )
{
	KillTimer( 0 );

	if ( !GenCon( View,FindActiveImageThumbnailView ) )
	{ 
		KillTimer( 0 );
		return NoSelectedImages(); 
	}

	if ( View( IsThumbNailView ) && (~<$con.View[ViewDataType]>~ == ~Image~) )
	{
		if ( !View( GetSelected,SelectedImages ) )		
			{ return NoSelectedImages(); }

		count = 0;
		while ( SelectedImages( GetNext,Image ) )
		{
			if ( !NoChange(ImageEditData) )	{ UpdateUserCounts(Save,1); }

			ImageEditData( SaveCorrections,~<$con.Image[Path]>~ );
			
			++count;
		}		
		
		if ( !<count> )
			{ return NoSelectedImages(); }

	}
	else
	{
		if ( !NoChange(ImageEditData) )	{ UpdateUserCounts(Save,1); }
		ImageEditData( SaveCorrections );
	}

	ResetDeltas(<WantAETab>, <UpdateImages>, <ResetAESettings>) ;
	EditDialog( SetStatus,1,~Corrections saved~ );

	if ( View( IsThumbNailView ) )
	{
		View( RefreshView ) ;
	}
	
	return EditDialog( Update );
}


NUMERIC CancelImageEdits( ImagesMustBeSelected, IsClosing )
{
	KillTimer( 0 ); 
	count = 0;

	value = GetOrigApplyShasta();

	ImageEditData( CancelCorrections );
	
	if ( <IsClosing> )
	{
		ImageEditData( SetValues,cDensity,0,cRed,0,cGreen,0,cBlue,0,cContrast,0,
						cGamma,0.0,cPSDensity,0,cPSRed,0,cPSGreen,0,cPSBlue,0,cPSContrast,0,
						cPSGamma,0.0,cGammaRed,0.0,cGammaGreen,0.0,cGammaBlue,0.0,
						cSaturation,0,cArbitraryRotation,0.0,cRotateFromDisk,0,
						cShastaHighlight,0,cShastaMidTone,0,cShastaShadow,0,
						cShadowContrast,0,cMidtoneContrast,0,cHighlightContrast,0);

		ImageEditData( SetValues,cCropX,50,cCropY,50,cCropWidth,100,cCropLength,100 );
		ImageEditData( SetValues,cSharpen,0 );
		ImageEditData( SetValue, AutoBalanceDone, 0 );

		if ( <value> == 1 )
		{
			ImageEditData( SetValues, cApplyShasta, 1 );
		}
		else if ( <value> == 0 )
		{
			ImageEditData( SetValues, cApplyShasta, 0 );
		}

		OnLutResetButton(FALSE);

		ImageEditData( UpdateCorrections );
		return TRUE;
	}

	AlwaysResetDeltas(<value>,1,0);
	return ImageEditData( RefreshCorrections );
}

NUMERIC GetOrigApplyShasta()
{
	if ( !GenCon( View,FindActiveImageThumbnailView ) )
	{
		return FALSE;
	}
	
	Count = View( GetSelectedIconCount );
	if ( <Count> == 0 )
	{
		return FALSE;
	}
	
	if ( !View( GetSelected,SelectedImages ) )
	{
		return FALSE;
	}

	if ( !SelectedImages( GetLast,Image ) )
	{
		return FALSE;
	}

	ImagePath = ~<$con.Image[Path]>~;
	colorType = Numeric( ~<$con.Image[ColorType]>~ );

	if ( !ImageCorrections( GetCurrentCorrections,~<ImagePath>~,theCorrections ) )
	{
		return FALSE;
	}
	
	if ( <colorType> <= 2 )	// BW or Color
	{
		value = ~<$con.theCorrections[orgApplyShasta]>~;
	}
	else
	{
		value = FALSE;
	}
	
	return <value>;
}

VOID OnRememberColorBalance()
{
	if ( <ImageEditDataCount> >= <MaxImageEditDataCount> )
	{
		Warning( ~you can only store 9 values~ );
		return;
	}
		
	ForgetGlobal( GetNameForBalanceDialog );
	Class( GetNameForBalance,Extends,BaseEnterText );
	GetNameForBalance( New,GetNameForBalanceDialog );	
	GetNameForBalanceDialog.DefineDialog();			
	Global( GetNameForBalanceDialog );

	EditDialog( EnableControls,FALSE,RememberButton );
}

VOID GetNameForBalance::OnReturnKey()	
{ 
	dlg( GetInput );

	BalanceName = GetText();

	if ( IsNull( ~<BalanceName>~ ) )		
	{ 
		dlg( SetControlFocus,EditTextField );
		return;
	}

	RememberColorBalance( ~<BalanceName>~ );
	DoCancelButton();
}

VOID GetNameForBalance::DoCancelButton()	
{ 
	EditDialog( EnableControls,TRUE,RememberButton );
	EditDialog( SetFocus );
	BaseEnterText::DoCancelButton();
}

VOID GetNameForBalance::GetNameForBalance()
{ 
	Title = ~Enter a name and press Enter~;
	ImageEditDialog( GetWindowPosition,Left,Top);
	ToolTip = Translate( ~Enter the name of the balance you wish to save and press Enter~ );
	Left += 50;
}


NUMERIC GetNameForBalance::OldRememberColorBalance( Name )	// No longer called
{
	EditDialog( GetInput );

	GenCon( ImageData,New,DDImageEdit,Permanent );

	ImageData( SetValues,SettingsName,~<Name>~ );

	SavedImageEditData( InsertBack,ImageData );

	RememberValues( ImageData );

	return TRUE;
}


NUMERIC GetNameForBalance::RememberColorBalance( Name )
{
	EditDialog( GetInput );

	Query = ~SELECT * FROM ImageAdjustments WHERE ID = '<Name>'~;

	if ( !PGenConList( List, Connect, GetRecordFor, ~<Query>~, Adjustments ) )
	{
		List( GetErrorDescription,0,theErr );
		return	Warning( Translate(DBMessages,QueryFailed,~<Query>~,~<theErr>~) );
	}

	Adjustments( Set,ID,~<Name>~ );
	Adjustments( Set,Category,~<$App.UserName>~ );

	LutChange();

	if ( !Adjustments(UpdateFrom,ImageEditData) )
	{
		List( GetErrorDescription,0,theErr );
		return	Warning( Translate(DBMessages,UpdateFailed,~<Query>~,~<theErr>~) );
	}

	if ( !Adjustments(ConvertFromLUT,~cLut~,GenCon,ImageEditData,~cLut~) )
	{
		return	Warning( ~Failed to save the Lut~ );
	}

	if ( !Adjustments(ConvertFromLUTPoints,~LUTControlPoints~,GenCon,ImageEditData,~LUTControlPoints~) )
	{
		return	Warning( ~Failed to save the Lut points~ );
	}

	if ( !List( Update ) )
	{
		List( GetErrorDescription,0,theErr );
		return	Warning( Translate(DBMessages,UpdateFailed,~<Query>~,~<theErr>~) );
	}

	return TRUE;
}



NUMERIC DisplayRecallMenu()
{
	GenCon(ListMenu,New,DDMenuDef,SetValue,Position,-1 );

	Count = -1;

	Query = ~Select ID,Category From ImageAdjustments Order By Category,Sequence,ID~;

	if ( !PGenConList( List,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		List( GetErrorDescription,0,theErr );
		Error( ~Database Query Failed: <Query>.  <theErr>~ ); 
	}

	LastCategory = ~~;
	CategoryCount = 0;

	while ( List( GetNext,Data ) )
	{
		GenCon( Recall<++Count>,New,DDMenuItemDef,SetValues,
				Text,		~&<$pcon.Data[ID]>~,
				IDText,		~ID~ );

		theAction = ACTION Exec ( RecallLast( ~<$pcon.Data[ID]>~ ); );

		Recall<Count>( SetValuesFrom,ActionsText,theAction );

		if ( SimilarStr(~<$pcon.Data[Category]>~,~<$App.UserName>~) || IsNull(~<$pcon.Data[Category]>~) )
		{
			ListMenu( InsertBack,Recall<Count> );
		}
		else if ( SimilarStr( ~<$pcon.Data[Category]>~,~<LastCategory>~ ) )
		{
			Category<CategoryCount>( InsertBack,Recall<Count> );
		}
		else
		{
			GenCon( Category<++CategoryCount>,New,DDMenuItemDef,SetValues,
					Text,		~&<$pcon.Data[Category]>~,
					IDText,		~ID~ );

			Category<CategoryCount>( InsertBack,Recall<Count> );

			ListMenu( InsertBack,Category<CategoryCount> );

			LastCategory = ~<$pcon.Data[Category]>~;
		}
	}

	EditDialog( SetControlFocus,RecallButton );

	EditDialog( DisplayMenu,ListMenu,RecallButton(GetLeft,Position),RecallButton(GetTop,Position) );

	return TRUE;
}


NUMERIC NoChange( &Data )
{
	return  !Numeric(~<$con.Data[cRed]>~) &&
			!Numeric(~<$con.Data[cGreen]>~) &&
			!Numeric(~<$con.Data[cBlue]>~) &&
			!Numeric(~<$con.Data[cDensity]>~) &&
			!Numeric(~<$con.Data[cContrast]>~) &&
			 Numeric(~<$con.Data[cGamma]>~) == 0.0 &&
			!Numeric(~<$con.Data[cPSRed]>~) &&
			!Numeric(~<$con.Data[cPSGreen]>~) &&
			!Numeric(~<$con.Data[cPSBlue]>~) &&
			!Numeric(~<$con.Data[cPSDensity]>~) &&
			!Numeric(~<$con.Data[cPSContrast]>~) &&
			 Numeric(~<$con.Data[cPSGamma]>~) == 0.0 &&
			 Numeric(~<$con.Data[cGammaRed]>~) == 0.0 &&
			 Numeric(~<$con.Data[cGammaGreen]>~) == 0.0 &&
			 Numeric(~<$con.Data[cGammaBlue]>~) == 0.0 &&
			 Numeric(~<$con.Data[cArbitraryRotation]>~) == 0.0 &&
			!Numeric(~<$con.Data[cSaturation]>~) &&
			!Numeric(~<$con.Data[cSharpen]>~) &&
			!Numeric(~<$con.Data[cShastaHighlight]>~) &&
			!Numeric(~<$con.Data[cShastaMidTone]>~) &&
			!Numeric(~<$con.Data[cShastaShadow]>~) &&
			!Numeric(~<$con.Data[cShadowContrast]>~) &&
			!Numeric(~<$con.Data[cMidtoneContrast]>~) &&
			!Numeric(~<$con.Data[cHighlightContrast]>~) ;
}

NUMERIC RecallLast( Name )
{
	Query = ~SELECT * FROM ImageAdjustments WHERE ID = '<Name>'~;

	if ( !PGenConList( List, Connect, GetExistingRecordFor, ~<Query>~, Data ) )
	{
		return	Warning( ~<Name> no longer exists~ );
	}

	if ( !Data(ConvertToLUT,~cLut~,GenCon,ImageEditData,~cLut~) )
	{
		return	Warning( ~Failed to get the Lut~ );
	}

	if ( !Data(ConvertToLUTPoints,~LUTControlPoints~,GenCon,ImageEditData,~LUTControlPoints~) )
	{
		return	Warning( ~Failed to get the Lut points~ );
	}

	RefreshLut();

	EditDialog( SetStrings,cRed,~<$pcon.Data[cRed]>~,
				cGreen,~<$pcon.Data[cGreen]>~,
				cBlue,~<$pcon.Data[cBlue]>~,
				cDensity,~<$pcon.Data[cDensity]>~,
				cContrast,~<$pcon.Data[cContrast]>~,
				cGamma,~<$pcon.Data[cGamma]>~,
		//		cApplyShasta,~<$pcon.Data[cApplyShasta]>~
				cPSRed,~<$pcon.Data[cPSRed]>~,
				cPSGreen,~<$pcon.Data[cPSGreen]>~,
				cPSBlue,~<$pcon.Data[cPSBlue]>~,
				cPSDensity,~<$pcon.Data[cPSDensity]>~,
				cPSContrast,~<$pcon.Data[cPSContrast]>~,
				cPSGamma,~<$pcon.Data[cPSGamma]>~,
				cGammaRed,~<$pcon.Data[cGammaRed]>~,
				cGammaGreen,~<$pcon.Data[cGammaGreen]>~,
				cGammaBlue,~<$pcon.Data[cGammaBlue]>~,
				cSaturation,~<$pcon.Data[cSaturation]>~,
				cArbitraryRotation,~<$pcon.Data[cArbitraryRotation]>~,
				cSharpen,~<$pcon.Data[cSharpen]>~,
				cShadowContrast,~<$pcon.Data[cShadowContrast]>~,
				cMidtoneContrast,~<$pcon.Data[cMidtoneContrast]>~,
				cHighlightContrast,~<$pcon.Data[cHighlightContrast]>~
				 );

	EditDialog( SetStatus,1,~Loaded <Name>~ );

	return ApplyUpdates();
}


VOID RememberValues( &Data )	// No longer called
{
	Data( SetValues,cRed,~<$con.ImageEditData[cRed]>~,
					cGreen,~<$con.ImageEditData[cGreen]>~,
					cBlue,~<$con.ImageEditData[cBlue]>~,
					cDensity,~<$con.ImageEditData[cDensity]>~,
					cContrast,~<$con.ImageEditData[cContrast]>~,
					cGamma,~<$con.ImageEditData[cGamma]>~,
					
					cPSRed,~<$con.ImageEditData[cPSRed]>~,
					cPSGreen,~<$con.ImageEditData[cPSGreen]>~,
					cPSBlue,~<$con.ImageEditData[cPSBlue]>~,
					cPSDensity,~<$con.ImageEditData[cPSDensity]>~,
					cPSContrast,~<$con.ImageEditData[cPSContrast]>~,
					cPSGamma,~<$con.ImageEditData[cPSGamma]>~,

					cGammaRed,~<$con.ImageEditData[cGammaRed]>~,
					cGammaGreen,~<$con.ImageEditData[cGammaGreen]>~,
					cGammaBlue,~<$con.ImageEditData[cGammaBlue]>~,
					cSaturation,~<$con.ImageEditData[cSaturation]>~,
					cSharpen,~<$con.ImageEditData[cSharpen]>~,
					
					cApplyShasta,~<$con.ImageEditData[ApplyShasta]>~,
					cShastaHighlight,~<$con.ImageEditData[ShastaHighlight]>~,
					cShastaMidTone,~<$con.ImageEditData[ShastaMidTone]>~,
					cShastaShadow,~<$con.ImageEditData[ShastaShadow]>~,

					cShadowContrast,~<$con.ImageEditData[cShadowContrast]>~,
					cMidtoneContrast,~<$con.ImageEditData[cMidtoneContrast]>~,
					cHighlightContrast,~<$con.ImageEditData[cHighlightContrast]> );

}

VOID OnShasta(wantAETab, UpdateImages, colorType)
{
	if ( !DefinedAndNotNull( colorType ) )
	{
		colorType = 0;
	}

	if ( <gCurrentTab> != <wantAETab> )
	{
		if ( <wantAETab> != -1 && <colorType> <= 2 )
		{
			gCurrentTab = <wantAETab> ;
		}
		else if ( <wantAETab> != -1 && <colorType> > 2 )
		{
			gCurrentTab = <wantAETab> ;
		}
		
		if ( <wantAETab> != -1 )
		{
			if ( <wantAETab> == 1 && <colorType> <= 2 )
			{
				EditDialog( SelectTab,TabWindow,2 ) ;
											 				
				EditDialog(EnableControls,FALSE, cDensityPrompt,			cDensityField,				cDensitySlider,
												cDensityZeroButton,			cDensityMinus,				cDensityPlus,
												cRedPrompt,					cRedField,					cRedSlider,
												cRedZeroButton,				cRedMinus,					cRedPlus,
												cGreenPrompt,				cGreenField,				cGreenSlider,
												cGreenZeroButton,			cGreenMinus,				cGreenPlus ) ;
												 
				EditDialog(EnableControls,FALSE, cBluePrompt,				cBlueField,					cBlueSlider,
												cBlueZeroButton,			cBlueMinus,					cBluePlus,
												cContrastPrompt,			cContrastField,				cContrastSlider,
												cContrastZeroButton,		cContrastMinus,				cContrastPlus,
												cGammaPrompt,				cGammaField,				cGammaSlider,
												cGammaZeroButton,			cGammaMinus,				cGammaPlus ) ;
																 
				EditDialog(EnableControls,FALSE, cSaturationPrompt,			cSaturationField,			cSaturationSlider,
												cSaturationZeroButton,		cSaturationMinus,			cSaturationPlus,
												cSharpenPrompt,				cSharpenField,				cSharpenSlider,
												cSharpenZeroButton,			cSharpenMinus,				cSharpenPlus,
												cArbitraryRotationPrompt,	cArbitraryRotationField,	cArbitraryRotationSlider,
												cArbitraryRotationZeroButton,	cArbitraryRotationMinus,	cArbitraryRotationPlus ) ;	

				EditDialog(EnableControls,FALSE, RotateCCWButton,			RotateCWButton,
												AutoBalDRGBButton,			AutoBalDenButton,			AutoBalRGBButton ) ;	

				EditDialog(EnableControls,FALSE, LutControl,				DensityRadio,				ResetLutDenButton,
												SmoothLutDenButton,			RedRadio,					ResetLutRedButton,
												SmoothLutRedButton,			GreenRadio,					ResetLutGreenButton,
												SmoothLutGreenButton,		BlueRadio,					ResetLutBlueButton,
												SmoothLutBlueButton,		ResetLutButton,				SmoothLutButton,
												InputOutputField,			DrawModeComboBox,
												LutControlRed,				LutControlGreen,			LutControlBlue,									
												cGammaRedPrompt,			cGammaRedField,				cGammaRedSlider,
												cGammaRedZeroButton,		cGammaRedMinus,				cGammaRedPlus,	
												cGammaGreenPrompt,			cGammaGreenField,			cGammaGreenSlider,
												cGammaGreenZeroButton,		cGammaGreenMinus,			cGammaGreenPlus,	
												cGammaBluePrompt,			cGammaBlueField,			cGammaBlueSlider,
												cGammaBlueZeroButton,		cGammaBlueMinus,			cGammaBluePlus ) ;	

				EditDialog(EnableControls,FALSE, cShadowContrastPrompt,		cShadowContrastField,		cShadowContrastSlider,
												cShadowContrastZeroButton,	cShadowContrastMinus,		cShadowContrastPlus,
												cMidtoneContrastPrompt,		cMidtoneContrastField,		cMidtoneContrastSlider,
												cMidtoneContrastZeroButton, cMidtoneContrastMinus,		cMidtoneContrastPlus,
												cHighlightContrastPrompt,	cHighlightContrastField,	cHighlightContrastSlider,
												cHighlightContrastZeroButton, cHighlightContrastMinus,	cHighlightContrastPlus ) ;

				EditDialog(EnableControls,FALSE, RememberButton,			RecallButton ) ;	

				EditDialog( EnableControls,TRUE, cPSDensityPrompt,			cPSDensityField,			cPSDensitySlider,
												cPSDensityZeroButton,		cPSDensityMinus,			cPSDensityPlus,
												cPSRedPrompt,				cPSRedField,				cPSRedSlider,
												cPSRedZeroButton,			cPSRedMinus,				cPSRedPlus,
												cPSGreenPrompt,				cPSGreenField,				cPSGreenSlider,
												cPSGreenZeroButton,			cPSGreenMinus,				cPSGreenPlus ) ;
												 
				EditDialog( EnableControls,TRUE, cPSBluePrompt,				cPSBlueField,				cPSBlueSlider,
												cPSBlueZeroButton,			cPSBlueMinus,				cPSBluePlus,
												cPSContrastPrompt,			cPSContrastField,			cPSContrastSlider,
												cPSContrastZeroButton,		cPSContrastMinus,			cPSContrastPlus,
												cPSGammaPrompt,				cPSGammaField,				cPSGammaSlider,
												cPSGammaZeroButton,			cPSGammaMinus,				cPSGammaPlus ) ;
												 
				EditDialog( EnableControls,TRUE, cShastaHighlightPrompt,	cShastaHighlightField,		cShastaHighlightSlider,
												cShastaHighlightZeroButton,	cShastaHighlightMinus,		cShastaHighlightPlus,
												cShastaMidTonePrompt,		cShastaMidToneField,		cShastaMidToneSlider,
												cShastaMidToneZeroButton,	cShastaMidToneMinus,		cShastaMidTonePlus,
												cShastaShadowPrompt,		cShastaShadowField,			cShastaShadowSlider,
												cShastaShadowZeroButton,	cShastaShadowMinus,			cShastaShadowPlus ) ;

				UpdateClickBalanceControls(0);
			}
			else	//	ShowControls
			{
				EditDialog( SelectTab, TabWindow, 0 ) ;

				EditDialog(EnableControls,FALSE, cPSDensityPrompt,			cPSDensityField,			cPSDensitySlider,
												cPSDensityZeroButton,		cPSDensityMinus,			cPSDensityPlus,
												cPSRedPrompt,				cPSRedField,				cPSRedSlider,
												cPSRedZeroButton,			cPSRedMinus,				cPSRedPlus,
												cPSGreenPrompt,				cPSGreenField,				cPSGreenSlider,
												cPSGreenZeroButton,			cPSGreenMinus,				cPSGreenPlus ) ;
												 
				EditDialog(EnableControls,FALSE, cPSBluePrompt,				cPSBlueField,				cPSBlueSlider,
												cPSBlueZeroButton,			cPSBlueMinus,				cPSBluePlus,
												cPSContrastPrompt,			cPSContrastField,			cPSContrastSlider,
												cPSContrastZeroButton,		cPSContrastMinus,			cPSContrastPlus,
												cPSGammaPrompt,				cPSGammaField,				cPSGammaSlider,
												cPSGammaZeroButton,			cPSGammaMinus,				cPSGammaPlus ) ;
												 					
				EditDialog(EnableControls,FALSE, cShastaHighlightPrompt,	cShastaHighlightField,		cShastaHighlightSlider,
												cShastaHighlightZeroButton,	cShastaHighlightMinus,		cShastaHighlightPlus,
												cShastaMidTonePrompt,		cShastaMidToneField,		cShastaMidToneSlider,
												cShastaMidToneZeroButton,	cShastaMidToneMinus,		cShastaMidTonePlus,
												cShastaShadowPrompt,		cShastaShadowField,			cShastaShadowSlider,
												cShastaShadowZeroButton,	cShastaShadowMinus,			cShastaShadowPlus ) ;

				EditDialog( EnableControls,TRUE, cDensityPrompt,			cDensityField,				cDensitySlider,
												cDensityZeroButton,			cDensityMinus,				cDensityPlus,
												cRedPrompt,					cRedField,					cRedSlider,
												cRedZeroButton,				cRedMinus,					cRedPlus,
												cGreenPrompt,				cGreenField,				cGreenSlider,
												cGreenZeroButton,			cGreenMinus,				cGreenPlus ) ;	

				EditDialog( EnableControls,TRUE, cBluePrompt,				cBlueField,					cBlueSlider,
												cBlueZeroButton,			cBlueMinus,					cBluePlus,
												cContrastPrompt,			cContrastField,				cContrastSlider,
												cContrastZeroButton,		cContrastMinus,				cContrastPlus,
												cGammaPrompt,				cGammaField,				cGammaSlider,
												cGammaZeroButton,			cGammaMinus,				cGammaPlus ) ;
												 
				EditDialog( EnableControls,TRUE, cSaturationPrompt,			cSaturationField,			cSaturationSlider,
												cSaturationZeroButton,		cSaturationMinus,			cSaturationPlus,
												cSharpenPrompt,				cSharpenField,				cSharpenSlider,
												cSharpenZeroButton,			cSharpenMinus,				cSharpenPlus,
												cArbitraryRotationPrompt,	cArbitraryRotationField,	cArbitraryRotationSlider,
												cArbitraryRotationZeroButton,	cArbitraryRotationMinus,	cArbitraryRotationPlus ) ;	

				EditDialog( EnableControls,TRUE, RotateCCWButton,			RotateCWButton,
												AutoBalDRGBButton,			AutoBalDenButton,			AutoBalRGBButton ) ;	

				EditDialog(EnableControls,TRUE, LutControl,				DensityRadio,				ResetLutDenButton,
												SmoothLutDenButton,			RedRadio,					ResetLutRedButton,
												SmoothLutRedButton,			GreenRadio,					ResetLutGreenButton,
												SmoothLutGreenButton,		BlueRadio,					ResetLutBlueButton,
												SmoothLutBlueButton,		ResetLutButton,				SmoothLutButton,
												InputOutputField,			DrawModeComboBox,
												LutControlRed,				LutControlGreen,			LutControlBlue,									
												cGammaRedPrompt,			cGammaRedField,				cGammaRedSlider,
												cGammaRedZeroButton,		cGammaRedMinus,				cGammaRedPlus,	
												cGammaGreenPrompt,			cGammaGreenField,			cGammaGreenSlider,
												cGammaGreenZeroButton,		cGammaGreenMinus,			cGammaGreenPlus,	
												cGammaBluePrompt,			cGammaBlueField,			cGammaBlueSlider,
												cGammaBlueZeroButton,		cGammaBlueMinus,			cGammaBluePlus ) ;	

				EditDialog(EnableControls,TRUE, cShadowContrastPrompt,		cShadowContrastField,		cShadowContrastSlider,
												cShadowContrastZeroButton,	cShadowContrastMinus,		cShadowContrastPlus,
												cMidtoneContrastPrompt,		cMidtoneContrastField,		cMidtoneContrastSlider,
												cMidtoneContrastZeroButton, cMidtoneContrastMinus,		cMidtoneContrastPlus,
												cHighlightContrastPrompt,	cHighlightContrastField,	cHighlightContrastSlider,
												cHighlightContrastZeroButton, cHighlightContrastMinus,	cHighlightContrastPlus ) ;

				EditDialog(EnableControls,TRUE, RememberButton,			RecallButton ) ;

				UpdateClickBalanceControls(1);
			}

			UpdateColorTypeOptions( <colorType>,<wantAETab> );
		}
	}
	
//	EditDialog( Update ) ;

//	if ( <changed> )
	if ( <UpdateImages> )
	{
		UpdateAffectedImages();
	}

}

VOID OnHold()
{
	EditDialog( GetInput );

	if ( ~<$con.ImageEditData[DontResetOnSave]>~ == ~1~ )
	{
		if ( ~<$con.ImageEditData[AutomaticAutoBal]>~ == ~1~ )
		{
			if ( MessageBox( ~Are you sure you want to turn off automatic auto balance?~,YESNO ) != YES )
			{ 
				EditDialog( SetCheck,FALSE,DontResetOnSaveCheckBox );
				return; 
			}
			else
			{
				EditDialog( SetCheck,FALSE,AutoBalCheckBox );
			}
		}
		EditDialog( SetCheck,TRUE, DontResetOnSaveCheckBox );
	}
	else
	{
		EditDialog( SetCheck,FALSE,DontResetOnSaveCheckBox );
	}
}


VOID OnAutoAutoBal()
{
	EditDialog( GetInput );

	if ( ~<$con.ImageEditData[AutomaticAutoBal]>~ == ~1~ )
	{
		if ( ~<$con.ImageEditData[DontResetOnSave]>~ == ~1~ )
		{
			if ( MessageBox( ~Are you sure you want to disable holding adjustments?~,YESNO ) != YES )
			{ 
				EditDialog( SetCheck,FALSE,AutoBalCheckBox );
				return; 
			}
			else
			{
				EditDialog( SetCheck,FALSE,DontResetOnSaveCheckBox );
			}
		}
			
		EditDialog( SetCheck,TRUE, AutoBalCheckBox );
	}
	else
	{
		EditDialog( SetCheck,FALSE,AutoBalCheckBox );
	}
}


VOID OnTrackAutoBalData()
{
	EditDialog( GetInput );

	EditDialog( GetControlValue,TrackAutoBalCheckBox,saveData );

	if ( !SetAutoBalTracking( <saveData> ) )
	{
		SetWorkstationSettings( ~Analyzer~, ~SaveAutoBalData~, ~<saveData>~, TRUE );
	}
}


VOID ResetDeltas(WantAETab, UpdateImages, ResetAESettings)
{
	if ( ! Numeric(~<$con.ImageEditData[DontResetOnSave]>~) )
	{
		AlwaysResetDeltas(<WantAETab>,<UpdateImages>,0);
	}
	else if ( <ResetAESettings> )
	{
		ResetAEDeltas(<WantAETab>,<UpdateImages>);
	}
}

VOID AlwaysResetDeltas(wantAETab, updateImages, colorType)
{
	ImageEditData( SetValues,cDensity,0,cRed,0,cGreen,0,cBlue,0,cContrast,0,
					cGamma,0.0,cPSDensity,0,cPSRed,0,cPSGreen,0,cPSBlue,0,cPSContrast,0,
					cPSGamma,0.0,cGammaRed,0.0,cGammaGreen,0.0,cGammaBlue,0.0,
					cSaturation,0,cArbitraryRotation,0.0,cRotateFromDisk,0,
					cShastaHighlight,0,cShastaMidTone,0,cShastaShadow,0,
					cShadowContrast,0,cMidtoneContrast,0,cHighlightContrast,0);

	ImageEditData( SetValues,cCropX,50,cCropY,50,cCropWidth,100,cCropLength,100 );
	ImageEditData( SetValues,cSharpen,0 );
	ImageEditData( SetValue, AutoBalanceDone, 0 );

	if ( <wantAETab> == 1 )
	{
		ImageEditData( SetValues, cApplyShasta, 1 );
	}
	else if ( <wantAETab> == 0 )
	{
		ImageEditData( SetValues, cApplyShasta, 0 );
	}

	OnShasta(<wantAETab>,<updateImages>,<colorType>) ;
	
	EditDialog( Update );
	OnLutResetButton(<updateImages>);
	ShowNormalized();
}

VOID ResetAEDeltas(wantAETab, updateImages)
{
	ImageEditData( SetValues,cPSDensity,0,cPSRed,0,cPSGreen,0,cPSBlue,0,cPSContrast,0,
					cPSGamma,0.0,cShastaHighlight,0,cShastaMidTone,0,cShastaShadow,0);

	if ( <wantAETab> == 1 )
	{
		ImageEditData( SetValues, cApplyShasta, 1 );
	}
	else if ( <wantAETab> == 0 )
	{
		ImageEditData( SetValues, cApplyShasta, 0 );
	}

	OnShasta(<wantAETab>,<updateImages>) ;
	
	EditDialog( Update );
}

NUMERIC ResetImageEdits()
{
// 10/5/00 PDF
// The inclusion of this message box causes the current button having the focus in the
// edit images dialog box to lose focus.  This causes keystrokes to be lost until the
// user clicks on a button in the edit images dialog box.  

	if ( MessageBox( ~Are you sure you want to forget all current and previous changes (except crops) ?~,YESNO ) != YES )
	{ 
		return FALSE; 
	}

	// Get the color type so that we can use the value to determine what state to set the
	// various buttons to after we do the reset.
	colorType = 0;
	if ( GenCon( View,FindActiveImageThumbnailView ) )
	{
		Count = View( GetSelectedIconCount );
		if ( <Count> == 0 )
		{
			return FALSE;
		}
	
		if ( View( GetSelected,SelectedImages ) )
		{
			if ( SelectedImages( GetLast,Image ) )
			{
				colorType = Numeric( ~<$con.Image[ColorType]>~ );
			}
		}
	}

	ImageEditData( SetValue, AutoBalanceDone, 0 );
	ImageEditData( ResetCorrections );
	AlwaysResetDeltas(0,1,<colorType>);
	ImageEditData( RefreshCorrections );
	
	EditDialog( SetStatus,1,Translate( ~Reset complete~ ) );

	return TRUE;
}

VOID OnNeutralizeCheckBox()
{
	EditDialog( GetInput );

	EditDialog( SetCheck,FALSE, BalanceToAimCheckBox );
	EditDialog( SetCheck,FALSE, ClickWhiteCheckBox );
	EditDialog( SetCheck,FALSE, ClickBlackCheckBox );

	CurrentTab = EditDialog( SelectedTab,TabWindow );
	if ( <CurrentTab> != 0 )
	{
		EditDialog( SelectTab,TabWindow,0 ) ;
	}

	UpdateClickBalanceControls(-1);
	ChooseWhiteBalanceTool();
}

VOID ChooseWhiteBalanceTool()
{
	SetImageEditViewTool(WhiteBalanceTool);

	Action = STR ( GreenScreenDoc "SetTool(ClickBalance);" );
	PerformDocActions( Action );
	
}

VOID OnClickWhiteCheckBox()
{
	EditDialog( GetInput );

	EditDialog( SetCheck,FALSE, NeutralizeCheckBox );
	EditDialog( SetCheck,FALSE, BalanceToAimCheckBox );
	EditDialog( SetCheck,FALSE, ClickBlackCheckBox );

	CurrentTab = EditDialog( SelectedTab,TabWindow );
	if ( <CurrentTab> != 1 )
	{
		EditDialog( SelectTab,TabWindow,1 ) ;
	}

	UpdateClickBalanceControls(-1);
	ChooseWhiteBalanceTool();
}

VOID OnClickBlackCheckBox()
{
	EditDialog( GetInput );

	EditDialog( SetCheck,FALSE, NeutralizeCheckBox );
	EditDialog( SetCheck,FALSE, BalanceToAimCheckBox );
	EditDialog( SetCheck,FALSE, ClickWhiteCheckBox );

	CurrentTab = EditDialog( SelectedTab,TabWindow );
	if ( <CurrentTab> != 1 )
	{
		EditDialog( SelectTab,TabWindow,1 ) ;
	}

	UpdateClickBalanceControls(-1);
	ChooseWhiteBalanceTool();
}

VOID OnBalanceToAimCheckBox()
{
	EditDialog( GetInput );

	EditDialog( SetCheck,FALSE, NeutralizeCheckBox );
	EditDialog( SetCheck,FALSE, ClickWhiteCheckBox );
	EditDialog( SetCheck,FALSE, ClickBlackCheckBox );

	EditDialog( GetControlValue,BalanceToAimCheckBox,BalanceToAimChecked );

	CurrentTab = EditDialog( SelectedTab,TabWindow );
	if ( <CurrentTab> != 0 )
	{
		EditDialog( SelectTab,TabWindow,0 ) ;
	}

	UpdateClickBalanceControls(-1);
	ChooseWhiteBalanceTool();
}

VOID OnAimSelChange()
{
	AimSetup = ~~;
	EditDialog( GetControlValue, AimComboBox, AimSetup );

	if ( DefinedAndNotNULL( CurrentAimPref ) )
	{
		if ( SimilarStr(~<AimSetup>~,~<CurrentAimPref>~) )
		{
			return;
		}
	}

	CurrentAimPref = ~<AimSetup>~;
	InitClickBalanceOptions(FALSE);
}

VOID OnAimValueChange()
{
	EditDialog( GetControlValue,AimRedField,AimRedValue);
	EditDialog( GetControlValue,AimGreenField,AimGreenValue);
	EditDialog( GetControlValue,AimBlueField,AimBlueValue);

	AimRedValue = Numeric(~<AimRedValue>~);
	AimGreenValue = Numeric(~<AimGreenValue>~);
	AimBlueValue = Numeric(~<AimBlueValue>~);

	if ( <AimRedValue> > 255 )
	{
		AimRedValue = 255;
	}
	if ( <AimGreenValue> > 255 )
	{
		AimGreenValue = 255;
	}
	if ( <AimBlueValue> > 255 )
	{
		AimBlueValue = 255;
	}

	EditDialog( SetControlColor, AimColorPatch, BGColor, <AimRedValue>, <AimGreenValue>, <AimBlueValue> );
}

VOID OnSampleValueChange()
{
	EditDialog( GetControlValue,SampledValueRedField,SampledValueRedValue);
	EditDialog( GetControlValue,SampledValueGreenField,SampledValueGreenValue);
	EditDialog( GetControlValue,SampledValueBlueField,SampledValueBlueValue);

	SampledValueRedValue = Numeric(~<SampledValueRedValue>~);
	SampledValueGreenValue = Numeric(~<SampledValueGreenValue>~);
	SampledValueBlueValue = Numeric(~<SampledValueBlueValue>~);

	if ( <SampledValueRedValue> > 255 )
	{
		SampledValueRedValue = 255;
	}
	if ( <SampledValueGreenValue> > 255 )
	{
		SampledValueGreenValue = 255;
	}
	if ( <SampledValueBlueValue> > 255 )
	{
		SampledValueBlueValue = 255;
	}

	EditDialog( SetControlColor, SampledValueColorPatch, BGColor, <SampledValueRedValue>, <SampledValueGreenValue>, <SampledValueBlueValue> );
}

VOID InitClickBalanceOptions( FirstTime )
{
	Query = ~Select * From ClickBalanceAimsDef Where Name = '<CurrentAimPref>'~;

	if ( !PGenConList( AimsList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		AimsList( GetErrorDescription,0,theErr );
		Error( ~Database Query Failed: <Query>.  <theErr>~ );
		return;
	}

	if ( AimsList( GetFirst,Aim ) )
	{
		AimRedValue = Numeric(~<$pcon.Aim[RedValue]>~);
		AimGreenValue = Numeric(~<$pcon.Aim[GreenValue]>~);
		AimBlueValue = Numeric(~<$pcon.Aim[BlueValue]>~);

		EditDialog( SetControlValue,AimRedField,~<AimRedValue>~);
		EditDialog( SetControlValue,AimGreenField,~<AimGreenValue>~);
		EditDialog( SetControlValue,AimBlueField,~<AimBlueValue>~);

		EditDialog( SetControlColor, AimColorPatch, BGColor, <AimRedValue>, <AimGreenValue>, <AimBlueValue> );
	}

	if ( <FirstTime> )
	{
		EditDialog( SetControlValue,SampledValueRedField,~0~);
		EditDialog( SetControlValue,SampledValueGreenField,~0~);
		EditDialog( SetControlValue,SampledValueBlueField,~0~);
	}

	EditDialog( GetControlValue,SampledValueRedField,SampledRedValue);
	EditDialog( GetControlValue,SampledValueGreenField,SampledGreenValue);
	EditDialog( GetControlValue,SampledValueBlueField,SampledBlueValue);

	SampledRedValue = Numeric(~<SampledRedValue>~);
	SampledGreenValue = Numeric(~<SampledGreenValue>~);
	SampledBlueValue = Numeric(~<SampledBlueValue>~);

	EditDialog( SetControlColor, SampledValueColorPatch, BGColor, <SampledRedValue>, <SampledGreenValue>, <SampledBlueValue> );

	if ( <FirstTime> )
	{
		if ( GenCon( WhiteBalanceToolParameters,GetFrom,WhiteBalanceToolParameters,~[GENCONS]~ ) )
		{
			WhiteBalanceToolParameters( SetValue, ~DoNewClickBalance~, 1 );
		}
	}

	UpdateClickBalanceControls(-1);
}

VOID UpdateClickBalanceControls( updateValue )
{
	EditDialog( GetControlValue,NeutralizeCheckBox,NeutralizeChecked );
	EditDialog( GetControlValue,BalanceToAimCheckBox,BalanceToAimChecked );
	EditDialog( GetControlValue,ClickWhiteCheckBox,ClickWhiteChecked );
	EditDialog( GetControlValue,ClickBlackCheckBox,ClickBlackChecked );

	if ( <updateValue> == 0 )
	{
		EditDialog( EnableControls,FALSE,NeutralizeCheckBox );
		EditDialog( EnableControls,FALSE,BalanceToAimCheckBox );
		EditDialog( EnableControls,FALSE,ClickWhiteCheckBox );
		EditDialog( EnableControls,FALSE,ClickBlackCheckBox );

		EditDialog( EnableControls,FALSE,AimComboBox );
		EditDialog( EnableControls,FALSE,AimSetupButton );
		EditDialog( EnableControls,FALSE,AimRedLabel );
		EditDialog( EnableControls,FALSE,AimRedField );
		EditDialog( EnableControls,FALSE,AimGreenLabel );
		EditDialog( EnableControls,FALSE,AimGreenField );
		EditDialog( EnableControls,FALSE,AimBlueLabel );
		EditDialog( EnableControls,FALSE,AimBlueField );

		EditDialog( EnableControls,FALSE,SampledValuesLabel );
		EditDialog( EnableControls,FALSE,SampledValueRedLabel );
		EditDialog( EnableControls,FALSE,SampledValueRedField );
		EditDialog( EnableControls,FALSE,SampledValueGreenLabel );
		EditDialog( EnableControls,FALSE,SampledValueGreenField );
		EditDialog( EnableControls,FALSE,SampledValueBlueLabel );
		EditDialog( EnableControls,FALSE,SampledValueBlueField );
	}
	else
	{
		EditDialog( EnableControls,TRUE,NeutralizeCheckBox );
		EditDialog( EnableControls,TRUE,BalanceToAimCheckBox );
		EditDialog( EnableControls,TRUE,ClickWhiteCheckBox );
		EditDialog( EnableControls,TRUE,ClickBlackCheckBox );


		EditDialog( EnableControls,TRUE,SampledValuesLabel );
		EditDialog( EnableControls,TRUE,SampledValueRedLabel );
		EditDialog( EnableControls,TRUE,SampledValueRedField );
		EditDialog( EnableControls,TRUE,SampledValueGreenLabel );
		EditDialog( EnableControls,TRUE,SampledValueGreenField );
		EditDialog( EnableControls,TRUE,SampledValueBlueLabel );
		EditDialog( EnableControls,TRUE,SampledValueBlueField );

		if ( <BalanceToAimChecked> )
		{
			EditDialog( EnableControls,TRUE,AimComboBox );
			EditDialog( EnableControls,TRUE,AimSetupButton );
			EditDialog( EnableControls,TRUE,AimRedLabel );
			EditDialog( EnableControls,TRUE,AimRedField );
			EditDialog( EnableControls,TRUE,AimGreenLabel );
			EditDialog( EnableControls,TRUE,AimGreenField );
			EditDialog( EnableControls,TRUE,AimBlueLabel );
			EditDialog( EnableControls,TRUE,AimBlueField );
		}
		else
		{
			EditDialog( EnableControls,FALSE,AimComboBox );
			EditDialog( EnableControls,FALSE,AimSetupButton );
			EditDialog( EnableControls,FALSE,AimRedLabel );
			EditDialog( EnableControls,FALSE,AimRedField );
			EditDialog( EnableControls,FALSE,AimGreenLabel );
			EditDialog( EnableControls,FALSE,AimGreenField );
			EditDialog( EnableControls,FALSE,AimBlueLabel );
			EditDialog( EnableControls,FALSE,AimBlueField );
		}
	}
}

NUMERIC OnViewAims()
{
	Action = ACTION Doc ( ~AimsDefDoc~ OpenOnce AimsDefDoc "Init();" ); 
	return PerformActions( Action );

}

NUMERIC UpdateAimList( firstEntry )
{
	PrefsQuery = ~Select Name From ClickBalanceAimsDef Order By Name~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<PrefsQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Query Failed:\n\n<PrefsQuery>.\n\n<theErr>.~ ) ); 
	}

	Count = List( NumEntries );

	if ( !<Count> )
	{
		return EditDialog( SetStatus, Translate( ~No Aims defined.~ ) );
	}

	List( MakeStringList,AimsList,Name );

	EditDialog( SetControlFromStringList,AimComboBox,AimsList );

	if ( !IsNull( ~<CurrentAimPref>~ ) )
	{
		EditDialog( ComboBox,AimComboBox,SelectString,~<CurrentAimPref>~,-1 );
	}
	else if ( <firstEntry> )
	{
		EditDialog( ListBox,AimComboBox,select,0 );
	}

	return TRUE;
}

NUMERIC OnTabChange()
{
	tabNum = EditDialog( SelectedTab,TabWindowB );
	if ( <tabNum> == 0 )
	{
		NewDialogWidth = 785;
		NewTabWidth = 360;

		EditDialog( ControlRect,TabWindowB,GetPosition,x,y,w,l );
		EditDialog( ControlRect,TabWindowB,SetPosition,<x>,<y>,<NewTabWidth>,<l> );
	}
	else
	{
		NewDialogWidth = 995;
		NewTabWidth = 570;

		EditDialog( ControlRect,TabWindowB,GetPosition,x,y,w,l );
		EditDialog( ControlRect,TabWindowB,SetPosition,<x>,<y>,<NewTabWidth>,<l> );
	}

	EditDialog( SetWindowSize,<NewDialogWidth>,$DialogHeight );

	return TRUE;
}

NUMERIC OnCalculateClickBalance()
{
	EditDialog( GetInput );

	EditDialog( GetControlValue,SampledValueRedField,SampledRedValue);
	EditDialog( GetControlValue,SampledValueGreenField,SampledGreenValue);
	EditDialog( GetControlValue,SampledValueBlueField,SampledBlueValue);

	EditDialog( GetControlValue,NeutralizeCheckBox,NeutralizeChecked );
	EditDialog( GetControlValue,ClickWhiteCheckBox,ClickWhiteChecked );
	EditDialog( GetControlValue,ClickBlackCheckBox,ClickBlackChecked );
	EditDialog( GetControlValue,BalanceToAimCheckBox,BalanceToAimChecked );

	AimRedValue = 0;
	AimGreenValue = 0;
	AimBlueValue = 0;

	if ( Numeric(~<NeutralizeChecked>~) )
	{
		AimRedValue = 128;
		AimGreenValue = 128;
		AimBlueValue = 128;
	}
	else if ( Numeric(~<BalanceToAimChecked>~) )
	{
		EditDialog( GetControlValue,AimRedField,AimRedValue);
		EditDialog( GetControlValue,AimGreenField,AimGreenValue);
		EditDialog( GetControlValue,AimBlueField,AimBlueValue);

		if ( SimilarStr(~<AimRedValue>~,~~ ) || SimilarStr(~<AimGreenValue>~,~~) || SimilarStr(~<AimBlueValue>~,~~) )
		{
			return Warning(~RGB aim values must be specified.~);
		}

		if ( Numeric(~<AimRedValue>~) > 255 || Numeric(~<AimGreenValue>~) > 255 || Numeric(~<AimBlueValue>~) > 255 )
		{
			return Warning(~RGB aim values must be a value from 0 to 255.~);
		}
	}

	if ( SimilarStr(~<SampledRedValue>~,~~ ) || SimilarStr(~<SampledGreenValue>~,~~) || SimilarStr(~<SampledBlueValue>~,~~) )
	{
		return Warning(~RGB sample values must be specified.~);
	}


	if ( Numeric(~<SampledRedValue>~) > 255 || Numeric(~<SampledGreenValue>~) > 255 || Numeric(~<SampledBlueValue>~) > 255 )
	{
		return Warning(~RGB sample values must be a value from 0 to 255.~);
	}

	RenderingLut = ~DP2_10_lut~;
	if ( ~<ClickedImagePath>~ != ~~ )
	{
		if ( ImageCorrections( GetCurrentCorrections,~<ClickedImagePath>~,theCorrections ) )
		{
			RenderingLut = ~<$con.theCorrections[Lut8To12]>~;
		}
	}

	WaitCursor( Begin );

	redSlider = 0;
	greenSlider = 0;
	blueSlider = 0;

	// Add function call to calculate DRGB values here.
	if ( !Lut( LutObject ) )
	{
		return FALSE;
	}

	if ( Numeric(~<NeutralizeChecked>~) )
	{
		result = LutObject( ClickNeutralize,<SampledRedValue>,<SampledGreenValue>,<SampledBlueValue>,~<RenderingLut>~,
					redSlider,greenSlider,blueSlider );
		if ( <result> )
		{
			ImageEditData( SetValues,cRed,<redSlider>,cGreen,<greenSlider>,cBlue,<blueSlider> );

			EditDialog( Update );
			UpdateAffectedImages();
			EditDialog( SetStatus,1,Translate( ~Click balance neutralize complete~ ) );
		}
	}
	else if ( Numeric(~<BalanceToAimChecked>~) )
	{
		result = LutObject( ClickRGB,<AimRedValue>,<AimGreenValue>,<AimBlueValue>,
					<SampledRedValue>,<SampledGreenValue>,<SampledBlueValue>,~<RenderingLut>~,
					redSlider,greenSlider,blueSlider );
		if ( <result> )
		{
			ImageEditData( SetValues,cRed,<redSlider>,cGreen,<greenSlider>,cBlue,<blueSlider> );

			EditDialog( Update );
			UpdateAffectedImages();
			EditDialog( SetStatus,1,Translate( ~Click balance RGB complete~ ) );
		}
	}
	else if ( Numeric(~<ClickWhiteChecked>~) )
	{
		//debug(1);
		currentHighlightValue = Numeric(~<$con.ImageEditData[cHighlightContrast]>~);
		currentMidtoneValue = Numeric(~<$con.ImageEditData[cMidtoneContrast]>~);
		currentShadowValue = Numeric(~<$con.ImageEditData[cShadowContrast]>~);
		result = LutObject( ClickWhite,<SampledRedValue>,<SampledGreenValue>,<SampledBlueValue>,~<RenderingLut>~,
			<currentHighlightValue>,<currentMidtoneValue>,<currentShadowValue>,
			highlightSlider,midtoneSlider,shadowSlider );
		if ( <result> )
		{
			//ImageEditData( SetValues,cHighlightContrast,<contrastSlider> );
			ImageEditData( SetValues,cHighlightContrast,<highlightSlider>,cMidtoneContrast,<midtoneSlider>,cShadowContrast,<shadowSlider> );

			EditDialog( Update );
			UpdateAffectedImages();
			EditDialog( SetStatus,1,Translate( ~Click white complete~ ) );
		}

		if ( !<result> )
		{
			//ImageEditData( SetValues,cHighlightContrast,<contrastSlider> );

			//EditDialog( Update );
			//UpdateAffectedImages();
			EditDialog( SetStatus,1,Translate( ~Click white failed. Sample value too dark.~ ) );
		}
	}
	else if ( Numeric(~<ClickBlackChecked>~) )
	{
		//debug(1);
		currentHighlightValue = Numeric(~<$con.ImageEditData[cHighlightContrast]>~);
		currentMidtoneValue = Numeric(~<$con.ImageEditData[cMidtoneContrast]>~);
		currentShadowValue = Numeric(~<$con.ImageEditData[cShadowContrast]>~);
		result = LutObject( ClickBlack,<SampledRedValue>,<SampledGreenValue>,<SampledBlueValue>,~<RenderingLut>~,
			<currentHighlightValue>,<currentMidtoneValue>,<currentShadowValue>,
			highlightSlider,midtoneSlider,shadowSlider );
		if ( <result> )
		{
			//ImageEditData( SetValues,cShadowContrast,<contrastSlider> );
			ImageEditData( SetValues,cHighlightContrast,<highlightSlider>,cMidtoneContrast,<midtoneSlider>,cShadowContrast,<shadowSlider> );

			EditDialog( Update );
			UpdateAffectedImages();
			EditDialog( SetStatus,1,Translate( ~Click black complete~ ) );
		}

		if ( !<result> )
		{
			//ImageEditData( SetValues,cShadowContrast,<contrastSlider> );

			//EditDialog( Update );
			//UpdateAffectedImages();
			EditDialog( SetStatus,1,Translate( ~Click black failed. Sample value too light.~ ) );
		}
	}

	WaitCursor( End );
	return TRUE;
}

VOID OnClickBalance( Path,x,y,x2,y2,RedValue,GreenValue,BlueValue )
{
	ClickedImagePath = ~<Path>~;

	RedValue = Numeric(~<RedValue>~);
	GreenValue = Numeric(~<GreenValue>~);
	BlueValue = Numeric(~<BlueValue>~);

	EditDialog( SetControlValue,SampledValueRedField,~<RedValue>~);
	EditDialog( SetControlValue,SampledValueGreenField,~<GreenValue>~);
	EditDialog( SetControlValue,SampledValueBlueField,~<BlueValue>~);

	EditDialog( SetControlColor, SampledValueColorPatch, BGColor, <RedValue>, <GreenValue>, <BlueValue> );

	OnCalculateClickBalance();
}

NUMERIC OnViewSbaPreferences()
{
	Action = ACTION Doc ( ~DSbaPrefsDefDoc~ OpenOnce DSbaPrefsDefDoc "Init();" ); 
	return PerformActions( Action );

}

NUMERIC UpdateAutoBalList( firstEntry )
{
	PrefsQuery = ~Select Name From DSbaPrefsDef Order By Name~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<PrefsQuery>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( ~Query Failed:\n\n<PrefsQuery>.\n\n<theErr>.~ ) ); 
	}

	Count = List( NumEntries );

	if ( !<Count> )
	{
		return EditDialog( SetStatus, Translate( ~No Preferences defined.~ ) );
	}

	List( MakeStringList,PrefsList,Name );

	EditDialog( SetControlFromStringList,AutoBalComboBox,PrefsList );

	if ( !IsNull( ~<DefaultAutoBalPref>~ ) )
	{
		EditDialog( ComboBox,AutoBalComboBox,SelectString,~<DefaultAutoBalPref>~,-1 );
	}
	else if ( <firstEntry> )
	{
		EditDialog( ListBox,AutoBalComboBox,select,0 );
	}

	return TRUE;
}

NUMERIC	UpdateSBALevel( level )
{
	EditDialog( GetInput );

	if ( <level> == 0 )
	{
		EditDialog(SetCheck, TRUE, ColorDensityButton);
		EditDialog(SetCheck, FALSE, DensityOnlyButton);
		EditDialog(SetCheck, FALSE, ColorOnlyButton);

		EditDialog(Save, ColorDensityButton);
	}
	else if ( <level> == 1 )
	{
		EditDialog(SetCheck, FALSE, ColorDensityButton);
		EditDialog(SetCheck, FALSE, DensityOnlyButton);
		EditDialog(SetCheck, TRUE, ColorOnlyButton);

		EditDialog(Save, ColorOnlyButton);
	}
	else if ( <level> == 16 )
	{
		EditDialog(SetCheck, FALSE, ColorDensityButton);
		EditDialog(SetCheck, TRUE, DensityOnlyButton);
		EditDialog(SetCheck, FALSE, ColorOnlyButton);

		EditDialog(Save, DensityOnlyButton);
	}
	else
	{
		return FALSE;
	}
	
	return TRUE;
}


VOID SetAutoBalMode( level, shiftState, altState, FromButton )
{
	ApplyShasta = <gCurrentTab> ;
	if ( <ApplyShasta> == 1 )
	{
		return;
	}

	if ( <FromButton> )
	{
		ImageEditData( SetValues,SBALevel,~<level>~ );
	}
	else
	{
		if ( <shiftState> )	// Density
		{
			ImageEditData( SetValues,SBALevel,16 );
		}
		else if ( <altState> ) // RGB
		{
			ImageEditData( SetValues,SBALevel,1 );
		}
		else		// DRGB
		{
			ImageEditData( SetValues,SBALevel,0 );
		}
	}
}


NUMERIC AutoBalance( FromButton,FromShortcut )
{
	ApplyShasta = <gCurrentTab> ;
	if ( <ApplyShasta> == 1 )
	{
		return TRUE;
	}

	count = NumSelectedImages();

	if ( <count> > 1 )
	{
		return Warning( Translate(~You should select the one image you wish to auto balance~ ) );
	}
	else if ( <count> == 0 )
	{
		if (!AskForCurrentImageData( ~AutoBalanceImage~,~<FromButton>~ ) )
		{
			return Warning( Translate(~You should select the one image you wish to auto balance~ ) );
		}

		return TRUE;
	}

	if ( GenCon( View,FindActiveImageThumbnailView ) )
	{ 
		if ( View( IsThumbNailView ) && (~<$con.View[ViewDataType]>~ == ~Image~) )
		{
			View( GetSelected,SelectedImages );
		}
	}

	success = SelectedImages( GetNext, Image );

	if ( !<FromButton> )
	{
		if ( ~<$con.Image[AutoBalance]>~ != ~1~ )
		{
			EditDialog( SetStatus,1,Translate( ~Auto balance previously completed~ ) );
			return FALSE;
		}
	}

	if ( <success> )
	{
		if ( Numeric( ~<$con.Image[ColorType]>~ ) > 2 )
		{
			if ( !<FromShortcut> )
			{
				Warning( ~The selected Image is Spot color or Sepia. Auto Balance cannot be applied. Please select only color or BW images for Auto Balance.~ );
			}
			EditDialog( SetStatus,1,Translate( ~Sepia or spot color - auto balance cannot be applied~ ) );
			return FALSE;
		}

		return RunAutoBalance(  ~<$con.Image[OrderID]>~, 
								~<$con.Image[Roll]>~, 
								~<$con.Image[Frame]>~, 
								~<$con.Image[ICCProfile]>~, 
								~<$con.Image[Path]>~,
								Numeric( ~<$con.Image[ColorType]>~ ) );
	}

	return FALSE;
}




NUMERIC AutoBalanceImage( FromButton,FromShortcut,Order,Roll,Frame )
{
	count = NumSelectedImages();

	if ( ~<Order>~ == ~~  ||
		 ~<Roll>~  == ~~  ||
		 ~<Frame>~ == ~~    )
	{
		return Warning( Translate(~You should select the one image you wish to auto balance~ ) );
	}

	ICCProfile	= ~<$con.Image[ICCProfile]>~ ;
	Path		= ~<$con.Image[Path]>~ ;
	AutoBalance = ~<$con.Image[AutoBalance]>~ ;
	ColorType	= ~<$con.Image[ColorType]>~ ;

	if ( !<FromButton> )
	{
		if ( ~<AutoBalance>~ != ~1~ )
		{
			EditDialog( SetStatus,1,Translate( ~Auto balance previously completed~ ) );
			return FALSE;
		}
	}

	if ( Numeric( ~<ColorType>~ ) > 2 )
	{
		if ( !<FromShortcut> )
		{
			Warning( ~The selected Image is Spot color or Sepia. Auto Balance cannot be applied. Please select only color or BW images for Auto Balance.~ );
		}
		EditDialog( SetStatus,1,Translate( ~Sepia or Spot Color - Auto balance cannot be applied~ ) );
		return FALSE;
	}

	EditDialog( SetStatus,1,Translate( ~Auto balancing image~ ) );
	return RunAutoBalance( ~<Order>~, ~<Roll>~, ~<Frame>~, ~<ICCProfile>~, ~<Path>~, <ColorType> );
}

NUMERIC RunAutoBalance(Order,Roll,Frame,ICCProfile,Path,ColorType)
{
	WaitCursor( Begin );
	SbaSetup = ~~;
	EditDialog( GetControlValue, AutoBalComboBox, SbaSetup );

	SbaInit();

	result = FALSE;

	thumbnailImage = ~~;
	embeddedProfile = ~~;
	embeddedProfileChecked = FALSE;

	den		= 0;
	red		= 0;
	green	= 0;
	blue	= 0;

	if ( GenCon( View,FindActiveImageThumbnailView ) )
	{
		View( GetThumbnailImage,~<Path>~,thumbnailImage,embeddedProfile );
		embeddedProfileChecked = TRUE;
	}

	SBALevel = ~<$con.ImageEditData[SBALevel]>~;
	result = BalanceImage( thumbnailImage,~<SbaSetup>~,~<SBALevel>~,
							~<Order>~,~<Roll>~,~<Frame>~,~<Path>~,~<ICCProfile>~,
							~<embeddedProfile>~,~<embeddedProfileChecked>~,<ColorType> );

	if ( <result> )
	{
		GetSbaSliders( den,red,green,blue );
		ImageEditData( SetValues,cDensity,<den>,cRed,<red>,cGreen,<green>,cBlue,<blue>,AutoBalanceDone,TRUE );

		EditDialog( Update );
		UpdateAffectedImages();
		EditDialog( SetStatus,1,Translate( ~Auto balance complete~ ) );
	}
	else
	{
		ColorType = GetColorType();
		if ( Numeric( ~<ColorType>~ ) > 2 )
		{
			EditDialog( SetStatus,1,Translate( ~Sepia or Spot Color - Auto balance cannot be applied~ ) );
		}
	}

	WaitCursor( End );
	return TRUE;
}


NUMERIC NumSelectedImages()
{
	if ( GenCon( View,FindActiveImageThumbnailView ) )
	{ 
		if ( View( IsThumbNailView ) && (~<$con.View[ViewDataType]>~ == ~Image~) )
		{
			if ( View( GetSelected,SelectedImages ) )		
			{ 
				return SelectedImages(ChildCount);
			}
		}
	}

	return 0;
}



NUMERIC NoSelectedImages()
{
	EditDialog( SetStatus,1,Translate( ~There are no selected images~ ) );
	return FALSE;
} 


VOID CloseImageEditDialog()
{
	EditDialog( GetInput );
	SetWorkStationSettings( ~<$Job.Title>~,ColorCorrectionInputDevice,~<$con.ImageEditData[ColorCorrectionInputDevice]>~,TRUE );
	SetWorkStationSettings( ~<$Job.Title>~,SerialInputPort,~<$con.ImageEditData[SerialInputPort]>~,TRUE );
	SetUserSettings( ~<$Job.Title>~,UseNumlock,~<$con.ImageEditData[UseNumlock]>~,TRUE );
	SetUserSettings( ~<$Job.Title>~,DontResetOnSave,~<$con.ImageEditData[DontResetOnSave]>~,TRUE );
	SetUserSettings( ~<$Job.Title>~,KeepKeyboardFocus,~<$con.ImageEditData[KeepKeyboardFocus]>~,TRUE );
	SetUserSettings( ~<$Job.Title>~,IndependentAdjustments,~<$con.ImageEditData[IndependentAdjustments]>~,TRUE );
	SetUserSettings( ~<$Job.Title>~,AutomaticAutoBal,~<$con.ImageEditData[AutomaticAutoBal]>~,TRUE );
	SetWorkStationSettings( ~Analyzer~, ~DefaultAutoBalPref~, ~<$con.ImageEditData[AutoBalanceSetup]>~, TRUE );
	SetWorkStationSettings( ~Analyzer~, ~DefaultAimPref~, ~<$con.ImageEditData[AimSetup]>~, TRUE );

	ImageEditDialog( GetWindowPosition,Left,Top,Right,Bottom );

	top -= 78;  left -= 4;

	SetUserSettings( ~<$Job.Title>~,WindowPosition,~<left> <top>~,TRUE );

	CloseInputDevice();

	CloseColorPro();

	CancelImageEdits(FALSE,TRUE);

	KillTimer( 0 );
	EditDialog( End );

	if ( Defined( DImageSba ) )
	{
		ForgetGlobal( DImageSba );
	}

	Keyboard( UnHook,AllowNumlock );

	if ( GenCon( WhiteBalanceToolParameters,GetFrom,WhiteBalanceToolParameters,~[GENCONS]~ ) )
	{
		WhiteBalanceToolParameters( SetValue, ~DoNewClickBalance~, 0 );
	}

	Exit();
}


NUMERIC ReApplyUpdates()
{
	EditDialog( SetStatus,1,~Previous balance applied~ );
	return UpdateAffectedImages();
}



NUMERIC ApplyUpdates()
{
	return UpdateAffectedImages();
}



NUMERIC ViewChanges()
{
	ImageEditDataZero( UpdateCorrections );
	EditDialog( SetStatus,1,~Without current balance~ );

	Action = ~ReApplyBalance();~;
	return QueueContentsAfter( Action,~500~ );
}

NUMERIC ReApplyBalance()		
{
	EditDialog( SetStatus,1,~With current balance~ );

	return UpdateAffectedImages();
}


NUMERIC UpdateAffectedImages()		// APPLIES THE MOST RECENT DIALOG CHANGE TO THE AFFECTED IMAGES
{
	KillTimer( 0 );

	//RefreshLut();

	return ImageEditData( UpdateCorrections );
}


VOID GetProfiles( Type,Control )
{
	Query = ~Select * From Profiles Where Type = '<Type>'~;

	if ( !PGenConList( ProfilesList,Connect,Cursor,Forward,QUERY,~<Query>~ ) )
	{ 
		ProfilesList( GetErrorDescription,0,theErr );
		Error( ~Database Query Failed: <Query>.  <theErr>~ ); 
	}

	ProfilesList( MakeStringList,<Type>Profiles,Name );

	Global( <Type>Profiles );
}


VOID EditImages()	// BRINGS UP THE DIALOG 
{
	if ((~<$App.Name>~ !=~DP1.exe~) && (!GetUserPermissions( ImageEditing ) ))
	{
		Warning( Translate( ~You don't have permission to edit images.  See your administrator~ ) );
		Exit();
	}

	if ( !Defined(EditDialog) )
	{
		GetProfiles( Output,OutputProfileComboBox );
		GetProfiles( Input,InputProfileComboBox );
		GenDlg( EditDialog,Definition,ImageEditDialog,Data,ImageEditData,Document,$Doc.This,New,Temporary );
		
		EditDialog( SetControlFromStringList,OutputProfileComboBox,OutputProfiles,Selection,Update );
		EditDialog( SetControlFromStringList,InputProfileComboBox,InputProfiles,Selection,Update );

		Global( EditDialog );
	}

	OnShasta(0,0) ;
				
	ReOpen();
}

VOID ReOpen()
{
	if ( EditDialog( Show,NORMALSTATE ) )
	{
		EditDialog( GetWindowPlacement,x,y,w,l );

		PinOnScreen( 0,x,y,<w>,<l> );

		EditDialog( SetWindowPosition,<x>,<y> );

		EditDialog( SetWindowOrder,Top,SetFocus );
	}
}


NUMERIC OpenInputDevice( Port )
{
	ForgetGlobal( InputDevice );
	Device( InputDevice );
	Global( InputDevice );

	if ( !InputDevice( Name,Com<Port>,Access,ReadWrite,Attributes,OVERLAPPED,Open ) )
	{
		return Warning( Translate( ~Could not open serial port <Port>~ ) );
	}

	if ( !InputDevice( GetCommParameters, parameters ) )
	{
		return Warning( Translate( ~Could not get parameters for serial port <Port>~ ) );
	}

	// REM - ByteSize 4 5 6 7 8 = 4 5 6 7 8
	// REM - Parity   0 1 2 3 4 = no, odd, even, mark, space
	// REM - StopBits 0 1 2     = 1 1.5 2

	parameters( SetValues,BaudRate,9600,ByteSize,8,Parity,0,StopBits,0 ); 

	if ( !InputDevice( SetCommParameters,parameters ) )
	{
		return Warning( Translate( ~Could not set parameters for serial port <Port>~ ) );
	}

	if ( !InputDevice( SetupCommDevice,1024,1024 ) )
	{
		return Warning( Translate( ~Could not set up parameters on serial port <Port>~ ) );
	}

	InputDevice( OnReadComplete,SerialInputReceived );
	InputDevice( SerialReadTermination,~chr(0x0D)~,1 );
	InputDevice( StartSerialReadThread );

	InputDevice( WriteString,0,~m~ );	// TURN THE LIGHT OFF

	return TRUE;
}


VOID CloseInputDevice()
{
	if ( Defined( InputDevice ) )
	{
		InputDevice( Close );
		ForgetGlobal( InputDevice );
	}
}

NUMERIC OpenColorPro()
{
	ForgetGlobal( ColorProDevice );
	ColorPro( ColorProDevice );
	Global( ColorProDevice );

	if ( !ColorProDevice( Open ) )
	{
		return Warning( Translate( ~Could not connect to ColorPro II device.~ ) );
	}

	ColorProDevice( SetColorProAction, ColorProCallBack );
	//ColorProDevice( SetDebug, 1 );

	return TRUE;
}


VOID CloseColorPro()
{	
	if ( Defined( ColorProDevice ) )
	{
		ColorProDevice( Close );
		ForgetGlobal( ColorProDevice );
	}
}

VOID ColorProCallBack( control, value )
{
	theChar = ~~;
	if ( SimilarStr( ~<control>~,~Button1~ ) )
	{
		return;
	}
	else if ( SimilarStr( ~<control>~,~Button2~ ) )
	{
		theChar = ~A~;
	}
	else if ( SimilarStr( ~<control>~,~Button3~ ) )
	{
		theChar = ~N~;
	}
	else if ( SimilarStr( ~<control>~,~Button4~ ) )
	{
		theChar = ~P~;
	}
	else if ( SimilarStr( ~<control>~,~Button5~ ) )
	{
		theChar = ~M~;
	}
	else if ( SimilarStr( ~<control>~,~Button6~ ) )
	{
		return;
	}
	else if ( SimilarStr( ~<control>~,~Encoder1~ ) )
	{
		if ( <value> > 0 )
		{
			theChar = ~D~;
		}
		else
		{
			theChar = ~d~;
		}
	}
	else if ( SimilarStr( ~<control>~,~Encoder2~ ) )
	{
		if ( <value> > 0 )
		{
			theChar = ~R~;
		}
		else
		{
			theChar = ~r~;
		}
	}
	else if ( SimilarStr( ~<control>~,~Encoder3~ ) )
	{
		if ( <value> > 0 )
		{
			theChar = ~G~;
		}
		else
		{
			theChar = ~g~;
		}
	}
	else if ( SimilarStr( ~<control>~,~Encoder4~ ) )
	{
		if ( <value> > 0 )
		{
			theChar = ~B~;
		}
		else
		{
			theChar = ~b~;
		}
	}
	else
	{
		return;
	}

	if ( OnStr( ~<theChar>~,~N~,~OnNextButton()~,~P~,~OnPrevButton()~,~A~,~AcceptImageEdits(-1,FALSE,FALSE)~,~M~,~ToggleWheelMan()~ ) )
	{
		return;
	}

	if ( CroppingMode() )
	{
		ProcessCrop( ~<theChar>~ );
	}
	else
	{
		CurrentNumber = ~~;

		if ( KeyState( CONTROL ) )
		{
			OnStr(~<theChar>~,
					 ~d~,~IncrementValue(cContrast,<value>)~,~D~,~IncrementValue(cContrast,<value>)~,
					 ~r~,~IncrementValue(cGamma,<value> * .05)~,~R~,~IncrementValue(cGamma,<value> * .05)~,
					 ~g~,~IncrementValue(cSaturation,<value>)~,~G~,~IncrementValue(cSaturation,<value>)~,
					 ~b~,~IncrementRotateFromDisk(<value> * 90)~,~B~,~IncrementRotateFromDisk(<value> * 90)~ );
		}
		else 
		{
			OnStr(~<theChar>~,
					 ~d~,~AdjustValue(cDensity,<value>)~,~D~,~AdjustValue(cDensity,<value>)~,
					 ~r~,~AdjustValue(cRed,<value>)~,~R~,~AdjustValue(cRed,<value>)~,
					 ~g~,~AdjustValue(cGreen,<value>)~,~G~,~AdjustValue(cGreen,<value>)~,
					 ~b~,~AdjustValue(cBlue,<value>)~,~B~,~AdjustValue(cBlue,<value>)~ );
		}

		return;
	}
}

// Light Off is Color Manipulation Mode
// Light On is Cropping Mode

NUMERIC ModeButtonOnWheelman()
{
	InputDevice( WriteString,0,<WheelManMode> ? ~M~ : ~m~ );

	return TRUE;
}


VOID OnSwitchModesButton()
{
	ToggleWheelMan();
}

WheelManMode = 0; 

NUMERIC CurrentlyCropping()
{
	return <WheelManMode> != 0;
}


NUMERIC CroppingMode()
{
	return <WheelManMode>;
}

VOID ToggleWheelMan()
{
	WheelManMode = !<WheelManMode>;

	if ( Defined( InputDevice ) )
	{
		InputDevice( WriteString,0,<WheelManMode> ? ~M~ : ~m~ );
	}

	EditDialog( SetStatus,2,<WheelManMode> ? ~Crop~ : ~Color~ );
}


InputCount = 0;

NUMERIC SerialInputReceived( theChar )
{
	EditDialog( GetControlValue,DiagnosticsCheckBox,WantDiagnostics );

	if ( <WantDiagnostics> )
	{
		Code = Asc(~<theChar>~); HexCode = Format( ~<Code>~,~%02lx~ );
		return EditDialog( SetStatus,1,~<++InputCount>)  Received '<theChar>'   <Code>/<HexCode>~ );
	}

	ReturnOnSuccess( strlen( ~<theChar>~ ) > 1 ); // < 1 or > 125

	if ( OnStr( ~<theChar>~,~N~,~OnNextButton()~,~P~,~OnPrevButton()~,~A~,~AcceptImageEdits(-1,FALSE,FALSE)~,~M~,~ToggleWheelMan()~ ) )
	{
		return TRUE;
	}

	if ( !CroppingMode() )
	{
		KillTimer( 0 );

		CurrentNumber = ~~;

		if ( !KeyState( CONTROL ) )
		{
			OnStr(~<theChar>~,
					 ~d~,~AdjustValue(cDensity,-1)~,~D~,~AdjustValue(cDensity,1)~,
					 ~r~,~AdjustValue(cRed,-1)~,~R~,~AdjustValue(cRed,1)~,
					 ~g~,~AdjustValue(cGreen,-1)~,~G~,~AdjustValue(cGreen,1)~,
					 ~b~,~AdjustValue(cBlue,-1)~,~B~,~AdjustValue(cBlue,1)~ );
		}
		else 
		{
			OnStr(~<theChar>~,
					 ~d~,~IncrementValue(cContrast,-1)~,~D~,~IncrementValue(cContrast,1)~,
					 ~r~,~IncrementValue(cGamma,-.05)~,~R~,~IncrementValue(cGamma,.05)~,
					 ~g~,~IncrementValue(cSaturation,-1)~,~G~,~IncrementValue(cSaturation,1)~,
					 ~b~,~IncrementRotateFromDisk(-90)~,~B~,~IncrementRotateFromDisk(90)~ );
		}

		return TRUE;
	}

	KillTimer( 0 );

	ProcessCrop( ~<theChar>~ );

	return TRUE;

	Action = STR ( ProcessCrop( ~<theChar>~ ) );

	return QueueContentsAfter( Action,2 );
}

VOID ProcessCrop( theChar )
{
	angle = KeyState( Control ) ? .05 : .5;

	OnStr(~<theChar>~,
				 ~d~,~OpenImageToCrop(ExpandCrop)~,~D~,~OpenImageToCrop(ShrinkCrop)~,
				 ~r~,~OpenImageToCrop(ShiftCropRight)~,~R~,~OpenImageToCrop(ShiftCropLeft)~,
				 ~g~,~OpenImageToCrop(ShiftCropUp)~,~G~,~OpenImageToCrop(ShiftCropDown)~,
				 ~b~,~IncrementValue(cArbitraryRotation,-<angle>)~,~B~,~IncrementValue(cArbitraryRotation,<angle>)~ );
}

NUMERIC MakeGammaAdjustment( which,amount )
{
	if ( SimilarStr( ~<Which>~,~cRed~ ) )
	{
		return IncrementValue(cGammaRed,(<amount> < 0)  ? -.05 : .05);
	}
	else if ( SimilarStr( ~<Which>~,~cGreen~ ) )
	{
		return IncrementValue(cGammaGreen,(<amount> < 0) ? -.05 : .05);
	}
	else if ( SimilarStr( ~<Which>~,~cBlue~ ) )
	{
		return IncrementValue(cGammaBlue,(<amount> < 0) ? -.05 : .05);
	}
	else if ( SimilarStr( ~<Which>~,~cDensity~ ) )
	{
		ApplyShasta = <gCurrentTab> ;
		if ( <ApplyShasta> == 1 )
		{
			return IncrementValue(cPSGamma,(<amount> < 0) ? -.05 : .05);
		}
		else
		{
			return IncrementValue(cGamma,(<amount> < 0) ? -.05 : .05);
		}
	}

	return TRUE;

}

NUMERIC AdjustValue( which,amount )
{
	ApplyShasta = 0 ;
	if ( <gCurrentTab> == 1 )
	{	
		ApplyShasta = 1 ;
	}

//	Log( Session, ~EditImagesDoc3.AdjustValue: Which: <which> Amount: <amount> ApplyShasta: <ApplyShasta>~ ) ;

	if ( KeyState( Alt ) )		{ return MakeGammaAdjustment( ~<which>~,~<amount>~ ); }

	if ( Numeric(~<$con.ImageEditData[IndependentAdjustments]>~) )
	{
		if ( <ApplyShasta> )
		{
			if ( SimilarStr( ~<Which>~,~cDensity~ ) )	{ return IncrementValue( ~cPSDensity~,	~<amount>~ ) ; }
			if ( SimilarStr( ~<Which>~,~cRed~ ) )		{ return IncrementValue( ~cPSRed~,		~<amount>~ ) ; }
			if ( SimilarStr( ~<Which>~,~cGreen~ ) )		{ return IncrementValue( ~cPSGreen~,	~<amount>~ )  ; }
			if ( SimilarStr( ~<Which>~,~cBlue~ ) )		{ return IncrementValue( ~cPSBlue~,		~<amount>~ ) ; }
			if ( SimilarStr( ~<Which>~,~cContrast~ ) )	{ return IncrementValue( ~cPSContrast~,	~<amount>~ ) ; }
			if ( SimilarStr( ~<Which>~,~cGamma~ ) )		{ return IncrementValue( ~cPSGamma~,	~<amount>~ ) ; }

			if ( <amount> > 0 && <amount> < 1 )		{ amount =  1 ; }
			if ( <amount> < 0 && <amount> > -1 )	{ amount = -1 ; }
			if ( SimilarStr( ~<Which>~,~cSaturation~ ) ){ return IncrementValue( ~cShastaHighlight~,		~<amount>~ ) ; }
			if ( SimilarStr( ~<Which>~,~cSharpen~ ) )	{ return IncrementValue( ~cShastaMidTone~,	~<amount>~ ) ; }
			if ( SimilarStr( ~<Which>~,~cArbitraryRotation~ ) ){ return IncrementValue( ~cShastaShadow~,	~<amount>~ ) ; }
		}
		else
		{
			return IncrementValue( ~<Which>~,~<Amount>~ ); 
		}
	}

	if ( ~<CurrentNumber>~ == ~~ )
	{
		CurrentNumber = ~1~;
	}
	else if ( ~<CurrentNumber>~ == ~-~ )
	{
		return EditDialog( SetStatus,1,~You are still entering a negative number~ );
	}

	if ( SimilarStr( ~<Which>~,~cRed~ ) ||  SimilarStr( ~<Which>~,~cPSRed~ ) )
	{
		r = <amount>; g = -<amount>/2 * <CurrentNumber>; b = -<amount>/2 * <CurrentNumber>;
		
		if ( <ApplyShasta> )
		{
			ChangeValue(cPSGreen,<g>);
			ChangeValue(cPSBlue,<b>);
			return IncrementValue(cPSRed,<r>);
		}
		else
		{
			ChangeValue(cGreen,<g>);
			ChangeValue(cBlue,<b>);
			return IncrementValue(cRed,<r>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cGreen~ ) ||  SimilarStr( ~<Which>~,~cPSGreen~ ) )
	{
		g = <amount>; r = -<amount>/2 * <CurrentNumber>; b = -<amount>/2 * <CurrentNumber>;
		
		if ( <ApplyShasta> )
		{
			ChangeValue(cPSBlue,<b>);
			ChangeValue(cPSRed,<r>);
			return IncrementValue(cPSGreen,<g>);
		}
		else
		{
			ChangeValue(cBlue,<b>);
			ChangeValue(cRed,<r>);
			return IncrementValue(cGreen,<g>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cBlue~ ) ||  SimilarStr( ~<Which>~,~cPSBlue~ ) )
	{
		b = <amount>; g = -<amount>/2 * <CurrentNumber>; r = -<amount>/2 * <CurrentNumber>;
		
		if ( <ApplyShasta> )
		{
			ChangeValue(cPSRed,<r>);
			ChangeValue(cPSGreen,<g>);
			return IncrementValue(cPSBlue,<b>);
		}
		else
		{
			ChangeValue(cRed,<r>);
			ChangeValue(cGreen,<g>);
			return IncrementValue(cBlue,<b>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cDensity~ ) ||  SimilarStr( ~<Which>~,~cPSDensity~ ) )
	{
		if ( <ApplyShasta> )
		{
			return IncrementValue(cPSDensity,<amount>);
		}
		else
		{
			return IncrementValue(cDensity,<amount>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cContrast~ ) ||  SimilarStr( ~<Which>~,~cPSContrast~ ) )
	{
		if ( <ApplyShasta> )
		{
			return IncrementValue(cPSContrast,<amount>);
		}
		else
		{
			return IncrementValue(cContrast,<amount>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cGamma~ ) ||  SimilarStr( ~<Which>~,~cPSGamma~ ) )
	{
		if ( <ApplyShasta> )
		{
			return IncrementValue(cPSGamma,<amount>);
		}
		else
		{
			return IncrementValue(cGamma,<amount>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cSaturation~ ) )
	{
		if ( <amount> > 0 && <amount> < 1 )		{ amount =  1 ; }
		if ( <amount> < 0 && <amount> > -1 )	{ amount = -1 ; }
		if ( <ApplyShasta> )
		{
			return IncrementValue(cShastaHighlight,<amount>);
		}
		else
		{
			return IncrementValue(cSaturation,<amount>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cSharpen~ ) )
	{
		if ( <amount> > 0 && <amount> < 1 )		{ amount =  1 ; }
		if ( <amount> < 0 && <amount> > -1 )	{ amount = -1 ; }
		if ( <ApplyShasta> )
		{
			return IncrementValue(cShastaMidTone,<amount>);
		}
		else
		{
			return IncrementValue(cSharpen,<amount>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cArbitraryRotation~ ) )
	{
		if ( <amount> > 0 && <amount> < 1 )		{ amount =  1 ; }
		if ( <amount> < 0 && <amount> > -1 )	{ amount = -1 ; }
		if ( <ApplyShasta> )
		{
			return IncrementValue(cShastaShadow,<amount>);
		}
		else
		{
			return IncrementValue(cArbitraryRotation,<amount>);
		}
	}
	else if ( SimilarStr( ~<Which>~,~cShadowContrast~ ) )
	{
		return IncrementValue(cShadowContrast,<amount>);
	}
	else if ( SimilarStr( ~<Which>~,~cMidtoneContrast~ ) )
	{
		return IncrementValue(cMidtoneContrast,<amount>);
	}
	else if ( SimilarStr( ~<Which>~,~cHighlightContrast~ ) )
	{
		return IncrementValue(cHighlightContrast,<amount>);
	}

	return IncrementValue( ~<Which>~,~<Amount>~ );
}


VOID OnPortChange()
{
	CloseInputDevice();

	EditDialog( GetInput );
	if ( IsNumeric( ~<$con.ImageEditData[SerialInputPort]>~ ) )
	{
		OpenInputDevice( ~<$con.ImageEditData[SerialInputPort]>~ );
	}
}

LastCropX = 50;
LastCropY = 50;
LastCropWidth = 100;
LastCropLength = 100;
LastRotation = 0;

VOID ChangeCrop( SetTheCrop )
{
	EditDialog( GetInput );

	if ( ~<$con.ImageEditData[CropName]>~ != ~~ )
	{
		Query = ~Select CropX,CropY,CropWidth,CropLength,Rotation From Crops Where Name = '<$con.ImageEditData[CropName]>'~;

		if ( !Ado( dBase,Connect,GetValuesFor,~<Query>~,CropX,CropY,CropWidth,CropLength,Rotation ) )
		{
			return EditDialog( SetStatus,1,Translate( ~No crop exists for <$con.ImageEditData[CropName]>~ ) );
		}

		LastCropX = ~<CropX>~;			LastCropY = ~<CropY>~; 
		LastCropWidth = ~<CropWidth>~;	LastCropLength= ~<CropLength>~;
		LastRotation = ~<Rotation>~;

		if ( <SetTheCrop> )
		{
			OnUseLastCrop();
		}
	}
}


VOID MyBaseEnterText::OnReturnKey()	
{ 
	dlg( GetInput );

	CropName = GetText();

	if ( IsNull( ~<CropName>~ ) )		
	{ 
		dlg( SetControlFocus,EditTextField );
		return;
	}

	StoreCrop( ~<CropName>~ );
	DoCancelButton();
}

VOID MyBaseEnterText::DoCancelButton()	
{ 
	EditDialog( EnableControls,TRUE,CropButton );
	EditDialog( SetFocus );
	BaseEnterText::DoCancelButton();
}

VOID MyBaseEnterText::BaseEnterText()
{ 
	Title = ~Enter a crop name~;
	ImageEditDialog( GetWindowPosition,Left,Top);
	Left += 50;
}


NUMERIC MyBaseEnterText::StoreCrop( Name )
{
	EditDialog( GetInput );

	LastImagePath = GetOpenImagePath();

	if ( !ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		return Warning( ~Could not find '<LastImagePath>'~ );
	}

	if ( ADO( dBase,Connect,RecordCountFor,~Select Name From Crops Where Name = '<Name>'~ ) )
	{
		if ( MessageBox( ~<Name> already exists. Would you like to replace it?~,YESNO ) != YES ) { return FALSE; }

		Cmd = ~Update Crops Set CropX=<cX>,CropY=<cY>,CropWidth=<cW>,CropLength=<cL> Where Name = '<Name>'~;
	}
	else
	{
		Cmd = ~Insert Into Crops(Name,CropX,CropY,CropWidth,CropLength,Format) Values('<Name>',<cX>,<cY>,<cW>,<cL>,'35mm')~;
	}

	if ( !dBase( Cmd,~<Cmd>~ ) )
	{
		dBase( GetErrorDescription,theErr );
		return Warning( ~Failed to update the crops table: <cmd>. <theErr>~ );
	}

	return TRUE;
}


NUMERIC OnSaveCrop()
{
	ForgetGlobal( EnterTextDialog );

	EditDialog( GetInput );

	LastImagePath = GetOpenImagePath();

	if ( !ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		return Warning( ~Could not find '<LastImagePath>'~ );
	}

	Class( MyBaseEnterText,Extends,BaseEnterText );
	MyBaseEnterText( New,EnterTextDialog );	// Instantiate an object of class BaseEnterText
	EnterTextDialog.DefineDialog();			// Activate it
	Global( EnterTextDialog );

	EditDialog( EnableControls,FALSE,CropButton );

	return TRUE;
}


VOID OnViewCrops()
{
	Query = STR ( SELECT * From Crops Order By Name );

	Actions = ACTION Doc ( ~Crops~ OpenOnce CropsDoc "Init( ~~,~<Query>~ );" );
	PerformActions( Actions );
}

VOID OpenLabReference()
{
	EditDialog( EnableControls,FALSE,RefButton );
	Actions = ACTION Doc ( LabReferenceImage OpenOnce LabReferenceImage );
	PerformActions( Actions );

	EditDialog( SetFocus );
	EditDialog( EnableControls,TRUE,RefButton );

	AskForCurrentOrderID(ChangeLabRef);
}

NUMERIC SelectOrders()
{
	Query = ~SELECT ID,Owner FROM Orders WHERE Status = 'Adjust' Order by Owner,ShipDate, Priority DESC~ ;

	if ( !PGenConList( List,Connect,Cursor,Forward,SetMaxRecords,1000,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Crops table: <Query>. <theErr>~ );
	}

	Count = List( NumEntries );

	if ( !<Count> && FALSE )
	{
		if ( MessageBox( ~There are no orders marked as needing image adjustments.  Would you like to search the orders?~,YESNO ) == YES )
		{
			SkipActivate = 1;
			action = ACTION DOC ( AllOrders Open SearchDoc "Search(Orders);" );
			return PerformActions( action );			
		}

		//return FALSE;
	}

	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	Count = 0;
	CategoryCount = 0;
	LastCategory = ~~;
	NumInList = 0;

	while ( List( GetNext,Item ) )
	{
		GenCon( Order<++Count>,New,DDMenuItemDef,
				SetValues,	Text,~&<Count>)  <$pcon.Item[ID]>~,
							IDText,	~ID~ );

		theAction  = ACTION EXEC ( WantOrder(~<$pcon.Item[ID]>~); );

		Order<Count>( SetValuesFrom,ActionsText,theAction );

		//ListMenu( InsertBack,Order<Count> );

		//if ( <count> >= 9 )
		//	break;

		

		if ( IsNull(~<$pcon.Item[Owner]>~) )
		{
			if ( <NumInList> < 10 )
			{
				ListMenu( InsertBack,Order<Count> );
				++NumInList;
			}
		}
		else if ( SimilarStr( ~<$pcon.Item[Owner]>~,~<LastCategory>~ ) )
		{
		
			if ( <NumInList> < 10 )
			{
				Category<CategoryCount>( InsertBack,Order<Count> );
				++NumInList;
			}
		}
		else
		{
		
			GenCon( Category<++CategoryCount>,New,DDMenuItemDef,SetValues,
					Text,		~&<$pcon.Item[Owner]>~,
					IDText,		~ID~ );

			Category<CategoryCount>( InsertBack,Order<Count> );

			ListMenu( InsertBack,Category<CategoryCount> );

			LastCategory = ~<$pcon.Item[Owner]>~;

			NumInList = 0;
		}
	}


	GenCon( Order<++Count>,New,DDMenuItemDef,SetValues,	Text,~&Search)  Search for Orders~,IDText,	~ID~ );
	theAction  = ACTION EXEC ( OnOrdersSearch() );
	Order<Count>( SetValuesFrom,ActionsText,theAction );
	ListMenu( InsertBack,Order<Count> );

	GenCon( Order<++Count>,New,DDMenuItemDef,SetValues,	Text,~Sta&tus)  Set the status for the current order~,IDText,	~ID~ );
	theAction  = ACTION EXEC ( OnSetOrderStatus(~~) );
	Order<Count>( SetValuesFrom,ActionsText,theAction );
	ListMenu( InsertBack,Order<Count> );


	EditDialog( DisplayMenu,ListMenu,WorkButton(GetLeft,Position),WorkButton(GetTop,Position) );

	return TRUE;
}

VOID WantOrder( ID )
{
	if ( MessageBox( ~Would you like to set the status of the order <ID> to Adjusting?~,YESNO ) == YES )
	{
		ADO( dBase,Connect,Cmd,~Update Orders Set Status = 'Adjusting' Where Status = 'Adjust' AND ID = '<ID>'~ );

		if ( !dBase( RecordsAffected ) )
		{
			Warning( ~Someone else is already adjusting that order~ );
			return;
		}
	}

	Which = CustomMessageBox( Title,~Open Images for Order <ID>~,Message,~Select~,
									Button1,~&All Images~,
									Button2,~&Images Needing Adjustment~,
									Button3,~&Cancel~ );

	OpenMethod = KeyState( RSHIFT ) ? Open : OpenOnce;

	if ( <Which> == 1 )
	{
		Query = ~SELECT * FROM Images WHERE OrderID = '<ID>' ORDER BY OrderID,Roll,Frame~ ;

		if ( Document( Doc,FindByName,~ImagesDoc~ ) )
		{
			Actions = ACTION Doc ( ~ImagesToAdjust~ <OpenMethod> ImagesDoc "Init( ~<ID>~,TRUE,~<Query>~,0 );" );
		}
	}
	else if ( <Which> == 2 )
	{
		Query = ~SELECT * FROM Images WHERE OrderID = '<ID>' AND Inspect <> 0 ORDER BY OrderID,Roll,Frame~ ;

		if ( Document( Doc,FindByName,~ImagesDoc~ ) )
		{
			Actions = ACTION Doc ( ~ImagesToAdjust~ <OpenMethod> ImagesDoc "Init( ~<ID>~,TRUE,~<Query>~,0 );" );
		}
	}
	else
	{
		return;
	}
	
	PerformActions( Actions );

	Actions = ACTION DOC ( FrameSelectorDoc "HandleOrderIDReturnKey(~<ID>~);" );
	PerformActions( Actions );

	Actions = ACTION DOC ( OpenOrderDoc "ChangeOrder(~<ID>~);" );
	PerformActions( Actions );

	Actions = ACTION DOC ( LabReferenceImage "ChangeReferenceImage(~<ID>~);" );
	PerformActions( Actions );

	SelectFirstImage();
	RegainFocus();


}

VOID SelectFirstImage()
{
	Actions = ~OnPrevButton()~;
	QueueContentsAfter( Actions,1000 );
}

VOID RegainFocus()
{
	Actions = ~EditDialog( SetFocus )~;
	QueueContentsAfter( Actions,1000 );
}

VOID OnOrdersSearch()
{
	Actions = ACTIONS ( Doc( ~Search~ Open SearchDoc "Search( Orders );" ) );
	PerformActions( Actions );
}


VOID OnSetOrderStatus(ID)
{
	ImageEditDialog( GetWindowPosition,Left,Top);
	Left += 350;	
	Top -= 190;

	SkipActivate = 1;

	Actions = ACTIONS ( Doc( ~SetOrderStatusDoc~ Open SetOrderStatusDoc "Init( ~<ID>~,~<Left>~,~<Top>~ );" ) );
	PerformActions( Actions );
}


STR GetOpenImagePath()
{
	DocumentPath = ~~;
	GetImageEditViewPath( DocumentPath );

	return ~<DocumentPath>~;
}


NUMERIC ShrinkCrop()
{
	if ( KeyState( SHIFT ) )
	{
		return ExpandCrop();
	}

	LastImagePath = GetOpenImagePath();

	if ( ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		orgW = <cW>;

		if ( <--cW> < 10 )
		{
			cW = 10;
		}

		cL = <cW> * <cL> / <orgW>;

		EditDialog( SetStrings,CropWidth,~<cW>~,CropLength,~<cL>~ );
		EditDialog( SetStatus,0,Translate( ~Smaller~ ) );
		EditDialog( SetStatus,1,Translate( ~Crop is <cX>,<cY>,<cW>,<cL>~ ) );
		RememberCrop(cX,cY,cW,cL);
		ImageCorrections( MoveCrop,~<LastImagePath>~,~<cX>~,~<cY>~,~<cW>~,~<cL>~ );
		return TRUE;
	}

	return EditDialog( SetStatus,1,Translate( ~Can't alter crop.  No image selected~ ) );
}


NUMERIC ExpandCrop()
{
	LastImagePath = GetOpenImagePath();

	if ( ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		orgW = <cW>;

		if ( <++cW> > 100 )
		{
			cW = 100;
		}

		cL = <cW> * <cL> / <orgW>;

		if ( <--cX> - <cW> / 2 < 0 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at left edge.~ ) );
		}

		if ( <++cY> + <cL> / 2 > 100 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at bottom edge.~ ) );
		}

		if ( <--cY> - <cL> / 2 < 0 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at top edge.~ ) );
		}

		if ( <++cX> + <cW> / 2 > 100 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at right edge.~ ) );
		}

		EditDialog( SetStrings,CropWidth,~<cW>~,CropLength,~<cL>~ );
		EditDialog( SetStatus,0,Translate( ~Larger~ ) );
		EditDialog( SetStatus,1,Translate( ~Crop is <cX>,<cY>,<cW>,<cL>~ ) );
		RememberCrop(cX,cY,cW,cL);
		ImageCorrections( MoveCrop,~<LastImagePath>~,~<cX>~,~<cY>~,~<cW>~,~<cL>~ );
		return TRUE;
	}

	return EditDialog( SetStatus,1,Translate( ~Can't alter crop.  No image selected~ ) );
}


NUMERIC ShiftCropLeft()
{
	if ( KeyState( SHIFT ) )
	{
		return ShiftCropUp();
	}

	LastImagePath = GetOpenImagePath();

	if ( ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		if ( <--cX> - <cW> / 2 < 0 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at left edge.~ ) );
		}

		EditDialog( SetStrings,CropX,~<cX>~ );
		EditDialog( SetStatus,0,Translate( ~Left~ ) );
		EditDialog( SetStatus,1,Translate( ~Crop is <cX>,<cY>,<cW>,<cL>~ ) );
		RememberCrop(cX,cY,cW,cL);
		ImageCorrections( MoveCrop,~<LastImagePath>~,~<cX>~,~<cY>~,~<cW>~,~<cL>~ );
		return TRUE;
	}

	return EditDialog( SetStatus,1,Translate( ~Can't alter crop.  No image selected~ ) );
}


NUMERIC ShiftCropDown()
{
	LastImagePath = GetOpenImagePath();

	if ( ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		if ( <++cY> + <cL> / 2 > 100 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at bottom edge.~ ) );
		}
		EditDialog( SetStrings,CropY,~<cY>~ );
		EditDialog( SetStatus,0,Translate( ~Down~ ) );
		EditDialog( SetStatus,1,Translate( ~Crop is <cX>,<cY>,<cW>,<cL>~ ) );
		RememberCrop(cX,cY,cW,cL);
		ImageCorrections( MoveCrop,~<LastImagePath>~,~<cX>~,~<cY>~,~<cW>~,~<cL>~ );
		return TRUE;
	}

	return EditDialog( SetStatus,1,Translate( ~Can't alter crop.  No image selected~ ) );
}


NUMERIC ShiftCropRight()
{
	if ( KeyState( SHIFT ) )
	{
		return ShiftCropDown();
	}

	LastImagePath = GetOpenImagePath();

	if ( ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		if ( <++cX> + <cW> / 2 > 100 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at right edge.~ ) );
		}

		EditDialog( SetStrings,CropX,~<cX>~ );
		EditDialog( SetStatus,0,Translate( ~Right~ ) );
		EditDialog( SetStatus,1,Translate( ~Crop is <cX>,<cY>,<cW>,<cL>~ ) );
		RememberCrop(cX,cY,cW,cL);
		ImageCorrections( MoveCrop,~<LastImagePath>~,~<cX>~,~<cY>~,~<cW>~,~<cL>~ );
		return TRUE;
	}

	return EditDialog( SetStatus,1,Translate( ~Can't alter crop.  No image selected~ ) );
}


NUMERIC ShiftCropUp()
{
	LastImagePath = GetOpenImagePath();

	if ( ImageCorrections( GetCrop,~<LastImagePath>~,cX,cY,cW,cL ) )
	{
		if ( <--cY> - <cL> / 2 < 0 )
		{
			return EditDialog( SetStatus,1,Translate( ~Crop is at top edge.~ ) );
		}


		EditDialog( SetStrings,CropY,~<cY>~ );
		EditDialog( SetStatus,0,Translate( ~Up~ ) );
		EditDialog( SetStatus,1,Translate( ~Crop is <cX>,<cY>,<cW>,<cL>~ ) );
		RememberCrop(cX,cY,cW,cL);
		ImageCorrections( MoveCrop,~<LastImagePath>~,~<cX>~,~<cY>~,~<cW>~,~<cL>~ );
		return TRUE;
	}

	return EditDialog( SetStatus,1,Translate( ~Can't alter crop.  No image selected~ ) );
}


NUMERIC OnUseLastCrop()
{
	return ImageCorrections( UpdateCrop,GetOpenImagePath(),~<LastCropX>~,~<LastCropY>~,~<LastCropWidth>~,~<LastCropLength>~ );
}


VOID RememberCrop(&X,&Y,&Width,&Length)
{
	LastCropX = ~<X>~;	LastCropY = ~<Y>~;  LastCropWidth = ~<Width>~;  LastCropLength = ~<Length>~; 
}

NUMERIC SetCrop()
{
	if ( IsNULL( GetOpenImagePath() ) )
	{
		return Warning( ~You must open an image first~ );
	}

	Query = ~Select Name From Crops Order By Name~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Crops table: <Query>. <theErr>~ );
	}

	Count = List( NumEntries );

	if ( FALSE /* !<Count> */ )
	{
		if ( MessageBox( ~There are no crops defined.  Would you like to define crops?~,YESNO ) == YES )
		{
			action = ACTION DOC ( AllCrops OpenOnce CropsDoc "Init( ~~,~SELECT * From Crops Order By Name~ );" );
			return PerformActions( action );			
		}

		return FALSE;
	}

	GenCon( ListMenu,New,DDMenuDef,SetValues,Position,-1 );

	Count = 0;

	while ( List( GetNext,Item ) )
	{
		GenCon( CropName<++Count>,New,DDMenuItemDef,
				SetValues,	Text,~&<Count>)  <$pcon.Item[Name]>~,
							IDText,	~ID~ );

		theAction  = ACTION EXEC ( WantCrop(~<$pcon.Item[Name]>~); );

		CropName<Count>( SetValuesFrom,ActionsText,theAction );

		ListMenu( InsertBack,CropName<Count> );
	}

	GenCon( CropName<++Count>,New,DDMenuItemDef,SetValues,	Text,~&All)  Select all of the image~,IDText,	~ID~ );
	theAction  = ACTION EXEC ( CropEntire(); );
	CropName<Count>( SetValuesFrom,ActionsText,theAction );
	ListMenu( InsertBack,CropName<Count> );


	GenCon( CropName<++Count>,New,DDMenuItemDef,SetValues,	Text,~&Open)  Open the crops table~,IDText,	~ID~ );
	theAction  = ACTION EXEC ( OpenCropsTable(); );
	CropName<Count>( SetValuesFrom,ActionsText,theAction );
	ListMenu( InsertBack,CropName<Count> );

	GenCon( CropName<++Count>,New,DDMenuItemDef,SetValues,	Text,~&Save)  Remember the current crop~,IDText,	~ID~ );
	theAction  = ACTION EXEC ( OnSaveCrop(); );
	CropName<Count>( SetValuesFrom,ActionsText,theAction );
	ListMenu( InsertBack,CropName<Count> );

	EditDialog( DisplayMenu,ListMenu,CropButton(GetLeft,Position),CropButton(GetTop,Position) );

	return TRUE;
}

NUMERIC OpenCropsTable()
{
	action = ACTION DOC ( AllCrops OpenOnce CropsDoc "Init( ~~,~SELECT * From Crops Order By Name~ );" );
	return PerformActions( action );			
}


NUMERIC WantCrop( Name )
{
	Query = ~Select Name,CropX,CropY,CropWidth,CropLength From Crops Where Name = '<Name>'~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( ~Failed to query the Crops table: <Query>. <theErr>~ );
	}

	if ( !List( GetFirst,Item ) )
	{
		return Warning( ~Failed to query the Crops table: <Query>. <theErr>~ );
	}

	CopiedCropX = ~<$pcon.Item[CropX]>~;
	CopiedCropY = ~<$pcon.Item[CropY]>~;
	CopiedCropWidth = ~<$pcon.Item[CropWidth]>~;
	CopiedCropLength = ~<$pcon.Item[CropLength]>~;

	RememberCrop( CopiedCropX,CopiedCropY,CopiedCropWidth,CopiedCropLength );

	return OnUseLastCrop();
}

NUMERIC CropEntire()
{
	RememberCrop( 50,50,100,100 );
	return OnUseLastCrop();
}
	

NUMERIC PasteCrop()	// CALLED FROM SUBJECTIDDIALOG
{
	if ( <CopiedCropWidth> == 0 || <CopiedCropLength> == 0 )
	{
		return Warning( Translate( ~You must copy a crop first~ ) );
	}

	if ( !GenCon( View,FindActiveImageThumbnailView ) )
		{ return Warning( ~There was no active view~ ); }

	if ( !View( GetSelected,SelectedImages ) )		
		{ return Warning( ~There were no rows selected~ ); }

	ImagesCount = SelectedImages( ChildCount );

	if ( <ImagesCount> <= 0 )
		{ return Warning( ~There were no images selected~ ); }

	while ( SelectedImages( GetNext,Item ) )
	{
		Path = ~<$con.Item[Path]>~;

		if ( ~<Path>~ != ~~ )
		{		
			ImageCorrections( UpdateCrop,~<Path>~,<CopiedCropX>,<CopiedCropY>,<CopiedCropWidth>,<CopiedCropLength> );
		}
	}

	return TRUE;
}

NUMERIC ReconvertRaw()
{
	if ( !GenCon( View,FindActiveImageThumbnailView ) )
		{ return Warning( ~There was no active view~ ); }

	Count = View( GetSelectedIconCount );

	if ( <Count> >= 1 )
	{
		if ( !View( GetSelected,SelectedImages ) )
		{
			return FALSE;
		}
	} else
	{
		// Got to have at least one image selected to do this. Performing the operation on the
		// entire order if none were selected could potentially be catastrophic if they
		// didn't really mean to do so.
		MessageBox(~You must have at least one image selected in order to reset the Processed flag.~);
		return 1; 
	}

	if ( !ADO( dBase,Connect ) )
	{
		WaitCursor( End );
		dBase( GetErrorDescription,theErr );
		return Warning( ~Error: <theErr>~,~From: [<theSQL>]~ );
	}

	WaitCursor( Begin );

	NumDigitalImages = 0;
	NumBibbleImages  = 0;	
	// In the loop, first check if each image is a Kodak DCR digital camera image (has a RawImages record)
	// If it does, then we set Processed = 0.
	// Then we look at Images and clear the ICCProfile field, and set Reprocess = 1.
	// Also delete the output file.
	// (If ImageType == 4 (RAW), the image has been processed by Bibble not Digital Camera Import)
	//
	// Once we're done with the loop, then we should make sure that the order status is set to Convert.

	while ( SelectedImages( GetNext,Image ) )
	{
		Key = ~(OrderID = '<$con.Image[OrderID]>' AND Roll = '<$con.Image[Roll]>' AND Frame = '<$con.Image[Frame]>')~;

		LegacyCountCmd = ~Select * from RawImages Where <Key> AND Path IS NOT NULL AND ImageType <> 4~;
		bibbleCountCmd = ~Select * from RawImages Where <Key> AND Path IS NOT NULL AND ImageType = 4~;
		Cmd = ~Update RawImages Set Processed = 0 Where <Key>~;

		legacyCount = dBase(RecordCountFor, ~<LegacyCountCmd>~);
		NumBibbleImages = <NumBibbleImages> + dBase(RecordCountFor, ~<bibbleCountCmd>~);
		
		// handle and deselect legacy images first
		if ( <legacyCount> > 0 )
		{
			++NumDigitalImages;

			if ( !dBase( CMD,~<Cmd>~ ) )
			{
				WaitCursor( End );
				dBase( GetErrorDescription,theErr );
				return Warning( ~Error: <theErr>~,~From: [<Cmd>]~ );
			}

			ResetImagesForReprocess( dBase,~<$con.Image[OrderID]>~,~<$con.Image[Roll]>~,~<$con.Image[Frame]>~,~<$con.Image[Path]>~ );
		
			// Set the reprocess field in the Images table
			// No longer clear the Path field
			
			Cmd = ~Update Images Set Reprocess = 1, ICCProfile = NULL, PreviewWidth=0, PreviewLength=0, FileType=NULL, ApplyShasta = 0, AutoRetouchComplete = 0, Reconverting = 1 Where <Key>~;
			
			if ( !dBase( CMD,~<Cmd>~ ) )
			{
				WaitCursor( End );
				dBase( GetErrorDescription,theErr );
				return Warning( ~Error: <theErr>~,~From: [<Cmd>]~ );
			}
			
			if ( Image( GetThumbNailInfo,ThumbNail ) )
			{
				View( SetSelected,ThumbNail,FALSE,FALSE );
				View( RedrawThumbNail,ThumbNail,TRUE );
			}
		}
	}

	if ( <NumDigitalImages> <= 0 && <NumBibbleImages> <= 0 )
	{
		return Warning( ~No raw images were selected.~ );
	}

	if (<NumDigitalImages> > 0)
	{
		// Set the order status to Needs Converting
		// ~None~=0, ~Needs Converting~=1, ~In Progress~=2, ~Complete~=3
		Cmd = ~Update Orders Set CameraFileConversionStatus = 1 Where ID = '<$con.Image[OrderID]>'~;
		if ( !dBase( CMD,~<Cmd>~ ) )
		{
			WaitCursor( End );
			dBase( GetErrorDescription,theErr );
			return Warning( ~Error: <theErr>~,~From: [<Cmd>]~ );
		}
		
		Warning( ~<NumDigitalImages> DCR image(s) submitted to the legacy Kodak Digital Camera Importer for reprocessing.~ );
	}

	// Handle Bibble image conversion
	if ( <NumBibbleImages> > 0 )
	{
		Actions = ACTION Doc ( RawImageDialog OpenOnce RawImageDialog "Init();" );
		PerformActions( Actions );
	}
	
	WaitCursor( End );
	return TRUE;
}

NUMERIC CloseWindowOfPath( Path )
{
	Count = Index = 0;

	app( ThisApp,MessagePump,3 );

	while ( GenCon( Window,GetWindowByIndex,<Index++> ) )
	{
		if ( Window( GETNEXT,aView ) )
		{
			aView( GET,ViewType,ViewType );

			if ( ~<ViewType>~ == ~ImageEditView~ || ~<ViewType>~ == ~PIEEditView~)
			{
				aView( GetDocumentPath,DocumentPath );

				if ( ~<DocumentPath>~ == ~<Path>~ )
				{ 
					Window( CloseWindow );
					ThisApp( MessagePump,3 );
					++Count;
					Index = 0;
				}
			}
		}
	}

	ThisApp( MessagePump,0 );

	return TRUE;
}


VOID SetupColorBalanceScale()
{
	if ( GetSystemSettings( ~AdjustImages~,~Scale~,ScaleFactor,Enabled ) )
	{
		if ( !IsNULL( ~<ScaleFactor>~ ) && <Enabled> )
		{
			CBScale( Set,~<ScaleFactor>~ );
		}
	}
}

VOID SetApplyShasta( applyShasta, changed, colorType )
{
	ImagePath = GetOpenImagePath();
	Count	  = 1;
	if ( !DefinedAndNotNull( colorType ) )
	{
		colorType = 0;

		if ( ~<ImagePath>~ == ~~ )
		{
			if ( GenCon( View,FindActiveImageThumbnailView ) )
			{
				if ( View( IsThumbNailView ) && (~<$con.View[ViewDataType]>~ == ~Image~) )
				{
					View( GetSelected,SelectedImages );
				}
			}
			else if ( GenCon( TheWindow,GetWindow,~DataWindow~ ) )
			{
				if ( TheWindow( GetActiveViewOfWindow,View ) )
				{ 
					if ( View( IsThumbNailView ) && (~<$con.View[ViewDataType]>~ == ~Image~) )
					{
						View( GetSelected,SelectedImages );
					}
				}
			}

			Count = View( GetSelectedIconCount );
			if ( <Count> == 0 )
			{
				return;
			}
		
			success = SelectedImages( GetNext, Image );

			if ( !<success> )
			{
				return;
			}
			ImagePath = ~<$con.Image[Path]>~;
			colorType = Numeric( ~<$con.Image[ColorType]>~ );

		}
		else
		{
			if ( ImageCorrections( GetCurrentCorrections,~<ImagePath>~,theCorrections ) )
			{
				colorType = Numeric( ~<$con.theCorrections[colorType]>~ );
			}
		}

	}

	if ( <colorType> == 0 && <applyShasta> && <CheckColorType> && ~<ImagePath>~ != ~~ )
	{
		colorType = DetermineColorType( ~<ImagePath>~ );
	}

	if ( <NextPrevButtonPressed> )
	{
		NextPrevButtonPressed = FALSE;
	}
	else
	{
		ImageEditData( SetValues, cApplyShasta, <applyShasta> );
		OnShasta(<applyShasta>, <changed>, <colorType> ) ;
	}
}

/*
NUMERIC GetApplyShasta( Path )
{
	if( Path == ~~ )
	{
		//	GET THE IMAGE PATH...
		Path = GetOpenImagePath() ;	//	IS THERE AN OPEN IMAGE ?
		if( Path == ~~ )
		{
		}
	}
	
	//	GET THE CORRECTIONS
	
	//	GET THE SHASTA FLAGS
	
	//	RETURN THE CURRENT STATE OF THE SHASTA FLAG
	
}
*/

Mode = ~Color~;
Timer0_Action = ~UpdateAffectedImages()~;	// WHERE TO GO WHEN TIMER0 TRIPS
CorrectIndividualImages = FALSE;				

DefineImageEditDialog();

SetupColorBalanceScale();

EditImages();

if ( GetUserSettings( ~<$Job.Title>~,UseNumLock,UseNumLock,Enabled ) )
{
	if ( Numeric( ~<UseNumLock>~ ) )
	{
		Keyboard( AllowNumlock );
		EditDialog( SetCheck,TRUE,UseNumlockCheckBox );
	}
}
else
{
	EditDialog( SetCheck,TRUE,UseNumlockCheckBox );
}

if ( GetUserSettings( ~<$Job.Title>~,DontResetOnSave,DontResetOnSave,Enabled ) )
{
	if ( Numeric( ~<DontResetOnSave>~ ) )
	{
		EditDialog( SetCheck,TRUE,DontResetOnSaveCheckBox );
	}
}

if ( GetUserSettings( ~<$Job.Title>~,AutomaticAutoBal,AutomaticAutoBal,Enabled ) )
{
	if ( Numeric( ~<AutomaticAutoBal>~ ) )
	{
		EditDialog( SetCheck,TRUE,AutoBalCheckBox );
	}
}


if ( GetUserSettings( ~<$Job.Title>~,KeepKeyboardFocus,KeepKeyboardFocus,Enabled ) )
{
	if ( Numeric( ~<KeepKeyboardFocus>~ ) )
	{
		EditDialog( SetCheck,TRUE,TopCheckBox );
	}
}

if ( GetUserSettings( ~<$Job.Title>~,IndependentAdjustments,IndependentAdjustments,Enabled ) )
{
	if ( Numeric( ~<IndependentAdjustments>~ ) )
	{
		EditDialog( SetCheck,TRUE,IndependentAdjustmentsBox );
	}
}

ColorCorrectionInputDevice = -1;
GetWorkStationSettings( ~<$Job.Title>~,ColorCorrectionInputDevice,ColorCorrectionInputDevice,Enabled );

if ( GetWorkStationSettings( ~<$Job.Title>~,SerialInputPort,SerialInputPort,Enabled ) )
{
	if ( !IsNULL( ~<SerialInputPort>~ ) )
	{
		if ( IsNumeric( ~<SerialInputPort>~ ) )
		{
			EditDialog( SetString,~<SerialInputPort>~ ,SerialInputPort,0 );
			
			if ( <ColorCorrectionInputDevice> == -1 )
			{
				ColorCorrectionInputDevice = 2;
			}
		}
	}
}

UpdateInputDevice( <ColorCorrectionInputDevice> );

if ( GetWorkstationSettings( ~Analyzer~,~SaveAutoBalData~,saveSbaData,Enabled ) )
{
	if ( !IsNull( ~<saveSbaData>~ ) )
	{
		EditDialog( SetString, ~<saveSbaData>~, TrackAutoBalData,0 );
	}
	else
	{
		EditDialog( SetString, ~0~, TrackAutoBalData,0 );
	}
}
else
{
	EditDialog( SetString, ~0~, TrackAutoBalData,0 );
}

DefaultAutoBalPref = ~~;
GetWorkStationSettings( ~Analyzer~, ~DefaultAutoBalPref~, DefaultAutoBalPref, Enabled );
if ( IsNull( ~<DefaultAutoBalPref>~ ) )
{
	GetSystemSettings( ~Analyzer~, ~DefaultAutoBalPref~, DefaultAutoBalPref, Enabled );
}

DefaultAimPref = ~~;
GetWorkStationSettings( ~Analyzer~, ~DefaultAimPref~, DefaultAimPref, Enabled );
if ( IsNull( ~<DefaultAimPref>~ ) )
{
	GetSystemSettings( ~Analyzer~, ~DefaultAimPref~, DefaultAimPref, Enabled );
}
CurrentAimPref = ~<DefaultAimPref>~;
ClickedImagePath = ~~;
InitClickBalanceOptions(TRUE);

SetUseNumlock();

EditDialog( SetStatus,2,<WheelManMode> ? ~Crop~ : ~Color~ );

CheckColorType = GetCheckColorTypeSetting();

InitializeLut();

InitApplyShasta();

//ReOpen();

//EditDialog( SetStatus,2,~<Mode>~ );



OptionalInclude( ~<$App.ShareDirectory>\Scripts\ScriptOverrides\<$Job.Name>~ );
