//	REThread.txt

ExecC() ;

char	*NULL ;
int		 FALSE = 0 ;
int		 TRUE  = ! FALSE ;

int		gTesting = FALSE ;

int		gNewWay	 = TRUE ;

main()
{
	Debug(0) ;
	SessionLogDirect( _T("REThread.main: Version 1.0.3")) ;

//	UCInterpreter	*thisCI = THIS() ;
//	thisCI->SetProfiling( TRUE ) ;
}



CIThread	*gThisThread ;
int			 WM_QUIT				= 0x0012 ;
int			 WM_TIMER				= 0x0113 ;

//	9000 SERIES FOR THE RENDER ENGINE DIALOG THREAD
//	9100 SERIES FOR THE RENDER ENGINE MAIN THREAD
//	9200 SERIES FOR THE RENDER ENGINE BATCH THREAD
//	9300 SERIES FOR THE RENDER ENGINE RENDERING THREAD
//	9400 SERIES FOR THE RENDER ENGINE RESPONSE THREAD
//	9500 SERIES FOR THE RENDER ENGINE SCRIPT THREAD ?

//	UNITS SERIES FOR SENDING DATA
//	TENS SERIES FOR STARTUP AND SHUTDOWN
//	TWENTY SERIES FOR SUSPEND AND RESUME
//	THIRTY TO SIXTY SERIES FOR WORK COMMANDS
//	SEVENTY SERIES FOR COMPLETE MESSAGES
//	EIGHTY SERIES FOR CANCEL MESSAGES
//	NINETY SERIES FOR ERROR MESSAGES

//	THE RENDER ENGINE DIALOG THREAD
int			 REM_DIALOG					= 0x9000 ;
int			 REM_DATAGC					= 0x9001 ;
int			 REM_RE_START				= 0x9010 ;
int			 REM_RE_SHUTDOWN			= 0x9011 ;
int			 REM_RE_HAS_SHUTDOWN		= 0x9012 ;
int			 REM_RE_SUSPEND				= 0x9020 ;
int			 REM_RE_RESUME				= 0x9021 ;
int			 REM_RE_SHOWSTATUS			= 0x9030 ;
int			 REM_RE_SIREN				= 0x9090 ;
int			 REM_RE_WAIT_FOR_STATUS		= 0x9091 ;
int			 REM_UPDATE_PRINTER_SETUP	= 0x9092 ;

//	THE RENDER ENGINE MAIN THREAD
int			 REM_PRINTERSETUP			= 0x9102 ;
int			 REM_STATUS_GC				= 0x9103 ;
int			 REM_SHUTDOWN				= 0x9111 ;
int			 REM_GETNUMJOBSTOPRINT		= 0x9112 ;
int			 REM_SUSPEND				= 0x9120 ;
int			 REM_RESUME					= 0x9121 ;
int			 REM_TIMER					= 0x9225 ;
int			 REM_STATUS_REQUEST			= 0x9130 ;
int			 REM_RESERVE_NEXT_BATCH		= 0x9131 ; // This constant is hard coded in RemoteJobServer.cpp
int			 REM_GET_PAGE_LIST			= 0x9132 ;
int			 REM_START_BATCH			= 0x9133 ;
int			 REM_RESPONSESCRIPT			= 0x9134 ;
int			 REM_DB_SQL					= 0x9135 ;
int			 REM_GET_PRINTER_STATUS		= 0x9136 ;
int			 REM_DELETE_JOB_RECORD		= 0x9137 ;
int			 REM_ORDER_COMPLETE			= 0x9170 ;
int			 REM_BATCH_COMPLETE			= 0x9171 ;
int			 REM_CANCEL_BATCH			= 0x9180 ;
int			 REM_MESSAGE_RESPONSE		= 0x9190 ;
int			 REM_EXCEPTION_RESPONSE		= 0x9191 ;
int			 REM_ERROR_DLG_RESPONSE		= 0x9192 ;
int			 REM_DB_ERROR_DLG_RESPONSE	= 0x9193 ;

//	THE RENDER ENGINE BATCH THREAD
int			 REM_BATCH_PRINTERSETUP		= 0x9202 ;
int			 REM_BATCH_STATUS_GC		= 0x9203 ;
int			 REM_BATCH_BATCH_GC			= 0x9204 ;
int			 REM_BATCH_START_RENDER		= 0x9205 ;
int			 REM_BATCH_SHUTDOWN			= 0x9211 ;
int			 REM_BATCH_SUSPEND			= 0x9220 ;
int			 REM_BATCH_RESUME			= 0x9221 ;

int			 REM_BATCH_TIMER			= 0x9225 ;

int			 REM_BATCH_STATUS_REQ		= 0x9230 ;
int			 REM_BATCH_PARSE_JOB		= 0x9234 ;
int			 REM_BATCH_PRGRM_JOB		= 0x9235 ;
int			 REM_BATCH_RENDER_JOB		= 0x9236 ;

int			 REM_BATCH_ORDERCOMP		= 0x9250 ;
int			 REM_BATCH_BATCHCOMP		= 0x9251 ;
int			 REM_SCRIPT_COMPLETE		= 0x9252 ;

int			 REM_BATCH_CANCEL_BATCH		= 0x9260 ;
int			 REM_BATCH_CANCEL_ORDER		= 0x9261 ;
int			 REM_BATCH_CANCEL_PAGE		= 0x9262 ;

int			 REM_BATCH_PARSE_ERROR		= 0x9265 ;

int			 REM_BATCH_RNDR_SUCCESS		= 0x9270 ;
int			 REM_BATCH_RNDR_ERROR		= 0x9271 ;
int			 REM_BATCH_RNDR_CANCEL		= 0x9272 ;

int			 REM_BATCH_PRINT_SUCCESS	= 0x9280 ;
int			 REM_BATCH_PRINT_ERROR		= 0x9281 ;
int			 REM_BATCH_PRINT_CANCEL		= 0x9282 ;

int			 REM_BATCH_REMOVE_PAGE		= 0x9290 ;
int			 REM_BATCH_PARSE_RESPONSE	= 0x9291 ;
int			 REM_BATCH_RENDER_RESPONSE	= 0x9292 ;
int			 REM_BATCH_PRINTER_RESPONSE = 0x9293 ;
int			 REM_BATCH_EXCEPTION_RESPONSE = 0x9094 ;

//	THE RENDER ENGINE PIE THREAD
int			 REM_PIE_SET_PAGE			= 0x9300 ;
int			 REM_PIE_START_RENDER		= 0x9301 ;
int			 REM_PIE_STATUS				= 0x9330 ;

//	THE RENDER ENGINE RESPONSE THREAD

//	THE RENDER ENGINE SCRIPT THREAD


//	PRINT QUEUE JOB STATES
int			 HOLD				=  0 ;
int			 READY				=  1 ;
int			 RESERVED			=  2 ;
int			 PRINTING			=  3 ;
int			 COMPLETED			=  4 ;
int			 SAVED				=  5 ;
int			 ERROR				=  6 ;
int			 CANCELLED			=  7 ;
int			 PENDING			=  8 ;
int			 LOADED				=  9 ;
int			 PARSED				= 10 ;

//	BATCH STATES
int			 BATCH_RESERVED		= 1 ;
int			 BATCH_READY		= 2 ;
int			 BATCH_PRINTING		= 3 ;
int			 BATCH_CANCELLING	= 4 ;
int			 BATCH_COMPLETED	= 5 ;
int			 BATCH_ERROR		= 6 ;

//	PAGE STATES
int			 PAGE_READY			= 1 ;
int			 PAGE_PARSED		= 2 ;
int			 PAGE_PROGRAMMED	= 3 ;
int			 PAGE_RENDERED		= 4 ;
int			 PAGE_CANCELLED		= 5 ;
int			 PAGE_COMPLETE		= 6 ;
int			 PAGE_ERROR			= 7 ;

//	RENDER ENGINE STATUS
int			 RE_RUNNING			= 1 ;
int			 RE_SUSPENDED		= 2 ;
int			 RE_SHUTTING_DOWN	= 3 ;
int			 RE_QUITTING		= 4 ;

int			 RE_USER_SUSPEND	= 0x01 ;	//	THE USER SUSPENDED US
int			 RE_PROG_SUSPEND	= 0x02 ;	//	THE PROG SUSPENDED US
int			 RE_ERR_SUSPEND		= 0x04 ;	//	WE ARE SUSPENDED DUE TO AN ERROR
int			 RE_THRT_SUSPEND	= 0x08 ;	//	ARE WE SUSPENDED BECAUSE OF THROTTLING ?
int			 RE_DISK_SUSPEND	= 0x10 ;	//	ARE WE SUSPENDED FOR DISK SPACE ?
int			 RE_TABL_SUSPEND	= 0x20 ;	//	SOMEONE CHANGED THE PRINTER TABLE TO SUSPEND

int			 gREStatus			= RE_RUNNING ;
int			 gREStatusB4Suspend	= RE_RUNNING ;
int			 gSuspendType		= 0 ;

UGenCon		*gCurrentBatch		= NULL ;	//	BATCH CURRENTLY RENDERING

//	THE PRINTER SETUP GENCON HAS CHILDREN...
//	THE FIRST CHILD IS THE STATUS TO BE RETURNED TO THE DIALOG.
//	THE SECOND CHILD IS A GENCON TO KEEP TRACK OF THE ORDER PROCESSING THREAD.
UGenCon		*gPrinterSetupGC ;		//	THE PRINTER SETUP GENCON
UGenCon		*gStatusGC ;			//	THE STATUS GENCON
UQueue		*gBatchQueue ;			//	THE LIST OF BATCHES IN PROCESS

UGenCon		*gRELookAhead ;			//	THE QUEUE TUNING PARAMETERS
long		 gLogAmount ;			//	HOW MUCH LOGGING TO DO
int			 gCheckTextLibFirst ;	//	CHECK THE TEXT LIBRARY FIRST

UREMain		*gREMain			= NULL ;

/*
Dictionary: DDREStatus
	Fields:	Name	Time			Type	Text
	Fields:	Name	Status			Type	Text
	Fields:	Name	Batch			Type	Text
	Fields:	Name	Order			Type	Text
	Fields:	Name	Item			Type	Long
	Fields:	Name	QtyRendered		Type	Long
	Fields:	Name	DlgThread		Type	Long
	Fields:	Name	REThread		Type	Long
	Fields:	Name	BatchThread		Type	Long
	Fields:	Name	ScriptThread	Type	Long
	Fields:	Name	LogAmount		Type	Long
	;

Dictionary:	DDREBatchInfo
	Fields:	Name	BatchID				Type	Text
	Fields:	Name	OrderID				Type	Text
	Fields:	Name	OrderItemID			Type	Long
	Fields:	Name	State				Type	Long
	Fields:	Name	REThread			Type	Long
	Fields:	Name	BatchThread			Type	Long

			//	FROM DDFSOrder
	Fields:	Name	CustomerID			Type	Text
	Fields:	Name	VendorOrderNumber	Type	Text
	Fields:	Name	OrderStatus			Type	Long
	Fields:	Name	PrinterSetup		Type	Long
	Fields:	Name	TotalPrints			Type	Long
	Fields:	Name	ErrorCode			Type	Long
	Fields:	Name	ErrorText			Type	Text
	Fields:	Name	ErrorType			Type	Long
	Fields:	Name	LastPrintTime		Type	Long
	;

//	THE DDREBatchInfo Children are the pages in the batch

Dictionary:	DDREPageInfo
	Fields:	Name	PageID				Type	Text
	Fields:	Name	JobID				Type	Long
	Fields:	Name	State				Type	Long
	Fields:	Name	PrintNumber			Type	Long
	Fields:	Name	PageNumber			Type	Long
	Fields:	Name	BatchID				Type	Text
	Fields:	Name	OrderID				Type	Text
	Fields:	Name	OrderSeq			Type	Long
	Fields:	Name	OrderItemID			Type	Long
	Fields:	Name	OrderItemSeq		Type	Long
	Fields:	Name	OrderItemQty		Type	Long
	Fields:	Name	JobPath				Type	Text
	Fields: Name	IsPackage			Type	Long
	Fields:	Name	PkgCode				Type	Long
	Fields:	Name	BarCode				Type	Text
	Fields:	Name	BarCodeType			Type	Long	//	FALSE, TRUE (Full), TRUE_INTERMEDIATE
	Fields:	Name	EndOfOrder			Type	Long
	Fields:	Name	URenderList			Type	Long
	Fields:	Name	UIC					Type	Reference
	Fields:	Name	Pie					Type	Long
	Fields:	Name	BatchThread			Type	Long
	Fields:	Name	PieThread			Type	Long
	Fields:	Name	ErrorCode			Type	Long	//	OK, Error Number
	Fields:	Name	ErrorType			Type	Long	//	INFO, WARN, FATAL
	Fields:	Name	ErrorText			Type	Text
	Fields:	Name	PrintThisPage		Type	Long	//	FOR PAPER FILL
	Fields:	Name	DeleteAfter			Type	Long	//	FOR PAPER FILL

			//	FROM DDFSPrint
	Fields:	Name	ProductDesc			Type	Text
	Fields:	Name	ShortDimension		Type	Double
	Fields:	Name	LongDimension		Type	Double
	Fields:	Name	Units				Type	Text
	Fields:	Name	Quantity			Type	Long
	Fields:	Name	ImagePath			Type	Text
	Fields:	Name	FileFormat			Type	Text
	Fields:	Name	ColorSpace			Type	Text
	Fields:	Name	DeleteOnComplete	Type	Long
	Fields:	Name	BackPrintMessage1	Type	Text
	Fields:	Name	BackPrintMessage2	Type	Text
	Fields:	Name	PrintStatus			Type	Long
	Fields:	Name	PrinterChannel		Type	Long
	Fields:	Name	PaperSurface		Type	Long
	Fields:	Name	OEMPrinterChannel	Type	Long	//	FOR BACKWARD COMPATABILITY
	Fields:	Name	OEMPrinterSurface	Type	Long	//	FOR BACKWARD COMPATABILITY
	Fields:	Name	ReproMode			Type	Long
	Fields:	Name	PrinterResize		Type	Long
	Fields:	Name	ResponseText		Type	Text
	Fields:	Name	ResponseCode		Type	Long
	Fields:	Name	OutputNode			Type	Long
	Fields:	Name	Resolution			Type	Double
	Fields:	Name	PaperWidth			Type	Double
	Fields:	Name	CommandSent			Type	Long
	Fields:	Name	ExpandedCDSaveName	Type	Text
	;

Dictionary:	DDREThreadResponse
	Fields:	Name	PrinterSetupGC			Type	Long	//	input fields
	Fields:	Name	StatusGC				Type	Long
	Fields:	Name	PageGC					Type	Long
	Fields:	Name	BatchGC					Type	Long
	Fields:	Name	PrinterResponseGC		Type	Reference

	Fields:	Name	ErrorCode				Type	Long	//	output fields
	Fields:	Name	ErrorText				Type	Text
	Fields:	Name	Cancel					Type	Long	//	0:	No Cancel,
															//	1:	Cancel Page
															//	2:	Cancel Order
															//	3:	Cancel Batch
	;

//	Response Code = Error Code (0 = OK)
//	Response Type	1: Info, 2: Warning, 3: Fatal
//	Response Text	Error Message
//	Response Flag	1: Error, 0: Fixed
Dictionary: DDFSResponse
	Fields:	Name		~ResponseFolder~		Type	Text
	Fields:	Name		~ResponseFilePath~		Type	Text
	Fields:	Name		~ResponseType~			Type	Text
	Fields:	Name		~ResponsePage~			Type	Long
	Fields:	Name		~OrderID~				Type	Text
	Fields:	Name		~BatchID~				Type	Text
	Fields:	Name		~Date~					Type	Long
	Fields:	Name		~Time~					Type	Long
	Fields:	Name		~ResponseCode~			Type	Long
	Fields:	Name		~ErrorType~				Type	Long
	Fields:	Name		~ErrorText~				Type	Text
	Fields:	Name		~ResponseFlag~			Type	Long
	Fields:	Name		~FoundResponse~			Type	Long
	Fields:	Name		~Action~				Type	Text
	Fields:	Name		~PrinterSetupGC~		Type	Long
	;
*/

//															  0		 1		  2			 3			4			5	  6			7			8		9		 10
//	StringList( PrintStatusList,New,InListOrder,AddStrings,~Hold~,~Ready~,~Reserved~,~Printing~,~Completed~,~Saved~,~Error~,~Cancelled~,~Pending~,~Loaded~,~Parsed~ );

//	START THE THREAD HERE !
int InitInstance(CIThread *ThisThread)
{
//	SessionLogDirect( _T("**\tREThread.InitInstance: Thread: [%08lX]"), ThisThread) ;
	int		Result = TRUE ;

	if( gNewWay )
	{
		gREMain = new UREMain ;
		Result = gREMain->InitInstance( ThisThread ) ;
		return( Result ) ;
	}


	gThisThread		= ThisThread ;
	gCurrentBatch	= NULL ;
	gREStatus		= RE_RUNNING ;

	gBatchQueue		= new UQueue ;

	gRELookAhead	= GetTreeObject(_T("RELookAhead"),_T("[GenCons]")) ;

	gCheckTextLibFirst = TRUE ;
	UGenCon	*CICheckTextLibFirst = GetTreeObject( _T("CICheckTextLibFirst"), _T("GENCONS")) ;
	if( CICheckTextLibFirst )
	{
		gCheckTextLibFirst = CICheckTextLibFirst->GetLongValue(_T("Long")) ;
	}

	HangDebugTargetGC() ;	//	DEBUGGER2 CODE

//	gRELookAhead->SetLongValue(_T("SuspendNow"), 0L ) ;

	return( TRUE ) ;
}

int OnIdle( long Count )
{
	return( Count ) ;
}

//	TELL THE DIALOG THREAD THAT WE ARE DONE.
int ExitInstance()
{

	if( gNewWay )
	{
		int Result = gREMain->ExitInstance() ;
		delete gREMain ;
		return( Result ) ;
	}

	if( gLogAmount >= 5 )
		{ SessionLogDirect( _T("**\tREThread.ExitInstance: Thread: [%08lX]"), gThisThread) ; }

	if( gBatchQueue )	{ delete gBatchQueue ; }

	if( gStatusGC )
	{
		gStatusGC->SetLongValue(_T("REThread"), NULL ) ;

		//	RUN THE BUILT IN SHUTDOWN SCRIPT BEFORE WE KILL THE THREAD.
		TCHAR	 FuncCall[1024] ;
		TCHAR	*ShutDownScript = gPrinterSetupGC->GetStringValue(_T("BIShutdownScript")) ;
		if( ShutDownScript )
		{
			if( *ShutDownScript )
			{
				sprintf( FuncCall, _T("Init(0x%08lX);"), gPrinterSetupGC ) ;
				CallScript( ShutDownScript, FuncCall ) ;
			}
		}

		//	RUN THE USER DEFINED SHUTDOWN SCRIPT BEFORE WE KILL THE THREAD.
		ShutDownScript = gPrinterSetupGC->GetStringValue(_T("ShutdownScript")) ;
		if( ShutDownScript )
		{
			if( *ShutDownScript )
			{
				sprintf( FuncCall, _T("Init(0x%08lX);"), gPrinterSetupGC ) ;
				CallScript( ShutDownScript, FuncCall ) ;
			}
		}

		CIThread *aThreadPtr = gStatusGC->GetLongValue(_T("DlgThread")) ;

		if( gLogAmount >= 5 )
			{ SessionLogDirect( _T("**\tREThread.ExitInstance: Notify Thread: %08lX"), aThreadPtr ) ; }

		if( aThreadPtr )
		{
			//	TELL THE DIALOG THAT WE HAVE SHUT DOWN
			PostAThreadMessage( aThreadPtr, REM_RE_HAS_SHUTDOWN, 0L, gPrinterSetupGC ) ;
		}
		else
		{
			//	WE CAN GET HERE IF THE USER SHUT US DOWN BY THE PRINTER DATA TABLE
			ShutUsDown() ;
		}
	}

	RemoveDebugTargetGC() ;		//	DEBUGGER2 CODE

	return( 1 ) ;
}




//	AT THIS POINT THE RENDER ENGINE HAS SHUT DOWN
//	SO LET'S DO THE CLEAN UP.
void ShutUsDown()
{
	TCHAR	*PrinterName = gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;

	PluckTreeObject( PrinterName, _T("Renderers")) ;

	SessionLogDirect( _T("REThread.ShutUsDown: Printer: %s Has Shut Down"), PrinterName ) ;

	UpdatePrinterTable( PrinterName, _T("Shutdown"), NULL ) ;

	delete gPrinterSetupGC ;
}



int PreTranslateMessage( UGenCon *pMsg)
{
	if( gNewWay )
	{
		int Result = gREMain->PreTranslateMessage(pMsg) ;
		return( Result ) ;
	}

	
	long		MessageHandled = FALSE ;
	long		Value ;

	long		Message = pMsg->GetLongValue(_T("Message")) ;
	long		wParam  = pMsg->GetLongValue(_T("wParam"))  ;
	long		lParam  = pMsg->GetLongValue(_T("lParam"))  ;

	if( Message != WM_TIMER && gLogAmount >= 5 )
	{
		SessionLogDirect( _T("**\tREThread.PreTranslateMessage: Status: %ld, Msg: 0x%08lX, wParam: 0x%08lX, lParam: 0x%08lX"),
									gREStatus, Message, wParam, lParam ) ;
	}

	switch( Message )
	{
		case		WM_TIMER	:	//	HANDLE TIMER CODE
			PostAThreadMessage( gThisThread, REM_TIMER, 0L, 0L ) ;
			break ;

		case	REM_TIMER	:		//	REALLY HANDLE THE TIMER
			HandleTimer() ;
			KickBatchThreads() ;
			break ;

		case		REM_PRINTERSETUP		:	//	SET PrinterSetup GC
			gPrinterSetupGC = lParam ;
			gPrinterSetupGC->SetLongValue( _T("ThreadID"), gThisThread->GetThreadID() ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_STATUS_GC			:	//	Set the Status GC
			gStatusGC = lParam ;
			gStatusGC->SetLongValue(_T("REThread"), gThisThread ) ;
			long NumSavedJobs = GetSavedCountFromJobQueueRecord() ;
			gStatusGC->SetLongValue(_T("NumPrinterJobs"), NumSavedJobs ) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_STATUS_REQUEST		:	//	Handle Status Request
			HandleStatusRequest() ;
			MessageHandled = TRUE ;
			break ;

		case		REM_SHUTDOWN			:	//	Handle Shutdown
			HandleShutDown(lParam) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_GETNUMJOBSTOPRINT :		//	GET NUMBER OF JOBS LEFT TO PRINT
			gNumJobsLeftToPrint = GetNumJobsToBePrinted() ;
			if( gNumJobsLeftToPrint >= 0L )
			{
				gStatusGC->SetLongValue(_T("NumPrinterJobs"), gNumJobsLeftToPrint ) ;
			}
			break ;

		case		REM_CANCEL_BATCH		:	//	Handle Cancel			TBD
			MessageHandled = TRUE ;
			break ;

		case		REM_SUSPEND				:	//	Handle Suspend
			HandleSuspend(lParam) ;
			break ;

		case		REM_RESUME				:	//	Handle Resume
			HandleResume(lParam) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_ORDER_COMPLETE		:	//	Handle Order Complete	TBD
			MessageHandled = TRUE ;
			break ;

		case		REM_BATCH_COMPLETE		:	//	Handle Batch Complete
			HandleBatchComplete((UGenCon *) lParam) ;	//	lParam is the BatchInfo GenCon
			MessageHandled = TRUE ;
			break ;

		case		REM_RESERVE_NEXT_BATCH	:	//	Get Next Batch
			ReserveNextBatch() ;
			MessageHandled = TRUE ;
			break ;

//		case		REM_GET_PAGE_LIST		:	//	Get Page List
//			GetPageList((UGenCon *) lParam) ;	//	lParam is the BatchInfo GenCon
//			MessageHandled = TRUE ;
//			break ;

		case		REM_MESSAGE_RESPONSE	:	//	MESSAGE DIALOG RESPONDS HERE
			MessageDialogReply(lParam) ;		//	A COPY OF THE MESSAGE DIALOG GENCON
			MessageHandled = TRUE ;
			break ;

		case		REM_ERROR_DLG_RESPONSE	:
			DialogErrorResponse(wParam, lParam) ;
			MessageHandled = TRUE ;
			break ;

		case	REM_DB_ERROR_DLG_RESPONSE	:
			DialogDBErrorResponse(wParam, lParam) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_START_BATCH			:	//	Start Batch Rendering
			StartBatch() ;
			MessageHandled = TRUE ;
			break ;

		case		REM_RESPONSESCRIPT		:	//	RUN THE RESPONSE SCRIPT
			RunResponseScript(lParam) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_DB_SQL				:	//	DO AN SQL STATEMENT
			HandleSQL(lParam) ;
			MessageHandled = TRUE ;
			break ;

		case		REM_GET_PRINTER_STATUS	:	//	GET PRINTER STATUS
			HandlePrinterStatus() ;
			MessageHandled = TRUE ;
			break ;

		case		REM_DELETE_JOB_RECORD	:	//	DELETE JOB QUEUE RECORD
			DeleteRecordFromJobQueue( lParam ) ;	//	lParam = aPage
			MessageHandled = TRUE ;
			break ;

//		case		REM_DELETE_JOB_RECORD	:	//	DELETE JOB QUEUE RECORD		OLD WAY
//			DeleteRecordFromJobQueue( lParam ) ;	//	lParam = JobID
//			MessageHandled = TRUE ;
//			break ;

//		case		REM_SCRIPT_COMPLETE		:	//	SCRIPT COMPLETE MESSAGE
//			HandleScriptComplete( (UGenCon *) lParam ) ;
//			MessageHandled = TRUE ;
//			break ;

		case		REM_EXCEPTION_RESPONSE :	//	EXCEPTION DIALOG RESPONDS HERE
			HandleExceptionResponse(lParam) ;
//			gREStatus = RE_RUNNING ;
			MessageHandled = TRUE ;
			break ;
	}

	return( MessageHandled ) ;
}




//=============================================================================
//=============================================================================
//============================= HANDLE TIMER ==================================
//=============================================================================
//=============================================================================

//	StringList( PrinterStatusList,New,InListOrder,AddStrings,~Shutdown~,~Run~,~Suspend~,~Quit~ );

//	gPrinterStatusReady is needed because we come through here before the
//		printer table in the database gets updated to "Run".
long	gPrinterStatusReady = FALSE ;
long	gLastWorkCheck		= 0L ;		//	TICKS SINCE WE LAST CHECKED FOR WORK
long	gLastResponse		= 0L ;		//	TICKS SINCE WE LAST CHECKED FOR A RESPONSE
long	gLastPrinterStatus	= 0L ;		//	TICKS SINCE WE LAST CHECKED THE PRINTER STATUS
long	gLastJobLeftToPrint = 0L ;		//.	TICKS SINCE WE LAST CHECKED FOR JOBS LEFT TO BE PRINTED
long	gNumJobsLeftToPrint	= 0L ;		//	NUMBER OF JOBS LEFT AT IPS PROGRAM

int HandleTimer()
{
	if( gStatusGC == NULL )	{ return( FALSE ) ; }

	UGenCon	*DlgDataGC = (UGenCon *) gStatusGC->GetLongValue(_T("DlgDataGC")) ;
	if( DlgDataGC )
	{
		gLogAmount = DlgDataGC->GetLongValue(_T("RELogValue")) ;
		gStatusGC->SetLongValue(_T("LogAmount"), gLogAmount ) ;
	}

	if( gCurrentBatch == NULL && gREStatus >= RE_SHUTTING_DOWN )
	{
		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("**\tREThread.HandleTimer: gNumJobsLeftToPrint: %ld"), gNumJobsLeftToPrint ) ;
		}

		if( gREStatus == RE_SHUTTING_DOWN && gNumJobsLeftToPrint == 0L )
		{
			SessionLogDirect( _T("**\tREThread.HandleTimer: Posting WM_QUIT: Status: %ld"), gREStatus ) ;
			PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;
			return( FALSE ) ;
		}
		else
		{
			if( gREStatus == RE_QUITTING )
			{
				SessionLogDirect( _T("**\tREThread.HandleTimer: Posting WM_QUIT: Status: %ld"), gREStatus ) ;
				PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;
				return( FALSE ) ;
			}
		}
	}

	//	DO WE NEED TO LOOK FOR MORE WORK ?
	long	CurrentTicks = Clock() ;
	if( gLastWorkCheck + 10000 < CurrentTicks )
	{
		if( gREStatus == RE_RUNNING && gBatchQueue->QtyInQueue() < 2 )
		{
			//	RESERVE ANOTHER BATCH
			PostAThreadMessage( gThisThread, REM_RESERVE_NEXT_BATCH, 0L, 0L ) ;
			gLastWorkCheck = CurrentTicks ;
		}
	}

	//	LOOK FOR RESPONSES
	if( gLastResponse + 1000 < CurrentTicks )
	{
		PostAThreadMessage( gThisThread, REM_RESPONSESCRIPT, 0L, gLastResponse ) ;
		gLastResponse = CurrentTicks ;
	}

	//	GET PRINTER STATUS
	if( gLastPrinterStatus + 10000 < CurrentTicks )
	{
		PostAThreadMessage( gThisThread, REM_GET_PRINTER_STATUS, 0L, 0L ) ;
		gLastPrinterStatus = CurrentTicks ;
	}

	long	LastJobTimeDelay = 10000L ;
	if( gREStatus >= RE_SHUTTING_DOWN )	{ LastJobTimeDelay = 1000L ; }

	if( gLastJobLeftToPrint + LastJobTimeDelay < CurrentTicks )
	{
		PostAThreadMessage( gThisThread, REM_GETNUMJOBSTOPRINT, 0L, 0L ) ;
		gLastJobLeftToPrint = CurrentTicks ;
	}

	//	START A BATCH RENDERING
	if( gCurrentBatch == NULL && gBatchQueue->QtyInQueue())
	{
		PostAThreadMessage( gThisThread, REM_START_BATCH, 0L, 0L ) ;
	}

	return(TRUE) ;
}

void KickBatchThreads()
{
	//	KICK THE CURRENT BATCH
	if( gCurrentBatch )
	{
		CIThread *theBatchThread = (CIThread *) gCurrentBatch->GetLongValue( _T("BatchThread")) ;
		if( theBatchThread )
		{
			PostAThreadMessage( theBatchThread, WM_TIMER, 0L, 0L ) ;
		}
	}

	//	KICK THE NEXT BATCH
	UGenCon	*NextBatch = (UGenCon *) gBatchQueue->GetNext() ;
	if( NextBatch )
	{
		CIThread *theNextBatchThread = (CIThread *) NextBatch->GetLongValue( _T("BatchThread")) ;
		if( theNextBatchThread )
		{
			PostAThreadMessage( theNextBatchThread, WM_TIMER, 0L, 0L ) ;
		}
	}

	//	KICK THE DIALOG THREAD JUST FOR GRINS.
	CIThread *DlgThread = (CIThread *) gStatusGC->GetLongValue(_T("DlgThread")) ;
	if( DlgThread )
	{
		PostAThreadMessage( DlgThread, WM_TIMER, 0L, 0L ) ;
	}
}

//=============================================================================
//=============================================================================
//========================== GET THE NEXT BATCH ===============================
//=============================================================================
//=============================================================================

int ReserveNextBatch()
{
	TCHAR	BatchID[128] ;
	TCHAR	theQuery[1024] ;

	if( gREStatus != RE_RUNNING )			{ return( FALSE ) ; }

	if( gBatchQueue->QtyInQueue() >= 2 )	{ return( FALSE ) ; }


	TCHAR	*PrinterName	= gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
	TCHAR	*QueueName		= gPrinterSetupGC->GetStringValue(_T("QueueName")) ;

	UADO	*theADO = ConnectToADO() ;
	if( theADO )
	{
	
		int	Result = GetNextBatchID( theADO, BatchID ) ;
		if( Result != 1 )
		{
			delete theADO ;
			return( FALSE ) ;
		}

		if( BatchID[0] == 0 )
		{
			delete theADO ;
			return( FALSE ) ; 
		}

		sprintf( theQuery,
			_T("Update JobQueue Set PrinterName = '%s', PrintStatus = %d Where BatchID = '%s' AND Queuename = '%s' AND PrintStatus = 1"),
									PrinterName, RESERVED, BatchID, QueueName ) ;

		Result = theADO->Command( theQuery, _T("SQL"), NULL ) ;
		long RecordsAffected = theADO->GetRecordsAffected() ;

		if( Result != 0 || RecordsAffected == 0 )
		{
			//	THE UPDATE FAILED
			SessionLogDirect(_T("**\tREThread.ReserveNextBatch: Query Failed: [%s] result = %0lX, RecordsAffected = %ld"),
										theQuery, Result, RecordsAffected ) ;

			Result = theADO->RefreshConnectionCache() ;
			delete theADO ;
			return( FALSE ) ;
		}

		//	AT THIS POINT WE HAVE A BATCH TO WORK ON.
		//	LEAVE IT AT RESERVED UNTIL WE ACTUALLY START WORKING ON IT ?!?!?!  TBD

		UGenCon	*BatchInfo = new UGenCon( GetDataDictionary( _T("DDREBatchInfo"))) ;
		BatchInfo->SetAttrValue( _T("BatchID"), BatchID ) ;
		BatchInfo->SetLongValue(_T("State"), BATCH_RESERVED ) ;		//	READY TO BE WORKED ON
		BatchInfo->SetLongValue(_T("REThread"), (long) gThisThread ) ;		//	CALL BACK THREAD
	//	BatchInfo->SetLongValue(_T("PrinterSetup"), gPrinterSetupGC ) ;	//	DO THIS IN StartBatch 
		BatchInfo->SetAttrValue( _T("CustomerID"), _T("DP2")) ;
		gBatchQueue->EnQueue( BatchInfo ) ;							//	PUT THE BATCH IN THE QUEUE

		Result = theADO->RefreshConnectionCache() ;

		GetPageList( theADO, BatchInfo ) ;

		delete theADO ;
	}

	//	GET THE PAGE LIST
//	PostAThreadMessage( gThisThread, REM_GET_PAGE_LIST, 0L, (long) BatchInfo ) ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("**\tREThread.ReserveNextBatch: Reserved: [%s]"), BatchID ) ;
	}

	return( TRUE ) ;
}


//	THIS ROUTINE WILL GET THE NEXT ORDER ID FROM THE JOB QUEUE
int GetNextBatchID( UADO *theADO, TCHAR *BatchID )
{
	UGenCon			*thePGC = NULL ;
	TCHAR			*Result = NULL ;
	long			 PrintStatus = -1L ;
	long			 Count = 0L ;
	int				 Error = FALSE ;

//	UADO	*theADO = ConnectToADO() ;

	if( theADO )
	{
		UPGenConList	*QueuePGCList = new UPGenConList( theADO ) ;
		if( QueuePGCList == NULL )
		{
			HandleDBError(theADO) ;
			Error = TRUE ;
		}

		if( ! Error )
		{
			QueuePGCList->SetName(_T("GetNextBatchID_UPGCList")) ;
			Error = QueryQueue( QueuePGCList ) ;

			if( Error == 1 )
			{
				thePGC = (UGenCon *) GetFirst() ;
				if( thePGC  )
				{
					thePGC->GetAttrValue( _T("BatchID"), BatchID ) ;
				}
			} 
		}
		
		if( QueuePGCList )
		{
			delete QueuePGCList ;
		}

//		delete theADO ;
	}
	return( Error ) ;
}

QueryQueue( UPGenConList *QueuePGCList )
{
	TCHAR	theQuery[1024] ;
	int		result ;

	sprintf( theQuery,
_T("Select BatchID From JobQueue\
 Where QueueName = '%s' AND PrintStatus = 1 AND (PrinterName IS NULL OR PrinterName = '%s')\
 Order By Priority DESC, SubmitDate"),
				gPrinterSetupGC->GetStringValue(_T("QueueName")),
				gPrinterSetupGC->GetStringValue(_T("PrinterName"))) ;

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("**\tREThread.QueryQueue: \"%s\""),theQuery ) ;
	}

	result = QueuePGCList->Query( theQuery, _T("ReadOnly"), _T("Static") ) ;
//	result = Query( QueuePGCList, theQuery, _T("ReadOnly"), _T("Static") ) ;

	if( result != 1 )
	{
		SessionLogDirect( _T("**\tREThread.QueryQueue:\r\n%s\r\n\tFAILED. result = %ld"), theQuery, result ) ;
		gPrinterSetupGC->SetLongValue( _T("DBError"), result ) ;
//		HandleDBError(anADO) ;	JUST LOG THIS... WE WILL BE CHECKING THIS AGAIN IN ABOUT 5 SECONDS.s
	}
	
	return( result ) ;
}

//	PrintStatus:
//	0:	Hold	1:	Ready	2:	Reserved	3:	Printing	4:	Completed
//	5:	Saved	6:	Error	7:	Cancelled	8:	Pending		9:	Loaded			10:	Parsed

//	GET THE LIST OF PAGES FOR THIS BATCH
int GetPageList(UADO *theADO, UGenCon *BatchInfo)
{
	TCHAR	theQuery[2048] ;

	TCHAR	*SelectCmd = _T("Select JobPath, OrderID, OrderSequence, OrderItemID,\
 OrderItemSequence, OrderItemQty, JobID From JobQueue\
 Where BatchID = '%s' AND QueueName = '%s' AND (PrintStatus = 2 OR PrintStatus = 9)\
 Order By BatchID, OrderSequence, OrderID, OrderItemSequence") ;

	if( gREStatus != RE_RUNNING )	{ return( FALSE ) ; }

	if( BatchInfo->GetChildren() )	{ return( TRUE ) ; }	//	ALREADY DONE !

	TCHAR	*BatchID		= BatchInfo->GetStringValue(_T("BatchID")) ;
	TCHAR	*QueueName		= gPrinterSetupGC->GetStringValue(_T("QueueName")) ;
	
	if( gLogAmount >= 2 )
		{ SessionLogDirect( _T("**\tREThread.GetPageList: Batch: [%s]"), BatchID ) ; }

	sprintf( theQuery, SelectCmd, BatchID, QueueName ) ;

	if( gLogAmount >= 7 )
		{ SessionLogDirect( _T("**\tREThread.GetPageList: [%s]"), theQuery ) ; }

//	UADO	*theADO = ConnectToADO() ;
	if( theADO == NULL )
	{
		SessionLogDirect( _T("**\tREThread.GetPageList: Could not get an ADO.")) ;
		return( FALSE ) ;
	}

	UPGenConList *OrderPGCList = new UPGenConList( theADO ) ;
	if( OrderPGCList == NULL )
	{
		HandleDBError(theADO) ;
//		delete theADO ;
		return( FALSE ) ;
	}

	OrderPGCList->SetName(_T("SubmitOrder_UPGCList")) ;

	int Result = OrderPGCList->Query( theQuery, _T("ReadOnly"), _T("Static") ) ;
	if( Result != 1 )
	{
		HandleDBError(theADO) ;
		delete OrderPGCList ;

		SessionLogDirect( _T("**\tREThread.GetPageList: Query Failed, Result = %d."), Result ) ;

		if( gPrinterSetupGC )
			{ gPrinterSetupGC->SetLongValue(_T("DBError"), Result ) ; }

//		delete theADO ;
		return(FALSE) ;
	}

	UGenCon		*PageInfo ;
	UGenCon		*LastPageInfo ;
	TCHAR		*OrderID ;
	TCHAR		*LastOrderID = NULL ;
	long		 PageNumber = 1L ;
	TCHAR		*PrinterName = gPrinterSetupGC->GetStringValue( _T("PrinterName")) ;

	UList		*thePageList = new UList ;
	if( thePageList == NULL )
	{
		ResetBatch( theADO, PrinterName, ERROR, BatchID, QueueName ) ;

		SessionLogDirect( _T("**\tREThread.GetPageList: Could not get the PageList for batch \"%s\"."), BatchID ) ;
		delete OrderPGCList ;
//		delete theADO ;
		return( FALSE ) ;
	}

	TCHAR	theMsg[128] ;
	sprintf( theMsg, _T("PageListBatch_%s"), BatchID ) ;
	thePageList->SetName( theMsg ) ;

	UPGenCon	*thePGC = (UPGenCon *) OrderPGCList->GetFirst() ;
	while( thePGC )
	{
		PageInfo = SetUpPage( BatchID, thePGC, PageNumber ) ;

		if( PageInfo == NULL )
		{
			ResetBatch( theADO, PrinterName, ERROR, BatchID, QueueName ) ;

			SessionLogDirect( _T("**\tREThread.GetPageList: Could not get a Page Info GenCon for Batch \"%s\"."), BatchID ) ;
			delete OrderPGCList ;
//			delete theADO ;
			return( FALSE ) ;
		}

		PageNumber++ ;

		OrderID = PageInfo->GetStringValue(_T("OrderID")) ;
		if( LastOrderID == NULL )
		{
			LastOrderID		= OrderID ;
			LastPageInfo	= PageInfo ;
		}

		if( stricmp( LastOrderID, OrderID ))
		{
			LastPageInfo->SetLongValue( _T("EndOfOrder"), TRUE ) ;
		}

		PageInfo->SetParent( BatchInfo ) ;
		thePageList->InsertBack( PageInfo ) ;

		LastOrderID  = OrderID ;
		LastPageInfo = PageInfo ;

		thePGC = (UPGenCon *) OrderPGCList->GetNext() ;
	}

	//	BE SURE THE LAST PAGE IS MARKED AS END OF ORDER
	if( LastPageInfo )
	{
		LastPageInfo->SetLongValue( _T("EndOfOrder"), TRUE ) ;
	}

	if( gLogAmount >= 2 )
	{
		SessionLogDirect( _T("**\tREThread.GetPageList: NumPages: %ld"), thePageList->GetNumEntries() ) ;
	}

	//	IF WE HAVE ENTRIES, THEN SAY BATCH READY
	if( thePageList->GetNumEntries() )
	{
		thePageList->SetParent( BatchInfo ) ;
		BatchInfo->SetChildren( thePageList ) ;
		BatchInfo->SetLongValue( _T("State"), BATCH_READY ) ;
		BatchInfo->SetLongValue( _T("TotalPrints"), thePageList->GetNumEntries()) ;
	}
	else	//	LET'S TRY THIS AGAIN
	{
		//	GET THE PAGE LIST
//		PostAThreadMessage( gThisThread, REM_GET_PAGE_LIST, 0L, (long) BatchInfo ) ;
		if( gLogAmount >= 5 )
		{
			SessionLogDirect( _T("**\tREThread.GetPageList: Could not get PageList for Batch: \"%s\"."), 
											BatchInfo->GetStringValue(_T("BatchID")) ) ;
		}
	}

//	NEW 04/27/05
	
/*	Result = TRUE ;

	sprintf( theQuery,
		_T("Update JobQueue Set PrintStatus = %d Where BatchID = '%s' AND Queuename = '%s' AND PrintStatus = 2"),
								LOADED, BatchID, QueueName ) ;

	Result = ADOCommand( theADO, theQuery, "SQL", NULL ) ;
	long RecordsAffected = theADO->GetRecordsAffected() ;

	if( Result != 0 || RecordsAffected == 0 )
	{
		//	THE UPDATE FAILED
		SessionLogDirect(_T("**\tREThread.GetPageList: Query Failed: [%s] result = %0lX, RecordsAffected = %ld"),
									theQuery, Result, RecordsAffected ) ;

		Result = theADO->RefreshConnectionCache() ;

		Result = FALSE ;
	}
*/
	delete OrderPGCList ;
//	delete theADO ;

	return( Result ) ;
}

UGenCon *SetUpPage( TCHAR *BatchID, UGenCon *thePGC, long PageNumber )
{
	UGenCon *PageInfo = new UGenCon( GetDataDictionary( _T("DDREPageInfo"))) ;
	if( PageInfo )
	{
		TCHAR	*theJobID		= thePGC->GetStringValue(_T("JobID")) ;
		TCHAR	*JobPath		= thePGC->GetStringValue(_T("JobPath")) ;
		TCHAR	*OrderID		= thePGC->GetStringValue(_T("OrderID")) ;
		long	 OrderSeq		= thePGC->GetLongValue( _T("OrderSequence") ) ;
		long	 OrderItemID	= thePGC->GetLongValue( _T("OrderItemID") ) ;
		long	 OrderItemSeq	= thePGC->GetLongValue( _T("OrderItemSequence") ) ;
		long	 OrderItemQty	= thePGC->GetLongValue( _T("OrderItemQty") ) ;
		
		TCHAR	 PageName[64] ;
		sprintf( PageName, _T("P%09ld"), atoi( theJobID ) ) ;
		PageInfo->SetName( PageName ) ;

		if( gLogAmount >= 2 )
		{
			SessionLogDirect( _T("**\tREThread.SetUpPage: Name: %s"), PageName ) ;
		}

		StripTrailingBlanks( theJobID ) ;
		PageInfo->SetAttrValue( _T("PageID"), theJobID ) ;
		PageInfo->SetLongValue( _T("JobID"), atoi( theJobID )) ;	//	BACKWARD COMPATABILITY

		StripTrailingBlanks( BatchID ) ;
		PageInfo->SetAttrValue( _T("BatchID"), BatchID ) ;

		StripTrailingBlanks( OrderID ) ;
		PageInfo->SetAttrValue( _T("OrderID"), OrderID ) ;

		StripTrailingBlanks( JobPath ) ;
		PageInfo->SetAttrValue( _T("JobPath"), JobPath ) ;
		
		PageInfo->SetLongValue( _T("PrintNumber"),	PageNumber ) ;
		PageInfo->SetLongValue( _T("PageNumber"),	PageNumber ) ;	//	BACKWARD COMPATABILITY
		PageInfo->SetLongValue( _T("OrderSeq"),		OrderSeq ) ;
		PageInfo->SetLongValue( _T("OrderItemID"),	OrderItemID ) ;
		PageInfo->SetLongValue( _T("OrderItemSeq"), OrderItemSeq ) ;
		PageInfo->SetLongValue( _T("OrderItemQty"), OrderItemQty ) ;
		PageInfo->SetLongValue( _T("State"),		PAGE_READY ) ;
		PageInfo->SetLongValue( _T("PrintThisPage"), 1L ) ;			//	USED FOR PAPER FILL

		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("**\tREThread.SetUpPage: JobID: \"%s\", OrderID: \"%s\", OrderSeq: %ld, OrderItemID: %ld, OrderItemSeq: %ld, OrderItemQty: %ld, JobPath: \"%s\""),
					theJobID, OrderID, OrderSeq, OrderItemID, OrderItemSeq, OrderItemQty, JobPath ) ;
		}

	}
	return( PageInfo ) ;
}

int ResetBatch(UADO *theADO, TCHAR *PrinterName, long PrintStatus, TCHAR *BatchID, TCHAR *QueueName )
{
	int		Result ;
	TCHAR	theQuery[1024] ;

	sprintf( theQuery,
		_T("Update JobQueue Set PrinterName = '%s', PrintStatus = %d Where BatchID = '%s' AND Queuename = '%s' AND PrintStatus = 1"),
								PrinterName, PrintStatus, BatchID, QueueName ) ;

//	Result = ADOCommand( theADO, theQuery, "SQL", NULL ) ;
		Result = theADO->Command( theQuery, _T("SQL"), NULL ) ;

	return( Result ) ;
}


int StartBatch()
{
	if( gCurrentBatch )				{ return( FALSE ) ; }

	if( gREStatus != RE_RUNNING )	{ return( FALSE ) ; }

	//	LOOK AHEAD WITHOUT REMOVING BATCH FROM QUEUE.
	UGenCon	*theBatch = (UGenCon *) gBatchQueue->GetNext() ;
	if( theBatch )
	{
		if( theBatch->GetLongValue(_T("State")) == BATCH_READY )
		{
			//	GET BATCH AND REMOVE FROM QUEUE.
			theBatch = (UGenCon *) gBatchQueue->DeQueue() ;
			if( theBatch == NULL)
				{ return( FALSE ) ; }

			gCurrentBatch = theBatch ;

			TCHAR	*BatchID = theBatch->GetStringValue(_T("BatchID")) ;

			if( gLogAmount >= 0 )
			{
				SessionLogDirect(_T("**\tREThread.StartBatch: Starting Batch: \"%s\"."), BatchID ) ;
			}
	
			UGenCon	*theNewPrinterSetup = gPrinterSetupGC->Copy() ;

			theBatch->SetLongValue(_T("PrinterSetup"), (long) theNewPrinterSetup ) ;
			theBatch->SetLongValue(_T("StatusGC"), (long) gStatusGC ) ;

			CIThread *theBatchThread = StartBatchThread( theNewPrinterSetup, gStatusGC, theBatch ) ;
			theBatch->SetLongValue(_T("BatchThread"), (long) theBatchThread ) ;


			//	START THE THREAD RENDERING
			PostAThreadMessage( theBatchThread, REM_BATCH_START_RENDER, 0L, 0L ) ;

			gStatusGC->SetAttrValue( _T("Status"), _T("Rndr")) ;

			return( TRUE ) ;
		}
		else	//	THE BATCH IS NOT READY YET, TRY AGAIN
		{
			PostAThreadMessage( gThisThread, REM_GET_PAGE_LIST, 0L, (long) theBatch ) ;
			if( gLogAmount >= 5 )
			{
				SessionLogDirect( _T("**\tREThread.StartBatch: Trying to get PageList for Batch: \"%s\" again."), theBatch ) ;
			}
		}
	}
	return( FALSE ) ;
}


CIThread *StartBatchThread(UGenCon *thePrinterSetup, UGenCon *theStatusGC, UGenCon *theBatch)
{
	TCHAR		 FileName[2048] ;

	sprintf( FileName, _T("[E]\\CommonText\\REBatchThread.txt") ) ;

	CIThread	*theThread = new CIThread ;

	if( gLogAmount >= 7 )
	{
		SessionLogDirect(_T("**\tREThread.StartBatchThread: BatchThread: \"0x%08lX\"."), theThread ) ;
	}

	if( theThread )
	{
		theThread->SetRegisterName(_T("REBatchThread")) ;
		int		Result = theThread->Setup(FileName, NULL, -2L, 1000L, thePrinterSetup, gCheckTextLibFirst ) ;

		if( Result == FALSE )
		{
			delete theThread ;
			return( NULL ) ;
		}

		//	PASS THE PRINTER SETUP GENCON
		PostAThreadMessage( theThread, REM_BATCH_PRINTERSETUP, 0L, (long) thePrinterSetup ) ;

		//	PASS THE STATUS GENCON
		PostAThreadMessage( theThread, REM_BATCH_STATUS_GC, 0L, (long) theStatusGC ) ;

		//	PASS THE BATCH GENCON WITH PAGE LIST
		PostAThreadMessage( theThread, REM_BATCH_BATCH_GC, 0L, (long) theBatch ) ;
	}
	return( theThread ) ;
}

void HandleBatchComplete(UGenCon *BatchInfo)
{
	if( BatchInfo == NULL )
	{
		SessionLogDirect( _T("**\tREThread.HandleBatchComplete: Batch is NULL.")) ;
		return ; 
	}

	if( ! IsPointerValid( (unsigned char *) BatchInfo, 12 ))
	{
		SessionLogDirect( _T("**\tREThread.HandleBatchComplete: Batch is bad pointer.")) ;
		return ; 
	}

	TCHAR	*BatchID	= BatchInfo->GetStringValue( _T("BatchID")) ;
	TCHAR	*QueueName	= gPrinterSetupGC->GetStringValue(_T("QueueName")) ;

	if( gLogAmount >= 0 )
		{ SessionLogDirect( _T("**\tREThread.HandleBatchComplete: BatchID: [%s]"), BatchID ) ; }

	TCHAR	*ResponseScript = gPrinterSetupGC->GetStringValue(_T("BIResponseScript")) ;
	if( ResponseScript == NULL )
	{
		RemoveBatchFromQueue( QueueName, BatchID ) ;
	}
	else
	{
		if( *ResponseScript == 0x00 )
		{
			RemoveBatchFromQueue( QueueName, BatchID ) ;
		}
	}

	//	IF WE ARE TALKING TO AN RP30, DO NOT REMOVE THE BATCH FROM THE QUEUE YET
	if( BatchInfo->GetLongValue(_T("State")) == BATCH_CANCELLING ||
		gREStatus == RE_SHUTTING_DOWN || gREStatus == RE_QUITTING )
	{
		RestoreJobQueueToReady() ;	//	THIS DELETES THE BATCH (WHICH DELETES THE gPrinterSetupGC)
	}


	gCurrentBatch = NULL ;

	//	IF WE ARE RUNNING PAPER FILL AND WE HAD A PROBLEM
	//	THEN A PACKAGE MAY STILL HAVE PAGES ASSOCIATED WITH IT
	//	AND WE SHOULD NOT DELETE THE PAGE TWICE.
//	CleanUpBatch( BatchInfo ) ;

	//	TO HELP DEBUG, DELETE THE PAGES EXPLICITLY
	//	ALONG WITH THE CHILD LIST.
	if( BatchInfo )
	{
		delete BatchInfo ;
	}

	gStatusGC->SetAttrValue( _T("Status"), _T("Idle")) ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("**\tREThread.HandleBatchComplete: (End) Status: %ld"), gREStatus ) ;
	}

/*	if( gREStatus >= RE_SHUTTING_DOWN )	//	IF SHUTTING DOWN OR QUITTING
	{
		//	ALL THE BATCHES SHOULD NOW BE TAKEN CARE OF
		//	SO POST THE QUIT MESSAGE
		PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;
	}
*/
}


//	IF WE ARE RUNNING PAPER FILL AND WE HAD A PROBLEM
//	THEN A PACKAGE MAY STILL HAVE PAGES ASSOCIATED WITH IT
//	AND WE SHOULD NOT DELETE THE PAGE TWICE.
int CleanUpBatch( UGenCon *Batch )
{
	if( Batch == NULL )	{ return( FALSE ) ; }

	UList	*PageList = Batch->GetChildren() ;
	UListIterator	*anIter = new UListIterator( PageList ) ;
	UGenCon	*aPage = (UGenCon *) anIter->GetFirst() ;
	UList	*PkgPageList ;

	while( aPage )
	{
		if( gLogAmount >= 3 )
		{
			SessionLogDirect( _T("**\tREThread.CleanUpBatch: aPage: 0x%08lX"), aPage ) ;
		}
		
		if( aPage->GetLongValue( _T("IsPackage")))	//	NEW 10/06/04 
		{
			PkgPageList = aPage->GetChildren() ;
			if( PkgPageList )
			{
				PkgPageList->RemoveAll() ;
				delete PkgPageList ;
				aPage->SetChildren( NULL ) ;
			}
		}
		aPage = (UGenCon *) anIter->GetNext() ;
	}
	delete anIter ;
	return( TRUE ) ;
}

//	PrintStatus:
//	0:	Hold	1:	Ready	2:	Reserved	3:	Printing	4:	Completed
//	5:	Saved	6:	Error	7:	Cancelled	8:	Pending

//	THIS ROUTINE WILL REMOVE JOBS FROM THE JOB QUEUE
//	THE JOBS MUST HAVE COMPLETED SUCCESSFULLY !
int RemoveBatchFromQueue( TCHAR *QueueName, TCHAR *BatchID )
{
	TCHAR			*SelectCmd = _T("Select JobPath, OrderID, JobID From JobQueue\
 Where QueueName = '%s' AND BatchID = '%s' AND\
 (PrintStatus = 4 OR PrintStatus = 5)\
 Order By BatchID, OrderSequence, OrderID, OrderItemSequence") ;

	TCHAR			 theSelectCmd[1024] ;
	TCHAR			 theCmd[1024] ;
	TCHAR			 theJobPath[2048] ;
	TCHAR			 theOrderID[2048] ;
	TCHAR			 LastOrderID[2048] ;
	TCHAR			 JobID[64];
	int				 result ;
	int				 NewOrder = FALSE ;
	int				 FirstTime = TRUE ;
	
	sprintf( theSelectCmd, SelectCmd, QueueName, BatchID ) ;

	UADO	*theADO = ConnectToADO() ;

	if( theADO == NULL )
	{
		SessionLogDirect(_T("**\tREThread.RemoveBatchFromQueue: theADO = %0lX"), theADO ) ;
		return( FALSE ) ;
	}

	// CREATE A NEW UPGENCONLIST.
	UPGenConList *aPGCList = new UPGenConList( theADO ) ;
	if( aPGCList == NULL )
	{
		HandleDBError(theADO) ;
		SessionLogDirect(_T("**\tREThread.RemoveBatchFromQueue: new PGenConList result = NULL")) ;
		delete theADO ;
		return( FALSE ) ;
	}

	aPGCList->SetName(_T("RemoveBatchFromQueue_UPGCList")) ;
	result = aPGCList->Query( theSelectCmd, _T("ReadOnly"), _T("Static") ) ;
	if( result != 1 )
	{
		HandleDBError(theADO) ;
		delete aPGCList ;
		SessionLogDirect(_T("**\tREThread.RemoveBatchFromQueue: Query result = %ld"), result ) ;
		delete theADO ;
		return(FALSE) ;
	}

	//	FOR EACH ENTRY WE HAVE TO DELETE THE JOB FILE
	UPGenCon *aPGC = (UPGenCon *) aPGCList->GetFirst() ;
	while( aPGC && ! NewOrder )
	{
		aPGC->GetAttrValue( _T("JobPath"), theJobPath ) ;
		aPGC->GetAttrValue( _T("OrderID"), theOrderID ) ;
		aPGC->GetAttrValue( _T("JobID"), JobID ) ;

		if( FirstTime )
		{
			strcpy( LastOrderID, theOrderID ) ;
			FirstTime = FALSE ;
		}

		if( strcmp( theOrderID, LastOrderID ) != 0 )
		{
			NewOrder = TRUE ;
		}

		if( ! NewOrder && *theJobPath )
		{
			if( gLogAmount > 5 )
			{
				SessionLogDirect(_T("**\tRemoveBatchFromQueue: Deleting = [%s]"), theJobPath ) ;
			}

			DeleteThisFile( theJobPath ) ;

			sprintf( theCmd, _T("Delete From JobQueue Where JobID = '%s'"), JobID ) ;

			result = DoSQL( theCmd ) ;
		}

		aPGC = (UPGenCon *) aPGCList->GetNext() ;
	}

	delete aPGCList ;
	aPGCList = NULL ;

	delete theADO ;
	return( result == 0 ) ;
}


void HandleShutDown(long ShutdownNow)
{
	gREStatus = RE_SHUTTING_DOWN ;
	if( ShutdownNow )	{ gREStatus = RE_QUITTING ; }

	if( gLogAmount >= 5 )	//	TBD DEBUG
	{
		SessionLogDirect( _T("**\tREThread.HandleShutDown: REStatus: %ld, Now: %ld, gCurrentBatch: 0x%08lX"),
					gREStatus, ShutdownNow, gCurrentBatch ) ;
	}

	if( ShutdownNow && gCurrentBatch )
	{
		CIThread	*theBatchThread = (CIThread *) gCurrentBatch->GetLongValue( _T("BatchThread")) ;

		SessionLogDirect( _T("**\tREThread.HandleShutDown: Batch: %s theBatchThread: 0x%08lX"), 
			gCurrentBatch->GetStringValue(_T("BatchID")), theBatchThread ) ;

		if( theBatchThread )
		{
			//	TELL THE BATCH TO SHUT DOWN
			//	WAIT TILL IT TELLS US IT'S DONE
			gCurrentBatch->SetLongValue(_T("State"), BATCH_CANCELLING ) ;
			PostAThreadMessage( theBatchThread, REM_BATCH_SHUTDOWN, 0L, ShutdownNow ) ;
		}
	}

	//	RESTORE THE OTHER BATCHES IN THE QUEUE TO READY		//	TBD
	//	SO THAT ANOTHER RENDER ENGINE CAN TAKE OVER.

//	RestoreJobQueueToReady() ;
}



int HandleSuspend(long WhySuspended)
{
	if( gREStatus != RE_SUSPENDED )
	{
		if( gLogAmount >= 8 )
		{
			SessionLogDirect( _T("**\tREThread.HandleSuspend: REStatus: %ld, B4Suspend: %ld"), gREStatus, gREStatusB4Suspend ) ;
		}
		gREStatusB4Suspend = gREStatus ;
	}

	gREStatus = RE_SUSPENDED ;
	gSuspendType |= WhySuspended ;

	if( gLogAmount >= 0 )
	{
		SessionLogDirect( _T("**\tREThread.HandleSuspend: Suspended... (SuspendType: %ld)"), gSuspendType ) ;
	}

	TCHAR	*PrinterName = gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
//	UpdatePrinterTable( PrinterName, _T("Suspend"), NULL ) ;

	if( gCurrentBatch )
	{
		CIThread	*theBatchThread = (CIThread *) gCurrentBatch->GetLongValue( _T("BatchThread")) ;
		if( theBatchThread )
		{
			PostAThreadMessage( theBatchThread, REM_BATCH_SUSPEND, 0L, WhySuspended ) ;
		}
	}

//	gRELookAhead->SetLongValue(_T("SuspendNow"), 1L ) ;
	gRELookAhead->SetLongValue(_T("SetFatalErrorToReady"), 1L ) ;	//	TBD 

	CIThread	*DlgThread = (CIThread *) gStatusGC->GetLongValue(_T("DlgThread")) ;
	if( DlgThread )
	{
		TCHAR	*theMsg = (TCHAR *) malloc( 64 * 2 ) ;	//	FREED BY RECIPIENT
		sprintf( theMsg, _T("%s has been suspended."), PrinterName ) ;
		PostAThreadMessage( DlgThread, REM_RE_SHOWSTATUS, 0L, (long) theMsg ) ;
	}

	return( FALSE ) ;
}

/*	PrinterModels:	_T("KPDM II")
					_T("KPDM")
					_T("Kodak LFCRT")
					_T("Kodak CRT")
					_T("Kodak LED")
*/

int HandleResume(long WhySuspended)
{

	if( gSuspendType & WhySuspended )	{ gSuspendType -= WhySuspended ; }

	if( gSuspendType <= 0 )
	{
		if( gLogAmount >= 0 )
		{
			SessionLogDirect( _T("**\tREThread.HandleResume: Resuming... (SuspendType: %ld)"), gSuspendType ) ;
		}

		gREStatus = RE_RUNNING ;
		gSuspendType = 0 ;

		if( gLogAmount >= 8 )
		{
			SessionLogDirect( _T("**\tREThread.HandleResume: REStatus: %ld, B4Suspend: %ld"), gREStatus, gREStatusB4Suspend ) ;
		}

		if( gREStatusB4Suspend == RE_SHUTTING_DOWN || gREStatusB4Suspend == RE_QUITTING )
		{
			gREStatus = gREStatusB4Suspend ;
		}


		TCHAR	*PrinterName = gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
//		UpdatePrinterTable( PrinterName, _T("Run"), NULL ) ;

//		gRELookAhead->SetLongValue(_T("SuspendNow"), 0L ) ;

		if( gCurrentBatch )
		{
			CIThread	*theBatchThread = (CIThread *) gCurrentBatch->GetLongValue( _T("BatchThread")) ;
			if( theBatchThread )
			{
				PostAThreadMessage( theBatchThread, REM_BATCH_RESUME, 0L, WhySuspended ) ;
			}
		}


		CIThread	*DlgThread = (CIThread *) gStatusGC->GetLongValue(_T("DlgThread")) ;
		if( DlgThread )
		{
			TCHAR	*theMsg = (TCHAR *) malloc( 64 * 2 ) ;	//	FREED BY RECIPIENT
			sprintf( theMsg, _T("%s has been resumed."), PrinterName ) ;
			PostAThreadMessage( DlgThread, REM_RE_SHOWSTATUS, 0L, (long) theMsg ) ;
		}

	}
	return( FALSE ) ;
}


//	ALL EXCEPT CURRENTLY RUNNING BATCH
void RestoreJobQueueToReady()
{
	int		 Result ;

	TCHAR	 theQuery[2048] ;

	//	NOT SAVED, COMPLETED, ERROR, CANCELLED, OR PENDING
//	TCHAR	*theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = 1 WHERE BatchID = '%s' AND PrintStatus > 0 AND PrintStatus < 4 ") ;
	TCHAR	*theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = 1	WHERE BatchID = '%s' AND \
						   (PrintStatus	= 1		OR\
							PrintStatus	= 2		OR\
							PrintStatus = 3		OR\
							PrintStatus = 5		OR\
							PrintStatus = 9		OR\
							PrintStatus = 10	)") ;	//	NOT HOLD, COMPLETED, ERROR, CANCELLED, OR PENDING

	if( gLogAmount >= 8 )
	{
		SessionLogDirect( _T("REThread.RestoreJobQueueToReady: Num In BatchQueue: %ld"),
								gBatchQueue->GetNumEntries()) ;
	}

	TCHAR	*BatchID ;
	UGenCon *aBatch = (UGenCon *) gBatchQueue->DeQueue() ;
	while( aBatch )
	{
		BatchID = aBatch->GetStringValue( _T("BatchID")) ;

		if( gLogAmount >= 3 )
			{ SessionLogDirect( _T("**\tREThread.RestoreJobQueueToReady: BatchID: \"%s\"."), BatchID ) ; }

		sprintf( theQuery, theUpdateCmd, BatchID ) ;

		Result = DoSQL( theQuery ) ;

		delete aBatch ;

		aBatch = (UGenCon *) gBatchQueue->DeQueue() ;
	}
}

//	ALL EXCEPT CURRENTLY RUNNING BATCH
void RestoreJobQueueToReadyForTest(TCHAR *BatchID)
{
	TCHAR	 theQuery[2048] ;

	TCHAR	*theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = 1 WHERE BatchID = '%s'") ;

	sprintf( theQuery, theUpdateCmd, BatchID ) ;

	int Result = DoSQL( theQuery ) ;

}


void HandleStatusRequest()
{
	TCHAR	DateAndTime[64] ;

	if( gCurrentBatch )
	{
		CIThread	*theBatchThread = (CIThread *) gCurrentBatch->GetLongValue( _T("BatchThread")) ;
		if( theBatchThread )
		{
			PostAThreadMessage( theBatchThread, REM_BATCH_STATUS_REQ, 0L, 0L ) ;	//	Request Status
			return ;
		}
	}
	else
	{
		gStatusGC->SetAttrValue( _T("Batch"), _T(" ")) ;
		gStatusGC->SetAttrValue( _T("Order"), _T(" ")) ;
		gStatusGC->SetLongValue( _T("Item"), 0L ) ;

		GetTimeNow( DateAndTime, _T("%H:%M:%S")) ;
		gStatusGC->SetAttrValue( _T("Time"), DateAndTime ) ;

		if( gREStatus == RE_SUSPENDED )
		{
			if( gSuspendType & RE_THRT_SUSPEND )
			{
				gStatusGC->SetAttrValue( _T("Status"), _T("Throttled")) ;
			}
			else
			{
				if( gSuspendType & RE_DISK_SUSPEND )
				{
					gStatusGC->SetAttrValue( _T("Status"), _T("Throttled (Disk)") ) ;
				}
				else
				{
					gStatusGC->SetAttrValue( _T("Status"), _T("Susp") ) ;
				}
			}
		}
		else
		{
			gStatusGC->SetAttrValue( _T("Status"), _T("Idle") ) ;
		}
	}
}


//		int			 RE_RUNNING			= 1 ;
//		int			 RE_SUSPENDED		= 2 ;
//		int			 RE_SHUTTING_DOWN	= 3 ;
//		int			 RE_QUITTING		= 4 ;

TCHAR	*GetStatusString( int Status )
{
	TCHAR	*theString = _T(" ") ;
	switch( Status )
	{
		case	1	:	theString = _T("Running") ; break ;
		case	2	:	theString = _T("Suspended") ; break ;
		case	3	:	theString = _T("Shutting Down") ; break ;
		case	4	:	theString = _T("Quitting") ; break ;
	}

	return( theString ) ;
}

//=============================================================================
//=============================================================================
//=========================== PRINTER TABLE HANDLING ==========================
//=============================================================================
//=============================================================================

int UpdatePrinterTable( TCHAR *PrinterName, TCHAR *Status, TCHAR *QueueName )
{
	TCHAR	 UpdateCmd[1024] ;
	TCHAR	*UpdateTemplate = NULL ;
	long	 StatusNumber = 0L ;

	if( QueueName && Status )
	{
		StatusNumber = GetStatusNumber( Status ) ;
		UpdateTemplate = _T("Update Printers Set QueueName = '%s', Status = %ld Where PrinterName = '%s'") ;
		sprintf( UpdateCmd, UpdateTemplate, QueueName, StatusNumber, PrinterName ) ;
	}
	else
	{
		if( Status )
		{
			StatusNumber = GetStatusNumber( Status ) ;
			UpdateTemplate = _T("Update Printers Set Status = %ld Where PrinterName = '%s'") ;
			sprintf( UpdateCmd, UpdateTemplate, StatusNumber, PrinterName ) ;
		}
		else
		{
			UpdateTemplate = _T("Update Printers Set QueueName = '%s' Where PrinterName = '%s'") ;
			sprintf( UpdateCmd, UpdateTemplate, QueueName, PrinterName ) ;
		}
	}

	if( gLogAmount > 7 )
	{
		SessionLogDirect( _T("REThread.UpdatePrinterTable: \"%s\"."), UpdateCmd ) ;
	}

	int Result = DoSQL( UpdateCmd ) ;

	return( Result ) ;
}

long GetStatusNumber( TCHAR *Status )
{
	if( stricmp( Status, _T("Run")) == 0 )		{ return( 1L ) ; }
	if( stricmp( Status, _T("Suspend")) == 0 )	{ return( 2L ) ; }
	if( stricmp( Status, _T("Quit")) == 0 )		{ return( 3L ) ; }

	return( 0L ) ;	//	SHUTDOWN
}

long HandlePrinterStatus()
{
	long PrinterStatus = GetPrinterStatus( gPrinterSetupGC ) ;
	switch( PrinterStatus )
	{
		case	0	:	//	SHUTDOWN
			if( gPrinterStatusReady )
			{
				HandleShutDown(0L) ;
			}
			break ;

		case	1	:	//	RUN / RESUME
			if( gREStatus == RE_SUSPENDED )
			{
				HandleResume(RE_TABL_SUSPEND) ;
//				gREStatus = RE_RUNNING ;
			}

			gPrinterStatusReady = TRUE ;
			break ;

		case	2	:	//	SUSPENDED
			if( gREStatus == RE_RUNNING )
			{
				HandleSuspend(RE_TABL_SUSPEND) ;
			}
			break ;

		case	3	:	//	QUIT	( SHUTDOWN NOW )
			if( gPrinterStatusReady )
			{
				HandleShutDown(1L) ;
			}
			break ;
	}
	return( PrinterStatus ) ;
}

/*
int			 RE_RUNNING			= 1 ;
int			 RE_SUSPENDED		= 2 ;
int			 RE_SHUTTING_DOWN	= 3 ;
int			 RE_QUITTING		= 4 ;
*/

//=============================================================================
//=============================================================================
//=========================== SCRIPT HANDLING =================================
//=============================================================================
//=============================================================================

int RunResponseScript(long LastTickCount)
{
	TCHAR	*ResponseScript = gPrinterSetupGC->GetStringValue(_T("BIResponseScript")) ;
	if( ResponseScript )
	{
		if( *ResponseScript )
		{
			RunScript( ResponseScript, TRUE, LastTickCount ) ;
		}
	}

	ResponseScript = gPrinterSetupGC->GetStringValue(_T("ResponseScript")) ;
	if( ResponseScript )
	{
		if( *ResponseScript )
		{
			RunScript( ResponseScript, TRUE, LastTickCount ) ;
		}
	}
	return( TRUE ) ;
}


int RunScript( TCHAR *ScriptName, int IsResponseScript, long LastTickCount )
{
	int			 Result = TRUE ;
	TCHAR		 FuncCall[1024] ;
	UGenCon		*PrinterResponseGC ;
	TCHAR		*ResponseFolder ;
	TCHAR		*ResponseFilePath ;

	if( LastTickCount == 0L )
	{
		CallScript( ScriptName, _T("Advertize()")) ;
	}

	if( IsResponseScript )
	{
		while( Result )
		{
			PrinterResponseGC = new UGenCon( GetDataDictionary(_T("DDFSResponse"))) ;

			if( PrinterResponseGC )
			{
				//	SET UP THE RESPONSE FOLDER PATH		TBD
				ResponseFolder = gPrinterSetupGC->GetStringValue( _T("ResponseFolder")) ;
				PrinterResponseGC->SetAttrValue(_T("ResponseFolder"), ResponseFolder ) ;
				PrinterResponseGC->SetLongValue(_T("PrinterSetupGC"), (long) gPrinterSetupGC ) ;
				PrinterResponseGC->SetLongValue(_T("StatusGC"), (long) gStatusGC ) ;
				PrinterResponseGC->SetLongValue(_T("REThread"), (long) gThisThread ) ;
				PrinterResponseGC->SetLongValue(_T("SuspendType"), gSuspendType ) ;

				sprintf( FuncCall, _T("Init(0x%08lX, 0x%08lX);"), 0L, PrinterResponseGC ) ;

//=============================================================================
				Result = CallScript( ScriptName, FuncCall ) ;
//=============================================================================
				ResponseFilePath = PrinterResponseGC->GetStringValue(_T("ResponseFilePath")) ;
				DeleteThisFile( ResponseFilePath ) ;		//	QWERTY
//=============================================================================
				HandleResponseScript( PrinterResponseGC ) ;	//	suspends on error with dialog
//=============================================================================

				delete PrinterResponseGC ;
			}
			else
			{
				Result = FALSE ;
			}
		}
//		Result = TRUE ;
	}

	return( Result ) ;
}



int	HandleResponseScript( UGenCon *PrinterResponseGC )
{
	//	DO WE NEED TO UPDATE A STATUS ?		TBD
	//	DO WE NEED TO DISPLAY AN ERROR ?
	int		 Result = TRUE ;
	TCHAR	*ErrorText = _T("") ;

	if( PrinterResponseGC == NULL )	{ return( FALSE ) ; }

	long	 PageID			= PrinterResponseGC->GetLongValue(_T("ResponsePage")) ;
	long	 RunAttended	= gPrinterSetupGC->GetLongValue(_T("RunAttended")) ;

	UGenCon	*thePage = NULL ;

//	if( PageID == 0L )				{ return( FALSE ) ; }

//=============================================================================
	if( PageID ) { 	thePage = LoadPage( PageID ) ; }
//=============================================================================

	//	WE ARE RUNNING A RESPONSE SCRIPT SO...
//=============================================================================
	//	THIS ROUTINE UPDATES THE JOB QUEUE AND FILTERS SOME ERRORS (RP30?) TBD remove filters
	Result = HandleTheResponse( thePage, PrinterResponseGC ) ;
//=============================================================================

	long	ErrorCode	= PrinterResponseGC->GetLongValue(_T("ResponseCode")) ;
	long	Found		= PrinterResponseGC->GetLongValue(_T("FoundResponse")) ;

	if( Found )
	{
		if( gLogAmount >= 7 )	//	TBD was 7
		{
			SessionLogDirect( _T("**\tREThread.HandleResponseScript: ErrorCode: %ld, RunAttended: %ld"),
									ErrorCode, RunAttended ) ;
		}

		if( ErrorCode == 0 )
		{
			HandleSuccessResponse( thePage, PrinterResponseGC ) ;
			if( thePage )
			{
				delete thePage ;	//	dies here if paper fill ! trying to delete children.
			}
		}
		else
		{
			HandleErrorResponse( thePage, PrinterResponseGC ) ;
			//	DON'T DELETE PAGE HERE, WAIT FOR DIALOG RESPONSE
		}
	}


	return( TRUE ) ;
}

int HandleSuccessResponse( UGenCon *thePage, UGenCon *ResponseGC )
{
	TCHAR	*Type			= ResponseGC->GetStringValue(_T("ResponseType")) ;
	long	 ResponseError	= ResponseGC->GetLongValue(_T("ResponseCode")) ;
	long	 JobID			= ResponseGC->GetLongValue(_T("ResponsePage")) ;
	
	if( Type == NULL)	{ return( FALSE ) ; }

	if( Type[0] )
	{
		if( stricmp( Type, _T("RESPONSE")) == 0 )
		{
//			DeleteRecordFromJobQueue( thePage ) ;	//	DONE IN HandleResponse
//			DeleteRecordFromJobQueue( JobID ) ;		//	DONE IN HandleResponse (OLD WAY)

			if( gCurrentBatch == NULL )	{ return( FALSE ) ; }

			UGenCon		*aPage = FindPageByID( gCurrentBatch, JobID ) ;		//	thePage ????? TBD

			if( aPage == NULL )			{ return( FALSE ) ; }

			CIThread	*theBatchThread = (CIThread *) gCurrentBatch->GetLongValue(_T("BatchThread")) ;
			PostAThreadMessage( theBatchThread, REM_BATCH_PRINT_SUCCESS, 0L, (long) aPage ) ;
		}
	}	//	IF TYPE[0]
	return( TRUE ) ;
}


int HandleErrorResponse( UGenCon *thePage, UGenCon *PrinterResponseGC )
{
	long	 IsMode			= IsModePrinter() ;
	long	 PageID			= PrinterResponseGC->GetLongValue(_T("ResponsePage")) ;
	long	 RunAttended	= gPrinterSetupGC->GetLongValue(_T("RunAttended")) ;

	long	 ErrorCode		= PrinterResponseGC->GetLongValue(_T("ResponseCode")) ;
	TCHAR	*ErrorText		= PrinterResponseGC->GetStringValue(_T("ErrorText")) ;
	int		 ErrorType		= PrinterResponseGC->GetLongValue(_T("ErrorType")) ;

	CIThread	*theBatchThread ;

	if( thePage == NULL && IsMode )
	{
		thePage = new UGenCon( GetDataDictionary(_T("DDREPageInfo"))) ;
		if( thePage )
		{
			thePage->SetLongValue(_T("JobID"), PageID ) ;
			thePage->SetAttrValue(_T("BatchID"), PrinterResponseGC->GetStringValue(_T("BatchID")) ) ;
			thePage->SetAttrValue(_T("OrderID"), PrinterResponseGC->GetStringValue(_T("BOrderID")) ) ;
		}
	}

	int UserAction = 2 ;
	if( RunAttended || ( IsMode && ErrorType == 3) )
	{
		//	SUSPEND THE BATCH RENDERING
		if( gCurrentBatch )
		{
			theBatchThread = (CIThread *) gCurrentBatch->GetLongValue(_T("BatchThread")) ;
			if( theBatchThread )
			{
				PostAThreadMessage( theBatchThread, REM_BATCH_SUSPEND, 0L, 0L ) ;
			}
		}

		if( gLogAmount >= 8 )
		{
			SessionLogDirect( _T("**\tREThread.HandleErrorResponse: REStatus: %ld, B4Suspend: %ld"), gREStatus, gREStatusB4Suspend ) ;
		}

		if( gREStatus != RE_SUSPENDED )
		{
			gREStatusB4Suspend = gREStatus ;
		}

		gREStatus = RE_SUSPENDED ;
		gSuspendType |= RE_ERR_SUSPEND ;

//=============================================================================
		UserAction = ShowDialog( ErrorText, ErrorType, REM_ERROR_DLG_RESPONSE, thePage ) ;
//=============================================================================

	}
	else	//	RUNNING unATTENDED
	{
		if( thePage )
		{
					 PageID		= thePage->GetLongValue(_T("JobID")) ;
			TCHAR	*BatchID	= thePage->GetStringValue(_T("BatchID")) ;
			TCHAR	*OrderID	= thePage->GetStringValue(_T("OrderID")) ;

			HandlePrinterError( UserAction, BatchID, OrderID, PageID ) ;

			HandleUserAction( UserAction, thePage ) ;

			delete thePage ;
		}
	}
	return( TRUE ) ;
}


int DialogErrorResponse(UGenCon *thePage, long UserAction)
{
	//	JUST CANCEL THE PAGE AND KEEP GOING
	long	 PageID	= 0L ;
	TCHAR	*BatchID = NULL ;
	TCHAR	*OrderID = NULL ;

	if( thePage )
	{
		PageID	= thePage->GetLongValue(_T("JobID")) ;
		BatchID	= thePage->GetStringValue(_T("BatchID")) ;
		OrderID	= thePage->GetStringValue(_T("OrderID")) ;
	}

	HandlePrinterError( UserAction, BatchID, OrderID, PageID ) ;

	HandleUserAction( UserAction, thePage ) ;

	//	RESUME THE BATCH RENDERING
	if( gCurrentBatch )
	{
		CIThread	*theBatchThread = (CIThread *) gCurrentBatch->GetLongValue(_T("BatchThread")) ;
		if( theBatchThread )
		{
//			PostAThreadMessage( theBatchThread, REM_BATCH_RESUME, 0L, 0L ) ;
			PostAThreadMessage( theBatchThread, REM_BATCH_RESUME, 0L, RE_ERR_SUSPEND ) ;
		}
	}

	if( gSuspendType & RE_ERR_SUSPEND )
	{
		gSuspendType -= RE_ERR_SUSPEND ;
		if( gSuspendType <= 0 )
		{
			if( gLogAmount >= 8 )
			{
				SessionLogDirect( _T("**\tREThread.DialogErrorResponse: REStatus: %ld, B4Suspend: %ld"), gREStatus, gREStatusB4Suspend ) ;
			}

			gREStatus = RE_RUNNING ;
			gSuspendType = 0 ;
			if( gREStatusB4Suspend == RE_SHUTTING_DOWN || gREStatusB4Suspend == RE_QUITTING )
			{
				gREStatus = gREStatusB4Suspend ;
			}

			if( gLogAmount >= 8 )
			{
				SessionLogDirect( _T("**\tREThread.DialogErrorResponse: REStatus: %ld, B4Suspend: %ld"), gREStatus, gREStatusB4Suspend ) ;
			}
		}
	}

	if( thePage )
	{
		delete thePage ;
	}

	return( TRUE ) ;
}

//		if( stricmp( Response, _T("Retry")) == 0 )			{ UserAction = 1L ; }
//		if( stricmp( Response, _T("CancelPage")) == 0 )		{ UserAction = 2L ; }
//		if( stricmp( Response, _T("CancelOrder")) == 0 )	{ UserAction = 3L ; }
//		if( stricmp( Response, _T("CancelBatch")) == 0 )	{ UserAction = 4L ; }

void HandleUserAction( long UserAction, UGenCon *thePage )
{
	CIThread	*theBatchThread = NULL ;

	if( gCurrentBatch )
	{
		theBatchThread = (CIThread *) gCurrentBatch->GetLongValue(_T("BatchThread")) ;
		if( theBatchThread == NULL )
		{
			SessionLogDirect( _T("**\tREThread.HandleUserAction: theBatchThread == NULL!")) ;
		}
	}

	
	switch( UserAction )
	{
		case	1	:	//	Retry
			if( thePage )
			{
				SavePage( thePage ) ;
				UpdateJobRecord( thePage->GetLongValue(_T("JobID")), PRINTING ) ;
				UpdateOrderItemsRecord(thePage, PRINTING ) ;
			}
			break ;

		case	2	:	//	Cancel Page
			if( theBatchThread )
			{
				PostAThreadMessage( theBatchThread, REM_BATCH_CANCEL_PAGE,  0L, 0L ) ;				//	CANCEL PAGE RENDERING
			}
//			else
//			{
//				CancelPage( thePage ) ;
//			}

			CancelPage( thePage ) ;

			break ;

		case	3	:	//	Cancel Order
		case	4	:	//	Cancel Batch
			if( theBatchThread )
			{
				PostAThreadMessage( theBatchThread, REM_BATCH_CANCEL_PAGE,  0L, 0L ) ;				//	CANCEL PAGE RENDERING
				PostAThreadMessage( theBatchThread, REM_BATCH_CANCEL_BATCH, 0L, (long) gCurrentBatch ) ;	//	CANCEL THE BATCH
			}
			else
			{
				CancelBatch( thePage ) ;
			}
			break ;
	}
}


void CancelPage( UGenCon *thePage )
{
	if( thePage )
	{
		long	PageID = thePage->GetLongValue(_T("JobID")) ;
		if( thePage->GetLongValue(_T("IsPackage")))
		{
			UList	*SrcPages = thePage->GetChildren() ;
			if( SrcPages )
			{
				UListIterator	*anIter = new UListIterator( SrcPages ) ;
				UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
				while( aPage )
				{
					PageID = aPage->GetLongValue(_T("JobID")) ;
					UpdateJobRecord( PageID, CANCELLED ) ;
					CleanPageFile( PageID ) ;
					aPage = (UGenCon *) anIter->GetNext() ;
				}
				delete anIter ;
			}
		}
		else
		{
			UpdateJobRecord( PageID, CANCELLED ) ;
		}
	}
}

void CancelBatch( UGenCon *thePage )
{
	if( thePage == NULL )	{ return ; }

	TCHAR	*BatchID	= thePage->GetStringValue(_T("BatchID")) ;

//	HandlePrinterError( 4L,BatchID, NULL, 0L ) ;

	int		 Result		= FALSE ;
	TCHAR	*theQuery	= (TCHAR *) malloc( 2048 * 2 ) ;	//	THIS WILL BE FREED BY RECEIVER

	//	HOLD(0), READY(1), RESERVED(2), PRINTING(3), COMPLETE(4),
	//	SAVED(5), ERROR(6), CANCELLED(7), PENDING(8), LOADED(9), PARSED(10)

	TCHAR	*theUpdateCmd = _T("UPDATE JobQueue SET PrintStatus = %ld\
									WHERE BatchID = '%s' AND \
								   (PrintStatus	= 1		OR\
									PrintStatus	= 2		OR\
									PrintStatus = 3		OR\
									PrintStatus = 5		OR\
									PrintStatus = 9		OR\
									PrintStatus = 10	)") ;	//	NOT HOLD, COMPLETED, ERROR, CANCELLED, OR PENDING


	sprintf( theQuery, theUpdateCmd, CANCELLED, BatchID ) ;

	if( gLogAmount >=5 )
	{
		SessionLogDirect( _T("****\tREThread.CancelBatch: SQL: [%s]"), theQuery) ;
	}

	HandleSQL(theQuery) ;

	RemoveCancelledPages(BatchID) ;
}

//	GET THE LIST OF PAGES FOR THIS BATCH
int RemoveCancelledPages(TCHAR *BatchID)
{
	TCHAR	theQuery[2048] ;

	TCHAR	*SelectCmd = _T("Select JobID From JobQueue Where BatchID = '%s' AND PrintStatus = 7") ;

	if( gLogAmount >= 2 )
		{ SessionLogDirect( _T("**\tREThread.RemoveCancelledPages: Batch: [%s]"), BatchID ) ; }

	sprintf( theQuery, SelectCmd, BatchID ) ;

	if( gLogAmount >= 7 )
		{ SessionLogDirect( _T("**\tREThread.RemoveCancelledPages: [%s]"), theQuery ) ; }

	UADO	*theADO = ConnectToADO() ;
	if( theADO == NULL )
	{
		SessionLogDirect( _T("**\tREThread.RemoveCancelledPages: Could not get an ADO.")) ;
		return( FALSE ) ;
	}

	UPGenConList *OrderPGCList = new UPGenConList( theADO ) ;
	if( OrderPGCList == NULL )
	{
		HandleDBError(theADO) ;
		delete theADO ;
		return( FALSE ) ;
	}

	OrderPGCList->SetName(_T("RemoveCancelledPages_UPGCList")) ;

	int Result = OrderPGCList->Query( theQuery, _T("ReadOnly"), _T("Static") ) ;
	if( Result != 1 )
	{
		HandleDBError(theADO) ;
		delete OrderPGCList ;

		SessionLogDirect( _T("**\tREThread.RemoveCancelledPages: Query Failed, Result = %d."), Result ) ;

		if( gPrinterSetupGC )
			{ gPrinterSetupGC->SetLongValue(_T("DBError"), Result ) ; }

		delete theADO ;
		return(FALSE) ;
	}

	TCHAR		*JobID ;
	long		 PageID ;

	UPGenCon	*thePGC = (UPGenCon *) OrderPGCList->GetFirst() ;
	while( thePGC )
	{
		JobID = thePGC->GetStringValue(_T("JobID")) ;
		PageID = atoi( JobID ) ;

		CleanPageFile( PageID ) ;

		thePGC = (UPGenCon *) OrderPGCList->GetNext() ;
	}

	delete OrderPGCList ;
	delete theADO ;
	return( Result ) ;
}


int CleanPageFile( long PageID )
{
	UGenCon *aPage = LoadPage(PageID) ;

	if( gLogAmount >= 6 )
	{
		SessionLogDirect( _T("**\tREThread.CleanPageFile: PageID: %09ld, aPage: 0x%08lX"), PageID, aPage ) ;
	}

	if( aPage )
	{
		aPage->SetLongValue(_T("UIC"), NULL ) ;
		aPage->SetLongValue(_T("URenderList"), NULL ) ;
		aPage->SetLongValue(_T("Pie"), NULL ) ;
		delete aPage ;
	}
	return( TRUE ) ;
}

int HandlePrinterError(long UserAction, TCHAR *BatchID, TCHAR *OrderID, long PageID )
{
	TCHAR	 FuncCall[1024] ;
	TCHAR	*ResponseScript = gPrinterSetupGC->GetStringValue(_T("BIResponseScript")) ;
	sprintf( FuncCall, _T("PerformUserAction( 0x%08lX, %ld, \"%s\", \"%s\", %ld ) ;"),
				gPrinterSetupGC, UserAction, BatchID, OrderID, PageID ) ;
	int Result = CallScript( ResponseScript, FuncCall ) ;

	if( gLogAmount > 3 )
	{
		SessionLogDirect( _T("REThread.HandlePrinterError: %ld = %s"), Result, FuncCall ) ;
	}

	return( Result ) ;
}



//	TBD:	THIS ROUTINE FILTERS ERRORS AND UPDATES THE JOB QUEUE AND ORDER ITEM TABLE
int HandleTheResponse( UGenCon *thePage, UGenCon *PrinterResponse )
{
	//	UPDATE THE DATABASE TABLE WITH THE STATUS FROM THE PRINTER RESPONSE
	//	DELETE THE RESPONSE FILE

	//	WE NEED TO FIND THE PAGE ASSOCIATED WITH THIS RESPONSE (IF THERE IS ONE.)

	//	COPY ANY ERROR INFORMATION FROM THE PRINTER_RESPONSE TO THE PAGE

	long	ErrorCode	= PrinterResponse->GetLongValue(_T("ResponseCode")) ;

	if( gLogAmount >= 7 )
	{
		PrinterResponse->Dump(_T("REThread.HandleTheResponse: PrinterResponse")) ;
	}


	//	POST EITHER THE SUCCESS OR ERROR THREAD MESSAGE
	TCHAR	*ResponseType = PrinterResponse->GetStringValue(_T("ResponseType")) ;
	if( ResponseType == NULL )	{ return( TRUE ) ; }

	if( stricmp( ResponseType, _T("ERROR")) == 0 )
	{
		//	DEAL WITH THE COMMUNICATIONS OR PRINTER ERROR			TBD.
//		SessionLogDirect( _T("**\tREThread.HandleTheResponse: Type: ERROR")) ;
		return( TRUE ) ;
	}

	//	DEAL WITH THE ACKNOWLEDGE OR RESPONSE FILE
	//	WE NEED THE PAGE.

	TCHAR	PageIDText[64] ;
	PrinterResponse->GetAttrValue(_T("ResponsePage"), PageIDText ) ;
	if( *PageIDText == 0x00 )
	{
		//	WHAT DO WE DO HERE ? COULD NOT FIND THE PAGE !			TBD
		SessionLogDirect( _T("**\tREThread.HandleTheResponse: PageID: NULL")) ;
		return( FALSE ) ;
	}

	if( stricmp( ResponseType, _T("ACKNOWLEDGE")) == 0 )
	{
		//	THIS ROUTINE UPDATES THE JOB QUEUE
		//	THIS SHOULD HAVE BEEN HANDLED BY THE RESPONSE SCRIPT	TBD
		HandleAcknowledge( thePage, PrinterResponse ) ;

		//	SINCE WE HAVE READ THE PAGE, AND WE ARE STILL WAITING FOR "RESPONSE"
		//	WE WILL RE-WRITE THE PAGE.
		if( ErrorCode == 0L )
		{
			SavePage( thePage ) ;
		}
	}

	if( stricmp( ResponseType, _T("RESPONSE")) == 0 )
	{
		//	THIS ROUTINE FILTERS ERRORS AND UPDATES THE JOB QUEUE AND ORDER ITEM TABLE
		//	THIS SHOULD HAVE BEEN HANDLED BY THE RESPONSE SCRIPT	TBD
		HandleResponse( thePage, PrinterResponse ) ;
	}

	return( TRUE ) ;
}

int HandleAcknowledge( UGenCon *thePage, UGenCon *PrinterResponse )
{
	long	JobID		= PrinterResponse->GetLongValue(_T("ResponsePage")) ;
	long	ErrorCode	= PrinterResponse->GetLongValue(_T("ResponseCode")) ;

	if( ErrorCode )
	{
		UpdateJobRecord( JobID, ERROR ) ;
	}
	else
	{
		UpdateJobRecord( JobID, SAVED ) ;
	}

	return( ErrorCode ) ;
}

//	THIS ROUTINE FILTERS ERRORS AND UPDATES THE JOB QUEUE AND ORDER ITEM TABLE
//	TBD:	SHOULD THIS REALLY FILTER ERROR MESSAGES OR SHOULD THIS BE PART OF THE
//			RESPONSE SCRIPT?
int HandleResponse( UGenCon *thePage, UGenCon *PrinterResponse )
{
	int		Result ;
	long	JobID		= PrinterResponse->GetLongValue(_T("ResponsePage")) ;
	long	ErrorCode	= PrinterResponse->GetLongValue(_T("ResponseCode")) ;
//	UGenCon	*thePage = LoadPage( JobID ) ;

	if( gLogAmount >= 2 )
	{
		SessionLogDirect( _T("**\tREThread.HandleResponse: JobID: %ld, thePage: 0x%08lX, ErrorCode: %ld"),
							JobID, thePage, ErrorCode ) ;
	}

	if( ErrorCode )
	{

		//	DO WE OUTPUT AN ERROR MESSAGE HERE ???	NO ! DONE IN HandleResponseScript

		//	DEFAULT JOB STATUS TO BE AN ERROR
		long JobStatus			= ERROR ;

		//	IF THE RESPONSE SCRIPT SETS A DIFFERENT JOB STATUS - USE IT.
		if( PrinterResponse->AttrChanged( _T("JobQueueStatus")))
		{
			JobStatus			= PrinterResponse->GetLongValue(_T("JobQueueStatus")) ;
		}

		long OrderItemStatus	= PrinterResponse->GetLongValue(_T("OrderItemStatus")) ;
		long ResetErrorCode		= PrinterResponse->GetLongValue(_T("ResetErrorCode") ) ;

		UpdateJobRecord( JobID, JobStatus ) ;

		if( OrderItemStatus )
		{
			UpdateOrderItemsRecord(thePage, OrderItemStatus ) ;
		}

		if( ResetErrorCode )
		{
			PrinterResponse->SetLongValue(_T("ResponseCode"), 0L ) ;	//	SAY NO ERROR
			ErrorCode = 0L ;
		}

		if( ErrorCode )
		{
			if( thePage )
			{
				if( thePage->GetLongValue(_T("IsPackage")) == 0 )
				{
						//	NOT A PACKAGE
					UpdateOrderItemsRecord(thePage, OrderItemStatus ) ;
				}
				else	//	A PACKAGE
				{
					Result = DeletePFPagesFromJobQ( thePage, JobStatus ) ;
				}
			}
		}
	}
	else	//	SUCCESSFUL PRINT
	{
		if( thePage )
		{
			if( thePage->GetLongValue(_T("IsPackage")) == 0 )
			{
					//	NOT A PACKAGE
				Result = DeleteRecordFromJobQueue( thePage ) ;
//				Result = DeleteRecordFromJobQueue( JobID ) ;	//	OLD WAY
				UpdateOrderItemsRecord(thePage, COMPLETED ) ;

			}
			else	//	A PACKAGE
			{
				Result = DeletePFPagesFromJobQ( thePage, COMPLETED ) ;
			}
		}
	}	//	SUCCESSFUL PRINT

	return( ErrorCode ) ;
}


//	DeletePaperFillPagesFromJobQueue
int DeletePFPagesFromJobQ( UGenCon *thePage, int State )
{
	int			 Result = TRUE ;

	if( thePage )
	{
		long		 JobID ;
		long		 LastJobID	= 0L ;
		UGenCon		*SourcePage ;

		UIC	*theUIC = (UIC *) thePage->GetLongValue(_T("UIC")) ;
		if( theUIC )
		{
			thePage->SetLongValue(_T("UIC"), NULL ) ;
			thePage->SetLongValue(_T("URenderList"), NULL ) ;
		}

		UList	*theOriginalPages	= thePage->GetChildren() ;
		UListIterator	*anIter		= new UListIterator( theOriginalPages ) ;
		UGenCon	*anOrigPage			= (UGenCon *) anIter->GetFirst() ;
		while( anOrigPage )
		{
			JobID = anOrigPage->GetLongValue(_T("JobID")) ;

			if( gLogAmount >= 4 )
			{
				SessionLogDirect( _T("**\tREThread.DeletePFPagesFromJobQ: JobID: P%09ld"), JobID ) ;
			}

			if( JobID != LastJobID )
			{
				if( State == PRINTING || State == COMPLETED || State == SAVED )
				{
					DeleteRecordFromJobQueue( anOrigPage ) ;
//					DeleteRecordFromJobQueue( JobID ) ; OLD WAY
				}

				SourcePage = LoadPage( JobID ) ;
				if( SourcePage )
				{
					UpdateOrderItemsRecord(SourcePage, State ) ;
					delete SourcePage ;
				}
			}

			LastJobID = JobID ;

			anOrigPage = (UGenCon *) anIter->GetNext() ;
		}	//	while( anOrigPage )

		delete anIter ;

	}	//	if( thePage )

	return( Result ) ;
}



int	DeleteThisFile( TCHAR *FilePath )
{
	int	Result = FALSE ;

	if( FilePath )
	{
		if( *FilePath )
		{
			Result = unlink( FilePath ) ;
			if( Result )
			{
				//	HANDLE THE ERROR
				TCHAR	Msg[1024] ;
				int		ErrNo = errno(Msg) ;
				SessionLogDirect( _T("**\tREThread.DeleteThisFile: Error %ld \"%s\" deleting \"%s\""),
								ErrNo, Msg, FilePath ) ;
			}
		}
	}
	return( Result ) ;
}

//															  0		 1		  2			 3			4			5	  6			7			8		9		 10
//	StringList( PrintStatusList,New,InListOrder,AddStrings,~Hold~,~Ready~,~Reserved~,~Printing~,~Completed~,~Saved~,~Error~,~Cancelled~,~Pending~,~Loaded~,~Parsed~ );

int DeleteRecordFromJobQueue( UGenCon *thePage )
{
	int		Result = TRUE ;

	long	 JobID			= thePage->GetLongValue(_T("JobID")) ;
	TCHAR	*OrderID		= thePage->GetStringValue(_T("OrderID")) ;
	TCHAR	*OrderItemID	= thePage->GetStringValue(_T("OrderItemID")) ;
	TCHAR	*JobPath		= thePage->GetStringValue(_T("JobPath")) ;
	long	 PrintStatus	= thePage->GetLongValue(_T("PrintStatus")) ;

	if( gLogAmount >= 4 )
	{
		SessionLogDirect( _T("**\tREThread.DeleteRecordFromJobQueue: Deleting Record: JobID: %ld, OrderID: \"%s\", OrderItem: \"%s\", JobPath: \"%s\", PrintStatus: %ld"),
			 JobID, OrderID, OrderItemID, JobPath, PrintStatus ) ;
	}

	DeleteJobQueueRecord( JobID ) ;

	if( JobPath[0] )
	{
		DeleteThisFile( JobPath ) ;		//	DEBUG DO NOT DELETE THIS FILE
	}	//	if JobPath

	return( Result ) ;
}

/*	OLD WAY
int DeleteRecordFromJobQueue( long JobID )
{
	int		Result = TRUE ;
	TCHAR	OrderID[64] ;
	TCHAR	OrderItemID[64] ;
	TCHAR	JobPath[2048] ;
	long	PrintStatus ;

	if( GetDataFromJobQueueRecord( JobID, OrderID, OrderItemID, JobPath, &PrintStatus ))
	{
		if( gLogAmount >= 4 )
		{
			SessionLogDirect( _T("**\tREThread.DeleteRecordFromJobQueue: Deleting Record: JobID: %ld, OrderID: \"%s\", OrderItem: \"%s\", JobPath: \"%s\", PrintStatus: %ld"),
				 JobID, OrderID, OrderItemID, JobPath, PrintStatus ) ;
		}

		DeleteJobQueueRecord( JobID ) ;

		if( JobPath[0] )
		{
			DeleteThisFile( JobPath ) ;		//	DEBUG DO NOT DELETE THIS FILE
		}	//	if JobPath
	}	//	if we got data from the job queue
	else
	{
		SessionLogDirect( _T("**\tREThread.DeleteRecordFromJobQueue: Could not get data for Record: JobID: %ld"), JobID ) ;
	}

	return( Result ) ;
}
*/

void GetTemporaryFilePath( TCHAR *TempPath )
{
	//	DETERMINE WHERE TO PUT THE TEMPORARY IMAGE FILES
	long	 TempPathSize = 1024 ;

	int result = GetEnvironmentVariable( _T("TMP"), TempPath, TempPathSize ) ;

	if( result == 0 )
	{
		sprintf( TempPath, _T("%s\\Temp"), GetApplicationDirectory() ) ;
	}
	
	//	MAKE SURE THE PATH EXISTS
	CreateFullDirectoryPath( TempPath ) ;
}

UGenCon *FindPageByID(UGenCon *aBatch, long PageID)
{
	long	 lBatchPageID ;

	if( aBatch == NULL )	{ return( NULL ) ; }

	if( aBatch->GetChildren() )
	{
		UListIterator	*anIter = new UListIterator( aBatch->GetChildren() ) ;
		UGenCon	*aPage = (UGenCon *) anIter->GetLast() ;
		while( aPage )
		{
			lBatchPageID	 = aPage->GetLongValue( _T("JobID")) ;

			if( gLogAmount >= 7 )
			{
				SessionLogDirect( _T("**\tREThread.FindPageByID: BatchPageID: %ld, PageID: %ld"),
							lBatchPageID, PageID ) ;
			}

			if( lBatchPageID == PageID )
			{
				delete anIter ;
				return( aPage ) ;
			}

			aPage = (UGenCon *) anIter->GetPrev() ;
		}
		delete anIter ;
	}
	return( NULL ) ;
}


int	UpdateJobRecord(long JobID, long PrintStatus )
{
	int		 Result		= TRUE ;
	TCHAR	*UpdateCmd	= _T("UPDATE JobQueue Set PrintStatus = %ld WHERE JobID = '%09ld'") ;
	TCHAR	 theQuery[2048] ;

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("**\tREThread.UpdateJobRecord: JobID: %0ld"), JobID ) ;
	}

	sprintf( theQuery, UpdateCmd, PrintStatus, JobID ) ;

	Result = DoSQL( theQuery ) ;

	return( Result ) ;
}


int	UpdateOrderItemsRecord(UGenCon *thePage, long PrintStatus )
{
	int		 Result		= FALSE ;

	TCHAR	 DateTime[128] ;
	GetSortableTimeNow(DateTime) ;

	if( thePage )
	{
		long	JobID = thePage->GetLongValue(_T("JobID")) ;
		if( gLogAmount >= 2 )
		{
			SessionLogDirect( _T("**\tREThread.UpdateOrderItemsRecord: Loaded Page %09ld"), JobID ) ;
		}

		TCHAR	*PrinterName	= gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
		TCHAR	*OrderID		= thePage->GetStringValue(_T("OrderID")) ;
		long	 OrderItemID	= thePage->GetLongValue(_T("OrderItemID")) ;

		TCHAR	*UpdateCmd	= _T("UPDATE OrderItems SET PrintCount=PrintCount+1, PrinterName = '%s', PrintStatus = %d, TimePrinted = '%s', Remake = 0 WHERE OrderID = '%s' AND ID = %ld") ;
		TCHAR	 theQuery[4098] ;

		sprintf( theQuery, UpdateCmd, PrinterName, PrintStatus, DateTime, OrderID, OrderItemID ) ;

		Result = DoSQL( theQuery ) ;

		thePage->SetLongValue(_T("UIC"), NULL ) ;	//	TBD 12/06/04
	}
	else
	{
		SessionLogDirect( _T("**\tREThread.UpdateOrderItemsRecord: No Page Available")) ;
	}

	return( Result ) ;
}



long GetSavedCountFromJobQueueRecord()
{
	TCHAR			 theQuery[1024] ;
	UPGenConList	*QueuePGCList = NULL ;
	UPGenCon		*thePGC = NULL ;
	TCHAR			*Result = NULL ;
	long			 Count = 0L ;
	int				 Error = FALSE ;

	TCHAR			*PrinterName	= gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
	TCHAR			*QueueName		= gPrinterSetupGC->GetStringValue(_T("QueueName")) ;

	TCHAR			*theSelectCmd = _T("SELECT count(*) FROM JobQueue WHERE PrinterName = '%s' AND QueueName = '%s' AND PrintStatus = 5") ;
	sprintf( theQuery, theSelectCmd, PrinterName, QueueName ) ;

	UADO			*anADO = ConnectToADO() ;
	if( anADO == NULL )	{ return( FALSE ) ; }

	QueuePGCList = new UPGenConList( anADO ) ;
	if( QueuePGCList == NULL )
	{
		HandleDBError(anADO) ;
		delete anADO ;
		return( FALSE ) ;
	}

	int result = QueuePGCList->Query( theQuery, _T("ReadOnly"), _T("Static") ) ;
	if( result != 1 )
	{
		SessionLogDirect( _T("CRP30_Response.GetSavedCountFromJobQueueRecord:\r\n%s\r\n\tFAILED. result = %ld"), theQuery, result ) ;
		delete QueuePGCList ;
		delete anADO ;
		return( FALSE ) ;
	}

	TCHAR	FieldNameBuf[128] ;
	TCHAR	CountText[128] ;
	strcpy( CountText, _T("0")) ;

	QueuePGCList->GetFieldName( 0L, FieldNameBuf ) ;

	thePGC = (UPGenCon *) QueuePGCList->GetFirst() ;
	if( thePGC )
	{
		thePGC->GetAttrValue( FieldName, CountText ) ;
		printf( _T("TheCount: %s\r\n"), CountText ) ;
	}

	delete QueuePGCList ;
	delete anADO ;

	long NumPrinterJobs = atoi(CountText) ;

	if( gLogAmount >= 2 )
	{
		SessionLogDirect( _T("**\tREThread.GetSavedCountFromJobQueueRecord: NumPrinterJobs: %ld"), NumPrinterJobs ) ;
	}

	return( NumPrinterJobs ) ;
}


UGenCon *GetPageByID( long JobID )
{
	long	PageID ;

	if( gCurrentBatch )
	{
		UList	*thePages = gCurrentBatch->GetChildren() ;
		if( thePages )
		{
			UListIterator	*anIter = new UListIterator(thePages) ;
			UGenCon			*aPage  = (UGenCon *) anIter->GetFirst() ;
			while( aPage )
			{
				PageID = aPage->GetLongValue(_T("JobID")) ;
				if( PageID == JobID )
				{
					delete anIter ;
					return( aPage ) ;
				}

				aPage  = (UGenCon *) anIter->GetNext() ;
			}
			delete anIter ;
		}
	}
	return( NULL ) ;
}


HandleSQL(TCHAR *theSQLStatement)
{
	int	Result ;
	Result = DoSQL( theSQLStatement ) ;
	free( theSQLStatement ) ;
	return( Result ) ;
}


int GetDataFromJobQueueRecord( long JobID, TCHAR *OrderID, TCHAR *OrderItemID, TCHAR *JobPath, long *PrintStatus )
{
	TCHAR			 theQuery[1024] ;
	UPGenConList	*QueuePGCList = NULL ;
	UGenCon			*thePGC = NULL ;
	TCHAR			*Result = NULL ;
	long			 Count = 0L ;
	int				 Error = FALSE ;

	TCHAR			*theSelectCmd = _T("SELECT OrderID, OrderItemID, JobPath, PrintStatus FROM JobQueue WHERE JobID = '%09ld'") ;
	sprintf( theQuery, theSelectCmd, JobID ) ;

	if( gLogAmount > 5 )
		{ SessionLogDirect( _T("**\tGetDataFromJobQueueRecord: Query: %s"), theQuery ) ; }

	UADO			*anADO = ConnectToADO() ;
	if( anADO == NULL )	{ return( FALSE ) ; }

	QueuePGCList = new UPGenConList( anADO ) ;
	if( QueuePGCList == NULL )
	{
		HandleDBError(anADO) ;
		delete anADO ;
		return( FALSE ) ;
	}

	int result = QueuePGCList->Query( theQuery, _T("ReadOnly"), _T("Static") ) ;
	if( result != 1 )
	{
		SessionLogDirect( _T("**\tREThread.GetDataFromJobQueueRecord:\r\n%s\r\n\tFAILED. result = %ld"), theQuery, result ) ;
		delete QueuePGCList ;
		delete anADO ;
		return( FALSE ) ;
	}

	long	NumRecords = QueuePGCList->GetNumEntries() ;

	thePGC = (UPGenCon *) QueuePGCList->GetFirst() ;
	if( thePGC )
	{
		thePGC->GetAttrValue(_T("OrderID"), OrderID ) ;
		thePGC->GetAttrValue(_T("OrderItemID"), OrderItemID ) ;
		thePGC->GetAttrValue(_T("JobPath"), JobPath ) ;
		*PrintStatus = thePGC->GetLongValue(_T("PrintStatus")) ;
	}

	delete QueuePGCList ;
	delete anADO ;
	return( TRUE ) ;
}


long GetPrinterStatus( UGenCon *thePrinterGC )
{
	TCHAR			 theQuery[256] ;
	int				 result ;
	
	UADO			*anADO = ConnectToADO() ;
	if( anADO == NULL )	{ return( -1L ) ; }

	// CREATE A NEW UPGENCONLIST.
	UPGenConList	*PGCList = new UPGenConList(anADO);
	if( PGCList == NULL )
	{
		HandleDBError(anADO) ;
		delete anADO ;
		return( -1L ) ;
	}

	PGCList->SetName( _T("GetPrinterStatus_UPGCList") ) ;
	sprintf( theQuery, _T("Select Status, RunAttended From Printers Where PrinterName = '%s'"),
					thePrinterGC->GetStringValue( _T("PrinterName"))) ;

	// GET THE PRINTER INFO FROM THE DATABASE.
	result = PGCList->Query( theQuery, _T("ReadOnly"),  _T("Static") ) ;

	if( result == 0L )
	{
		HandleDBError(anADO) ;
		thePrinterGC->SetLongValue(_T("DBError"), result ) ;
		delete PGCList ;
		delete anADO ;
		return( result ) ;
	}

	UGenCon *thePGC = (UGenCon *) PGCList->GetFirst() ;
	if( thePGC == NULL )
	{
		HandleDBError(anADO) ;
		thePrinterGC->SetLongValue(_T("DBError"), TRUE ) ;
		delete PGCList ;
		delete anADO ;
		return( result ) ;
	}

	//	WE FOUND THE RECORD
	long Status = thePGC->GetLongValue( _T("Status") ) ;

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("REThread.GetPrinterStatus: Status: %ld"), Status ) ;
	}

	long RunAttended = thePGC->GetLongValue( _T("RunAttended") ) ;
	thePrinterGC->SetLongValue( _T("RunAttended"), RunAttended ) ;

	result = anADO->RefreshConnectionCache() ;

	delete PGCList ;
	delete anADO ;
	return( Status ) ;
}

int PostAThreadMessage( CIThread *theThread, long MsgNum, long wParam, long lParam )
{
	int		Result = 0 ;
	int		Count  = 0 ;
	long	LastError = 0L ;

	if( IsPointerValid( (unsigned char *)theThread, 4 ) )
	{
		long	ThreadID = theThread->GetThreadID() ;

		while( Result == 0 )
		{
			Result = theThread->PostThreadMessage( MsgNum, wParam, lParam ) ;
			if( Result == 0 )
			{
				LastError = GetLastError() ;
				SessionLogDirect( _T("REThread.PostAThreadMessage(0x%08lX, %ld, %ld): Failed: Thread: 0x%08lX, ThreadID: 0x%08lX, Error: %d"),
						MsgNum, wParam, lParam, theThread, ThreadID, LastError ) ;
			}

			Count++ ;

			if( Count >= 1 )
			{
				break ;
			}
		}
	}
	else
	{
		SessionLogDirect( _T("**\tREThread.PostAThreadMessage: theThread is 0x%08lX, not Valid.\t**"), theThread ) ;
	}

	return( Result ) ;
}


//	IN THE FOLLOWING ROUTINE...
//	IF WE ARE SUSPENDED BECAUSE THE USER SUSPENDED US AND NOT BECAUSE
//	WE ARE THROTTLING, THEN THE USER MUST WANT TO DO A PBL.
//	SO, DO NOT CALL THESE ERRORs BUT CHANGE THE STATUS TO READY.		????
//	SO, DO NOT CALL THESE ERRORs BUT CHANGE THE STATUS TO CANCELLED.	????

int UpdateJobQueueTable(long PageID, long ResponseError)
{
	int PrintStatus = 6 ;									//	Error

//	long	WeAreSuspended			= gRELookAhead->GetLongValue(_T("SuspendNow")) ;
//	long	DiskSpaceSuspend		= gRELookAhead->GetLongValue(_T("DiskSpaceSuspend")) ;
//	long	SetFatalErrorToReady	= gRELookAhead->GetLongValue(_T("SetFatalErrorToReady")) ;

//	if( WeAreSuspended && (DiskSpaceSuspend == FALSE ) && ResponseError == 1L )
	if( gSuspendType & RE_USER_SUSPEND )
	{
		if( ResponseError == 1L )
		{
			PrintStatus = 1 ;									//	Ready
	//		PrintStatus = 7 ;									//	Canceled
	//		if( SetFatalErrorToReady )
	//			{ PrintStatus = 1 ; }							//	Ready
		}
	}

	if( ResponseError == 0 )
	{
		PrintStatus = 4 ;									//	Completed
	}

	TCHAR	theQuery[1024] ;
	sprintf( theQuery, _T("UPDATE JobQueue SET PrintStatus = %d WHERE JobID = '%09ld'"),
								PrintStatus, PageID ) ;

	int Result = DoSQL(theQuery ) ;

	return( TRUE ) ;
}



int DeleteJobQueueRecord( long JobID )
{
	TCHAR	 DelCmd[128] ;
	TCHAR	*DelRecord = _T("Delete from JobQueue where JobID = '%09ld'") ;
	sprintf( DelCmd, DelRecord, JobID ) ;

//	DumpCStack(_T("DeleteJobQueueRecord")) ;

	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("**\tREThread.DeleteJobQueueRecord: [%s]"), DelCmd ) ;
	}

	int Result = DoSQL( DelCmd ) ;

	if( gLogAmount >= 4 )
	{
		SessionLogDirect( _T("**\tREThread: Delete JobQueueRecord: \"%s\". Result: %d"), DelCmd, Result ) ;
	}

	return( Result ) ;
}

int SavePage( UGenCon *thePage )
{
	TCHAR	*AttrName ;
	TCHAR	 AttrValue[2048] ;
	TCHAR	 FilePath[1024] ;
	TCHAR	 ModifiedValue[2048] ;

	if( thePage == NULL )				{ return( FALSE ) ; }

	TCHAR	*ExeDirectory = GetExeDirectory() ;

	sprintf( FilePath, _T("%s\\Pages"), ExeDirectory ) ;
	CreateFullDirectoryPath( FilePath ) ;

	sprintf( FilePath, _T("%s\\Pages\\P%09ld.page"), ExeDirectory, thePage->GetLongValue(_T("JobID"))) ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("****\tREBatchThread.SavePage: File: \"%s\""), FilePath ) ;
	}

	UDataDict	*theDict = thePage->GetDataDict() ;

	char		*fp = fopen( FilePath, _T("w")) ;
	if( fp )
	{
		TCHAR			*GCName = thePage->GetName() ;
		TCHAR			*DDName = theDict->GetName() ;

		fprintf( fp, _T("//\tREBatch\n\n")) ;
		fprintf( fp, _T("Create \"%s\" Using \"%s\"\n{\n"), GCName, DDName ) ;
		UListIterator	*anIter = new UListIterator( theDict ) ;
		UAttribute		*anAttr = (UAttribute *) anIter->GetFirst() ;
		while( anAttr )
		{
			AttrName = anAttr->GetName() ;

			if( stricmp( AttrName, _T("BackPrintMessage1")) != 0 &&
				stricmp( AttrName, _T("BackPrintMessage2")) != 0  )
			{
				if( thePage->AttrChanged( AttrName ))
				{
					thePage->GetAttrValue( AttrName, AttrValue ) ;
					GetModifiedValue( AttrValue, ModifiedValue ) ;
					fprintf( fp, _T("\t%-24.24s\t\"%s\"\n"), AttrName, ModifiedValue ) ;
				}
			}

			anAttr = (UAttribute *) anIter->GetNext() ;
		}
		fprintf( fp, _T("%c\n"), 0x7D) ;
		delete anIter ;

		//	IF THIS IS A PACKAGE, WRITE OUT THE JOB IDs OF THE PAGES THAT MAKE UP THE PACKAGE
		//	AS WELL AS WHETHER OR NOT WE ARE DONE WITH THE PAGE.		NEW TBD 01/03/05
		
		if( thePage->GetLongValue(_T("IsPackage")))
		{
			long	 PageID ;

			UList	*thePkgPages = thePage->GetChildren() ;
			anIter = new UListIterator( thePkgPages ) ;
			UGenCon	*aPage = (UGenCon *) anIter->GetFirst() ;

			fprintf( fp, _T("\n{")) ;

			while( aPage )
			{
				PageID		= aPage->GetLongValue(_T("JobID")) ;
				fprintf( fp, _T("\n\tJobID %ld\n"), PageID ) ;
				aPage = (UGenCon *) anIter->GetNext() ;
			}
			fprintf( fp, _T("%c"), 0x7D ) ;

			delete anIter ;
		}

		fclose(fp) ;
		return( TRUE ) ;
	}
	return( FALSE ) ;
}

int  GetModifiedValue( TCHAR *SrcValue, TCHAR *DstValue )
{
	long	SrcPos = 0L ;
	long	DstPos = 0L ;

	while( SrcValue[SrcPos] )
	{
		if( SrcValue[SrcPos] == 0x22 )	//	DOUBLE QUOTE
		{
			DstValue[DstPos] = 0x5C ;	//	BACKSLASH
			DstPos++ ;
		}

		if( SrcValue[SrcPos] == 0x5C )	//	BACKSLASH
		{
			DstValue[DstPos] = 0x5C ;	//	ADD ANOTHER BACKSLASH
			DstPos++ ;
		}

		DstValue[DstPos] = SrcValue[SrcPos] ;
		DstPos++ ;
		SrcPos++ ;
	}
	DstValue[DstPos] = 0x00 ;
	return( TRUE ) ;
}


void GetQuoteCharacter( TCHAR *String, TCHAR *QuoteChar )
{
	QuoteChar[0] = 0x00 ;
	QuoteChar[1] = 0x00 ;

	if( strchr( String, 0x22 ) == NULL )	{ QuoteChar[0] = 0x22 ; return ; }	//	"
	if( strchr( String, 0x27 ) == NULL )	{ QuoteChar[0] = 0x27 ; return ; }	//	'
	if( strchr( String, 0x60 ) == NULL )	{ QuoteChar[0] = 0x60 ; return ; }	//	`
	if( strchr( String, 0x7C ) == NULL )	{ QuoteChar[0] = 0x7C ; return ; }	//	|
	if( strchr( String, 0x7E ) == NULL )	{ QuoteChar[0] = 0x7E ; return ; }	//	~
	if( strchr( String, 0x21 ) == NULL )	{ QuoteChar[0] = 0x21 ; return ; }	//	!
	if( strchr( String, 0x23 ) == NULL )	{ QuoteChar[0] = 0x23 ; return ; }	//	#
	QuoteChar[0] = 0x25 ;	//	%
}


UGenCon *LoadPage( long PageID )
{
	UREUtils	*REUtils = new UREUtils ;
	UGenCon *thePage = REUtils->LoadPage( PageID, gLogAmount ) ;
	delete REUtils ;
	return( thePage ) ;
}

UGenCon *LoadPageX( long PageID )
{
	TCHAR	 AttrValue[2048] ;
	TCHAR	 Token[1024] ;
	TCHAR	 GCName[64] ;
	TCHAR	 DDName[64] ;
	TCHAR	 FilePath[1024] ;

	TCHAR	*ExeDirectory = GetExeDirectory() ;

	sprintf( FilePath, _T("%s\\Pages\\P%09ld.page"), ExeDirectory, PageID ) ;

	UGenCon	*aPage = NULL ;

	if(  FilePath == NULL )	{ return( aPage ) ; }
	if( *FilePath == 0x00 )	{ return( aPage ) ; }

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("**\tREThread.LoadPage: File: \"%s\""), FilePath ) ;
	}

	TCHAR	*Text = GetFile( FilePath, 0 ) ;
	if( Text )
	{
//=============================================================================
		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("**\tREThread.LoadPage: Text: \n\"%s\""), Text ) ;	//	DEBUG ONLY
			DumpCStack(_T("LoadPage (Start)")) ;
		}
//=============================================================================

		UParser	*theParser = new UParser ;
		theParser->SetText( Text ) ;
		theParser->SetProcessBackSlashes(TRUE) ;

		theParser->GetToken( Token ) ;
		if( stricmp( Token, _T("Create")) == 0 )
		{
			theParser->GetToken( GCName ) ;				//	GC Name
			theParser->GetToken( Token ) ;				//	Using
			theParser->GetToken( DDName ) ;				//	DD Name

			aPage = new UGenCon( GetDataDictionary( DDName )) ;

			if( aPage )
			{
				aPage->SetName( GCName ) ;
				theParser->GetToken(Token) ;			//	'OPEN BRACE'
				theParser->GetToken( Token ) ;			//	ATTR NAME

				while( *Token )
				{
					if( *Token == 0x7D ) {	break ;	}

					//	THIS WILL ALLOW QUOTES IN IMAGE PATH
//					theParser->GetUntil( 0x0A, AttrValue, FALSE ) ;
//					theParser->GetDelimitedToken( AttrValue ) ;
					theParser->GetToken( AttrValue ) ;

					aPage->SetAttrValue( Token, AttrValue ) ;

					if( gLogAmount >= 9 )
					{
						SessionLogDirect( _T("**\tREThread.LoadPage: Token: %-20.20s\t%s"), Token, AttrValue ) ;
					}

					theParser->GetToken( Token ) ;
				}

				//	AT THIS POINT, CHECK TO SEE IF THIS IS A PACKAGE
				//	IF A PACKAGE THEN READ THE ORIGINAL IMAGE DATA

				if( gLogAmount >= 9 )
				{
					aPage->Dump(_T("**\tREThread.LoadPage: aPage")) ;
				}

				if( aPage->GetLongValue(_T("IsPackage")))
				{
					ReadOriginalPages( theParser, aPage ) ;
				}
			}	//	if( aPage )
		}	//	if( Create )

		theParser->SetText( NULL ) ;
		delete theParser ;
		free( Text ) ;

		DeleteThisFile( FilePath ) ;


	}
	else
	{
		if( gLogAmount >= 2 )
		{
			SessionLogDirect( _T("**\tREThread.LoadPage: Note: File: \"%s\" Could not be read."), FilePath ) ;
		}
		if( gLogAmount >= 6 )
		{
			DumpCStack(_T("LoadPage (End)")) ;
		}
	}

	if( aPage )
	{
		UList	*theErrors = (UList *) aPage->GetLongValue(_T("RenderErrorList")) ;
		if( theErrors )
		{
//			delete theErrors ;
			aPage->SetLongValue(_T("RenderErrorList"), 0L ) ;
		}
	}

	return( aPage ) ;
}

int ReadOriginalPages( UParser *theParser, UGenCon *thePkg )
{
	TCHAR	 Token[2048] ;
	UGenCon	*OrigPage ;
	long	 JobID ;

	theParser->GetToken(Token) ;	//	'OPEN BRACE'
	theParser->GetToken(Token) ;
	while( *Token != 0x7D )			//	'CLOSE BRACE'
	{
		OrigPage = new UGenCon( GetDataDictionary( _T("DDPaperFillResponse"))) ;
		if( OrigPage )
		{
			if( stricmp( Token, _T("JobID")) == 0 )
			{
				JobID = theParser->GetLong() ;
				OrigPage->SetLongValue(_T("JobID"), JobID ) ;

				if( gLogAmount >= 8 )
				{
					SessionLogDirect( _T("**\tREThread.ReadOriginalPages: JobID: %09ld"), JobID ) ;
				}

				theParser->GetToken(Token) ;
			}

			thePkg->AddChildBack( OrigPage ) ;

		}	//	if( OrigPage )
	}	//	while( *Token != 'CLOSE BRACE' )
	return( TRUE ) ;
}


long CallScript( TCHAR *ScriptName, TCHAR *FuncCall )
{
	long	Result = FALSE ;
	TCHAR	FilePath[2048] ;
	TCHAR	FileName[280] ;
	TCHAR	FileExtn[32] ;
	GetFilePathNameAndExt( ScriptName, FilePath, FileName, FileExtn ) ;

	if( FileName[0] == 'C' && FileName[1] == '_' )
	{
		Result = CallCScript( ScriptName, FuncCall ) ;
	}
	else
	{
		//	BUILD THE FUNCTION CALL
		Result = CallKPLScript( ScriptName, FuncCall ) ;
	}
	return( Result ) ;
}

//	CALL A SCRIPT HERE !
long CallCScript( TCHAR *ScriptName, TCHAR *FuncCall )
{
	long Result = FALSE ;
	if( gLogAmount >= 7 )
	{
		SessionLogDirect( _T("****\tREThread.CallCScript: \"%s\", \"%s\"."), ScriptName, FuncCall ) ;
	}

	TCHAR		 ScriptPath[2048] ;
	GetScriptPath( ScriptName, ScriptPath ) ;

	UCInterpreter *Interp = new UCInterpreter ;
	if( Interp )
	{
		Interp->SetCheckTextLibFirst( gCheckTextLibFirst ) ;
		Result = Interp->InterpretC( ScriptPath ) ;
		Result = Interp->CallBack( FuncCall ) ;
		Result = Interp->GetLongReturn() ;
		delete Interp ;
	}
	return( Result ) ;
}


long CallKPLScript( TCHAR *ScriptName, TCHAR *FuncCall )
{
	long	Result = 0L ;
	TCHAR	ScriptPath[2048] ;

	GetScriptPath( ScriptName, ScriptPath ) ;

	UIC		*theUIC = new UIC ;
	if( theUIC )
	{
		//										CheckLib IsJob	Unicode	  Trigger
		theUIC->ParseFile( ScriptPath, NULL,		0,		0,		0,		FuncCall ) ;

		TCHAR	*TxtResult = theUIC->GetScriptReturnValue() ;
		if( TxtResult )
		{
			if( *TxtResult )
			{
				Result = atoi( TxtResult ) ;
			}
		}

		//	DELETE THE INSTRUCTION CLASS OBJECT SO WE HAVE NO MEMORY LEAKS.
		delete theUIC ;
	}
	return(Result) ;
}


TCHAR	*GetScriptPath( TCHAR *ScriptName, TCHAR *Path )
{
	int		 IsDirectory ;

	if( FileOrDirectoryExists( ScriptName, &IsDirectory ) )
	{
		strcpy( Path, ScriptName ) ;
		return( Path ) ;
	}

	TCHAR	*ShareDirectory = GetShareDirectory() ;
	sprintf( Path, _T("%s\\Scripts\\%s"), ShareDirectory, ScriptName ) ;

	if( FileOrDirectoryExists( Path, &IsDirectory ) )
	{
		return( Path ) ;
	}

	TCHAR	*ExeDirectory = GetExeDirectory() ;
	sprintf( Path, _T("%s\\Scripts\\%s"), ExeDirectory, ScriptName ) ;

	if( FileOrDirectoryExists( Path, &IsDirectory ) )
	{
		return( Path ) ;
	}

	strcpy( Path, ScriptName ) ;

	return( Path ) ;
}

void GetFilePathNameAndExt( TCHAR *Source, TCHAR *FilePath, TCHAR *FileName, TCHAR *FileExtn )
{
	TCHAR	Src[2048] ;
	strcpy( Src, Source ) ;

	FileExtn[0] = 0 ;
	FileName[0] = 0 ;
	FilePath[0] = 0 ;

	if( strchr( Src, 0x2E ) )
	{
		GetLastToken( Src, FileExtn, 0x2E ) ;	//	"." GET THE EXTENSION
	}

	if( strchr( Src, 0x5C ) )
	{
		GetLastToken( Src, FileName, 0x5C ) ;	//	"\" GET THE BASE FILE NAME
		strcpy( FilePath, Src ) ;				//		GET THE PATH
	}
	else
	{
		strcpy( FileName, Src ) ;
	}

}

void GetLastToken( TCHAR *Source, TCHAR *Dst, int SrchChar )
{
	long	SrcPos = strlen( Source ) - 1L ;
	long	DstPos = 0L ;

	Dst[DstPos] = 0x00 ;

	while( SrcPos >= 0L && Source[SrcPos] != SrchChar )
	{
		SrcPos-- ;
	}

	if( SrcPos >= 0L )
	{
		Source[SrcPos] = 0x00 ;
		SrcPos++ ;

		while( Source[SrcPos] )
		{
			Dst[DstPos] = Source[SrcPos] ;
			SrcPos++ ;
			DstPos++ ;
		}
		Dst[DstPos] = 0x00 ;
	}
}

//=============================================================================
//=============================================================================
//============================ MODE INTERFACE =================================
//=============================================================================
//=============================================================================

long GetNumJobsToBePrinted()
{
	long	NumJobsToBePrinted = 0L ;
	if(	IsModePrinter() )
	{
		//	GET MODE STATUS
		WriteModeAction(_T("STATUS_JOB_COUNT\n")) ;	//	YTREWQ

		UGenCon *ModeStatusGC = WaitForModeStatus() ;
		if( ModeStatusGC )
		{
			NumJobsToBePrinted = ModeStatusGC->GetLongValue(_T("NumberJobs:")) ;
			delete ModeStatusGC ;
		}
	}
	return( NumJobsToBePrinted ) ;
}


WriteModeAction(TCHAR *Action)
{
	if( gPrinterSetupGC && Action )
	{
		TCHAR	*ControlFolder	= gPrinterSetupGC->GetStringValue(_T("ControlFolder")) ;
		TCHAR	 ActionPath[1024] ;

		sprintf( ActionPath, _T("%s\\201.act"), ControlFolder ) ;

		if( gLogAmount >= 5 )
		{
			SessionLogDirect( _T("REThread.WriteModeAction: Writing Flie: \"%s\"\nAction:\n%s"),
					ActionPath, Action ) ;
		}

		char	*fp = fopen( ActionPath, _T("w")) ;
		if( fp )
		{
			fprintf( fp, _T("ACTION: %s"), Action ) ;
			fclose(fp) ;
		}
	}
}


UGenCon *WaitForModeStatus()
{
	UGenCon	*ModeStatusGC = NULL ;
	TCHAR	*StatusText ;
	if( gPrinterSetupGC )
	{
		TCHAR	*ResponseFolder	= gPrinterSetupGC->GetStringValue(_T("ResponseFolder")) ;
		TCHAR	 ResponsePath[1024] ;
		sprintf( ResponsePath, _T("%s\\201.sta"), ResponseFolder ) ;

		if( gLogAmount >= 8 )
		{
			SessionLogDirect( _T("RenderEngineDlg_2.WaitForStatus: ResponsePath: \"%s\""), ResponsePath ) ;
		}

		int	Count = 0L ;
		while( Count < 10L )
		{
			StatusText = GetFile( ResponsePath ) ;
			if( StatusText )
			{
				if( gLogAmount >= 3 )
				{
					SessionLogDirect( StatusText ) ;
				}

				ModeStatusGC = ParseModeStatus( StatusText ) ;
				unlink( ResponsePath ) ;
				free( StatusText ) ;
				break ;
			}

			if( gLogAmount >= 6 )
			{
				SessionLogDirect( _T("RenderEngineDlg_2.WaitForStatus: Count: %d, ResponsePath: \"%s\""), Count, ResponsePath ) ;
			}

			Sleep( 1000 ) ;
			Count++ ;
		}
	}
	return( ModeStatusGC ) ;
}


UGenCon *ParseModeStatus( TCHAR *Text )
{
	if( Text )
	{
		TCHAR		 Token[2048] ;
		TCHAR		 Keyword[2048] ;
		double		 Resolution ;
		long		 NumberJobs ;
		UGenCon		*aGC ;

		UGenCon		*ModeStatusGC = new UGenCon( GetDataDictionary( _T("DDModeStatus"))) ;
		UParser *theParser = new UParser ;
		theParser->SetText( Text ) ;

		theParser->GetToken( Keyword ) ;
		while( *Keyword )
		{
			if( stricmp( Keyword, _T("Type:")) == 0 ||
				stricmp( Keyword, _T("Action:")) == 0 ||
				stricmp( Keyword, _T("Code:")) == 0 )
			{
				theParser->GetToken(Token) ;
				ModeStatusGC->SetAttrValue( Keyword, Token ) ;
			}

			if( stricmp( Keyword, _T("Date_Time:")) == 0 )
			{
				theParser->GetLine( Token, FALSE ) ;
				ModeStatusGC->SetAttrValue( Keyword, Token ) ;
			}

			if( stricmp( Keyword, _T("Msg:")) == 0 )
			{
				theParser->GetUntil(0x22, Token, FALSE ) ;
				theParser->GetUntil(0x22, Token, FALSE ) ;
				ModeStatusGC->SetAttrValue( Keyword, Token ) ;
			}

			if( stricmp( Keyword, _T("Resolution:")) == 0 )
			{
				Resolution = theParser->GetDouble() ;
				aGC = new UGenCon( GetDataDictionary( _T("DDDouble"))) ;
				aGC->SetDoubleValue( _T("Double"), Resolution ) ;
				ModeStatusGC->AddChildBack( aGC ) ;
			}

			if( stricmp( Keyword, _T("State:")) == 0 )
			{
				theParser->GetToken( Token ) ;
				ModeStatusGC->SetAttrValue(_T("State:"), Token ) ;
			}

			if( stricmp( Keyword, _T("Number_Jobs:")) == 0 )
			{
				NumberJobs = theParser->GetLong() ;
				ModeStatusGC->SetLongValue(_T("NumberJobs:"), NumberJobs ) ;
			}

			if( stricmp( Keyword, _T("Page_Status:")) == 0 )
			{
				theParser->GetLine( Token, FALSE ) ;
			}

			theParser->GetToken(Keyword) ;
		}

		theParser->SetText( NULL ) ;
		delete theParser ;
		return( ModeStatusGC ) ;
	}
	return( NULL ) ;
}

int	IsModePrinter()
{
	int	IsMode = FALSE ;
	TCHAR	*PrinterModel = gPrinterSetupGC->GetStringValue(_T("PrinterModel")) ;
	if(	stricmp( PrinterModel, _T("Kodak LED"))		== 0 ||
		stricmp( PrinterModel, _T("Kodak CRT"))		== 0 ||
		stricmp( PrinterModel, _T("Kodak LFCRT"))	== 0 ||
		stricmp( PrinterModel, _T("KPDM"))			== 0 ||
		stricmp( PrinterModel, _T("KPDM II"))		== 0 ||
		stricmp( PrinterModel, _T("NT Printer"))	== 0 ||
		stricmp( PrinterModel, _T("Windows Printer")) == 0 )
	{
		IsMode = TRUE ;
	}
	return( IsMode ) ;
}


//=============================================================================
//=============================================================================
//============================ RP30 INTERFACE =================================
//=============================================================================
//=============================================================================

//	CALL WITH 001.ACT, ACTION: 0005
WriteAction( TCHAR *FileName, TCHAR *Text )
{
	TCHAR	 FilePath[2048] ;
	TCHAR	*ControlFolder = gPrinterSetupGC->GetStringValue(_T("ControlFolder")) ;

	sprintf( FilePath, _T("%s\\%s"), ControlFolder, FileName ) ;
	char	*fp = fopen( FilePath, _T("wb")) ;
	if( fp )
	{
		TCHAR	IOBuff[32] ;
		IOBuff[0] = 0xFEFF ;
		IOBuff[1] = 0x0000 ;
		WriteUnicodeFile( fp, IOBuff ) ;

		WriteUnicodeFile( fp, Text ) ;
		fclose(fp) ;
	}
}

WriteUnicodeFile( char *fp, TCHAR *Text )
{
	long	Length = strlen( Text ) ;
	fwrite( Text, 2, Length, fp ) ;

	long	EndOfLine = 0x000A000D ;
	fwrite( &EndOfLine, 2, 2, fp ) ;
}


long WaitForStatus(TCHAR *FileName)
{
	long	 StartTime = Clock() ;
	long	 EndTime ;
	long	 Status = -1L ;
	int		 ErrorCode = -1 ;

	while( Status == -1L )
	{
		Sleep( 250 ) ;
		Status = ReadStatus(FileName) ;

		if( Status )	{ return( Status ) ; }

		EndTime = Clock() ;
		if( EndTime - StartTime > 30000 )	{ Done = TRUE ; }
	}

	return( Status ) ;
}


long ReadStatus(TCHAR *FileName)
{
	TCHAR	 StatusPath[1024] ;
	long	 Result = -1L ;
	
	TCHAR	*ResponseFolder = gPrinterSetupGC->GetStringValue(_T("ResponseFolder")) ;
	if( ResponseFolder )
	{
		sprintf( StatusPath, _T("%s\\%s"), ResponseFolder, FileName ) ;

		TCHAR	*StatusText = GetTheFile( StatusPath ) ;
		if( StatusText )
		{
			Result = ParseStatus( StatusText ) ;
			free( StatusText ) ;
			unlink( StatusPath ) ;
			return( Result ) ;
		}
	}
	return( Result ) ;
}

long ParseStatus( TCHAR *StatusText )
{
	long	Result = 0L ;
	if( StatusText )
	{
		UParser	*aParser = new UParser ;
		aParser->SetText( StatusText ) ;

		TCHAR	Token[1024] ;
		aParser->GetToken(Token) ;
		while( *Token )
		{
			if( stricmp( Token, _T("Code:")) == 0 )
			{
				aParser->GetToken( Token ) ;
				Result = atoi( Token ) ;
				break ;
			}
			aParser->GetToken(Token) ;
		}

		aParser->SetText( NULL ) ;
		delete aParser ;
	}
	return( Result ) ;
}

TCHAR *GetTheFile(TCHAR *Path)
{
	TCHAR	*Text = NULL ;

	char *fp = fopen( Path, _T("rb")) ;
	if( fp )
	{
		fseek( fp, 0L, 2 ) ;
		int	Length = ftell(fp) ;
		fseek( fp, 0L, 0 ) ;
		Text = (TCHAR *) malloc( (Length + 32) * 2 ) ;
		fread( Text, 2, Length, fp ) ;
		fclose( fp ) ;
	}
	return( Text ) ;
}

//=============================================================================
//=============================================================================
//========================== DATABASE INTERFACE ===============================
//=============================================================================
//=============================================================================

UADO *ConnectToADO()
{
	int		 result ;

	UADO	*theADO = new UADO ;

	if( theADO == NULL )
	{
		return(NULL) ;
	}

	result = theADO->ConnectKPIS() ;
	if( result )
	{
		delete theADO ;
		return(NULL) ;
	}

	return( theADO ) ;
}


int DoSQL( TCHAR *theSQLStatement )
{
	int		result	= 0x80004005 ;	//	COULD NOT UPDATE BECAUSE LOCKED BY ANOTHER
	long	count	= 0 ;
	int		RefreshResult ;

	UADO	*theADO = ConnectToADO() ;
	if( theADO == NULL )
	{
		SessionLogDirect( _T("**\tREThread.DoSQL: Could not get ADO for \"%s\"."), theSQLStatement ) ;
		return( FALSE ) ; 
	}

	while( result && count < 30 )
	{
		result = theADO->ADOCommand( theSQLStatement, _T("SQL"), NULL ) ;
		count++ ;
		if( result != 0L )
		{
			RefreshResult = theADO->RefreshConnectionCache() ;
			Sleep(2000) ;
		}

		if( gLogAmount >= 7 )
		{
			SessionLogDirect( _T("**\tREThread.DoSQL: %s, result = %0lX, Count = %ld [%0lX]"),
								theSQLStatement, result, count, theADO ) ;
		}
	}

	if( result != 0 )
	{
		HandleDBError(theADO) ;
	}
	else
	{
		RefreshResult = theADO->RefreshConnectionCache() ;
		if( gLogAmount >= 7 )
		{
			SessionLogDirect(_T("**\tREThread.DoSQL: CommitTransaction result = %0lX"), result) ;
		}
	}

	delete theADO ;
	return( result == 0 ) ;
}


HandleDBError(UADO *anADO)
{
	long	ErrorCount, ErrorIndex ;
	TCHAR	ADOErrDesc[2048] ;
	TCHAR	theMsg[4096] ;
	long	StopHere = 0 ;

	Debug(StopHere) ;

	//	SUSPEND THE BATCH RENDERING
	if( gCurrentBatch )
	{
		CIThread *theBatchThread = (CIThread *) gCurrentBatch->GetLongValue(_T("BatchThread")) ;
		if( theBatchThread )
		{
			PostAThreadMessage( theBatchThread, REM_BATCH_SUSPEND, 0L, 0L ) ;

			if( gLogAmount >= 2 )
			{
				SessionLogDirect( _T("**\tREThread.HandleDBError: REStatus: %ld, B4Suspend: %ld"), gREStatus, gREStatusB4Suspend ) ;
			}

			if( gREStatus != RE_SUSPENDED )
			{
				gREStatusB4Suspend = gREStatus ;
			}

			gREStatus = RE_SUSPENDED ;
			gSuspendType |= RE_ERR_SUSPEND ;
		}
	}

	ErrorCount = anADO->GetErrorCount() ;
	if( ErrorCount == 0L )
	{
//=============================================================================
		ShowDialog( _T("Lost Database Connection."), 0L, REM_DB_ERROR_DLG_RESPONSE, NULL ) ;
//=============================================================================
	}
	else
	{
		for( ErrorIndex = 0L ; ErrorIndex < ErrorCount ; ErrorIndex++ )
		{
			anADO->GetErrorDescription( ErrorIndex, ADOErrDesc ) ;
			sprintf( theMsg, _T("Database Error: %s"), ADOErrDesc ) ;
//=============================================================================
			ShowDialog( theMsg, 0L, REM_DB_ERROR_DLG_RESPONSE, NULL ) ;
//=============================================================================
		}
	}
}


int DialogDBErrorResponse(long wParam, long lParam)
{
	//	RESUME THE BATCH RENDERING
	if( gCurrentBatch )
	{
		CIThread	*theBatchThread = (CIThread *) gCurrentBatch->GetLongValue(_T("BatchThread")) ;
		if( theBatchThread )
		{
//			PostAThreadMessage( theBatchThread, REM_BATCH_RESUME, 0L, 0L ) ;
			PostAThreadMessage( theBatchThread, REM_BATCH_RESUME, 0L, RE_ERR_SUSPEND ) ;
		}
	}

	if( gSuspendType & RE_ERR_SUSPEND )
	{
		gSuspendType -= RE_ERR_SUSPEND ;
		if( gSuspendType <= 0 )
		{
			if( gLogAmount >= 2 )
			{
				SessionLogDirect( _T("**\tREThread.DialogDBErrorResponse: REStatus: %ld, B4Suspend: %ld"), gREStatus, gREStatusB4Suspend ) ;
			}

			gREStatus = RE_RUNNING ;
			gSuspendType = 0 ;
			if( gREStatusB4Suspend == RE_SHUTTING_DOWN || gREStatusB4Suspend == RE_QUITTING )
			{
				gREStatus = gREStatusB4Suspend ;
			}
		}
	}

	return( TRUE ) ;
}

//=============================================================================
//=============================================================================
//============================ SHOW ERROR DIALOG ==============================
//=============================================================================
//=============================================================================

long ShowDialog( TCHAR *theMsg, long MsgType, long ResponseMessage, UGenCon *thePage )
{
	UGenCon	*MsgDlg = new UGenCon( GetDataDictionary( _T("DDMessageDialog"))) ;
	MsgDlg->SetAttrValue( _T("Title"), _T("Render Engine Error")) ;
	MsgDlg->SetLongValue( _T("xPosition"), 250L ) ;
	MsgDlg->SetLongValue( _T("yPosition"), 150L ) ;
	MsgDlg->SetAttrValue( _T("Message1"), theMsg ) ;
	MsgDlg->SetLongValue( _T("ThreadID"), gThisThread->GetThreadID() ) ;
	MsgDlg->SetLongValue( _T("ThreadMessage"), REM_MESSAGE_RESPONSE ) ;
	MsgDlg->SetLongValue( _T("ReturnThisGC"), TRUE ) ;
	MsgDlg->SetLongValue( _T("ResponseMessage"), ResponseMessage ) ;
	MsgDlg->SetLongValue( _T("RenderPage"), (long) thePage ) ;

	if( MsgType > 4L || MsgType < 0 )	{ MsgType = 2L ; }

	switch( MsgType )
	{
		case	0	:	//	JOB PARSING OR RENDERING ERROR
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Retry") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Retry") ) ;

			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Page") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelPage") ) ;

			MsgDlg->SetAttrValue( _T("Button3"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button3Response"), _T("CancelBatch") ) ;
			break ;

		case	1	:	//	PRINTING INFORMATIONAL MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Retry") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Retry") ) ;

			MsgDlg->SetAttrValue( _T("Button3"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button3Response"), _T("CancelBatch") ) ;
			break ;

		case	2	:	//	PRINTING WARNING MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 2L ) ;
			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Page") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelPage") ) ;

			MsgDlg->SetAttrValue( _T("Button3"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button3Response"), _T("CancelBatch") ) ;
			break ;

		case	3	:	//	PRINTING ERROR MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Retry") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Retry") ) ;

			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Page") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelPage") ) ;

			MsgDlg->SetAttrValue( _T("Button3"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button3Response"), _T("CancelBatch") ) ;
			break ;

		case	4	:	//	MODE ERROR MESSAGE	(ie IMAGE FILE NOT FOUND)
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button2"), _T("Cancel Page") ) ;
			MsgDlg->SetAttrValue( _T("Button2Response"), _T("CancelPage") ) ;

			MsgDlg->SetAttrValue( _T("Button3"), _T("Cancel Batch") ) ;
			MsgDlg->SetAttrValue( _T("Button3Response"), _T("CancelBatch") ) ;
			break ;

		case	5	:	//	PRINTING ERROR MESSAGE
			MsgDlg->SetLongValue( _T("DefaultButton"), 1L ) ;
			MsgDlg->SetAttrValue( _T("Button1"), _T("Retry") ) ;
			MsgDlg->SetAttrValue( _T("Button1Response"), _T("Retry") ) ;
			break ;

	}

	SessionLogDirect( _T("**\tREThread.ShowDialog: \"%s\""), theMsg ) ;

	if( gREStatus == RE_RUNNING || gREStatus == RE_SUSPENDED )
	{
		CIThread	*theDlgThread = (CIThread *) gStatusGC->GetLongValue(_T("DlgThread")) ;
		if( theDlgThread )
		{
			PostAThreadMessage( theDlgThread, REM_RE_SIREN, 0L, 0L ) ;
		}

//=============================================================================
		MsgDlg->SetLongValue(_T("UseOrigGC"), TRUE ) ;
		MessageDialog( MsgDlg, FALSE ) ;
//=============================================================================

//	delete MsgDlg ;	//	WE WILL CLEAN THIS UP IN MessageDialogReply WHEN IT IS
						//	RETURNED FROM THE MessageDialog.
	}
	return( TRUE ) :
}

long MessageDialogReply(UGenCon *MsgDlg)
{
	long	UserAction = 0L ;
	if( MsgDlg )
	{
		long	ButtonPressed = MsgDlg->GetLongValue(_T("ButtonPressed")) ;
		TCHAR	ResponseAttrName[32] ;
		sprintf( ResponseAttrName, _T("Button%dResponse"), ButtonPressed ) ;

		TCHAR	*Response = MsgDlg->GetStringValue(ResponseAttrName) ;

		if( Response )
		{
			if( stricmp( Response, _T("Retry")) == 0 )			{ UserAction = 1L ; }
			if( stricmp( Response, _T("CancelPage")) == 0 )		{ UserAction = 2L ; }
			if( stricmp( Response, _T("CancelOrder")) == 0 )	{ UserAction = 3L ; }
			if( stricmp( Response, _T("CancelBatch")) == 0 )	{ UserAction = 4L ; }
		}

		long RenderPage		 = MsgDlg->GetLongValue( _T("RenderPage")) ;
		long ResponseMessage = MsgDlg->GetLongValue( _T("ResponseMessage")) ;

		PostAThreadMessage( gThisThread, ResponseMessage, RenderPage, UserAction ) ;

		SessionLogDirect( _T("****\tREThread.ShowDialog: User Selected: \"%s\""), Response ) ;

		delete MsgDlg ;
	}
	else
	{
		SessionLogDirect( _T("****\tREThread.MessageDialogReply: ERROR: We got here with no MsgDlg GenCon.")) ;
	}
	return( UserAction ) ;
}



//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================
//=============================================================================

//	FOR THIS EXCEPTION HANDLER TO WORK, THERE SHOULD BE A DDTEXT GENCON ON THE
//	DATA TREE DESCRIBING WHERE THE SCRIPT CRASHED.  WE SHOULD OUTPUT THE MESSAGE
//	TO THE SESSION LOG, CLEAN UP THE TREE, AND POST MESSAGES TO THE APPROPRIATE
//	THREADS TO KEEP THEM MOVING.

int ExceptionHandler()
{
	if( gNewWay )
	{
		int Result = gREMain->ExceptionHandler() ;
		return( Result ) ;
	}

	//	WHAT DO WE DO WITH THE BATCH THREAD AND THE PIE THREAD ???		TBD
	DumpCStack(_T("ExceptionHandler")) ;

	//	CLEAN UP THE TREE
	UGenCon *theMsgGC = (UGenCon *) PluckTreeObject(_T("CRunTimeError"), _T("[GenCons]")) ;
	if( theMsgGC )
	{
		TCHAR	*theMsg = theMsgGC->GetStringValue(_T("Text")) ;
		SessionLogDirect( _T("REThread.ExceptionHandler: The Error Message: \"%s\"."),
							theMsg ) ;

		ShowDialog( theMsg, 0L, REM_EXCEPTION_RESPONSE, 0L ) ;

		delete theMsgGC ;
	}

	return( TRUE ) ;
}


int HandleExceptionResponse(long UserAction)
{
	//	IS THERE A BATCH RUNNING ?  IF SO, TELL 'EM TO SHUTDOWN NOW !
	if( gCurrentBatch )
	{
		CIThread	*theBatchThread = NULL ;
		theBatchThread = (CIThread *) gCurrentBatch->GetLongValue( _T("BatchThread")) ;

		if( theBatchThread )
		{
			//	TELL THE BATCH TO SHUT DOWN
			//	WAIT TILL IT TELLS US IT'S DONE
			long	ShutdownNow = TRUE ;
			PostAThreadMessage( theBatchThread, REM_BATCH_SHUTDOWN, 0L, ShutdownNow ) ;
		}
	}

	//	MAKE THIS THREAD GO AWAY
	PostAThreadMessage( gThisThread, WM_QUIT, 0L, 0L ) ;

	return( TRUE ) ;
}


int DumpCStack(TCHAR *Where)
{
	UCInterpreter *ThisCInterp = THIS() ;
	TCHAR	*StackText = ThisCInterp->GetStackText() ;
	SessionLogDirect( _T("REBatchThread.%s: Stack:\n%s"), Where, StackText ) ;
	free( StackText ) ;
	return( TRUE ) ;
}


//=============================================================================
//=============================================================================

//	DEBUGGER2 CODE

TCHAR	gScriptName[2048] ;	//	SO WE KNOW WHAT TO REMOVE LATER

int HangDebugTargetGC()
{
	UCInterpreter	*theCI = THIS() ;

	TCHAR			 ScriptName[2048] ;
	GetScriptName( theCI, ScriptName ) ;

	UGenCon			*theDebugGC = new UGenCon( GetDataDictionary(_T("DDDebugScript"))) ;
	if( theDebugGC )
	{
		theDebugGC->SetName( ScriptName ) ;
		theDebugGC->SetLongValue( _T("CInterpreter"), theCI ) ;
		theDebugGC->SetLongValue( _T("CInterpThread"), gThisThread ) ;
	}

	strcpy( gScriptName, ScriptName ) ;

	HangTreeObject( theDebugGC, _T("[DebugScripts Scripts]")) ;

	return( TRUE ) ;
}


TCHAR	*GetScriptName( UCInterpreter *theCI, TCHAR *ScriptName )
{
	UList	*ScriptFiles = theCI->GetScriptFiles() ;
	UListIterator	*anIter = new UListIterator( ScriptFiles ) ;
	UScriptFile		*aFile  = (UScriptFile *) anIter->GetFirst() ;

	*ScriptName = 0x00 ;

	if( aFile )
	{
		TCHAR *ScriptPath = aFile->GetPath() ;
		if( ScriptPath )
		{
			TCHAR	FileName[2048] ;
			TCHAR	FilePath[2048] ;
			TCHAR	FileExtn[64] ;

			GetFilePathNameAndExt( ScriptPath, FilePath, FileName, FileExtn ) ;
			sprintf( ScriptName, _T("%s.%s"), FileName, FileExtn ) ;
		}
	}
	delete anIter ;
	return( ScriptName ) ;
}

int RemoveDebugTargetGC()
{
	UGenCon *theDebugGC = PluckTreeObject( gScriptName, _T("[DebugScripts Scripts]")) ;
	delete theDebugGC ;
	return(TRUE) ;
}

//=============================================================================
//=============================================================================
/* OLD WAY
int ReserveNextBatch()
{
	TCHAR	BatchID[128] ;
	TCHAR	theQuery[1024] ;

	if( gREStatus != RE_RUNNING )			{ return( FALSE ) ; }

	if( gBatchQueue->QtyInQueue() >= 2 )	{ return( FALSE ) ; }


	TCHAR	*PrinterName	= gPrinterSetupGC->GetStringValue(_T("PrinterName")) ;
	TCHAR	*QueueName		= gPrinterSetupGC->GetStringValue(_T("QueueName")) ;

	int	Result = GetNextBatchID( BatchID ) ;
	if( Result != 1 )		{ return( FALSE ) ; }

	if( BatchID[0] == 0 )	{ return( FALSE ) ; }

	sprintf( theQuery,
		_T("Update JobQueue Set PrinterName = '%s', PrintStatus = %d Where BatchID = '%s' AND Queuename = '%s' AND PrintStatus = 1"),
								PrinterName, RESERVED, BatchID, QueueName ) ;

	UADO	*theADO = ConnectToADO() ;
	if( theADO )
	{
		Result = ADOCommand( theADO, theQuery, "SQL", NULL ) ;
		long RecordsAffected = theADO->GetRecordsAffected() ;

		if( Result != 0 || RecordsAffected == 0 )
		{
			//	THE UPDATE FAILED
			SessionLogDirect(_T("**\tREThread.ReserveNextBatch: Query Failed: [%s] result = %0lX, RecordsAffected = %ld"),
										theQuery, Result, RecordsAffected ) ;

			Result = theADO->RefreshConnectionCache() ;
			delete theADO ;
			return( FALSE ) ;
		}

		//	AT THIS POINT WE HAVE A BATCH TO WORK ON.
		//	LEAVE IT AT RESERVED UNTIL WE ACTUALLY START WORKING ON IT ?!?!?!  TBD

		UGenCon	*BatchInfo = new UGenCon( GetDataDictionary( _T("DDREBatchInfo"))) ;
		BatchInfo->SetAttrValue( _T("BatchID"), BatchID ) ;
		BatchInfo->SetLongValue(_T("State"), BATCH_RESERVED ) ;		//	READY TO BE WORKED ON
		BatchInfo->SetLongValue(_T("REThread"), gThisThread ) ;		//	CALL BACK THREAD
	//	BatchInfo->SetLongValue(_T("PrinterSetup"), gPrinterSetupGC ) ;	//	DO THIS IN StartBatch 
		BatchInfo->SetAttrValue( _T("CustomerID"), _T("DP2")) ;
		gBatchQueue->EnQueue( BatchInfo ) ;							//	PUT THE BATCH IN THE QUEUE

		Result = theADO->RefreshConnectionCache() ;
		delete theADO ;
	}

	//	GET THE PAGE LIST
	PostAThreadMessage( gThisThread, REM_GET_PAGE_LIST, 0L, (long) BatchInfo ) ;

	if( gLogAmount >= 5 )
	{
		SessionLogDirect( _T("**\tREThread.ReserveNextBatch: Reserved: [%s]"), BatchID ) ;
	}

	return( TRUE ) ;
}
*/

