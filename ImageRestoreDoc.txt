
Include: CheckFileName;
Include: UtilityRoutines;


IncludeClass( BaseThread );
IncludeClass( BaseDialog );


Class(	ImgRstrDlg,Extends,BaseDialog,
		Member,fDebug,Numeric,FALSE,
		Member,TextHeight,Numeric,20
);


Class(	ImgRstrThread,Extends,BaseThread,
		Member,fConnectionCount,Numeric,0,
		Member,fDebug,Numeric,FALSE,
		Member,fVisible,Numeric,FALSE,
		Member,fTimeout,Numeric,30,
		Member,fPollDelay,Numeric,1000 * 30,
		Member,fRestoring,Numeric,FALSE,
		Member,fErrorState,Numeric,-1, // -1 indicates not set
		Member,ErrorMessage,String,~~,
		Member,DialogData,Numeric,0,			// DialogData from the dialog class
		Member,fFiles_Examined,Numeric,0,
		Member,fFiles_Rejected,Numeric,0,
		Member,fFiles_Loaded,Numeric,0,
		Member,DriveIsEjectable,Numeric,0,
		Member,RestoreImagesCompleted,Numeric,FALSE
);


VOID ImgRstrThread::ImgRstrThread( )	{  }
VOID ImgRstrThread::!ImgRstrThread()	{  }


////////////////////////////////////////////////////////////////////////////////////////////////////////
// Start IRTranslations Table
////////////////////////////////////////////////////////////////////////////////////////////////////////

Define:	IRTranslations Using DDSymbol;

// Define messages for dialog box

IRTranslations( AddText, SetupButton, ~Use Setup~ );
IRTranslations( AddText, EditSetupsButton, ~?~ );
IRTranslations( AddText, SaveSetupButton, ~Save~ );

IRTranslations( AddText, LoadFromPathBrowseButton, ~?~ );
IRTranslations( AddText, CopyToPathBrowseButton, ~?~ );

IRTranslations( AddText, LoadAllImagesButton, ~Load all images~ );
IRTranslations( AddText, LoadOrderItemImagesButton, ~Load images used by order items~ );

IRTranslations( AddText, KeepColorCorrectionsButton, ~Keep the existing color corrections~ );
IRTranslations( AddText, ClearColorCorrectionsButton, ~Clear the existing color corrections~ );

IRTranslations( AddText, CreateDBRecordsOnlyBox, ~Only add records to the database (do not copy the images)~ );
IRTranslations( AddText, UnwriteProtectBox, ~Unwrite protect the images~ );
IRTranslations( AddText, RefreshThumbnailsBox, ~Refresh thumbnails~ );

IRTranslations( AddText, AutoStartBox, ~Auto Start~ );

IRTranslations( AddText, VisibleBox, ~Visible on Auto Start~ );

IRTranslations( AddText, GoButton, ~Start~ );

IRTranslations( AddText, CheckNowButton, ~Check Now~ );

IRTranslations( AddText, HideButton, ~Hide~ );

IRTranslations( AddText, StopButton, ~Stop~ );

IRTranslations( AddText, ActivityButton, ~Activity~ );

IRTranslations( AddText, SessionLogButton, ~Session Log~ );

IRTranslations( AddText, CloseButton, ~Close~ );


///////////////////////////////////////////////////////////
// Dialog Prompts and Text
///////////////////////////////////////////////////////////

IRTranslations( AddText, LoadFromPrompt, ~Load From~ );
IRTranslations( AddText, SearchCriteriaPrompt, ~Search Criteria~ );
IRTranslations( AddText, LoadFromBrowserTitle, ~Load From~ );
IRTranslations( AddText, LoadFromBrowserDescription, ~Select the directory to load the images from~ );

IRTranslations( AddText, DirectoryFormatPrompt, ~Directory Format~ );
IRTranslations( AddText, LoadRollPrompt, ~Roll for "Order/Frame" format~ );

IRTranslations( AddText, CopyToPrompt, ~Copy To~ );
IRTranslations( AddText, CopyToBrowserTitle, ~Copy To~ );
IRTranslations( AddText, CopyToBrowserDescription, ~Select the directory to copy the images to~ );

IRTranslations( AddText, DirectoryOptionsGroupBox, ~Directory Options~ );
IRTranslations( AddText, LoadOptionsGroupBox, ~Load Options~ );
IRTranslations( AddText, ColorCorrectionsOptionsGroupBox, ~Color Corrections Options~ );
IRTranslations( AddText, CopyOptionsGroupBox, ~Copy Options~ );


///////////////////////////////////////////////////////////
// Dialog Tool Tips
///////////////////////////////////////////////////////////

IRTranslations( AddText, SetupButtonToolTip, ~Activate the selected restore setup~ );
IRTranslations( AddText, SetupComboBoxToolTip, ~Select a particular restore setup to use~ );
IRTranslations( AddText, EditSetupsButtonToolTip, ~Edit the ImageRestoreSetups table~ );
IRTranslations( AddText, SaveSetupButtonToolTip, ~Save the current settings in the ImageRestoreSetups table~ );
IRTranslations( AddText, LoadFromPathToolTip, ~Directory to load images from~ );
IRTranslations( AddText, SearchCriteriaComboBoxToolTip, ~Image file pattern to search for in the load from path~ );
IRTranslations( AddText, LoadFromPathBrowseButtonToolTip, ~Select a directory to load images from~ );
IRTranslations( AddText, LoadFromDirFormatComboBoxToolTip, ~Select the format of the directory that contains the images that are being loaded~ );
IRTranslations( AddText, LoadRollToolTip, ~Enter the roll number to be loaded (used when Order/Frame directory format is selected)~ );
IRTranslations( AddText, CopyToPathToolTip, ~The directory to copy images to~ );
IRTranslations( AddText, CopyToPathBrowseButtonToolTip, ~Select a directory to copy the images to~ );
IRTranslations( AddText, LoadAllImagesButtonToolTip, ~Load all images from the load from path~ );
IRTranslations( AddText, LoadOrderItemImagesButtonToolTip, ~Load only those images found in order items~ );
IRTranslations( AddText, KeepColorCorrectionsButtonToolTip, ~Keep the existing color corrections in the images table~ );
IRTranslations( AddText, ClearColorCorrectionsButtonToolTip, ~Clear the color corrections in the images table~ );
IRTranslations( AddText, CreateDBRecordsOnlyBoxToolTip, ~Create the image records in the images table.  Do not acutally copy the images~ );
IRTranslations( AddText, UnwriteProtectBoxToolTip, ~Unwrite protect image files to update thumbnails when only creating database records~ );
IRTranslations( AddText, RefreshThumbnailsBoxToolTip, ~Refresh the thumbnails in the image files~ );
IRTranslations( AddText, AutoStartBoxToolTip, ~Automatically startup when %1 starts~ );
IRTranslations( AddText, VisibleBoxToolTip, ~Make this dialog visible upon Auto Start~ );
IRTranslations( AddText, GoButtonToolTip, ~Start loading images~ );
IRTranslations( AddText, CheckNowButtonToolTip, ~Check the from location for images now.~ );
IRTranslations( AddText, HideButtonToolTip, ~Hide the Image Restore dialog~ );
IRTranslations( AddText, StopButtonToolTip, ~Stop the Image Restore dialog~ );
IRTranslations( AddText, ActivityButtonToolTip, ~Display the Image Restore activity log for this computer~ );
IRTranslations( AddText, SessionLogButtonToolTip, ~Display the session log for this computer~ );
IRTranslations( AddText, CloseButtonToolTip, ~Exit the Image Restore dialog~ );


///////////////////////////////////////////////////////////
// Dialog Messages
///////////////////////////////////////////////////////////

IRTranslations( AddText, MustSelectSetup, ~You must select a setup to load~ );
IRTranslations( AddText, QueryFailed, ~Query Failed: %1. %2~ );
IRTranslations( AddText, FailedToFindSetup, ~Could not find a setup named %1~ );
IRTranslations( AddText, FailedToUpdateDialogWithSetup, ~Failed to update the dialog from %1~ );
IRTranslations( AddText, SetupNameNotSpecified, ~No setup name specified~ );
IRTranslations( AddText, ConfirmToAddSetup, ~Create a new setup called %1?~ );
IRTranslations( AddText, FailedToAddSetup, ~AddNew for ImageRestoreSetups Failed: %1.~ );
IRTranslations( AddText, ConfirmToUpdateExistingSetup, ~Update the existing setup called %1?~ );
IRTranslations( AddText, FailedToUpdateSetup, ~Could not update ImageRestoreSetups record where %1. %2~ );
IRTranslations( AddText, FailedToUpdateSearchCriteriaComboBox, ~Could not update the search criteria combination box~ );
IRTranslations( AddText, FailedToUpdateFromDirFormatComboBox, ~Could not update the load from directory format combination box~ );

// Audits

IRTranslations( AddText, AuditFailed, ~Image Restore failed: %1~ );

IRTranslations( AddText, AuditFailedToGetFromDirFormat, ~Failed to get directory format of the directory being loaded from.~ );
IRTranslations( AddText, AuditFailedToGetToDirFormat,   ~Failed to get directory format of the directory being copied to.~ );

IRTranslations( AddText, AuditLoadFromDirNotSpecified, ~The directory to load from is not specified or is incorrect.~ );
IRTranslations( AddText, AuditCopyToDirNotSpecified,   ~The directory to copy to is not specified.~ );

IRTranslations( AddText, AuditSearchCriteriaNotSpecified, ~The load from directory search criteria is not specified.~ );

IRTranslations( AddText, AuditFromDirFormatNotSpecified, ~The directory format of the directory being loaded from is not specified.~ );
IRTranslations( AddText, AuditToDirFormatNotSpecified,   ~The directory format of the directory being copied to is not specified.~ );

IRTranslations( AddText, AuditFromDirRollNotSpecified, ~The load from directory roll is not specified.~ );

IRTranslations( AddText, AuditLoadFromDirNotExist, ~The directory specified to load from does not exist or is not a directory.~ );
IRTranslations( AddText, AuditLoadFromDirNotUNC, ~The directory specified to load from is not a valid UNC path name nor is it a shared path.  Since you have asked us not copy the images to a shared directory, the Load From directory must be shared.~ );
IRTranslations( AddText, AuditLoadFromDirEjectable, ~The directory specified to load from is ejectable.  Since you have asked us not copy the images to a shared directory, than the Load From Directory must be shared.~ );

IRTranslations( AddText, CreateOnlyNotShared,~Since we are not copying the files to a shared directory, the directory they are currently in needs to be shared.~ );

IRTranslations( AddText, AuditLoadFromToDirSame,    ~The directory specified to load from is the same name as the directory to copy to.~ );
IRTranslations( AddText, AuditCopyToDirNotUNC,      ~The directory specified to copy to is not a valid UNC path name or it is not a valid shared path.~ );
IRTranslations( AddText, AuditCopyToDirNotExist,    ~The directory specified to copy to does not exist or is not a directory.~ );
IRTranslations( AddText, AuditCopyToDirNotWritable, ~The directory specified to copy to is not writable.~ );

// File Name Check

IRTranslations( AddText, InvalidImage, ~Image file %1 was invalid. Check the activity log.~ );
IRTranslations( AddText, CheckFileNameFailed, ~Image file failed validity check... Check the activity log.~ );
IRTranslations( AddText, CheckFileNameModified, ~Unable to use modified image file name... Check the activity log.~ );
IRTranslations( AddText, CheckFileRollModified, ~Modified roll number... Check the activity log.~ );
IRTranslations( AddText, CheckFileStatusFailed, ~Failed to check status on image file... Check the activity log.~ );
IRTranslations( AddText, CheckFileImageAlreadyExists, ~Image file already exists for another order... Check the activity log.~ );


// Copy File

IRTranslations( AddText, CopyFailed, ~Copy image file %2 failed: %1~ );

IRTranslations( AddText, CopySourceFileNotSpecified, ~The source file was not specified.~ );
IRTranslations( AddText, CopyDestinationFileNotSpecified, ~The destination file was not specified.~ );
IRTranslations( AddText, CopySourceFileIsADirectory, ~The source file %1 is a directory.~ );
IRTranslations( AddText, CopySourceFileNotExist, ~The source file %1 does not exist.~ );
IRTranslations( AddText, CopyDestinationFileIsADirectory, ~The destination file %1 is a directory.~ );
IRTranslations( AddText, CopyDestinationFileExist, ~The destination file %1 already exists.~ );
IRTranslations( AddText, CopyDestinationChmodFailed, ~Failed to change the permissions on the destination file.  %1~ );
IRTranslations( AddText, CopyDestinationCopyFailed, ~Failed to copy the source file %1 to the destination file.  %2.~ );

// Thumbnail

IRTranslations( AddText, UnwriteProtectFailed, ~Failed to unwrite protect image %1~ );
IRTranslations( AddText, WriteAccessFailed, ~Unable to update write protected image %1~ );
IRTranslations( AddText, RefreshThumbnailFailed, ~Failed to refresh thumbnail for image %1~ );

// Add Order/Roll/Frame

IRTranslations( AddText, AddOrdRolFrmFailed, ~Add Order/Roll/Frame with image file failed: %1~ );

IRTranslations( AddText, AddOrdRolFrmOrdNotSpecified, ~The order id was not specified.~ );
IRTranslations( AddText, AddOrdRolFrmRolNotSpecified, ~The roll number was not specified.~ );
IRTranslations( AddText, AddOrdRolFrmImgNotSpecified, ~The image file name was not specified.~ );
IRTranslations( AddText, AddOrdRolFrmColCorNotSpecified, ~The color corrections instructions were not specified.~ );
IRTranslations( AddText, AddOrdRolFrmCreateOrdFailed, ~Unable to create the order id %1.~ );
IRTranslations( AddText, AddOrdRolFrmUpdateImgFailed, ~Unable to update the image record for Order/Roll/Frame %1/%2/%3.~ );
IRTranslations( AddText, AddOrdRolFrmCreateImgFailed, ~Unable to create an image record with Order/Roll/Frame %1/%2/%3.~ );

// General Error

IRTranslations( AddText, RestoreImagesAbortedKnown, ~Aborted restoring of images:\n\n%1~ );
IRTranslations( AddText, RestoreImagesAbortedUnknown, ~Aborted restoring of images.~ );

////////////////////////////////////////////////////////////////////////////////////////////////////////
// End IRTranslations Table
////////////////////////////////////////////////////////////////////////////////////////////////////////


VOID    ImgRstrThread::SetDebug( DebugFlag )	{ fDebug = <DebugFlag>; }
NUMERIC ImgRstrThread::Restoring()				{ return <fRestoring>; }


VOID ImgRstrThread::ResetRestoreFlags()
{
	fRestoring = FALSE;
	fErrorState = -1;
	ErrorMessage = ~~;
	DriveIsEjectable = FALSE;
	RestoreImagesCompleted = FALSE;
}


NUMERIC ImgRstrThread::GetDatabaseConnection( &ErrorMessage )
{
	// Create a local error message if not defined

	if ( !Defined( ErrorMessage ) )
	{
		ErrorMessage = ~~;
	}

	if ( MemberDefined( fConnection ) )
	{
		++fConnectionCount;
		return TRUE;
	}

	if ( ADO( fConnection,Connect ) )
	{
		++fConnectionCount;
		return Private( fConnection );
	}

	fConnection( GetErrorDescription,theErr );

	ErrorMessage = Translate( ConnectionFailed,~<theErr>~ );

	return FALSE;
}


NUMERIC ImgRstrThread::ReleaseDatabaseConnection()
{ 
	if ( MemberDefined( fConnection ) )
	{
		--fConnectionCount;
	}

	if ( <fConnectionCount> <= 0 )
	{
		ForgetPrivate( fConnection );
	}

	return TRUE;
}


STR ImgRstrThread::LookForWork( &dlgData )
{
	if ( <fDebug> )
	{
		Invoke( UpdateStatus,~<$Date.Time>  Entered LookForWork...~ );
		Sleep( 1000 );
	}

	// Stop Looking for work if we have a a non-ejectable drive
	// with either an error or the images have been restored

	if ( IsImageRestoreThreadCompleted( dlgData ) )
	{
		if ( <fDebug> )
		{
			Invoke( UpdateStatus,~<$Date.Time>  Exiting LookForWork NO Work Ejectable:<DriveIsEjectable> ErrorState:<fErrorState> Completed:<RestoreImagesCompleted>...~ );
			Sleep( 3000 );
		}
		return ~~;
	}

	Invoke( UpdateStatus,~<$Date.Time>  Looking for images to load...~ );

	// Check the input volume containing images to restore
	//
	// NOTE: If we cannot read the restore from directory then just
	// NOTE: continue - It might be an ejectable drive
	//
	// NOTE: The audit method is called before this routine so all of the
	// NOTE: restore infromation is validated


	LoadFromDirectory = ~<$con.DlgData[LoadFromDirectory].RemoveDoubleBackSlashes>~;

	if ( SimilarStr( ~<LoadFromDirectory>~,~c:~ ) || SimilarStr( ~<LoadFromDirectory>~,~c:\~ ) )
	{
		Invoke( UpdateStatus,~<$Date.Time>  You can't select c:\ as the from directory~ );
		return ~~;
	}

	if ( Files( DirectoryExists, ~<LoadFromDirectory>~ ) )
	{
		DriveIsEjectable = Drive( IsEjectable, ~<LoadFromDirectory>~ );
		Invoke( UpdateStatus,~<$Date.Time>  Loading images from <LoadFromDirectory>~ );
		return ~<LoadFromDirectory>~;
	}

	Invoke( UpdateStatus,~<$Date.Time>  Insert another disc into the drive or select the Stop button...~ );

	return ~~;
}


NUMERIC ImgRstrThread::IsImageRestoreThreadCompleted( &dlgData )
{
	// Stop Looking for work if we have a a non-ejectable drive
	// with either an error or the images have been restored

	if ( <fDebug> )
	{
		Invoke( UpdateStatus,~<$Date.Time>  Entered IsImageRestoreThreadCompleted Eject:<DriveIsEjectable>  Err:<fErrorState> Complete:<RestoreImagesCompleted>~ );
		Sleep( 4000 );
	}

	if ( !<DriveIsEjectable> && ( ( <fErrorState> == 1 ) || <RestoreImagesCompleted> ) )
	{
		if ( <fDebug> )
		{
			Invoke( UpdateStatus,~<$Date.Time>  Exit IsImageRestoreThreadCompleted with TRUE  Eject:<DriveIsEjectable>  Err:<fErrorState> Complete:<RestoreImagesCompleted>~ );
			Sleep( 4000 );
		}
		return TRUE;
	}

	if ( <fDebug> )
	{
		Invoke( UpdateStatus,~<$Date.Time>  Exit IsImageRestoreThreadCompleted with FALSE  Eject:<DriveIsEjectable>  Err:<fErrorState> Complete:<RestoreImagesCompleted>~ );
		Sleep( 4000 );
	}
	return FALSE;
}


VOID ImgRstrThread::WakeupNow()
{ 
	Post( WM_TIMER(),2,3 );
}


NUMERIC ImgRstrThread::HandleStart()
{ 
	SetTimer( <fPollDelay> );

	ID = ThreadID();

	Log( Session,~Starting <$Job.Title> background thread - ID=<$str.$ID.%lx>~ );

	return TRUE;
}	


NUMERIC ImgRstrThread::HandleQuit()
{ 
	ID = ThreadID();

	Log( Session,~Ending <$Job.Title> background thread - ID=<$str.$ID.%lx>~ );

	return TRUE;
}	


NUMERIC ImgRstrThread::HandleMsg( Msg,lparam,wparam )
{
	KillTimer();

	if ( <fDebug> )
	{
		Invoke( UpdateStatus,~<$Date.Time>  Entered HandleMsg Msg:<Msg>  Abort:<fAborting>   Running:<fRunning>...~ );
		Sleep( 3000 );
	}

	// Clear any messages in the queue
	NewMsg = aThread.Dequeue();

	if ( <fDebug> && !IsNULL( ~<NewMsg>~ ) )
	{
		Invoke( UpdateStatus,~<$Date.Time>  Discarding received a message <NewMsg>...~ );
		Sleep( 1000 );
	}

	if ( <Msg> == WM_QUIT() || Aborting() )
	{
		Invoke( DoStop, ~~ );
		return TRUE;
	}

	Gencon( TheDialogData,Is,<DialogData> );

	PollDelay = ~<fPollDelay>~;

	if ( <Msg> == WM_TIMER() && Running() )
	{
		if ( <fDebug> )
		{
			Invoke( UpdateStatus,~<$Date.Time>  HandleMsg handling WM_TIMER...~ );
			Sleep( 1000 );
		}

		fRestoring = TRUE;

		CurrentLoadFromDirectory = LookForWork( TheDialogData );

		if ( !IsNULL( ~<CurrentLoadFromDirectory>~ ) )
		{
			if ( Aborting() )	{ fRestoring = FALSE; return TRUE; }

			if ( !RestoreImages( TheDialogData ) )
			{
				if ( ~<ErrorMessage>~ != ~~ )
				{
					mesg = Translate( IRTranslations, RestoreImagesAbortedKnown, ~<ErrorMessage>~ );
				}
				else
				{
					mesg = Translate( IRTranslations, RestoreImagesAbortedUnknown );
				}
				Invoke( Warning, ~<mesg>~ );
				fRestoring = FALSE;
				Invoke( DoAbort, Translate( ~<$Date.Time>  Aborted loading images from <CurrentLoadFromDirectory>~ ) );
				return TRUE;
			}
			else
			{
				// NOTE: Special check for non-removable completed
				if ( IsImageRestoreThreadCompleted( TheDialogData ) )
				{
					fRestoring = FALSE;
					Invoke( DoStop, Translate( ~<$Date.Time>  Completed loading images from <CurrentLoadFromDirectory>~ ) );
					return TRUE;
				}
				Invoke( UpdateStatus, Translate( ~<$Date.Time>  Completed loading images from <CurrentLoadFromDirectory>~ ) );
			}

			if ( Aborting() )	{ fRestoring = FALSE; return TRUE; }

			PollDelay = 1000;
		}

		fRestoring = FALSE; 
	}

	SetTimer( <PollDelay> );

	return TRUE;
}


NUMERIC ImgRstrDlg::IsDebuggingOn() { return <fDebug>; }


VOID ImgRstrDlg::WindowDefinition()
{
	Fields:		IsHidden	TRUE;
}


VOID ImgRstrDlg::DefineControls()
{
	Define: SetupButton Using DDWinCtrlDef AsSymbol SetupButton Private 
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, SetupButton )
				DActionsText		ACTION EXEC ( <THIS>.OnUseSetupButton(TRUE) )
				RightJustified		TRUE
				Position			<hGap> * 2, <vGap> * 2,
									70, <TextHeight>
				IsTabStop			T
				Tooltip				Translate( IRTranslations, SetupButtonToolTip ) ;

	Define: SetupComboBox Using DDWinCtrlDef AsSymbol SetupComboBox Private
		Fields:	TypeName			ComboBox
				Position			SetupButton(GetRight,Position) + <hGap>, SetupButton(GetTop,Position),
									250, <TextHeight> * 4
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				DropDownActionsText	ACTION EXEC ( <THIS>.UpdateImageRestoreSetupComboBox() )
				GenConName			THIS
				GenConField			~Setup~
				Mask				~<$[DATABASE FieldTypes].ScanSetupName[Mask]>~
				PromptChar			~<$[DATABASE FieldTypes].ScanSetupName[PromptChar]>~
				AllowedChars		~<$[DATABASE FieldTypes].ScanSetupName[AllowedChars]>~
				DisallowedChars		~<$[DATABASE FieldTypes].ScanSetupName[DisallowedChars]>~
				IsTabStop			T
				Tooltip				Translate( IRTranslations, SetupComboBoxToolTip ) ;

	Define: EditSetupsButton Using DDWinCtrlDef AsSymbol EditSetupsButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, EditSetupsButton )
				Position			SetupComboBox(GetRight,Position) + <hGap>, SetupComboBox(GetTop,Position),
									<TextHeight>, <TextHeight>
				DActionsText		ACTION EXEC  ( <THIS>.OnEditSetups() )
				IsTabStop			T
				Tooltip				Translate( IRTranslations, EditSetupsButtonToolTip ) ;

	Define: SaveSetupButton Using DDWinCtrlDef AsSymbol SaveSetupButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, SaveSetupButton )
				Position			EditSetupsButton(GetRight,Position) + <hGap>, EditSetupsButton(GetTop,Position),
									70, <TextHeight>
				DActionsText		ACTION EXEC ( <THIS>.OnSaveSetup() ) 
				IsTabStop			T
				Tooltip				Translate( IRTranslations, SaveSetupButtonToolTip ) ;

	// Directory Group Options

	// Load From

	Define: LoadFromPrompt Using DDWinCtrlDef AsSymbol LoadFromPrompt Private 
		Fields:	TypeName			StaticText
				Text				Translate( IRTranslations, LoadFromPrompt )
				RightJustified		TRUE
				Position			SetupButton(GetLeft,Position), SetupButton(GetBottom,Position) + ( <vGap> * 10 ),
									SetupButton(GetWidth,Position), <TextHeight> ;

	Define: LoadFromPath Using DDWinCtrlDef AsSymbol LoadFromPath Private
		Fields:	TypeName			MaskedEditText
				Position			LoadFromPrompt(GetRight,Position) + <hGap>, LoadFromPrompt(GetTop,Position),
									300, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save "Exec(<THIS>.OnLoadFromPath();)" )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~LoadFromDirectory~
				Mask				~<$[DATABASE FieldTypes].Path[Mask]>~
				PromptChar			~<$[DATABASE FieldTypes].Path[PromptChar]>~
				AllowedChars		~<$[DATABASE FieldTypes].Path[AllowedChars]>~
				DisallowedChars		~<$[DATABASE FieldTypes].Path[DisallowedChars]>~
				IsTabStop			T
				Tooltip				Translate( IRTranslations, LoadFromPathToolTip ) ;

	Define: SearchCriteriaComboBox Using DDWinCtrlDef AsSymbol SearchCriteriaComboBox Private
		Fields:	TypeName			EComboBox
				Position			LoadFromPath(GetRight,Position) + <hGap>, LoadFromPath(GetTop,Position),
									80, <TextHeight> * 6
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~SearchCriteria~
				IsTabStop			T
				Tooltip				Translate( IRTranslations, SearchCriteriaComboBoxToolTip ) ;

	Define: SearchCriteriaPrompt Using DDWinCtrlDef AsSymbol SearchCriteriaPrompt Private 
		Fields:	TypeName			StaticText
				Text				Translate( IRTranslations, SearchCriteriaPrompt )
				RightJustified		TRUE
				Position			SearchCriteriaComboBox(GetLeft,Position), SearchCriteriaComboBox(GetTop,Position) - <TextHeight>,
									70, <TextHeight> ;

	Define: LoadFromPathBrowseButton Using DDWinCtrlDef AsSymbol LoadFromPathBrowseButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, LoadFromPathBrowseButton )
				Position			SearchCriteriaComboBox(GetRight, Position) + <hGap>, SearchCriteriaComboBox(GetTop, Position),
									<TextHeight>, <TextHeight>
				DActionsText		ACTION EXEC ( <This>.OnBrowseLoadFromPath() )
				IsTabStop			T
				Tooltip				Translate( IRTranslations, LoadFromPathBrowseButtonToolTip ) ;

	Define:	LoadFromDirFormatComboBox Using DDWinCtrlDef AsSymbol LoadFromDirFormatComboBox Private
		Fields:	TypeName			SComboBox
				Position			LoadFromPathBrowseButton(GetRight,Position) + <hGap>, LoadFromPathBrowseButton(GetTop,Position),
									150, <TextHeight> * 8
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save "Exec(<THIS>.OnLoadFromDirFormat();)" )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~LoadFromDirFormat~
				IsIndex				TRUE
				IsTabStop			T
				Tooltip				Translate( IRTranslations, LoadFromDirFormatComboBoxToolTip ) ;

	Define: DirectoryFormatPrompt Using DDWinCtrlDef AsSymbol DirectoryFormatPrompt Private 
		Fields:	TypeName			StaticText
				Text				Translate( IRTranslations, DirectoryFormatPrompt )
				RightJustified		FALSE
				Position			LoadFromDirFormatComboBox(GetLeft,Position), LoadFromDirFormatComboBox(GetTop,Position) - <TextHeight>,
									100, <TextHeight> ;

	Define: LoadRoll Using DDWinCtrlDef AsSymbol LoadRoll 
		Fields: TypeName			MaskedEditText
				Position			LoadFromDirFormatComboBox(GetRight,Position) + <hGap>, LoadFromDirFormatComboBox(GetTop,Position),
									150, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~Roll~
				Mask				~<$[DATABASE FieldTypes].Roll[Mask]>~
				PromptChar			~<$[DATABASE FieldTypes].Roll[PromptChar]>~
				AllowedChars		~<$[DATABASE FieldTypes].Roll[AllowedChars]>~
				DisallowedChars		~<$[DATABASE FieldTypes].Roll[DisallowedChars]>~
				IsTabStop			T
				Tooltip				Translate( IRTranslations, LoadRollToolTip ) ;

	Define: LoadRollPrompt Using DDWinCtrlDef AsSymbol LoadRollPrompt Private 
		Fields:	TypeName			StaticText
				Text				Translate( IRTranslations, LoadRollPrompt )
				RightJustified		FALSE
				Position			LoadRoll(GetLeft,Position), LoadRoll(GetTop,Position) - <TextHeight>,
									150, <TextHeight> ;

	// Copy To

	Define: CopyToPrompt Using DDWinCtrlDef AsSymbol CopyToPrompt Private 
		Fields:	TypeName			StaticText
				Text				Translate( IRTranslations, CopyToPrompt )
				RightJustified		TRUE
				Position			SetupButton(GetLeft,Position), LoadFromPrompt(GetBottom,Position) + <vGap>,
									SetupButton(GetWidth,Position), <TextHeight> ;

	Define: CopyToPath Using DDWinCtrlDef AsSymbol CopyToPath Private
		Fields:	TypeName			MaskedEditText
				Position			CopyToPrompt(GetRight,Position) + <hGap>, CopyToPrompt(GetTop,Position),
									SearchCriteriaComboBox(GetRight,Position) - LoadFromPath(GetLeft,Position), <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~CopyToDirectory~
				Mask				~<$[DATABASE FieldTypes].Path[Mask]>~
				PromptChar			~<$[DATABASE FieldTypes].Path[PromptChar]>~
				AllowedChars		~<$[DATABASE FieldTypes].Path[AllowedChars]>~
				DisallowedChars		~<$[DATABASE FieldTypes].Path[DisallowedChars]>~
				IsTabStop			T
				Tooltip				Translate( IRTranslations, CopyToPathToolTip ) ;

	Define: CopyToPathBrowseButton Using DDWinCtrlDef AsSymbol CopyToPathBrowseButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, CopyToPathBrowseButton )
				Position			CopyToPath(GetRight, Position) + <hGap>, CopyToPath(GetTop, Position),
									<TextHeight>, <TextHeight>
				DActionsText		ACTION EXEC ( <This>.OnBrowseCopyToPath() )
				IsTabStop			T
				Tooltip				Translate( IRTranslations, CopyToPathBrowseButtonToolTip ) ;


	// Directory Options GroupBox

	tmpX      = LoadFromPrompt(GetLeft,Position) - <vGap> ;
	tmpY      = SearchCriteriaPrompt(GetTop,Position) - (<hGap> * 3) ;

	tmpWidth  = LoadRoll(GetRight,Position) - LoadFromPrompt(GetLeft,Position) + (<hGap> * 3) ;
	tmpHeight = CopyToPath(GetBottom,Position) - SearchCriteriaPrompt(GetTop,Position) + (<vGap> * 6) ;

	Define: DirectoryOptionsGroupBox Using DDWinCtrlDef AsSymbol DirectoryOptionsGroupBox Private
		Fields:	TypeName			GroupBox
				Text				Translate( IRTranslations, DirectoryOptionsGroupBox )
				Position			<tmpX>, <tmpY>,
									<tmpWidth>, <tmpHeight> ;

	// Next GroupBoxX/Y

	gapBetweenBoxes = DirectoryOptionsGroupBox(GetTop,Position) - SetupButton(GetBottom,Position) ;
	nextGroupBoxX = DirectoryOptionsGroupBox(GetLeft,Position) ;
	nextGroupBoxY = DirectoryOptionsGroupBox(GetBottom,Position) + <gapBetweenBoxes> ;

	// Load Options

	Define: LoadAllImagesButton Using DDWinCtrlDef AsSymbol LoadAllImagesButton Private
		Fields:	TypeName			RadioButton
				Text				Translate( IRTranslations, LoadAllImagesButton )
				Position			<nextGroupBoxX> + (<hGap> * 3), <nextGroupBoxY> + (<vGap> * 4),
									180, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS (
										CheckButton(LoadAllImagesButton)
										UncheckButton(LoadOrderItemImagesButton)
										Save
									)
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~LoadAllImages~
				RadioTrueValue		TRUE
				IsTabStop			T
				Tooltip				Translate( IRTranslations, LoadAllImagesButtonToolTip ) ;

	Define: LoadOrderItemImagesButton Using DDWinCtrlDef AsSymbol LoadOrderItemImagesButton Private
		Fields:	TypeName			RadioButton
				Text				Translate( IRTranslations, LoadOrderItemImagesButton )
				Position			<nextGroupBoxX> + (<hGap> * 3), LoadAllImagesButton(GetBottom,Position) + <vGap>,
									180, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS (
										CheckButton(LoadOrderItemImagesButton)
										UncheckButton(LoadAllImagesButton)
										Save
									)
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~LoadAllImages~
				RadioTrueValue		FALSE
				IsTabStop			T
				Tooltip				Translate( IRTranslations, LoadOrderItemImagesButtonToolTip ) ;

	tmpWidth  = LoadAllImagesButton(GetRight,Position) - LoadAllImagesButton(GetLeft,Position) + (<hGap> * 5) ;
	tmpHeight = LoadOrderItemImagesButton(GetBottom,Position) - LoadAllImagesButton(GetTop,Position) + (<vGap> * 6) ;

	Define: LoadOptionsGroupBox Using DDWinCtrlDef AsSymbol LoadOptionsGroupBox Private
		Fields:	TypeName			GroupBox
				Text				Translate( IRTranslations, LoadOptionsGroupBox )
				Position			<nextGroupBoxX>, <nextGroupBoxY>,
									<tmpWidth>, <tmpHeight> ;

	nextGroupBoxX = LoadOptionsGroupBox(GetRight,Position) + (<hGap> * 3);
	nextGroupBoxY = DirectoryOptionsGroupBox(GetBottom,Position) + <gapBetweenBoxes> ;

	Define: KeepColorCorrectionsButton Using DDWinCtrlDef AsSymbol KeepColorCorrectionsButton Private
		Fields:	TypeName			RadioButton
				Text				Translate( IRTranslations, KeepColorCorrectionsButton )
				Position			<nextGroupBoxX> + (<hGap> * 3), <nextGroupBoxY> + (<vGap> * 4),
									200, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS (
										CheckButton(KeepColorCorrectionsButton)
										UncheckButton(ClearColorCorrectionsButton)
										Save
									)
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~KeepExistingColorCorrections~
				RadioTrueValue		TRUE
				IsTabStop			T
				Tooltip				Translate( IRTranslations, KeepColorCorrectionsButtonToolTip ) ;

	Define: ClearColorCorrectionsButton Using DDWinCtrlDef AsSymbol ClearColorCorrectionsButton Private
		Fields:	TypeName			RadioButton
				Text				Translate( IRTranslations, ClearColorCorrectionsButton )
				Position			KeepColorCorrectionsButton(GetLeft,Position), LoadAllImagesButton(GetBottom,Position) + <vGap>,
									200, <TextHeight>
				IActionsText		ACTIONS ( Get  )
				DActionsText		ACTIONS (
										CheckButton(ClearColorCorrectionsButton)
										UncheckButton(KeepColorCorrectionsButton)
										Save
									)
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~KeepExistingColorCorrections~
				RadioTrueValue		FALSE
				IsTabStop			T
				Tooltip				Translate( IRTranslations, ClearColorCorrectionsButtonToolTip ) ;

	tmpWidth  = KeepColorCorrectionsButton(GetRight,Position) - KeepColorCorrectionsButton(GetLeft,Position) + (<hGap> * 5) ;
	tmpHeight = ClearColorCorrectionsButton(GetBottom,Position) - KeepColorCorrectionsButton(GetTop,Position) + (<vGap> * 6) ;

	Define: ColorCorrectionsOptionsGroupBox Using DDWinCtrlDef AsSymbol ColorCorrectionsOptionsGroupBox Private
		Fields:	TypeName			GroupBox
				Text				Translate( IRTranslations, ColorCorrectionsOptionsGroupBox )
				Position			<nextGroupBoxX>, <nextGroupBoxY>,
									<tmpWidth>, <tmpHeight> ;

	nextGroupBoxX = ColorCorrectionsOptionsGroupBox(GetRight,Position) + (<hGap> * 3) ;
	nextGroupBoxY = DirectoryOptionsGroupBox(GetBottom,Position) + <gapBetweenBoxes> ;

	Define: CreateDBRecordsOnlyBox Using DDWinCtrlDef AsSymbol CreateDBRecordsOnlyBox Private
		Fields:	TypeName			CheckBox
				Text				Translate( IRTranslations, CreateDBRecordsOnlyBox )
				Position			<nextGroupBoxX> + (<hGap> * 3), <nextGroupBoxY> + (<vGap> * 4),
									325, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save "Exec(<THIS>.OnCreateDBRecordsOnlyBox();)" )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~CreateDBRecordsOnly~
				IsTabStop			T
				ToolTip				Translate( IRTranslations, CreateDBRecordsOnlyBoxToolTip ) ;


	Define: UnwriteProtectBox Using DDWinCtrlDef AsSymbol UnwriteProtectBox Private
		Fields:	TypeName			CheckBox
				Text				Translate( IRTranslations, UnwriteProtectBox )
				Position			CreateDBRecordsOnlyBox(GetLeft,Position), CreateDBRecordsOnlyBox(GetBottom,Position) + <vGap>,
									325, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~UnwriteProtect~
				IsTabStop			T
				ToolTip				Translate( IRTranslations, UnwriteProtectBoxToolTip ) ;

	Define: RefreshThumbnailsBox Using DDWinCtrlDef AsSymbol RefreshThumbnailsBox Private
		Fields:	TypeName			CheckBox
				Text				Translate( IRTranslations, RefreshThumbnailsBox )
				Position			UnwriteProtectBox(GetLeft,Position), UnwriteProtectBox(GetBottom,Position) + <vGap>,
									325, <TextHeight>
				IActionsText		ACTIONS ( Get )
				DActionsText		ACTIONS ( Save )
				OActionsText		ACTIONS ( Save )
				GenConName			THIS
				GenConField			~RefreshThumbnails~
				IsTabStop			T
				ToolTip				Translate( IRTranslations, RefreshThumbnailsBoxToolTip ) ;

	tmpWidth  = CreateDBRecordsOnlyBox(GetRight,Position) - CreateDBRecordsOnlyBox(GetLeft,Position) + (<hGap> * 5) ;
	tmpHeight = RefreshThumbnailsBox(GetBottom,Position) - CreateDBRecordsOnlyBox(GetTop,Position) + (<vGap> * 6) ;

	Define: CopyOptionsGroupBox Using DDWinCtrlDef AsSymbol CopyOptionsGroupBox Private
		Fields:	TypeName			GroupBox
				Text				Translate( IRTranslations, CopyOptionsGroupBox )
				Position			<nextGroupBoxX>, <nextGroupBoxY>,
									<tmpWidth>, <tmpHeight> ;

	Define: AutoStartBox Using DDWinCtrlDef AsSymbol AutoStartBox Private
		Fields:	TypeName			CheckBox
				Text				Translate( IRTranslations, AutoStartBox )
				Position			SetupButton(GetLeft,Position), LoadOptionsGroupBox(GetBottom,Position) + (<vGap> * 3),
									120, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.OnAutoStartBox() )
				GenConName			THIS
				GenConField			~AutoStart~
				IsTabStop			T
				ToolTip				Translate( IRTranslations, AutoStartBoxToolTip, ~<$App.Name>~ ) ;

	Define: VisibleBox Using DDWinCtrlDef AsSymbol VisibleBox Private
		Fields:	TypeName			CheckBox
				Text				Translate( IRTranslations, VisibleBox )
				Position			AutoStartBox(GetLeft,Position), AutoStartBox(GetBottom,Position) + <vGap>,
									120, <TextHeight>
				DActionsText		ACTION EXEC ( <THIS>.OnVisibleBox() )
				GenConName			THIS
				GenConField			~Visible~
				IsTabStop			T
				ToolTip				Translate( IRTranslations, VisibleBoxToolTip ) ;

	Define: GoButton Using DDWinCtrlDef AsSymbol GoButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, GoButton )
				Position			VisibleBox(GetLeft,Position), VisibleBox(GetBottom,Position) + ( <vGap> * 3 ),
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.OnGoButton() )
				GenConName			THIS
				IsTabStop			T
				ToolTip				Translate( IRTranslations, GoButtonToolTip ) ;

	Define: CheckNowButton Using DDWinCtrlDef AsSymbol CheckNowButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, CheckNowButton )
				Position			GoButton(GetRight,Position) + (<hGap> * 4), GoButton(GetTop,Position),
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.OnCheckNowButton() )
				GenConName			THIS
				IsTabStop			T
				ToolTip				Translate( IRTranslations, CheckNowButtonToolTip ) ;

	Define: HideButton Using DDWinCtrlDef AsSymbol HideButton Private
		Fields:	TypeName			DefaultButton
				Text				Translate( IRTranslations, HideButton )
				Position			CheckNowButton(GetRight,Position) + (<hGap> * 4), CheckNowButton(GetTop,Position),
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.HideDialog() )
				GenConName			THIS
				IsTabStop			T
				ToolTip				Translate( IRTranslations, HideButtonToolTip ) ;

	Define: StopButton Using DDWinCtrlDef AsSymbol StopButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, StopButton )
				Position			HideButton(GetRight,Position) +  + (<hGap> * 4), HideButton(GetTop,Position),
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.DoStopButton() )
				GenConName			THIS
				ISEnabled			F
				IsTabStop			T
				ToolTip				Translate( IRTranslations, StopButtonToolTip ) ;

	Define: ActivityButton Using DDWinCtrlDef AsSymbol ActivityButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, ActivityButton )
				Position			StopButton(GetRight,Position) +  + (<hGap> * 4), StopButton(GetTop,Position),
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.DoActivityButton() )
				GenConName			THIS
				ISEnabled			F
				IsTabStop			T
				ToolTip				Translate( IRTranslations, ActivityButtonToolTip ) ;

	Define: SessionLogButton Using DDWinCtrlDef AsSymbol SessionLogButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, SessionLogButton )
				Position			ActivityButton(GetRight,Position) +  + (<hGap> * 4), ActivityButton(GetTop,Position),
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.OnSessionLogButton() )
				GenConName			THIS
				ISEnabled			F
				IsTabStop			T
				ToolTip				Translate( IRTranslations, SessionLogButtonToolTip ) ;

	tmpX = GoButton(GetLeft,Position) - DirectoryOptionsGroupBox(GetLeft,Position);
	tmpX = DirectoryOptionsGroupBox(GetRight,Position) - <tmpX> - <ButtonWidth>;

	Define: CloseButton Using DDWinCtrlDef AsSymbol CloseButton Private
		Fields:	TypeName			Button
				Text				Translate( IRTranslations, CloseButton )
				Position			<tmpX>, ActivityButton(GetTop,Position),
									<ButtonWidth>, <ButtonHeight>
				DActionsText		ACTION EXEC ( <THIS>.DoCloseButton() )
				GenConName			THIS
				ISEnabled			T
				IsTabStop			T
				ToolTip				Translate( IRTranslations, CloseButtonToolTip ) ;
}

VOID ImgRstrDlg::OnSessionLogButton()
{
	DisplaySessionLog();
}


NUMERIC ImgRstrDlg::OnVisibleBox()
{
	dlg( GetInput );

	SetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,Visible,Numeric(~<$con.dlgData[Visible]>~),TRUE );

	aThread.Set( fVisible, dlgData(GetNumeric,Visible) );

	return TRUE;
}


NUMERIC ImgRstrDlg::OnAutoStartBox()
{
	dlg( GetInput );

	SetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,AutoStart,Numeric(~<$con.dlgData[AutoStart]>~),TRUE );

	return TRUE;
}


VOID ImgRstrDlg::HideDialog()
{
	dlg( ShowDialog,FALSE );
}


VOID ImgRstrDlg::EnableGo()
{
	// Setup Options
	EnableControls( SetupButton );
	EnableControls( SetupComboBox );
	EnableControls( EditSetupsButton );
	EnableControls( SaveSetupButton );

	// Load From Options
	EnableControls( LoadFromPath );
	EnableControls( SearchCriteriaComboBox );
	EnableControls( LoadFromPathBrowseButton );
	EnableControls( LoadFromDirFormatComboBox );
	EnableControls( LoadRoll );

	// Copy To Options
	EnableControls( CopyToPath );
	EnableControls( CopyToPathBrowseButton );

	// Restore Load Options
	EnableControls( LoadAllImagesButton );
	EnableControls( LoadOrderItemImagesButton );
	EnableControls( KeepColorCorrectionsButton );
	EnableControls( ClearColorCorrectionsButton );
	EnableControls( CreateDBRecordsOnlyBox );
	EnableControls( UnwriteProtectBox );
	EnableControls( RefreshThumbnailsBox );

	// Restore Dialog Options
	EnableControls( AutoStartBox );
	EnableControls( VisibleBox );

	// Restore Control Buttons
	EnableControls( GoButton );
	EnableControls( HideButton );
	DisableControls( StopButton );
	EnableControls( ActivityButton );
	EnableControls( SessionLogButton );
	EnableControls( CloseButton );

	// Check the controls that should normally
	// be disabled witht the current settings
	OnLoadFromPath();
	OnLoadFromDirFormat();
	OnCreateDBRecordsOnlyBox();
}

VOID ImgRstrDlg::EnableRestore()
{
	// Setup Options
	DisableControls( SetupButton );
	DisableControls( SetupComboBox );
	DisableControls( EditSetupsButton );
	DisableControls( SaveSetupButton );

	// Load From Options
	DisableControls( LoadFromPath );
	DisableControls( SearchCriteriaComboBox );
	DisableControls( LoadFromPathBrowseButton );
	DisableControls( LoadFromDirFormatComboBox );
	DisableControls( LoadRoll );

	// Copy To Options
	DisableControls( CopyToPath );
	DisableControls( CopyToPathBrowseButton );

	// Restore Load Options
	DisableControls( LoadAllImagesButton );
	DisableControls( LoadOrderItemImagesButton );
	DisableControls( KeepColorCorrectionsButton );
	DisableControls( ClearColorCorrectionsButton );
	DisableControls( CreateDBRecordsOnlyBox );
	DisableControls( UnwriteProtectBox );
	DisableControls( RefreshThumbnailsBox );

	// Restore Dialog Options
	DisableControls( AutoStartBox );
	DisableControls( VisibleBox );

	// Restore Control Buttons
	DisableControls( GoButton );
	EnableControls( HideButton );
	EnableControls( StopButton );
	EnableControls( ActivityButton );
	EnableControls( SessionLogButton );
	EnableControls( CloseButton );
}


VOID ImgRstrDlg::OnGoButton()
{
	Log( Session,~Starting <$Job.Title>~ );
	Invoke( UpdateStatus,~Started...~ );

	// Audit the restore information entered by the user
	if ( !IsAuditRestoreInfoOK( ErrorMessage ) )
	{
		mesg = Translate( IRTranslations, AuditFailed, ~<ErrorMessage>~);
		Warning( ~<mesg>~ );
		return;
	}

	EnableRestore();

	aThread.ResetRestoreFlags();

	aThread.SetRunning( TRUE );
	aThread.SetTimer( 100 );
	aThread.WakeupNow();
}


NUMERIC ImgRstrDlg::OnCheckNowButton()
{
	if ( Defined( aThread ) )
	{
		if ( !aThread.Running() )
		{
			return	Warning(~You must press Start first~);
		}

		aThread.WakeupNow();
	}

	return TRUE;
}


VOID DoStop( StopMessage )
{
	if ( !DefinedAndNotNULL( StopMessage) )
	{
		StopMessage = ~~;
	}

	if ( Defined( ThisDialog ) )
	{
		ThisDialog.OnStop( ~<StopMessage>~ );
	}
}


NUMERIC ImgRstrDlg::OnStop( StopMessage )
{
	if ( !DefinedAndNotNULL( StopMessage) )
	{
		StopMessage = ~Stopping~;
	}

	aThread.SetRunning( FALSE );

	Log( Session,~Stopping <$Job.Title>~ );
	Invoke( UpdateStatus, ~<$Date.Time>    <StopMessage>~ );

	Count = 10;

	Inprocess = aThread.Restoring();

	while ( <Inprocess> )
	{
		Sleep( 1000 );

		if ( <--count> <= 0 )
			break;

		UpdateStatus( ~<$Date.Time>     <StopMessage>~ );

		Inprocess = aThread.Restoring();
	}

	Inprocess = aThread.Restoring();

	if ( <Inprocess> )
	{
		UpdateStatus( ~Unable to stop now.  Try again later.~ );
		return FALSE;	
	}

	EnableGo();

	UpdateStatus( ~Stopped.~ );

	return TRUE;
}


VOID DoAbort( AbortMessage )
{
	if ( !DefinedAndNotNULL( AbortMessage) )
	{
		AbortMessage = ~~;
	}

	if ( Defined( ThisDialog ) )
	{
		ThisDialog.OnAbort( ~<AbortMessage>~ );
	}
}


VOID ImgRstrDlg::OnAbort( AbortMessage )
{
	if ( !DefinedAndNotNULL( AbortMessage) )
	{
		AbortMessage = ~<$Date.Time>  Restore Aborted...~;
	}
	aThread.SetRunning( FALSE );

	Log( Session, ~Aborting <$Job.Title>~ );
	Invoke( UpdateStatus, ~<AbortMessage>~ );

	EnableGo();
}


NUMERIC ImgRstrDlg::OkayToCancel()
{
	if ( IsAppShuttingDown() )
	{
		ReturnOnSuccess( !aThread.Running() );

		OnStop();

		Sleep( 100 );

		if ( aThread.Restoring() )
		{
			ShowDialog( TRUE );	
			return Warning( ~Wait for the current image loading process to complete and try again~ );
		}

		return TRUE;
	}

	ReturnOnSuccess( !aThread.Running() );

	if ( MessageBox( Translate(~Are you sure you want to stop Image Restore?~),YESNO ) == YES )
	{
		ReturnOnSuccess( !aThread.Running() );

		OnStop();

		Sleep( 100 );

		if ( aThread.Restoring() )
		{
			ShowDialog(TRUE );	
			return Warning( ~Wait for the current archived images to be restored and try again~ );
		}

		return TRUE;
	}

	CancelShutdown();

	return FALSE; 
}


VOID ImgRstrDlg::DoStopButton()
{
	DoStop( ~Stopping...~ );
}


VOID ImgRstrDlg::DoActivityButton()
{
	Process = ~Select * From Activity Where UserName = '<$Job.Title>' Order By TimeEntered~;

	Actions = ACTION Doc ( ~ActivityDoc~ OpenOnce ActivityDoc "Init( ~Activity From Image Restore~,~<Process>~ );" );

	PerformActions( Actions );
}


VOID ImgRstrDlg::DoCloseButton()
{
	if ( OkayToCancel() )
	{
		Log( Session,~Quitting <$Job.Title>~ );

		SetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,AutoStart,Numeric(~<$con.dlgData[AutoStart]>~),TRUE );

		aThread.WaitForThreadDeath();

		CancelNow();
	}
}


VOID ImgRstrDlg::DoCancelButton()
{
	DoCloseButton();
}


VOID UpdateStatus( Msg )
{
	if ( Defined( ThisDialog ) )
	{
		ThisDialog.StatusBar(0,~<Msg>~);
	}
}


NUMERIC ImgRstrDlg::OnUseSetupButton( DisplayWarning )
{
	dlg( GetInput );
	Setup = ~<$con.dlgData[Setup]>~;

	if ( IsNull( ~<Setup>~ ) )
	{
		if ( !<DisplayWarning> )
		{
			return FALSE;
		}

		return Warning( Translate( IRTranslations, MustSelectSetup ) );
	}

	Key = ~Setup = '<Setup>'~;

	Query = ~Select * from ImageRestoreSetups Where <Key>~;

	if ( !PGenConList( List,Connect,Cursor,Forward,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( IRTranslations, QueryFailed, ~<Query>~, ~<theErr>~ ) );
	}

	if ( !List( GetFirst,Setup ) )
	{
		return Warning( Translate( IRTranslations, FailedToFindSetup, ~<Setup>~ ) );
	}

	if ( !Setup( UpdateIn,dlgData ) )
	{
		return Warning( Translate( IRTranslations, FailedToUpdateDialogWithSetup, ~<Setup>~ ) );
	}

	dlg( Update );

	// If the search criteria in the dialog data is not in the standard
	// search criteria list, then it is added to the top of the list
	// so that it will be displayed

	UpdateSearchCriteriaComboBox( TRUE );

	// Update the LoadRoll enable/disable status

	OnLoadFromDirFormat();

	OnCreateDBRecordsOnlyBox();

	return TRUE;
}


VOID ImgRstrDlg::UpdateImageRestoreSetupComboBox()
{
	Query = ~Select * from ImageRestoreSetups Order By Setup~;

	if ( PGenConList( List, Connect, Cursor, Forward, QUERY, ~<Query>~ ) )
	{ 
		if ( List( GetFirst, SetupRecord ) )
		{
			List( MakeStringList, LoadFromSetupList, Setup );
			dlg( SetControlFromStringList, SetupComboBox, LoadFromSetupList, Selection );
			dlg( GetInput );
		}
	}
	return;
}


VOID ImgRstrDlg::OnEditSetups()
{
	Query = ~Select * From ImageRestoreSetups Order By Setup~;

	Actions = ACTION Doc ( ImageRestoreSetups OpenOnce ImageRestoreSetupsDoc "Init( ~Image Restore Setups~,~<Query>~ );" );

	PerformActions( Actions );
}


NUMERIC ImgRstrDlg::OnSaveSetup()
{
	dlg( GetInput );

	SetupName = ~<$con.DlgData[Setup]>~;

	if ( ~<SetupName>~ == ~~ )
	{
		return Warning( Translate( IRTranslations, SetupNameNotSpecified ) );
	}

	// If we are in non-standalone mode and are going to restore the
	// DB records only (no copy images), then make sure the restore
	// from path is a shared or UNC path
	CreateDBRecordsOnly = DlgData( GetNumeric, CreateDBRecordsOnly );
	Path = ~<$Con.DlgData[LoadFromDirectory].RemoveDoubleBackSlashes>~;

	if ( <CreateDBRecordsOnly> )
	{
		if ( !Files( IsUNC,~<Path>~ ) && NetworkOperation() )
		{
			return Warning( Translate( IRTranslations, CreateOnlyNotShared, ~<Path>~ ) );
		}

		dlg( SetStrings, LoadFromDirectory, ~<Path>~ );
	}

	Key = ~Setup = '<$con.DlgData[Setup]>'~;

	Query = ~Select * From ImageRestoreSetups Where <Key>~;

	if ( !PGenConList( List,Connect,Cursor,Keyset,Query,~<Query>~ ) )
	{
		List( GetErrorDescription,0,theErr );
		return Warning( Translate( IRTranslations, QueryFailed, ~<Query>~, ~<theErr>~ ) );
	}

	if ( !List( GetFirst,Item ) )
	{
		if ( MessageBox( Translate( IRTranslations, ConfirmToAddSetup, ~<$con.DlgData[Setup]>~ ), YESNO ) != YES )
		{
			return FALSE;
		}

		if ( !List( AddNew,Item ) )
		{
			List( GetErrorDescription,0,theErr );
			return Warning( Translate( IRTranslations, FailedToAddSetup, ~<theErr>~ ) );
		}

		Item( Set,Setup,~<$con.DlgData[Setup]>~ );
		Item( Set,Computer,~<$App.ComputerName>~ );
		Item( Set,Instance,~<$App.Instance>~ );
	}
	else
	{
		if ( MessageBox( Translate( IRTranslations, ConfirmToUpdateExistingSetup, ~<$con.DlgData[Setup]>~ ), YESNO ) != YES )
		{
			return FALSE;
		}
	}

	if ( !Item( UpdateFrom,DlgData ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		return Warning( Translate( IRTranslations, FailedToUpdateSetup, ~<Key>~, ~<theErr>~ ) );
	}

	if ( !List( Update ) )
	{
		List( GetErrorDescription,0,theErr,CancelUpdate,ClearErrors );
		return Warning( Translate( IRTranslations, FailedToUpdateSetup, ~<Key>~, ~<theErr>~ ) );
	}

	return TRUE;
}


VOID ImgRstrDlg::OnLoadFromPath()
{
	if ( aThread.Running() )	{ return; }

	dlg( GetInput );

	DlgLoadFromDirectory = ~<$con.dlgData[LoadFromDirectory].RemoveDoubleBackSlashes>~;

	if ( IsNull(~<DlgLoadFromDirectory>~ ) )	{ return; }

	LoadFromDirectory = ~<$Str.$DlgLoadFromDirectory.NoTrailingBlanks>~;

	LoadFromVolume = ~<$Str.$LoadFromDirectory.Volume>~;

	if ( Drive( IsEjectable, ~<LoadFromVolume>~ ) )
	{
		dlg( SetCheck, FALSE, CreateDBRecordsOnlyBox, UnwriteProtectBox ); 
		DisableControls( CreateDBRecordsOnlyBox );
		DisableControls( UnwriteProtectBox );
		return;
	}

	EnableControls( CreateDBRecordsOnlyBox );
	EnableControls( UnwriteProtectBox );

	return;
}


NUMERIC ImgRstrDlg::OnBrowseLoadFromPath()
{
	dlg( GetInput );

	DlgLoadFromDirectory = ~<$con.dlgData[LoadFromDirectory].RemoveDoubleBackSlashes>~;

	Path = ~~;

	DirectorySelected =	FileDialog( DefaultDirectory,~<DlgLoadFromDirectory>~,Title,Translate( IRTranslations, LoadFromBrowserDescription ),PATH,Path,DefaultFile,~In this directory~,Save );

	CheckCurrentDirectory();

	if ( <DirectorySelected> )
	{
		return dlg( SetStrings, LoadFromDirectory, ~<$Str.$Path.Path>~ );
	}

	return FALSE;
}


VOID ImgRstrDlg::OnLoadFromDirFormat()
{
	dlg( GetInput );

	DlgLoadFromDirFormat = GetSelectedLoadFromDirFormat( dlgData );

	if ( SimilarStr( ~<DlgLoadFromDirFormat>~, ~Order/Frame~ ) )
	{
		EnableControls( LoadRoll );
	}
	else
	{
		DisableControls( LoadRoll );
	}
	return;
}


NUMERIC ImgRstrDlg::UpdateSearchCriteriaComboBox( AddUserSearchCriteria )
{
	AddUserSearchCriteriaToList = FALSE;

	if ( DefinedAndNotNULL( AddUserSearchCriteria ) )
	{
		AddUserSearchCriteriaToList = <AddUserSearchCriteria>;
	}

	if ( <AddUserSearchCriteriaToList> )
	{
		SearchCriteria = ~<$con.dlgData[SearchCriteria]>~;

		retVal = StringList( SearchCriteriaList,New,InListOrder,NoDuplicateValues, AddStrings,
																			~<SearchCriteria>~,
																			Translate( ~*.*~ ),
																			Translate( ~*.jpg~ ),
																			Translate( ~*.jpeg~ ),
																			Translate( ~*.tif~ ),
																			Translate( ~*.tiff~ ) );
	}
	else
	{
		retVal = StringList( SearchCriteriaList,New,InListOrder,AddStrings,	Translate( ~*.*~ ),
																			Translate( ~*.jpg~ ),
																			Translate( ~*.jpeg~ ),
																			Translate( ~*.tif~ ),
																			Translate( ~*.tiff~ ) );
	}

	if ( !<retVal> )
	{
		return Warning( Translate( IRTranslations, FailedToUpdateSearchCriteriaComboBox ) );
	}
	return dlg( SetControlFromStringList, SearchCriteriaComboBox, SearchCriteriaList, Selection );
}


NUMERIC ImgRstrDlg::UpdateLoadFromDirFormatComboBox()
{
	if (! StringList( list, New, Is, ~<$[DATABASE FieldTypes].ImageRestoreDirFormat[ChoiceList]>~ ) ) 
	{
		return Warning( Translate( IRTranslations, FailedToUpdateFromDirFormatComboBox ) );
	}
	return dlg( SetControlFromStringList, LoadFromDirFormatComboBox, list, Selection );
}


NUMERIC ImgRstrDlg::OnBrowseCopyToPath()
{
	dlg( GetInput );

	DlgCopyToDirectory = ~<$con.dlgData[CopyToDirectory]>~;

	Path = ~~;

	DirectorySelected = FileDialog( DefaultDirectory,~<DlgCopyToDirectory>~,Title,Translate( IRTranslations, CopyToBrowserDescription ),PATH,Path,DefaultFile,~In this directory~,Save ) ;

	CheckCurrentDirectory();

	if ( <DirectorySelected> )
	{
		return dlg( SetStrings, CopyToDirectory, ~<$Str.$Path.Path>~ );
	}

	return FALSE;
}

VOID ImgRstrDlg::OnCreateDBRecordsOnlyBox()
{
	if ( aThread.Running() )
	{
		return;
	}

	dlg( GetInput );

	DlgCreateDBRecordsOnly = ~<$con.dlgData[CreateDBRecordsOnly]>~;

	if ( <DlgCreateDBRecordsOnly> )
	{
		DisableControls( CopyToPath );
	}
	else
	{
		EnableControls( CopyToPath );
	}

	return;
}


NUMERIC ImgRstrDlg::IsAuditRestoreInfoOK( &ErrorMessage )
{
	// Create a local error message if not defined

	if ( !Defined( ErrorMessage ) )
	{
		ErrorMessage = ~~;
	}

	dlg( GetInput );

	// Get the dialog data and strip off the trailing blanks
	// NOTE: Removing trailing blanks will allow minimal check
	// NOTE: for empty strings

	DlgLoadFromDirectory = ~<$con.dlgData[LoadFromDirectory].RemoveDoubleBackSlashes>~;
	LoadFromDirectory = ~<$Str.$DlgLoadFromDirectory.NoTrailingBlanks>~;

	DlgSearchCriteria = ~<$con.dlgData[SearchCriteria]>~;
	SearchCriteria = ~<$Str.$DlgSearchCriteria.NoTrailingBlanks>~;

	LoadFromDirFormat = GetSelectedLoadFromDirFormat( dlgData );

	DlgRoll = ~<$con.dlgData[Roll]>~;
	Roll = ~<$Str.$DlgRoll.NoTrailingBlanks>~;

	DlgCopyToDirectory = ~<$con.dlgData[CopyToDirectory]>~;
	CopyToDirectory = ~<$Str.$DlgCopyToDirectory.NoTrailingBlanks>~;

	CopyToDirFormat = GetSelectedLoadFromDirFormat( dlgData );

	LoadAllImages = Numeric( ~<$con.dlgData[LoadAllImages]>~ );
	KeepExistingColorCorrections = Numeric( ~<$con.dlgData[KeepExistingColorCorrections]>~ );
	CreateDBRecordsOnly = Numeric( ~<$con.dlgData[CreateDBRecordsOnly]>~ );

	// Verify that the user entered in restore from information

	if ( ~<LoadFromDirectory>~ == ~~ || SimilarStr( ~<LoadFromDirectory>~,~c:~ ) || SimilarStr( ~<LoadFromDirectory>~,~c:\~ )  )
	{
		ErrorMessage = Translate( IRTranslations, AuditLoadFromDirNotSpecified );
		return FALSE;
	}

	if ( ~<SearchCriteria>~ == ~~ )
	{
		ErrorMessage = Translate( IRTranslations, AuditSearchCriteriaNotSpecified );
		return FALSE;
	}

	if ( ~<LoadFromDirFormat>~ == ~~ )
	{
		ErrorMessage = Translate( IRTranslations, AuditFromDirFormatNotSpecified );
		return FALSE;
	}

	// Check the Roll number only if the input directory is Order/Frame

	if ( SimilarStr( ~<LoadFromDirFormat>~, ~Order/Frame~ ) )
	{
		if ( ~<Roll>~ == ~~ )
		{
			ErrorMessage = Translate( IRTranslations, AuditFromDirRollNotSpecified );
			return FALSE;
		}
	}

	// Test the input directory to see if it exists

	// LoadFromDirectory may not be active
	//
	//if ( !Files( DirectoryExists, ~<LoadFromDirectory>~ ) )
	//{
	//	ErrorMessage = Translate( IRTranslations, AuditLoadFromDirNotExist );
	//	return FALSE;
	//}

	// At this point the user has supplied all of the restore from
	// information.
	//
	// If the user has selected to only restore the image records in
	// the Images table (and not copy/restore the actual image files),
	// and that the application is in client/server mode,
	// then check to see if the restore from directory is a valid UNC
	// path (network) or that the restore from directory is shared.
	//
	// Also, verify that the restore from directory is not ejectable.
	//
	// NOTE: This is the final step needed to verify all of the restore
	// NOTE: from directory information.

	if ( <CreateDBRecordsOnly> )
	{
		Path = ~<LoadFromDirectory>~;

		if ( !Files( IsUNC,~<Path>~ ) && NetworkOperation() )
		{
			ErrorMessage = Translate( IRTranslations, CreateOnlyNotShared, ~<Path>~ );
			return FALSE;
		}
		dlg( SetStrings, LoadFromDirectory, ~<Path>~ );

		LoadFromVolume = $Str.$Path.Volume;
		if ( Drive( IsEjectable, ~<LoadFromVolume>~ ) )
		{
			ErrorMessage = Translate( IRTranslations, AuditLoadFromDirEjectable );
			return FALSE;
		}

		// If we are only creating DB records then the audit is completed
		return TRUE;
	}

	// We should only be here if the use has selected to restore the
	// actuall image files
	//
	// Verify the restore to directory information

	if ( ~<CopyToDirectory>~ == ~~ )
	{
		ErrorMessage = Translate( IRTranslations, AuditCopyToDirNotSpecified );
		return FALSE;
	}

	if ( ~<CopyToDirFormat>~ == ~~ )
	{
		ErrorMessage = Translate( IRTranslations, AuditToDirFormatNotSpecified );
		return FALSE;
	}

	// Verify that the input and output directories are not the same
	// NOTE: Not a thurough check - i.e. not counting for leading spaces

	LoadFromDirectory = ~<LoadFromDirectory>\~;
	LoadFromDirectory = ~<$Str.$LoadFromDirectory.RemoveDoubleBackSlashes>~;

	CopyToDirectory = ~<CopyToDirectory>\~;
	CopyToDirectory = ~<$Str.$CopyToDirectory.RemoveDoubleBackSlashes>~;

	if ( !IsNULL( String( BeginsWith,~<LoadFromDirectory>~,~<CopyToDirectory>~ ) ) )
	{
		ErrorMessage = Translate( IRTranslations, AuditLoadFromToDirSame );
		return FALSE;
	}

	// If the user is in client/client server mode, then the restore
	// to directory must be UNC or shared.
	Path = ~<CopyToDirectory>~;

	if ( !Files( IsUNC,~<Path>~ ) && NetworkOperation() )
	{
	
		ErrorMessage = Translate( IRTranslations, AuditCopyToDirNotUNC );
		return FALSE;
	}

	CopyToDirectory = ~<Path>~;

	dlg( SetStrings, LoadFromDirectory, ~<LoadFromDirectory>~ );
	dlg( SetStrings, CopyToDirectory, ~<CopyToDirectory>~ );

	Directory( Create,~<CopyToDirectory>~ ); 

	if ( !Files( DirectoryExists, ~<CopyToDirectory>~ ) )
	{
		ErrorMessage = Translate( IRTranslations, AuditCopyToDirNotExist );
		return FALSE;
	}

	if ( !Files( IsWritable, ~<CopyToDirectory>~ ) )
	{
		ErrorMessage = Translate( IRTranslations, AuditCopyToDirNotWritable );
		return FALSE;
	}
	return TRUE;
}


NUMERIC ImgRstrThread::RestoreImages( &dlgData )
{
	LoadFromDirectory = ~<$con.dlgData[LoadFromDirectory].RemoveDoubleBackSlashes>~;
	SearchCriteria = ~<$con.dlgData[SearchCriteria]>~;
	LoadFromDirFormat = GetSelectedLoadFromDirFormat( dlgData );
	Roll = ~<$con.dlgData[Roll]>~;
	CopyToDirectory = ~<$con.dlgData[CopyToDirectory]>~;
	CopyToDirFormat = GetSelectedLoadFromDirFormat( dlgData );
	LoadAllImages = Numeric( ~<$con.dlgData[LoadAllImages]>~ );
	KeepExistingColorCorrections = Numeric( ~<$con.dlgData[KeepExistingColorCorrections]>~ );
	CreateDBRecordsOnly = Numeric( ~<$con.dlgData[CreateDBRecordsOnly]>~ );
	UnwriteProtect = Numeric( ~<$con.dlgData[UnwriteProtect]>~ );
	RefreshThumbnails = Numeric( ~<$con.dlgData[RefreshThumbnails]>~ );

	// Get the system settings for thumbnail size and compression quality
	ThumbnailSize = ~<$SystemSettings.Thumbnail[Size]>~;
	ThumbnailSize = IsNULL( ~<ThumbnailSize>~ ) ? ~500~ : ~<ThumbnailSize>~;

	CompressionQuality = ~<$SystemSettings.Thumbnail[Quality]>~;
	CompressionQuality = IsNULL( ~<CompressionQuality>~ ) ? ~100~ : ~<CompressionQuality>~;

	fErrorState = 0;
	ErrorMessage = ~~;
	RestoreImagesCompleted = FALSE;

	CheckCurrentDirectory();

	if ( !GetDatabaseConnection( ErrorMessage ) )
	{
		fErrorState = 1;
		return FALSE;
	}

	fFiles_Examined = 0;
	fFiles_Rejected = 0;
	fFiles_Loaded = 0;

	retVal = RecursiveImageLoadFromOrderDirectory( ~<LoadFromDirectory>~, ~<SearchCriteria>~, ~<LoadFromDirFormat>~, ~<Roll>~, ~<CopyToDirectory>~, ~<CopyToDirFormat>~, <LoadAllImages>, <KeepExistingColorCorrections>, <CreateDBRecordsOnly>, <UnwriteProtect>, <RefreshThumbnails>, <ThumbnailSize>, <CompressionQuality> );

	fConnection( LogActivity,User,~<$Job.Title>~,Destination,~<$App.UserName>~,Type,Info,Msg,~Examined <fFiles_Examined>, Rejected <fFiles_Rejected>, Loaded <fFiles_Loaded>.~ );
	Log( Session,~Image Restore: Examined <fFiles_Examined> Rejected <fFiles_Rejected> Loaded <fFiles_Loaded>~ );

	ReleaseDatabaseConnection();

	Drive( Eject, ~<LoadFromDirectory>~ );		// EJECT THE DRIVE IF IT IS EJECTABLE SO WE DON'T RESTORE THE IMAGES AGAIN
	
	if ( <retVal> )		// Now Check the status
	{
		RestoreImagesCompleted = TRUE;
	}

	return <retVal>;
}


NUMERIC ImgRstrThread::RecursiveImageLoadFromOrderDirectory( FromPath, SearchCritera, FromDirFormat, FromRoll, ToPath, ToDirFormat, LoadAllImages, KeepExistingColorCorrections, CreateDBRecordsOnly, UnwriteProtect, RefreshThumbnails, ThumbnailSize, CompressionQuality )
{
	if ( <fErrorState> )
	{
		return FALSE;
	}

	// Check to see if the user has chosen to stop

	if ( <fAborting> || !<fRunning>)
	{
		return TRUE;
	}

	// Get all of the directory entries
	MoreDirectoryEntries = findfile( aDirectoryEntry, Find, ~<FromPath>\*.*~ );

	ImagePath = ~~;

	while ( ( <MoreDirectoryEntries> ) && ( !<fErrorState> && !<fAborting> && <fRunning> ) )
	{
		MoreDirectoryEntries = aDirectoryEntry( Next );

		aDirectoryEntry( Get, Path, CurrentFilePath );

		if ( aDirectoryEntry( Dots ) )
			continue;
			
		if ( aDirectoryEntry( Is, aDirectoryEntry(Directory) ) )
		{
			if ( !RecursiveImageLoadFromOrderDirectory( ~<CurrentFilePath>~, ~<SearchCritera>~, ~<FromDirFormat>~, ~<FromRoll>~, ~<ToPath>~, ~<ToDirFormat>~, <LoadAllImages>, <KeepExistingColorCorrections>, <CreateDBRecordsOnly>, <UnwriteProtect>, <RefreshThumbnails>, <ThumbnailSize>, <CompressionQuality> ) )
			{
				return FALSE;
			}
			continue;
		}

		++fFiles_Examined;

		// IS THE FILE EXTENSION ONE THE USER WANTS?

		if ( !SimilarStr( ~<SearchCritera>~,~*.*~ ) )	// ALL FILES?
		{
			if ( !SimilarStr( ~<$str.$CurrentFilePath.ext>~,~<$str.$SearchCritera.ext>~ ) )		// EXTENSIONS MATCH?
			{
				Log( Session,~Image Restore: Skipping <CurrentFilePath>.  Wrong extension.~ );
				++fFiles_Rejected;
				continue;
			}
		}
		else if ( SimilarStr( ~<$str.$CurrentFilePath.ext>~,~log~,~db~,~txt~,~text~,~exe~,~com~ ) )
		{
				Log( Session,~Image Restore: Skipping <CurrentFilePath>.  Unlikely extension.~ );
				++fFiles_Rejected;
				continue;
		}

		DirectoryLevel = GetTokens( ~<$str.$CurrentFilePath.pathwithoutvolume>~,~\~ ) - 1;

		// IF THE FROM DIRECTORY IS ORDER/ROLL/FRAME THEN WE NEED TO BE AT
		// LEVEL TWO (DOWN TWO DIRECTORIES) SO THAT WE ARE IN THE ROLL DIRECTORY TO READ THE FRAMES

		if ( SimilarStr( ~<FromDirFormat>~,~Order/Roll/Frame~ ) && ( <DirectoryLevel> < 2 ) )
		{
			Log( Session,~Image Restore: Skipping <CurrentFilePath>.  Need 2 levels of directories for Order/Roll/Frame.~ );
			++fFiles_Rejected;
			continue;
		}
		else if ( <DirectoryLevel> < 1 )
		{
			Log( Session,~Image Restore: Skipping <CurrentFilePath>.  Need 1 level of directories for Order/Frame.~ );
			++fFiles_Rejected;
			continue;
		}

		FileType=~~; xRes = yRes = 0; PreviewWidth = PreviewLength = 0;

		if ( !GetPIEImageInfo( ~<CurrentFilePath>~,MaxWidth,xRes,MaxHeight,yRes,FileType,FileType,ThumbWidth,PreviewWidth,ThumbHeight,PreviewLength ) )
		{
			Invoke( UpdateStatus, Translate( IRTranslations, InvalidImage,~<CurrentFilePath>~ ) );
			Log( Session,Translate( IRTranslations, InvalidImage,~<CurrentFilePath>~ ) );
			++fFiles_Rejected;
			continue;
		}

		ImagePath = ~<CurrentFilePath>~;

		// EXTRACT THE ORDER/ROLL/FRAME INFORMATION FROM THE DIRECTORY PATH

		TempFullPathImageFileName = ~<ImagePath>~;
		Roll = ~<FromRoll>~;
		Ext = ~~;
		RollNotInImagePath = SimilarStr( ~<FromDirFormat>~, ~Order/Frame~ ) ? TRUE : FALSE;
		ImagePathModified = FALSE;
		RollModified = FALSE;

		if ( !CheckFileName( fConnection, TempFullPathImageFileName, OrderID, Roll, Frame, Ext, <RollNotInImagePath>, ImagePathModified, RollModified ) )
		{
			Reason = Translate( IRTranslations, CheckFileNameFailed );
			Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <Reason>~ );
			Invoke( UpdateStatus, Translate( IRTranslations, CheckFileNameFailed ) );
			++fFiles_Rejected;
			continue;
		}

		if ( <CreateDBRecordsOnly> && <ImagePathModified> )		// TBD:  are we sure about this?
		{
			Reason = Translate( IRTranslations, CheckFileNameModified );
			Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <Reason>~ );
			Invoke( UpdateStatus, Translate( IRTranslations, CheckFileNameModified ) );
			++fFiles_Rejected;
			continue;
		}

		if ( <RollModified> )
		{
			Invoke( UpdateStatus, Translate( IRTranslations, CheckFileRollModified ) );
			Log( Session,Translate( IRTranslations, CheckFileRollModified ) );
		}

		// CHECK TO SEE IF THE USER CHOOSES TO RESTORE ONLY THOSE IMAGES THAT ARE IN THE ORDERITEMIMAGES TABLE
	
		if ( !<LoadAllImages> )
		{
			if ( !OrderItemImageRecordExists( fConnection, ~<OrderID>~, ~<Roll>~, ~<Frame>~ ) )
			{
				Invoke( UpdateStatus,~Image Restore: Skipping <CurrentFilePath>.  Image not used by any OrderItems~ );
				Log( Session,~Image Restore: Skipping <CurrentFilePath>.  Image not used by any OrderItems~ );
				++fFiles_Rejected;
				continue;
			}
		}

		// SELECT THE FINAL FILE NAME TO USE AS THE IMAGE PATH

		if ( <CreateDBRecordsOnly> == FALSE )
		{
			NewFullPathImageFileName = CreateFullPathImageFileName( ~<ToDirFormat>~, ~<ToPath>~, ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<Ext>~ );
		}
		else
		{
			// NOTE: If the user has selected to only create the image records
			// NOTE: then the image path needs to be updated to the original
			// NOTE: image file name in the Restore From directory
			NewFullPathImageFileName = ~<ImagePath>~;
		}

		AnotherOrderExistsWithSameImage = FALSE;

		CheckFileStatusResults = CheckFileStatus( fConnection, ~<NewFullPathImageFileName>~, ~<OrderID>~, ~<Roll>~, ~<Frame>~, AnotherOrderExistsWithSameImage );

		if ( !<CheckFileStatusResults> )
		{
			Reason = Translate( IRTranslations, CheckFileStatusFailed );
			Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <Reason>~ );
			Invoke( UpdateStatus, Translate( IRTranslations, CheckFileStatusFailed ) );
			++fFiles_Rejected;
			continue;
		}

		if ( <AnotherOrderExistsWithSameImage> )
		{
			Reason = Translate( IRTranslations, CheckFileImageAlreadyExists );
			Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <Reason>~ );
			Invoke( UpdateStatus, Translate( IRTranslations, CheckFileImageAlreadyExists ) );
			++fFiles_Rejected;
			continue;
		}

		Invoke( UpdateStatus,~<$Date.Time>  Restoring Image for <OrderID>/<Roll>/<Frame>~ );

		// CHECK TO SEE IF THE USER CHOOSES TO CREATE THE IMAGE RECORDS AND RESTORE THE ACTUAL IMAGE FILES

		if ( <CreateDBRecordsOnly> == FALSE )
		{
			// Copy the file from the Restore From directory to the Restore To directory
			// Note: Copy creates the full directory path if it does not exist

			FailIfFileExists = FALSE;
			DeleteIfFileExists = FALSE;

			if ( !CopyTheFile( ~<ImagePath>~, ~<NewFullPathImageFileName>~, <FailIfFileExists>, <DeleteIfFileExists>, ErrorMessage ) )
			{
				fErrorState = 1;
				ErrorMessage = Translate( IRTranslations, CopyFailed, ~<ErrorMessage>~,~<ImagePath>~ );
				fConnection( LogActivity,User,~<$Job.Title>~,Destination,~<$App.UserName>~,Msg,~<ErrorMessage>~,Type,Error );
				++fFiles_Rejected;
				return FALSE;
			}
		}

		ColorType = 0;
		if ( <RefreshThumbnails> )	// Update the thumbnail if requested
		{
			if ( <UnwriteProtect> )
			{
				if ( !Files( Chmod, ~<NewFullPathImageFileName>~, ~ReadWrite~ ) )
				{
					fErrorState = 1;
					ErrorMessage = Translate( IRTranslations, UnwriteProtectFailed, ~<NewFullPathImageFileName>~ );
					fConnection( LogActivity,User,~<$Job.Title>~,Destination,~<$App.UserName>~,Msg,~<ErrorMessage>~,Type,Error );
					Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <ErrorMessage>~ );
					++fFiles_Rejected;
					return FALSE;
				}
			}

			if ( !Files( Access, ~<NewFullPathImageFileName>~, ReadWrite ) )
			{
				fErrorState = 1;
				ErrorMessage = Translate( IRTranslations, WriteAccessFailed, ~<NewFullPathImageFileName>~ );
				fConnection( LogActivity,User,~<$Job.Title>~,Destination,~<$App.UserName>~,Msg,~<ErrorMessage>~,Type,Error );
				Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <ErrorMessage>~ );
				++fFiles_Rejected;
				return FALSE;
			}

			retVal = AddThumbNailToImage( ~<NewFullPathImageFileName>~,<ThumbnailSize>,<CompressionQuality>,FileType,xRes,yRes,PreviewWidth,PreviewLength,NULL,ColorType );

			if ( <retVal> <= 0 )
			{
				fErrorState = 1;
				ErrorMessage = Translate( IRTranslations, RefreshThumbnailFailed, ~<NewFullPathImageFileName>~ );
				fConnection( LogActivity,User,~<$Job.Title>~,Destination,~<$App.UserName>~,Msg,~<ErrorMessage>~,Type,Error );
				Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <ErrorMessage>~ );
				++fFiles_Rejected;
				return FALSE;
			}
		}

		// ADD/UPDATE THE ORDER AND IMAGE RECORDS

		if ( !AddOrderRollFrameImage( fConnection,~<OrderID>~,~<Roll>~,~<Frame>~,~<NewFullPathImageFileName>~,<KeepExistingColorCorrections>,~<FileType>~,<xRes>,<yRes>,<PreviewWidth>,<PreviewLength>,<ColorType>,ErrorMessage ) )
		{
			fErrorState = 1;
			ErrorMessage = Translate( IRTranslations, AddOrdRolFrmFailed, ~<ErrorMessage>~ );
			fConnection( LogActivity,User,~<$Job.Title>~,Destination,~<$App.UserName>~,Msg,~<ErrorMessage>~,Type,Error );
			Log( Session,~Image Restore: Skipping <CurrentFilePath>.  <ErrorMessage>~ );
			++fFiles_Rejected;
			return FALSE;
		}
		else
		{
			++fFiles_Loaded;
			Log( Session,~Image Restore: Imported Order <OrderID>,Roll <Roll>, Frame <Frame>.  <NewFullPathImageFileName>  KeepCorrections=<KeepExistingColorCorrections>,  <FileType> , HiRes=<xRes>x<yRes>, LoRes=<PreviewWidth>x<PreviewLength>~ );
		}
		
		ImagePath = ~~;		// CLEAR THE IMAGE PATH TO INDICATE THAT IT HAS BEEN PROCESSED
	}

	return TRUE;
}


NUMERIC ImgRstrThread::IsFileInSearchCriteria( FullPathSearchCriteria, FileName )
{
	// Get all of the directory entries with the specified search criteria
	MoreSearchCriteriaFiles = findfile( aSearchCriteriaEntry, Find, ~<FullPathSearchCriteria>~ );

	FoundSearchCriteriaFile = FALSE;

	while ( <MoreSearchCriteriaFiles> && !<FoundSearchCriteriaFile> )
	{
		MoreSearchCriteriaFiles = aSearchCriteriaEntry( Next );

		aSearchCriteriaEntry( Get, Path, SearchEntry );

		if ( ~<SearchEntry>~ == ~~ )
		{
			return <FoundSearchCriteriaFile>;
		}

		if ( aSearchCriteriaEntry( Dots ) )
		{
			continue;
		}

		if ( aSearchCriteriaEntry( Is, aSearchCriteriaEntry(Directory) ) )
		{
			continue;
		}

		if ( SimilarStr( ~<FileName>~, ~<SearchEntry>~ ) )
		{
			FoundSearchCriteriaFile = TRUE;
		}
	}
	return <FoundSearchCriteriaFile>;
}


VOID CheckCurrentDirectory()
{
	// If the user has selected a path in the FileDialog object, the
	// current working directory will be set to that path.
	// If the user has selected a path that is located on ejectable media
	// then we need to set the current working path to the application
	// directory so that we can eject the media after the images have been
	// restored.
	CurrentWorkingDirectory = ~~;
	Directory( GetCurrentDirectory, CurrentWorkingDirectory );

	CurrentVolume = $Str.$CurrentWorkingDirectory.Volume;
	if ( Drive( IsEjectable, ~<CurrentVolume>~ ) )
	{
		Directory( SetCurrentDirectory, ~<$App.Directory>~ );
	}
}


STR GetSelectedLoadFromDirFormat( &dlgData, OnErrorUseDefault )
{
	if ( !DefinedAndNotNULL( OnErrorUseDefault ) )
	{
		OnErrorUseDefault = FALSE;
	}

	TheSelectedItem = ~~;

	if ( <OnErrorUseDefault> )
	{
		TheSelectedItem = ~Order/Roll/Frame~;
	}

	DlgDataLoadFromDirFormat = ~<$con.dlgData[LoadFromDirFormat]>~;
	if (! StringList( FromList, New, Is, ~<$[DATABASE FieldTypes].ImageRestoreDirFormat[ChoiceList]>~ ) ) 
	{
		return ~<TheSelectedItem>~;
	}
	FromList(GetStringAt,~<DlgDataLoadFromDirFormat>~,LoadFromDirFormat);

	if ( ~<LoadFromDirFormat>~ == ~~ )
	{
		return ~<TheSelectedItem>~;
	}
	return ~<LoadFromDirFormat>~;
}


STR CreateFullPathImageFileName( DirFormat, Volume, Order, Roll, Frame, Ext )
{
	if ( ~<Ext>~ != ~~ )
	{
		Ext = ~.<Ext>~;
	}

	if ( SimilarStr( ~<DirFormat>~, ~Order/Frame~ ) || ( ~<Roll>~ == ~~ ) )
	{
		FullPathImageFileName = ~<Volume>\<Order>\<Frame><Ext>~;
	}
	else
	{
		FullPathImageFileName = ~<Volume>\<Order>\<Roll>\<Frame><Ext>~;
	}

	return ~<$str.$FullPathImageFileName.RemoveDoubleBackSlashes>~;
}


// NOTE: The flags FailIfFileExists and DeleteIfFileExists were added to allow the
// NOTE: calling methods to have contol over the behavior of the copy method
NUMERIC CopyTheFile(  SrcFile, DestFile, FailIfFileExists, DeleteIfFileExists, &ErrorMessage )
{
	// Check the parameters

	// Note: Create a temporary error message variable if not passed in

	if ( !Defined( ErrorMessage ) )
	{
		ErrorMessage = ~~;
	}

	if ( !DefinedAndNotNULL( SrcFile ) )
	{
		ErrorMessage = Translate( IRTranslations, CopySourceFileNotSpecified );
		return FALSE;
	}

	if ( !DefinedAndNotNULL( DestFile ) )
	{
		ErrorMessage = Translate( IRTranslations, CopyDestinationFileNotSpecified );
		return FALSE;
	}

	if ( !DefinedAndNotNULL( FailIfFileExists ) )
	{
		FailIfFileExists = FALSE;
	}

	if ( !DefinedAndNotNULL( DeleteIfFileExists ) )
	{
		DeleteIfFileExists = FALSE;
	}

	// Check the source and destination files

	srcIsDirectory = FALSE;
	destIsDirectory = FALSE;

	srcIsDirectory = Files( DirectoryExists, ~<SrcFile>~ );
	SrcFileExists = Files( FileExists, ~<SrcFile>~ );

	destIsDirectory = Files( DirectoryExists, ~<DestFile>~ );
	DestFileExists = Files( FileExists, ~<DestFile>~ );

	if ( <srcIsDirectory> )
	{
		ErrorMessage = Translate( IRTranslations, CopySourceFileIsADirectory,~<SrcFile>~ );
		return FALSE;
	}

	if ( <SrcFileExists> == FALSE )
	{
		ErrorMessage = Translate( IRTranslations, CopySourceFileNotExist,~<SrcFile>~ );
		return FALSE;
	}

	if ( <destIsDirectory> )
	{
		ErrorMessage = Translate( IRTranslations, CopyDestinationFileIsADirectory,~<DestFile>~ );
		return FALSE;
	}

	if ( <DestFileExists> && <FailIfFileExists> )
	{
		ErrorMessage = Translate( IRTranslations, CopyDestinationFileExist,~<DestFile>~ );
		return FALSE;
	}

	// Remove the destination file if it exists

	Files( Chmod, ~<DestFile>~, ~ReadWrite~ );

	if ( <DestFileExists> && <DeleteIfFileExists> )
	{
		if ( Files( Delete, ~<DestFile>~ ) == 0 )
		{
			ErrorMessage = Translate( IRTranslations, CopyDestinationChmodFailed,~<DestFile>~ );
			SysErrorMessage = GetLastErrorMsg();
			ErrorMessage = ~<ErrorMessage> <SysErrorMessage>~;
			return FALSE;
		}
	}

	// Copy the file

	if ( Files( Copy, ~<SrcFile>~, ~<DestFile>~, FALSE ) == 0 )
	{
		ErrorMessage = Translate( IRTranslations, CopyDestinationCopyFailed,~<SrcFile>~, ~<DestFile>~ );
		SysErrorMessage = GetLastErrorMsg();
		ErrorMessage = ~<ErrorMessage> <SysErrorMessage>~;
		return FALSE;
	}

	Files( Chmod, ~<DestFile>~, ~ReadWrite~ );

	return TRUE;
}


NUMERIC AddOrderRollFrameImage( &fConnection, OrderID, Roll, Frame, FullPathImageFileName, KeepExistingColorCorrections, FileType, xRes, yRes, PreviewWidth, PreviewLength, ColorType, &ErrorMessage )
{
	// Check the parameters

	// Note: Create a temporary error message variable if not passed in

	if ( !Defined( ErrorMessage ) )
	{
		ErrorMessage = ~~;
	}

	if ( !DefinedAndNotNULL( OrderID ) )
	{
		ErrorMessage = Translate( IRTranslations, AddOrdRolFrmOrdNotSpecified );
		return FALSE;
	}

	if ( !DefinedAndNotNULL( Roll ) )
	{
		ErrorMessage = Translate( IRTranslations, AddOrdRolFrmRolNotSpecified );
		return FALSE;
	}

	if ( !DefinedAndNotNULL( Frame ) )
	{
		ErrorMessage = Translate( IRTranslations, AddOrdRolFrmFrmNotSpecified );
		return FALSE;
	}

	if ( !DefinedAndNotNULL( FullPathImageFileName ) )
	{
		ErrorMessage = Translate( IRTranslations, AddOrdRolFrmImgNotSpecified );
		return FALSE;
	}

	if ( !DefinedAndNotNULL( KeepExistingColorCorrections ) )
	{
		ErrorMessage = Translate( IRTranslations, AddOrdRolFrmColCorNotSpecified );
		return FALSE;
	}

	// Verify that the OrderID exists

	if ( !OrderIDExists( fConnection, ~<OrderID>~ ) )
	{
		// Create the OrderID if it does not exist

		if ( !CreateOrderID( fConnection, ~<OrderID>~ ) )
		{
			ErrorMessage = Translate( IRTranslations, AddOrdRolFrmCreateOrdFailed, ~<OrderID>~ );
			return FALSE;
		}
	}

	if ( ImageRecordExists( fConnection, ~<OrderID>~, ~<Roll>~, ~<Frame>~ ) )
	{
		if ( !UpdateImageRecord( fConnection, ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<FullPathImageFileName>~, <KeepExistingColorCorrections>, ~<FileType>~, <xRes>, <yRes>, <PreviewWidth>, <PreviewLength>, <ColorType> ) )
		{
			ErrorMessage = Translate( IRTranslations, AddOrdRolFrmUpdateImgFailed, ~<OrderID>~, ~<Roll>~, ~<Frame>~ );
			return FALSE;
		}
	}
	else
	{
		if ( !CreateImageRecord( fConnection, ~<OrderID>~, ~<Roll>~, ~<Frame>~, ~<FullPathImageFileName>~, ~<FileType>~, <xRes>, <yRes>, <PreviewWidth>, <PreviewLength>, <ColorType> ) )
		{
			ErrorMessage = Translate( IRTranslations, AddOrdRolFrmCreateImgFailed, ~<OrderID>~, ~<Roll>~, ~<Frame>~ );
			return FALSE;
		}
	}

	return TRUE;
}


NUMERIC OrderIDExists( &fConnection, OrderID )
{
	if ( !DefinedAndNotNULL( OrderID ) )
	{
		return FALSE;
	}

	Query = ~Select ID From Orders Where ID = '<OrderID>'~;

	count = fConnection( RecordCountFor, ~<Query>~ );

	return <count> != 0;
}


NUMERIC CreateOrderID( &fConnection, OrderID )
{
	if ( !DefinedAndNotNULL( OrderID ) )
	{
		return FALSE;
	}

	InsertCmd	= STR ( Insert Into Orders(ID,OrderDate,ShipDate) Values('<OrderID>',<$Date.DataBaseDate.SharedDateQuoted>,<$Date.DataBaseDate.SharedDateQuoted>) );

	retVal = fConnection( CMD, ~<InsertCmd>~ );

	return <retVal>;
}


NUMERIC OrderItemImageRecordExists( &fConnection, OrderID, Roll, Frame )
{
	Query = STR ( SELECT count(*) From OrderItemImages WHERE OrderID = '<OrderID>' And Roll = '<Roll>' And Frame = '<Frame>' );

	if ( !fConnection( CMD,~<Query>~,RecordCount ) )
	{ 
		fConnection( GetErrorDescription,theErr );
		return Warning( ~Query failed: <Query>.  <theErr>~ );
	}

	return Numeric(~<$rs.RecordCount[#0]>~) > 0;

}


NUMERIC OldOrderItemImageRecordExists( &fConnection, OrderID, Roll, Frame )
{
	Query = STR ( SELECT count(*) From OrderItemImages WHERE OrderID = '<OrderID>' And Roll = '<Roll>' And Frame = '<Frame>' );

	count = fConnection( RecordCountFor, ~<Query>~ );

	return <count> > 0;
}

NUMERIC ImageRecordExists( &fConnection, OrderID, Roll, Frame )
{
	if ( !DefinedAndNotNULL( OrderID ) )
	{
		return FALSE;
	}

	if ( !Defined( Roll ) )
	{
		return FALSE;
	}

	if ( !Defined( Frame ) )
	{
		return FALSE;
	}

	Query = STR ( SELECT * From Images WHERE OrderID = '<OrderID>' And Roll = '<Roll>' And Frame = '<Frame>' Order By OrderID,Roll,Frame );

	count = fConnection( RecordCountFor, ~<Query>~ );

	return <count> != 0;
}


NUMERIC UpdateImageRecord( &fConnection, OrderID, Roll, Frame, ImagePath, KeepExistingColorCorrections, FileType, xRes, yRes, PreviewWidth, PreviewLength, ColorType )
{
	if ( !DefinedAndNotNULL( OrderID ) )
	{
		return FALSE;
	}

	if ( !DefinedAndNotNULL( Roll ) )
	{
		return FALSE;
	}

	if ( !DefinedAndNotNULL( Frame ) )
	{
		return FALSE;
	}

	if ( !DefinedAndNotNULL( KeepExistingColorCorrections ) )
	{
		return FALSE;
	}

	ImageFileName = ~~;
	if ( DefinedAndNotNULL( ImagePath ) )
	{
		ImageFileName = ~<ImagePath>~;
	}

	UpdateProfile = ~~;

	//if ( <ColorType> == 2 )
	//{
	//	UpdateProfile = ~, ICCProfile='srgb'~;
	//}

	
	if ( <KeepExistingColorCorrections> )
	{
		UpdateCmd	= STR ( Update Images Set Path = '<ImageFileName>', ImageOffline = 0, RestoreImg = 0, FileType = '<FileType>', Width = <xRes>, Length = <yRes>,  PreviewWidth = <PreviewWidth>, PreviewLength = <PreviewLength>, ColorType = <ColorType><UpdateProfile> Where OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>' );
	}
	else
	{
		// Image Color Correction Fields
		// Brt
		// Red
		// Grn
		// Blu
		// Con
		// Saturation
		// Sharpen
		// Gamma
		// GammaRed
		// GammaGreen
		// GammaBlue
		// RotateFromDisk
		// ArbitraryRotation

		UpdateCmd	= STR ( Update Images Set Path = '<ImageFileName>', ImageOffline = 0, RestoreImg = 0, FileType = '<FileType>', Width = <xRes>, Length = <yRes>,  PreviewWidth = <PreviewWidth>, PreviewLength = <PreviewLength>, ColorType = <ColorType><UpdateProfile>, Brt = 0, Red = 0, Grn = 0, Blu = 0, Con = 0, Saturation = 0, Sharpen = 0, Gamma = 1, GammaRed = 1, GammaGreen = 1, GammaBlue = 1, RotateFromDisk = 0, ArbitraryRotation = 0 Where OrderID = '<OrderID>' AND Roll = '<Roll>' AND Frame = '<Frame>' );

	}

	retVal = fConnection( CMD, ~<UpdateCmd>~ );

	return <retVal>;
}


NUMERIC CreateImageRecord( &fConnection, OrderID, Roll, Frame, ImagePath, FileType, xRes, yRes, PreviewWidth, PreviewLength, ColorType )
{
	if ( !DefinedAndNotNULL( OrderID ) )
	{
		return FALSE;
	}

	if ( !DefinedAndNotNULL( Roll ) )
	{
		return FALSE;
	}

	if ( !DefinedAndNotNULL( Frame ) )
	{
		return FALSE;
	}

	ImageFileName = ~~;
	if ( DefinedAndNotNULL( ImagePath ) )
	{
		ImageFileName = ~<ImagePath>~;
	}

	ProfileField = ~~;
	ProfileValue = ~~;

	//if ( <ColorType> == 2 )
	//{
	//	ProfileField = ~,ICCProfile~;
	//	ProfileValue = ~,'srgb'~;
	//}

	InsertCmd	= STR ( Insert Into Images(OrderID,Roll,Frame,Path,ImageOffline,RestoreImg,FileType,Width,Length,PreviewWidth,PreviewLength,ColorType<ProfileField>)
						 Values('<OrderID>','<Roll>','<Frame>','<ImageFileName>',0,0,'<FileType>',<xRes>,<yRes>,<PreviewWidth>,<PreviewLength>,<ColorType><ProfileValue>) );

	retVal = fConnection( CMD, ~<InsertCmd>~ );

	return <retVal>;
}


VOID ImgRstrDlg::ImgRstrDlg()
{
	Title = ~Image Restore~;
	Left = 200;
	HelpPage = ~ImageRestore.htm~;
	Dictionary = ~DDImgRstrDlg~;
	ButtonWidth = 75;
}


VOID ImgRstrDlg::DefineDictionary()
{
	Dictionary: ~<Dictionary>~

		Fields:	Name Setup							type Text

		Fields:	Name LoadFromDirectory				type Text
		Fields:	Name SearchCriteria					type Text
		Fields:	Name LoadFromDirFormat				type Long
		Fields:	Name Roll							type Text

		Fields:	Name CopyToDirectory				type Text

		Fields:	Name LoadAllImages					type Long

		Fields:	Name KeepExistingColorCorrections	type Long

		Fields:	Name CreateDBRecordsOnly			type Long
		Fields:	Name RefreshThumbnails				type Long
		Fields:	Name UnwriteProtect					type Long

		Fields: Name AutoStart						type Long
		Fields: Name Visible						type Long
}


VOID ImgRstrDlg::InitDialogData()
{
	dlgData( SetValues, LoadAllImages, TRUE );
	dlgData( SetValues, KeepExistingColorCorrections, TRUE );
	dlgData( SetValues, CreateDBRecordsOnly, FALSE );
	dlgData( SetValues, RefreshThumbnails, FALSE );
	dlgData( SetValues, UnwriteProtect, FALSE );
}


NUMERIC ImgRstrDlg::IsAutoStartOn()	{ return Numeric(~<$con.dlgData[AutoStart]>~); }
NUMERIC ImgRstrDlg::IsVisibleOn()	{ return Numeric(~<$con.dlgData[Visible]>~); }


VOID ImgRstrDlg::ReOpen()				
{ 
	dlg( ShowDialog,TRUE );
	dlg( SetFocus );
}


VOID ImgRstrDlg::OnDialogEnd()
{

	dlg( GetInput );

	SetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,Setup,~<$con.dlgData[Setup]>~,TRUE );
	SetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,AutoStart,Numeric(~<$con.dlgData[AutoStart]>~),TRUE );
	SetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,Visible,Numeric(~<$con.dlgData[Visible]>~),TRUE );
}


VOID ImgRstrDlg::Initialize()				
{ 
	if ( GetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,Setup,Setup,Enabled ) )
	{
		if ( <Enabled> )
		{
			dlg( SetStrings,Setup,~<Setup>~ ); 
		}
	}

	if ( GetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,AutoStart,AutoStart,Enabled ) )
	{
		if ( <Enabled> )
		{
			dlg( SetStrings,AutoStart,Numeric(~<AutoStart>~) ); 
		}
	}

	if ( GetWorkStationSettings( ~<$Job.Title>_<$App.Instance>~,Visible,Visible,Enabled ) )
	{
		if ( <Enabled> )
		{
			dlg( SetStrings,Visible,Numeric(~<Visible>~) ); 
		}
	}

	AThread.Set(DialogData,dlgData(GetObject));
}


VOID Init( Hide, WantAutoStart )
{
	if ( Defined( ThisDialog ) )
	{
		ThisDialog.ReOpen();
	}
	else
	{
		ImgRstrThread( New,aThread );
		Global( aThread );
			
		ImgRstrDlg( New,ThisDialog );	
		Global( ThisDialog );

		ThisDialog.DefineDialog();

		ThisDialog.UpdateImageRestoreSetupComboBox();
		ThisDialog.UpdateSearchCriteriaComboBox();
		ThisDialog.UpdateLoadFromDirFormatComboBox();

		ThisDialog.Initialize();

		aThread.SetDebug( ThisDialog.IsDebuggingOn() );
		aThread.New();
		aThread.SetRunning( FALSE );

		// Show the dialog if the calling method requests
		// the dialog to be displayed

		if ( !<Hide> )
		{
			ThisDialog.ShowDialog( TRUE );	
		}

		// Load the current setup

		SetupLoaded = FALSE;

		if ( <WantAutoStart> )
		{
			SetupLoaded = ThisDialog.OnUseSetupButton( TRUE );
		}
		else
		{
			SetupLoaded = ThisDialog.OnUseSetupButton( FALSE );
		}

		// Check for AutoStart

		Visible = ThisDialog.IsVisibleOn();
		AutoStartError = FALSE;

		if ( <WantAutoStart> )
		{
			// Load the ImageRestore setup information

			if ( <SetupLoaded> )
			{
				ThisDialog.OnGoButton();
				AutoStartError = aThread.Running() ? FALSE : TRUE;
			}

			// If the user requested that the dialog be displayed
			// or if there was an error with auto start, then display
			// the ImageRestore dialog

			if ( <Visible> || !<SetupLoaded> || <AutoStartError> )
			{
				ThisDialog.ShowDialog( TRUE );	
			}
		}
		else
		{
			ThisDialog.EnableGo();
		}

	}
}

